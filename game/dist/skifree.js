(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var Brain = require('brain.js');

(function (global) {
	function AiBrain () {
        this.aiBrainJs = undefined;
        this.step = 0;

        this.trainingVectors = []; // TODO we should use stream input for brainjs

        this.LEARNING_STEP_COUNT = 100;
        this.REPLAY_STEP_COUNT = 300;

        this.reset = function() {
            this.aiBrainJs = undefined;
            this.step = 0;
            console.log('aiBrain: reset');
        }

        this.cycle = function(mouseMapPosition, staticObjects, movingObjects, player) {
            let currentSituation = this.calcSituation(staticObjects, movingObjects, player);

            if (this.REPLAY_STEP_COUNT < this.step) {
                // permet d'arreter les logs
                this.aiBrainJs = undefined;
                return currentSituation;
            }

            if (this.step < this.LEARNING_STEP_COUNT) {
                console.log('aiBrain: record');
                // we learn (sampled learning, only when there is change in the inputs)
                // TODO
                
                console.log("situation: ", currentSituation);

                this.trainingVectors.push({
                    inputs: currentSituation,
                    outputs: { angle: this.getAngle(mouseMapPosition, player.mapPosition) }
                });
            } else if (this.step < this.REPLAY_STEP_COUNT) {
                if (!this.aiBrainJs) {
                    console.log('aiBrain: train AI');
                    // we create and train the IA
                    // TODO

                    					// on calcule la fonction
					const config = {
						binaryThresh: 0.5,
						hiddenLayers: [3],     // array of ints for the sizes of the hidden layers in the network
						activation: 'sigmoid',  // supported activation types: ['sigmoid', 'relu', 'leaky-relu', 'tanh'],
						leakyReluAlpha: 0.01   // supported for activation type 'leaky-relu'
					};

					// create a simple feed forward neural network with backpropagation
                    this.aiBrainJs = new Brain.NeuralNetwork(config);

					if (this.aiBrainJs) {
						// train the IA
						let dataForTraining = this.trainingVectors.map(x => {
							return {input: x.inputs.convert(), output: [x.outputs.angle]};
						})
                        // utiliser l'API de streaming

                        // echantillonnage?

                        // faire un pre apprentissage base sur du preprocessing (transfert de learning)
							

						console.log("inputs: ", dataForTraining);

                        this.aiBrainJs.train(dataForTraining);
                          
                        // pour le test
                        // this.aiBrainJs.train([{ input: [0, 0], output: [0] },
                        // { input: [0, 1], output: [1] },
                        // { input: [1, 0], output: [1] },
                        // { input: [1, 1], output: [0] }]);
					}
					
                    // alert the user about the switch to the replay mode
                    // TODO
                }
                console.log('aiBrain: replay');
                // we replay via getAICommand
            } else {
                // go to the score part
                this.processScore(player);
            }
            this.step++;
            
            return currentSituation;
        }

        this.getAICommand = function(player, currentSituation) {
           
            if (currentSituation && this.aiBrainJs) {
                // we return the command calculated by the IA
                // TODO
                console.log('aiBrain: getAICommand');

                const output = this.aiBrainJs.run(currentSituation.convert());
                console.log("output", output);
                const angle = output * Math.PI / 2;
                console.log("angle", angle);
                let mouseMapPosition = [0,0];
                let delta = {x: 100 * Math.sin(angle), y: 100 * Math.cos(angle)};
                console.log("delta", delta);
                mouseMapPosition[0] = player.canvasX + delta.x;
                mouseMapPosition[1] = player.canvasX + delta.y;
                console.log("mouseMapPosition", mouseMapPosition);
                return {mouseMapPosition: mouseMapPosition};
            }
            return undefined;
        }
        
        this.endcycle = function(player) {
            // TODO where to call it from game.js ??
            console.log('aiBrain: endcycle');
            // depending on the step
            if (this.step < this.LEARNING_STEP_COUNT) {
                // the skier should not be able to die in the learning phase
                // TODO
                
            } else if (this.step < this.REPLAY_STEP_COUNT) {



                // warn the user the IA just died
                this.processScore(player);
            }
        }

        this.processScore = function(player) {
            console.log('aiBrain: process score');
            alert('YOUR SCORE IS: ');
            // TODO

            // FPETODO en mode dev, on veut pas que ca recommence... this.reset();
            
            // TODO game must be also reset
        }

        this.calcSituation = function(staticObjects, movingObjects, player)
        {
			let iaInputs = {
				envInputs: [],
				playerInputs: {},
				dummyInput: {x: 0, y: 0, type: 0, dist: 0},
				convert: function() {
					let result = this.envInputs.flatMap(x => [x.x / 2000, x.y / 2000, x.type]); // 2000 pour normaliser a la hache
					// FPETODO normaliser entre 0 et 1
					result.push(this.playerInputs.dir);
					return result;
				}
			}
            // TODO ajouter la vitesse du skier comme entree??

            // FPETODO player.direction est parfois undefined ...
			iaInputs.playerInputs = { dir: 0 }; // pour test train player.direction };

			staticObjects.each(obj => {
				if (!obj.deleted) {
                    let delta = {x: obj.canvasX - player.mapPosition[0],
                                 y: obj.canvasY - player.mapPosition[1]};
					iaInputs.envInputs.push({ x: delta.x, 
						y: delta.y,
                        type: 0,  // comment typer les objets?
                        dist: Math.abs(delta.x * delta.x + delta.y * delta.y)
                    });
				}
			})
			movingObjects.each(obj => {
				if (!obj.deleted) {
                    let delta = {x: obj.canvasX - player.mapPosition[0],
                                 y: obj.canvasY - player.mapPosition[1]};
					iaInputs.envInputs.push({ x: delta.x, 
						y: delta.y,
						type: 1,  // comment typer les objets?
                        dist: Math.abs(delta.x * delta.x + delta.y * delta.y)
                    });
				}
			})
            
            // we take 5 nearest objects
            iaInputs.envInputs.sort((a, b) => a.dist - b.dist);
            iaInputs.envInputs.slice(0, 5);
            
			// we complete up to 5
			for (let i = 0; i < 5; ++i) {
				if (!iaInputs.envInputs[i]) {
					iaInputs.envInputs[i] = iaInputs.dummyInput;
				}
            }
            
            return iaInputs;
        } 

        this.getAngle = function(mouseMapPosition, playerMapPosition) {
            let relativeMousePos = [mouseMapPosition[0] - playerMapPosition[0],
                                    mouseMapPosition[1] - playerMapPosition[1]];
            return relativeMousePos[1] !== 0 
                ? Math.atan(relativeMousePos[0] / relativeMousePos[1]) / (Math.PI / 2) : 0;
        }
    }

    global.AiBrain = AiBrain;
})(this);

if (typeof module !== 'undefined') {
	module.exports = this.AiBrain;
}
},{"brain.js":66}],2:[function(require,module,exports){
CanvasRenderingContext2D.prototype.storeLoadedImage = function (key, image) {
	if (!this.images) {
		this.images = {};
	}

	this.images[key] = image;
};

CanvasRenderingContext2D.prototype.getLoadedImage = function (key) {
	if (this.images[key]) {
		return this.images[key];
	}
};

CanvasRenderingContext2D.prototype.followSprite = function (sprite) {
	this.centralSprite = sprite;
};

CanvasRenderingContext2D.prototype.getCentralPosition = function () {
	return {
		map: this.centralSprite.mapPosition,
		canvas: [ Math.round(this.canvas.width * 0.5), Math.round(this.canvas.height * 0.5), 0]
	};
};

CanvasRenderingContext2D.prototype.mapPositionToCanvasPosition = function (position) {
	var central = this.getCentralPosition();
	var centralMapPosition = central.map;
	var centralCanvasPosition = central.canvas;
	var mapDifferenceX = centralMapPosition[0] - position[0];
	var mapDifferenceY = centralMapPosition[1] - position[1];
	return [ centralCanvasPosition[0] - mapDifferenceX, centralCanvasPosition[1] - mapDifferenceY ];
};

CanvasRenderingContext2D.prototype.canvasPositionToMapPosition = function (position) {
	var central = this.getCentralPosition();
	var centralMapPosition = central.map;
	var centralCanvasPosition = central.canvas;
	var mapDifferenceX = centralCanvasPosition[0] - position[0];
	var mapDifferenceY = centralCanvasPosition[1] - position[1];
	return [ centralMapPosition[0] - mapDifferenceX, centralMapPosition[1] - mapDifferenceY ];
};

CanvasRenderingContext2D.prototype.getCentreOfViewport = function () {
	return (this.canvas.width / 2).floor();
};

// Y-pos canvas functions
CanvasRenderingContext2D.prototype.getMiddleOfViewport = function () {
	return (this.canvas.height / 2).floor();
};

CanvasRenderingContext2D.prototype.getBelowViewport = function () {
	return this.canvas.height.floor();
};

CanvasRenderingContext2D.prototype.getMapBelowViewport = function () {
	var below = this.getBelowViewport();
	return this.canvasPositionToMapPosition([ 0, below ])[1];
};

CanvasRenderingContext2D.prototype.getRandomlyInTheCentreOfCanvas = function (buffer) {
	var min = 0;
	var max = this.canvas.width;

	if (buffer) {
		min -= buffer;
		max += buffer;
	}

	return Number.random(min, max);
};

CanvasRenderingContext2D.prototype.getRandomlyInTheCentreOfMap = function (buffer) {
	var random = this.getRandomlyInTheCentreOfCanvas(buffer);
	return this.canvasPositionToMapPosition([ random, 0 ])[0];
};

CanvasRenderingContext2D.prototype.getRandomMapPositionBelowViewport = function () {
	var xCanvas = this.getRandomlyInTheCentreOfCanvas();
	var yCanvas = this.getBelowViewport();
	return this.canvasPositionToMapPosition([ xCanvas, yCanvas ]);
};

CanvasRenderingContext2D.prototype.getRandomMapPositionAboveViewport = function () {
	var xCanvas = this.getRandomlyInTheCentreOfCanvas();
	var yCanvas = this.getAboveViewport();
	return this.canvasPositionToMapPosition([ xCanvas, yCanvas ]);
};

CanvasRenderingContext2D.prototype.getTopOfViewport = function () {
	return this.canvasPositionToMapPosition([ 0, 0 ])[1];
};

CanvasRenderingContext2D.prototype.getAboveViewport = function () {
	return 0 - (this.canvas.height / 4).floor();
};
},{}],3:[function(require,module,exports){
var SpriteArray = require('./spriteArray');
var EventedLoop = require('eventedloop');
var AiBrain = require('./aiBrain');

(function (global) {
	function Game (mainCanvas, player) {
		var staticObjects = new SpriteArray();
		var movingObjects = new SpriteArray();
		var uiElements = new SpriteArray();
		var dContext = mainCanvas.getContext('2d');
		var mouseX = dContext.getCentreOfViewport();
		var mouseY = 0;
		var paused = false;
		var that = this;
		var beforeCycleCallbacks = [];
		var afterCycleCallbacks = [];
		var gameLoop = new EventedLoop();
		var aiBrain = new AiBrain();
		aiBrain.reset();

		this.addStaticObject = function (sprite) {
			staticObjects.push(sprite);
		};

		this.addStaticObjects = function (sprites) {
			sprites.forEach(this.addStaticObject.bind(this));
		};

		this.addMovingObject = function (movingObject, movingObjectType) {
			if (movingObjectType) {
				staticObjects.onPush(function (obj) {
					if (obj.data && obj.data.hitBehaviour[movingObjectType]) {
						obj.onHitting(movingObject, obj.data.hitBehaviour[movingObjectType]);
					}
				}, true);
			}

			movingObjects.push(movingObject);
		};

		this.addUIElement = function (element) {
			uiElements.push(element);
		};

		this.beforeCycle = function (callback) {
			beforeCycleCallbacks.push(callback);
		};

		this.afterCycle = function (callback) {
			afterCycleCallbacks.push(callback);
		};

		this.setMouseX = function (x) {
			mouseX = x;
		};

		this.setMouseY = function (y) {
			mouseY = y;
		};

		player.setMapPosition(0, 0);
		player.setMapPositionTarget(0, -10);
		dContext.followSprite(player);

		var intervalNum = 0;

		this.cycle = function () {
			beforeCycleCallbacks.each(function(c) {
				c();
			});

			// Clear canvas
			var mouseMapPosition = dContext.canvasPositionToMapPosition([mouseX, mouseY]);

			let currentSituation = aiBrain.cycle(mouseMapPosition, staticObjects, movingObjects, player);

			if (!player.isJumping) {
				let aiCommand = aiBrain.getAICommand(player, currentSituation);
				if (aiCommand) {
					mouseMapPosition = aiCommand.mouseMapPosition;
				}
				player.setMapPositionTarget(mouseMapPosition[0], mouseMapPosition[1]);
			}

			intervalNum++;

			player.cycle();

			movingObjects.each(function (movingObject, i) {
				movingObject.cycle(dContext);
			});
			
			staticObjects.cull();
			staticObjects.each(function (staticObject, i) {
				if (staticObject.cycle) {
					staticObject.cycle();
				}
			});

			uiElements.each(function (uiElement, i) {
				if (uiElement.cycle) {
					uiElement.cycle();
				}
			});

			afterCycleCallbacks.each(function(c) {
				c();
			});
		};

		that.draw = function () {
			// Clear canvas
			mainCanvas.width = mainCanvas.width;

			player.draw(dContext);

			player.cycle();

			movingObjects.each(function (movingObject, i) {
				movingObject.draw(dContext);
			});
			
			staticObjects.each(function (staticObject, i) {
				if (staticObject.draw) {
					staticObject.draw(dContext, 'main');
				}
			});

			uiElements.each(function (uiElement, i) {
				if (uiElement.draw) {
					uiElement.draw(dContext, 'main');
				}
			});
		};

		this.start = function () {
			gameLoop.start();
		};

		this.pause = function () {
			paused = true;
			gameLoop.stop();
		};

		this.isPaused = function () {
			return paused;
		};

		this.reset = function () {
			paused = false;
			staticObjects = new SpriteArray();
			movingObjects = new SpriteArray();
			mouseX = dContext.getCentreOfViewport();
			mouseY = 0;
			player.reset();
			player.setMapPosition(0, 0, 0);
			aiBrain.reset();
			this.start();
		}.bind(this);

		gameLoop.on('20', this.cycle);
		gameLoop.on('20', this.draw);
	}

	global.game = Game;
})( this );


if (typeof module !== 'undefined') {
	module.exports = this.game;
}
},{"./aiBrain":1,"./spriteArray":12,"eventedloop":67}],4:[function(require,module,exports){
// Creates a random ID string
(function(global) {
    function guid ()
    {
        var S4 = function ()
        {
            return Math.floor(
                    Math.random() * 0x10000 /* 65536 */
                ).toString(16);
        };

        return (
                S4() + S4() + "-" +
                S4() + "-" +
                S4() + "-" +
                S4() + "-" +
                S4() + S4() + S4()
            );
    }
    global.guid = guid;
})(this);

if (typeof module !== 'undefined') {
    module.exports = this.guid;
}
},{}],5:[function(require,module,exports){
function InfoBox(data) {
	var that = this;

	that.lines = data.initialLines;

	that.top = data.position.top;
	that.right = data.position.right;
	that.bottom = data.position.bottom;
	that.left = data.position.left;

	that.width = data.width;
	that.height = data.height;

	that.setLines = function (lines) {
		that.lines = lines;
	};

	that.draw = function (dContext) {
		dContext.font = '11px monospace';
		var yOffset = 0;
		that.lines.each(function (line) {
			var fontSize = +dContext.font.slice(0,2);
			var textWidth = dContext.measureText(line).width;
			var textHeight = fontSize * 1.5;
			var xPos, yPos;
			if (that.top) {
				yPos = that.top + yOffset;
			} else if (that.bottom) {
				yPos = dContext.canvas.height - that.top - textHeight + yOffset;
			}

			if (that.right) {
				xPos = dContext.canvas.width - that.right - textWidth;
			} else if (that.left) {
				xPos = that.left;
			}

			yOffset += textHeight;


			dContext.fillText(line, xPos, yPos);
		});
	};

	return that;
}

if (typeof module !== 'undefined') {
	module.exports = InfoBox;
}

},{}],6:[function(require,module,exports){
function isMobileDevice() {
	if(navigator.userAgent.match(/Android/i) ||
		navigator.userAgent.match(/webOS/i) ||
		navigator.userAgent.match(/iPhone/i) ||
		navigator.userAgent.match(/iPad/i) ||
		navigator.userAgent.match(/iPod/i) ||
		navigator.userAgent.match(/BlackBerry/i) ||
		navigator.userAgent.match(/Windows Phone/i)
	) {
		return true;
	}
	else {
		return false;
	}
}

module.exports = isMobileDevice;
},{}],7:[function(require,module,exports){
var Sprite = require('./sprite');

(function(global) {
	function Monster(data) {
		var that = new Sprite(data);
		var super_draw = that.draw.bind(that);
		var spriteVersion = 1;
		var eatingStage = 0;
		var standardSpeed = 6;

		that.isEating = false;
		that.isFull = false;
		that.setSpeed(standardSpeed);

		that.draw = function(dContext) {
			var spritePartToUse = function () {
				var xDiff = that.movingToward[0] - that.canvasX;

				if (that.isEating) {
					return 'eating' + eatingStage;
				}

				if (spriteVersion + 0.1 > 2) {
					spriteVersion = 0.1;
				} else {
					spriteVersion += 0.1;
				}
				if (xDiff >= 0) {
					return 'sEast' + Math.ceil(spriteVersion);
				} else if (xDiff < 0) {
					return 'sWest' + Math.ceil(spriteVersion);
				}
			};

			return super_draw(dContext, spritePartToUse());
		};

		function startEating (whenDone) {
			eatingStage += 1;
			that.isEating = true;
			that.isMoving = false;
			if (eatingStage < 6) {
				setTimeout(function () {
					startEating(whenDone);
				}, 300);
			} else {
				eatingStage = 0;
				that.isEating = false;
				that.isMoving = true;
				whenDone();
			}
		}

		that.startEating = startEating;

		return that;
	}

	global.monster = Monster;
})( this );


if (typeof module !== 'undefined') {
	module.exports = this.monster;
}
},{"./sprite":11}],8:[function(require,module,exports){
// Avoid `console` errors in browsers that lack a console.
(function() {
    var method;
    var noop = function noop() {};
    var methods = [
        'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
        'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
        'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
        'timeStamp', 'trace', 'warn'
    ];
    var length = methods.length;
    var console = (window.console = window.console || {});

    while (length--) {
        method = methods[length];

        // Only stub undefined methods.
        if (!console[method]) {
            console[method] = noop;
        }
    }
}());
},{}],9:[function(require,module,exports){
var Sprite = require('./sprite');
if (typeof navigator !== 'undefined') {
	navigator.vibrate = navigator.vibrate ||
		navigator.webkitVibrate ||
		navigator.mozVibrate ||
		navigator.msVibrate;
} else {
	navigator = {
		vibrate: false
	};
}

(function(global) {
	function Skier(data) {
		var discreteDirections = {
			'west': 270,
			'wsWest': 240,
			'sWest': 195,
			'south': 180,
			'sEast': 165,
			'esEast': 120,
			'east': 90
		};
		var that = new Sprite(data);
		var sup = {
			draw: that.draw.bind(that),
			cycle: that.cycle.bind(that),
			getSpeedX: that.getSpeedX.bind(that),
			getSpeedY: that.getSpeedY.bind(that),
			hits: that.hits.bind(that)
		};
		var directions = {
			esEast: function(xDiff) { return xDiff > 300; },
			sEast: function(xDiff) { return xDiff > 75; },
			wsWest: function(xDiff) { return xDiff < -300; },
			sWest: function(xDiff) { return xDiff < -75; }
		};

		var cancelableStateTimeout;
		var cancelableStateInterval;

		var canSpeedBoost = true;

		var obstaclesHit = [];
		var pixelsTravelled = 0;
		var standardSpeed = 5;
		var boostMultiplier = 2;
		var turnEaseCycles = 70;
		var speedX = 0;
		var speedXFactor = 0;
		var speedY = 0;
		var speedYFactor = 1;
		var trickStep = 0; // There are three of these

		that.isMoving = true;
		that.hasBeenHit = false;
		that.isJumping = false;
		that.isPerformingTrick = false;
		that.onHitObstacleCb = function() {};
		that.setSpeed(standardSpeed);

		that.reset = function () {
			obstaclesHit = [];
			pixelsTravelled = 0;
			that.isMoving = true;
			that.hasBeenHit = false;
			canSpeedBoost = true;
			setNormal();
		};

		function setNormal() {
			that.setSpeed(standardSpeed);
			that.isMoving = true;
			that.hasBeenHit = false;
			that.isJumping = false;
			that.isPerformingTrick = false;
			if (cancelableStateInterval) {
				clearInterval(cancelableStateInterval);
			}
			that.setMapPosition(undefined, undefined, 0);
		}

		function setCrashed() {
			that.isMoving = false;
			that.hasBeenHit = true;
			that.isJumping = false;
			that.isPerformingTrick = false;
			if (cancelableStateInterval) {
				clearInterval(cancelableStateInterval);
			}
			that.setMapPosition(undefined, undefined, 0);
		}

		function setJumping() {
			var currentSpeed = that.getSpeed();
			that.setSpeed(currentSpeed + 2);
			that.setSpeedY(currentSpeed + 2);
			that.isMoving = true;
			that.hasBeenHit = false;
			that.isJumping = true;
			that.setMapPosition(undefined, undefined, 1);
		}

		function getDiscreteDirection() {
			if (that.direction) {
				if (that.direction <= 90) {
					return 'east';
				} else if (that.direction > 90 && that.direction < 150) {
					return 'esEast';
				} else if (that.direction >= 150 && that.direction < 180) {
					return 'sEast';
				} else if (that.direction === 180) {
					return 'south';
				} else if (that.direction > 180 && that.direction <= 210) {
					return 'sWest';
				} else if (that.direction > 210 && that.direction < 270) {
					return 'wsWest';
				} else if (that.direction >= 270) {
					return 'west';
				} else {
					return 'south';
				}
			} else {
				var xDiff = that.movingToward[0] - that.mapPosition[0];
				var yDiff = that.movingToward[1] - that.mapPosition[1];
				if (yDiff <= 0) {
					if (xDiff > 0) {
						return 'east';
					} else {
						return 'west';
					}
				}

				if (directions.esEast(xDiff)) {
					return 'esEast';
				} else if (directions.sEast(xDiff)) {
					return 'sEast';
				} else if (directions.wsWest(xDiff)) {
					return 'wsWest';
				} else if (directions.sWest(xDiff)) {
					return 'sWest';
				}
			}
			return 'south';
		}

		that.getMyDiscreteDirection = function() {return getDiscreteDirection();}

		function setDiscreteDirection(d) {
			if (discreteDirections[d]) {
				that.setDirection(discreteDirections[d]);
			}

			if (d === 'west' || d === 'east') {
				that.isMoving = false;
			} else {
				that.isMoving = true;
			}
		}

		function getBeingEatenSprite() {
			return 'blank';
		}

		function getJumpingSprite() {
			return 'jumping';
		}

		function getTrickSprite() {
			console.log('Trick step is', trickStep);
			if (trickStep === 0) {
				return 'jumping';
			} else if (trickStep === 1) {
				return 'somersault1';
			} else {
				return 'somersault2';
			}
		}

		that.stop = function () {
			if (that.direction > 180) {
				setDiscreteDirection('west');
			} else {
				setDiscreteDirection('east');
			}
		};

		that.turnEast = function () {
			var discreteDirection = getDiscreteDirection();

			switch (discreteDirection) {
				case 'west':
					setDiscreteDirection('wsWest');
					break;
				case 'wsWest':
					setDiscreteDirection('sWest');
					break;
				case 'sWest':
					setDiscreteDirection('south');
					break;
				case 'south':
					setDiscreteDirection('sEast');
					break;
				case 'sEast':
					setDiscreteDirection('esEast');
					break;
				case 'esEast':
					setDiscreteDirection('east');
					break;
				default:
					setDiscreteDirection('south');
					break;
			}
		};

		that.turnWest = function () {
			var discreteDirection = getDiscreteDirection();

			switch (discreteDirection) {
				case 'east':
					setDiscreteDirection('esEast');
					break;
				case 'esEast':
					setDiscreteDirection('sEast');
					break;
				case 'sEast':
					setDiscreteDirection('south');
					break;
				case 'south':
					setDiscreteDirection('sWest');
					break;
				case 'sWest':
					setDiscreteDirection('wsWest');
					break;
				case 'wsWest':
					setDiscreteDirection('west');
					break;
				default:
					setDiscreteDirection('south');
					break;
			}
		};

		that.stepWest = function () {
			that.mapPosition[0] -= that.speed * 2;
		};

		that.stepEast = function () {
			that.mapPosition[0] += that.speed * 2;
		};

		that.setMapPositionTarget = function (x, y) {
			if (that.hasBeenHit) return;

			if (Math.abs(that.mapPosition[0] - x) <= 75) {
				x = that.mapPosition[0];
			}

			that.movingToward = [ x, y ];

			// that.resetDirection();
		};

		that.startMovingIfPossible = function () {
			if (!that.hasBeenHit && !that.isBeingEaten) {
				that.isMoving = true;
			}
		};

		that.setTurnEaseCycles = function (c) {
			turnEaseCycles = c;
		};

		that.getPixelsTravelledDownMountain = function () {
			return pixelsTravelled;
		};

		that.resetSpeed = function () {
			that.setSpeed(standardSpeed);
		};

		that.cycle = function () {
			if ( that.getSpeedX() <= 0 && that.getSpeedY() <= 0 ) {
						that.isMoving = false;
			}
			if (that.isMoving) {
				pixelsTravelled += that.speed;
			}

			if (that.isJumping) {
				that.setMapPositionTarget(undefined, that.mapPosition[1] + that.getSpeed());
			}

			sup.cycle();
			
			that.checkHittableObjects();
		};

		that.draw = function(dContext) {
			var spritePartToUse = function () {
				if (that.isBeingEaten) {
					return getBeingEatenSprite();
				}

				if (that.isJumping) {
					if (that.isPerformingTrick) {
						return getTrickSprite();
					}
					return getJumpingSprite();
				}

				if (that.hasBeenHit) {
					return 'hit';
				}

				return getDiscreteDirection();
			};

			return sup.draw(dContext, spritePartToUse());
		};

		that.hits = function (obs) {
			if (obstaclesHit.indexOf(obs.id) !== -1) {
				return false;
			}

			if (!obs.occupiesZIndex(that.mapPosition[2])) {
				return false;
			}

			if (sup.hits(obs)) {
				return true;
			}

			return false;
		};

		that.speedBoost = function () {
			var originalSpeed = that.speed;
			if (canSpeedBoost) {
				canSpeedBoost = false;
				that.setSpeed(that.speed * boostMultiplier);
				setTimeout(function () {
					that.setSpeed(originalSpeed);
					setTimeout(function () {
						canSpeedBoost = true;
					}, 10000);
				}, 2000);
			}
		};

		that.attemptTrick = function () {
			if (that.isJumping) {
				that.isPerformingTrick = true;
				cancelableStateInterval = setInterval(function () {
					if (trickStep >= 2) {
						trickStep = 0;
					} else {
						trickStep += 1;
					}
				}, 300);
			}
		};

		that.getStandardSpeed = function () {
			return standardSpeed;
		};

		function easeSpeedToTargetUsingFactor(sp, targetSpeed, f) {
			if (f === 0 || f === 1) {
				return targetSpeed;
			}

			if (sp < targetSpeed) {
				sp += that.getSpeed() * (f / turnEaseCycles);
			}

			if (sp > targetSpeed) {
				sp -= that.getSpeed() * (f / turnEaseCycles);
			}

			return sp;
		}

		that.getSpeedX = function () {
			if (getDiscreteDirection() === 'esEast' || getDiscreteDirection() === 'wsWest') {
				speedXFactor = 0.5;
				speedX = easeSpeedToTargetUsingFactor(speedX, that.getSpeed() * speedXFactor, speedXFactor);

				return speedX;
			}

			if (getDiscreteDirection() === 'sEast' || getDiscreteDirection() === 'sWest') {
				speedXFactor = 0.33;
				speedX = easeSpeedToTargetUsingFactor(speedX, that.getSpeed() * speedXFactor, speedXFactor);

				return speedX;
			}

			// So it must be south

			speedX = easeSpeedToTargetUsingFactor(speedX, 0, speedXFactor);

			return speedX;
		};

		that.setSpeedY = function(sy) {
			speedY = sy;
		};

		that.getSpeedY = function () {
			var targetSpeed;

			if (that.isJumping) {
				return speedY;
			}

			if (getDiscreteDirection() === 'esEast' || getDiscreteDirection() === 'wsWest') {
				speedYFactor = 0.6;
				speedY = easeSpeedToTargetUsingFactor(speedY, that.getSpeed() * 0.6, 0.6);

				return speedY;
			}

			if (getDiscreteDirection() === 'sEast' || getDiscreteDirection() === 'sWest') {
				speedYFactor = 0.85;
				speedY = easeSpeedToTargetUsingFactor(speedY, that.getSpeed() * 0.85, 0.85);

				return speedY;
			}

			if (getDiscreteDirection() === 'east' || getDiscreteDirection() === 'west') {
				speedYFactor = 1;
				speedY = 0;

				return speedY;
			}

			// So it must be south

			speedY = easeSpeedToTargetUsingFactor(speedY, that.getSpeed(), speedYFactor);

			return speedY;
		};

		that.hasHitObstacle = function (obs) {
			setCrashed();

			if (navigator.vibrate) {
				navigator.vibrate(500);
			}

			obstaclesHit.push(obs.id);

			that.resetSpeed();
			that.onHitObstacleCb(obs);

			if (cancelableStateTimeout) {
				clearTimeout(cancelableStateTimeout);
			}
			cancelableStateTimeout = setTimeout(function() {
				setNormal();
			}, 1500);
		};

		that.hasHitJump = function () {
			setJumping();

			if (cancelableStateTimeout) {
				clearTimeout(cancelableStateTimeout);
			}
			cancelableStateTimeout = setTimeout(function() {
				setNormal();
			}, 1000);
		};

		that.isEatenBy = function (monster, whenEaten) {
			that.hasHitObstacle(monster);
			monster.startEating(whenEaten);
			obstaclesHit.push(monster.id);
			that.isMoving = false;
			that.isBeingEaten = true;
		};

		that.reset = function () {
			obstaclesHit = [];
			pixelsTravelled = 0;
			that.isMoving = true;
			that.isJumping = false;
			that.hasBeenHit = false;
			canSpeedBoost = true;
		};

		that.setHitObstacleCb = function (fn) {
			that.onHitObstacleCb = fn || function() {};
		};
		return that;
	}

	global.skier = Skier;
})(this);

if (typeof module !== 'undefined') {
	module.exports = this.skier;
}

},{"./sprite":11}],10:[function(require,module,exports){
var Sprite = require('./sprite');

(function(global) {
	function Snowboarder(data) {
		var that = new Sprite(data);
		var sup = {
			draw: that.draw.bind(that),
			cycle: that.cycle.bind(that)
		};
		var directions = {
			sEast: function(xDiff) { return xDiff > 0; },
			sWest: function(xDiff) { return xDiff <= 0; }
		};
		var standardSpeed = 3;

		that.setSpeed(standardSpeed);

		function getDirection() {
			var xDiff = that.movingToward[0] - that.mapPosition[0];
			var yDiff = that.movingToward[1] - that.mapPosition[1];

			if (directions.sEast(xDiff)) {
				return 'sEast';
			} else {
				return 'sWest';
			}
		}

		that.cycle = function (dContext) {
			if (Number.random(10) === 1) {
				that.setMapPositionTarget(dContext.getRandomlyInTheCentreOfMap());
				that.setSpeed(standardSpeed + Number.random(-1, 1));
			}

			that.setMapPositionTarget(undefined, dContext.getMapBelowViewport() + 600);

			sup.cycle();
		};

		that.draw = function(dContext) {
			var spritePartToUse = function () {
				return getDirection();
			};

			return sup.draw(dContext, spritePartToUse());
		};

		return that;
	}

	global.snowboarder = Snowboarder;
})( this );


if (typeof module !== 'undefined') {
	module.exports = this.snowboarder;
}
},{"./sprite":11}],11:[function(require,module,exports){
(function (global) {
	var GUID = require('./guid');
	function Sprite (data) {
		var hittableObjects = {};
		var zIndexesOccupied = [ 0 ];
		var that = this;
		var trackedSpriteToMoveToward;
		that.direction = undefined;
		that.mapPosition = [0, 0, 0];
		that.id = GUID();
		that.canvasX = 0;
		that.canvasY = 0;
		that.canvasZ = 0;
		that.height = 0;
		that.speed = 0;
		that.data = data || { parts : {} };
		that.movingToward = [ 0, 0 ];
		that.metresDownTheMountain = 0;
		that.movingWithConviction = false;
		that.deleted = false;
		that.maxHeight = (function () {
			return Object.values(that.data.parts).map(function (p) { return p[3]; }).max();
		}());
		that.isMoving = true;

		if (!that.data.parts) {
			that.data.parts = {};
		}

		if (data && data.id){
			that.id = data.id;
		}

		if (data && data.zIndexesOccupied) {
			zIndexesOccupied = data.zIndexesOccupied;
		}

		function incrementX(amount) {
			that.canvasX += amount.toNumber();
		}

		function incrementY(amount) {
			that.canvasY += amount.toNumber();
		}

		function getHitBox(forZIndex) {
			if (that.data.hitBoxes) {
				if (data.hitBoxes[forZIndex]) {
					return data.hitBoxes[forZIndex];
				}
			}
		}

		function roundHalf(num) {
			num = Math.round(num*2)/2;
			return num;
		}

		function move() {
			if (!that.isMoving) {
				return;
			}

			var currentX = that.mapPosition[0];
			var currentY = that.mapPosition[1];

			if (typeof that.direction !== 'undefined') {
				// For this we need to modify the that.direction so it relates to the horizontal
				var d = that.direction - 90;
				if (d < 0) d = 360 + d;
				currentX += roundHalf(that.speed * Math.cos(d * (Math.PI / 180)));
				currentY += roundHalf(that.speed * Math.sin(d * (Math.PI / 180)));
			} else {
				if (typeof that.movingToward[0] !== 'undefined') {
					if (currentX > that.movingToward[0]) {
						currentX -= Math.min(that.getSpeedX(), Math.abs(currentX - that.movingToward[0]));
					} else if (currentX < that.movingToward[0]) {
						currentX += Math.min(that.getSpeedX(), Math.abs(currentX - that.movingToward[0]));
					}
				}
				
				if (typeof that.movingToward[1] !== 'undefined') {
					if (currentY > that.movingToward[1]) {
						currentY -= Math.min(that.getSpeedY(), Math.abs(currentY - that.movingToward[1]));
					} else if (currentY < that.movingToward[1]) {
						currentY += Math.min(that.getSpeedY(), Math.abs(currentY - that.movingToward[1]));
					}
				}
			}

			that.setMapPosition(currentX, currentY);
		}

		this.draw = function (dCtx, spriteFrame) {
			var fr = that.data.parts[spriteFrame];
			that.height = fr[3];
			that.width = fr[2];

			var newCanvasPosition = dCtx.mapPositionToCanvasPosition(that.mapPosition);
			that.setCanvasPosition(newCanvasPosition[0], newCanvasPosition[1]);

			dCtx.drawImage(dCtx.getLoadedImage(that.data.$imageFile), fr[0], fr[1], fr[2], fr[3], that.canvasX, that.canvasY, fr[2], fr[3]);
		};

		this.setMapPosition = function (x, y, z) {
			if (typeof x === 'undefined') {
				x = that.mapPosition[0];
			}
			if (typeof y === 'undefined') {
				y = that.mapPosition[1];
			}
			if (typeof z === 'undefined') {
				z = that.mapPosition[2];
			} else {
				that.zIndexesOccupied = [ z ];
			}
			that.mapPosition = [x, y, z];
		};

		this.setCanvasPosition = function (cx, cy) {
			if (cx) {
				if (Object.isString(cx) && (cx.first() === '+' || cx.first() === '-')) incrementX(cx);
				else that.canvasX = cx;
			}
			
			if (cy) {
				if (Object.isString(cy) && (cy.first() === '+' || cy.first() === '-')) incrementY(cy);
				else that.canvasY = cy;
			}
		};

		this.getCanvasPositionX = function () {
			return that.canvasX;
		};

		this.getCanvasPositionY = function  () {
			return that.canvasY;
		};

		this.getLeftHitBoxEdge = function (zIndex) {
			zIndex = zIndex || 0;
			var lhbe = this.getCanvasPositionX();
			if (getHitBox(zIndex)) {
				lhbe += getHitBox(zIndex)[0];
			}
			return lhbe;
		};

		this.getTopHitBoxEdge = function (zIndex) {
			zIndex = zIndex || 0;
			var thbe = this.getCanvasPositionY();
			if (getHitBox(zIndex)) {
				thbe += getHitBox(zIndex)[1];
			}
			return thbe;
		};

		this.getRightHitBoxEdge = function (zIndex) {
			zIndex = zIndex || 0;

			if (getHitBox(zIndex)) {
				return that.canvasX + getHitBox(zIndex)[2];
			}

			return that.canvasX + that.width;
		};

		this.getBottomHitBoxEdge = function (zIndex) {
			zIndex = zIndex || 0;

			if (getHitBox(zIndex)) {
				return that.canvasY + getHitBox(zIndex)[3];
			}

			return that.canvasY + that.height;
		};

		this.getPositionInFrontOf = function  () {
			return [that.canvasX, that.canvasY + that.height];
		};

		this.setSpeed = function (s) {
			that.speed = s;
			that.speedX = s;
			that.speedY = s;
		};

		this.incrementSpeedBy = function (s) {
			that.speed += s;
		};

		that.getSpeed = function getSpeed () {
			return that.speed;
		};

		that.getSpeedX = function () {
			return that.speed;
		};

		that.getSpeedY = function () {
			return that.speed;
		};

		this.setHeight = function (h) {
			that.height = h;
		};

		this.setWidth = function (w) {
			that.width = w;
		};

		this.getMaxHeight = function () {
			return that.maxHeight;
		};

		that.getMovingTowardOpposite = function () {
			if (!that.isMoving) {
				return [0, 0];
			}

			var dx = (that.movingToward[0] - that.mapPosition[0]);
			var dy = (that.movingToward[1] - that.mapPosition[1]);

			var oppositeX = (Math.abs(dx) > 75 ? 0 - dx : 0);
			var oppositeY = -dy;

			return [ oppositeX, oppositeY ];
		};

		this.checkHittableObjects = function () {
			Object.keys(hittableObjects, function (k, objectData) {
				if (objectData.object.deleted) {
					delete hittableObjects[k];
				} else {
					if (objectData.object.hits(that)) {
						objectData.callbacks.each(function (callback) {
							callback(that, objectData.object);
						});
					}
				}
			});
		};

		this.cycle = function () {
			that.checkHittableObjects();

			if (trackedSpriteToMoveToward) {
				that.setMapPositionTarget(trackedSpriteToMoveToward.mapPosition[0], trackedSpriteToMoveToward.mapPosition[1], true);
			}

			move();
		};

		this.setMapPositionTarget = function (x, y, override) {
			if (override) {
				that.movingWithConviction = false;
			}

			if (!that.movingWithConviction) {
				if (typeof x === 'undefined') {
					x = that.movingToward[0];
				}

				if (typeof y === 'undefined') {
					y = that.movingToward[1];
				}

				that.movingToward = [ x, y ];

				that.movingWithConviction = false;
			}

			// that.resetDirection();
		};

		this.setDirection = function (angle) {
			if (angle >= 360) {
				angle = 360 - angle;
			}
			that.direction = angle;
			that.movingToward = undefined;
		};

		this.resetDirection = function () {
			that.direction = undefined;
		};

		this.setMapPositionTargetWithConviction = function (cx, cy) {
			that.setMapPositionTarget(cx, cy);
			that.movingWithConviction = true;
			// that.resetDirection();
		};

		this.follow = function (sprite) {
			trackedSpriteToMoveToward = sprite;
			// that.resetDirection();
		};

		this.stopFollowing = function () {
			trackedSpriteToMoveToward = false;
		};

		this.onHitting = function (objectToHit, callback) {
			if (hittableObjects[objectToHit.id]) {
				return hittableObjects[objectToHit.id].callbacks.push(callback);
			}

			hittableObjects[objectToHit.id] = {
				object: objectToHit,
				callbacks: [ callback ]
			};
		};

		this.deleteOnNextCycle = function () {
			that.deleted = true;
		};

		this.occupiesZIndex = function (z) {
			return zIndexesOccupied.indexOf(z) >= 0;
		};

		this.hits = function (other) {
			var verticalIntersect = false;
			var horizontalIntersect = false;

			// Test that THIS has a bottom edge inside of the other object
			if (other.getTopHitBoxEdge(that.mapPosition[2]) <= that.getBottomHitBoxEdge(that.mapPosition[2]) && other.getBottomHitBoxEdge(that.mapPosition[2]) >= that.getBottomHitBoxEdge(that.mapPosition[2])) {
				verticalIntersect = true;
			}

			// Test that THIS has a top edge inside of the other object
			if (other.getTopHitBoxEdge(that.mapPosition[2]) <= that.getTopHitBoxEdge(that.mapPosition[2]) && other.getBottomHitBoxEdge(that.mapPosition[2]) >= that.getTopHitBoxEdge(that.mapPosition[2])) {
				verticalIntersect = true;
			}

			// Test that THIS has a right edge inside of the other object
			if (other.getLeftHitBoxEdge(that.mapPosition[2]) <= that.getRightHitBoxEdge(that.mapPosition[2]) && other.getRightHitBoxEdge(that.mapPosition[2]) >= that.getRightHitBoxEdge(that.mapPosition[2])) {
				horizontalIntersect = true;
			}

			// Test that THIS has a left edge inside of the other object
			if (other.getLeftHitBoxEdge(that.mapPosition[2]) <= that.getLeftHitBoxEdge(that.mapPosition[2]) && other.getRightHitBoxEdge(that.mapPosition[2]) >= that.getLeftHitBoxEdge(that.mapPosition[2])) {
				horizontalIntersect = true;
			}

			return verticalIntersect && horizontalIntersect;
		};

		this.isAboveOnCanvas = function (cy) {
			return (that.canvasY + that.height) < cy;
		};

		this.isBelowOnCanvas = function (cy) {
			return (that.canvasY) > cy;
		};

		return that;
	}

	Sprite.createObjects = function createObjects(spriteInfoArray, opts) {
		if (!Array.isArray(spriteInfoArray)) spriteInfoArray = [ spriteInfoArray ];
		opts = Object.merge(opts, {
			rateModifier: 0,
			dropRate: 1,
			position: [0, 0]
		}, false, false);

		function createOne (spriteInfo) {
			var position = opts.position;
			if (Number.random(100 + opts.rateModifier) <= spriteInfo.dropRate) {
				var sprite = new Sprite(spriteInfo.sprite);
				sprite.setSpeed(0);

				if (Object.isFunction(position)) {
					position = position();
				}

				sprite.setMapPosition(position[0], position[1]);

				if (spriteInfo.sprite.hitBehaviour && spriteInfo.sprite.hitBehaviour.skier && opts.player) {
					sprite.onHitting(opts.player, spriteInfo.sprite.hitBehaviour.skier);
				}

				return sprite;
			}
		}

		var objects = spriteInfoArray.map(createOne).remove(undefined);

		return objects;
	};

	global.sprite = Sprite;
})( this );


if (typeof module !== 'undefined') {
	module.exports = this.sprite;
}
},{"./guid":4}],12:[function(require,module,exports){
(function (global) {
	function SpriteArray() {
		this.pushHandlers = [];

		return this;
	}

	SpriteArray.prototype = Object.create(Array.prototype);

	SpriteArray.prototype.onPush = function(f, retroactive) {
		this.pushHandlers.push(f);

		if (retroactive) {
			this.each(f);
		}
	};

	SpriteArray.prototype.push = function(obj) {
		Array.prototype.push.call(this, obj);
		this.pushHandlers.each(function(handler) {
			handler(obj);
		});
	};

	SpriteArray.prototype.cull = function() {
		this.each(function (obj, i) {
			if (obj.deleted) {
				return (delete this[i]);
			}
		});
	};

	global.spriteArray = SpriteArray;
})(this);


if (typeof module !== 'undefined') {
	module.exports = this.spriteArray;
}
},{}],13:[function(require,module,exports){
// Global dependencies which return no modules
require('./lib/canvasRenderingContext2DExtensions');
require('./lib/plugins');

// External dependencies
var Hammer = require('hammerjs');
var Mousetrap = require('br-mousetrap');

// Method modules
var isMobileDevice = require('./lib/isMobileDevice');

// Game Objects
var SpriteArray = require('./lib/spriteArray');
var Monster = require('./lib/monster');
var Sprite = require('./lib/sprite');
var Snowboarder = require('./lib/snowboarder');
var Skier = require('./lib/skier');
var InfoBox = require('./lib/infoBox');
var Game = require('./lib/game');

// Local variables for starting the game
var mainCanvas = document.getElementById('skifree-canvas');
var dContext = mainCanvas.getContext('2d');
var imageSources = [ 'sprite-characters.png', 'skifree-objects.png' ];
var global = this;
var infoBoxControls = 'Use the mouse or WASD to control the player';
if (isMobileDevice()) infoBoxControls = 'Tap or drag on the piste to control the player';
var sprites = require('./spriteInfo');

var pixelsPerMetre = 18;
var distanceTravelledInMetres = 0;
var monsterDistanceThreshold = 2000;
var livesLeft = 5;
var highScore = 0;
var loseLifeOnObstacleHit = false;
var dropRates = {smallTree: 4, tallTree: 2, jump: 1, thickSnow: 1, rock: 1};
if (localStorage.getItem('highScore')) highScore = localStorage.getItem('highScore');

function loadImages (sources, next) {
	var loaded = 0;
	var images = {};

	function finish () {
		loaded += 1;
		if (loaded === sources.length) {
			next(images);
		}
	}

	sources.each(function (src) {
		var im = new Image();
		im.onload = finish;
		im.src = src;
		dContext.storeLoadedImage(src, im);
	});
}

function monsterHitsSkierBehaviour(monster, skier) {
	skier.isEatenBy(monster, function () {
		livesLeft -= 1;
		monster.isFull = true;
		monster.isEating = false;
		skier.isBeingEaten = false;
		monster.setSpeed(skier.getSpeed());
		monster.stopFollowing();
		var randomPositionAbove = dContext.getRandomMapPositionAboveViewport();
		monster.setMapPositionTarget(randomPositionAbove[0], randomPositionAbove[1]);
	});
}

function startNeverEndingGame (images) {
	var player;
	var startSign;
	var infoBox;
	var game;

	function resetGame () {
		distanceTravelledInMetres = 0;
		livesLeft = 5;
		highScore = localStorage.getItem('highScore');
		game.reset();
		game.addStaticObject(startSign);
	}

	function detectEnd () {
		if (!game.isPaused()) {
			highScore = localStorage.setItem('highScore', distanceTravelledInMetres);
			infoBox.setLines([
				'Game over!',
				'Hit space to restart'
			]);
			game.pause();
			game.cycle();
		}
	}

	function randomlySpawnNPC(spawnFunction, dropRate) {
		var rateModifier = Math.max(800 - mainCanvas.width, 0);
		if (Number.random(1000 + rateModifier) <= dropRate) {
			spawnFunction();
		}
	}

	function spawnMonster () {
		var newMonster = new Monster(sprites.monster);
		var randomPosition = dContext.getRandomMapPositionAboveViewport();
		newMonster.setMapPosition(randomPosition[0], randomPosition[1]);
		newMonster.follow(player);
		newMonster.setSpeed(player.getStandardSpeed());
		newMonster.onHitting(player, monsterHitsSkierBehaviour);

		game.addMovingObject(newMonster, 'monster');
	}

	function spawnBoarder () {
		var newBoarder = new Snowboarder(sprites.snowboarder);
		var randomPositionAbove = dContext.getRandomMapPositionAboveViewport();
		var randomPositionBelow = dContext.getRandomMapPositionBelowViewport();
		newBoarder.setMapPosition(randomPositionAbove[0], randomPositionAbove[1]);
		newBoarder.setMapPositionTarget(randomPositionBelow[0], randomPositionBelow[1]);
		newBoarder.onHitting(player, sprites.snowboarder.hitBehaviour.skier);

		game.addMovingObject(newBoarder);
	}

	player = new Skier(sprites.skier);
	player.setMapPosition(0, 0);
	player.setMapPositionTarget(0, -10);
	if ( loseLifeOnObstacleHit ) {
		player.setHitObstacleCb(function() {
			livesLeft -= 1;
		});
	}

	game = new Game(mainCanvas, player);

	startSign = new Sprite(sprites.signStart);
	game.addStaticObject(startSign);
	startSign.setMapPosition(-50, 0);
	dContext.followSprite(player);

	infoBox = new InfoBox({
		initialLines : [
			'SkiFree.js',
			infoBoxControls,
			'Travelled 0m',
			'High Score: ' + highScore,
			'Skiers left: ' + livesLeft,
			'Created by Dan Hough (@basicallydan)'
		],
		position: {
			top: 15,
			right: 10
		}
	});

	game.beforeCycle(function () {
		var newObjects = [];
		if (player.isMoving) {
			newObjects = Sprite.createObjects([
				{ sprite: sprites.smallTree, dropRate: dropRates.smallTree },
				{ sprite: sprites.tallTree, dropRate: dropRates.tallTree },
				{ sprite: sprites.jump, dropRate: dropRates.jump },
				{ sprite: sprites.thickSnow, dropRate: dropRates.thickSnow },
				{ sprite: sprites.rock, dropRate: dropRates.rock },
			], {
				rateModifier: Math.max(800 - mainCanvas.width, 0),
				position: function () {
					return dContext.getRandomMapPositionBelowViewport();
				},
				player: player
			});
		}
		if (!game.isPaused()) {
			game.addStaticObjects(newObjects);

			randomlySpawnNPC(spawnBoarder, 0.1);
			distanceTravelledInMetres = parseFloat(player.getPixelsTravelledDownMountain() / pixelsPerMetre).toFixed(1);

			if (distanceTravelledInMetres > monsterDistanceThreshold) {
				randomlySpawnNPC(spawnMonster, 0.001);
			}

			infoBox.setLines([
				'SkiFree.js',
				infoBoxControls,
				'Travelled ' + distanceTravelledInMetres + 'm',
				'Skiers left: ' + livesLeft,
				'High Score: ' + highScore,
				'Created by Dan Hough (@basicallydan)',
				'Current Speed: ' + player.getSpeed()/*,
				'Skier Map Position: ' + player.mapPosition[0].toFixed(1) + ', ' + player.mapPosition[1].toFixed(1),
				'Mouse Map Position: ' + mouseMapPosition[0].toFixed(1) + ', ' + mouseMapPosition[1].toFixed(1)*/
			]);
		}
	});

	game.afterCycle(function() {
		if (livesLeft === 0) {
			detectEnd();
		}
	});

	game.addUIElement(infoBox);
	
	$(mainCanvas)
	.mousemove(function (e) {
		game.setMouseX(e.pageX);
		game.setMouseY(e.pageY);
		player.resetDirection();
		player.startMovingIfPossible();
	})
	.bind('click', function (e) {
		game.setMouseX(e.pageX);
		game.setMouseY(e.pageY);
		player.resetDirection();
		player.startMovingIfPossible();
	})
	.focus(); // So we can listen to events immediately

	Mousetrap.bind('f', player.speedBoost);
	Mousetrap.bind('t', player.attemptTrick);
	Mousetrap.bind(['w', 'up'], function () {
		player.stop();
	});
	Mousetrap.bind(['a', 'left'], function () {
		if (player.direction === 270) {
			player.stepWest();
		} else {
			player.turnWest();
		}
	});
	Mousetrap.bind(['s', 'down'], function () {
		player.setDirection(180);
		player.startMovingIfPossible();
	});
	Mousetrap.bind(['d', 'right'], function () {
		if (player.direction === 90) {
			player.stepEast();
		} else {
			player.turnEast();
		}
	});
	Mousetrap.bind('m', spawnMonster);
	Mousetrap.bind('b', spawnBoarder);
	Mousetrap.bind('space', resetGame);

	var hammertime = Hammer(mainCanvas).on('press', function (e) {
		e.preventDefault();
		game.setMouseX(e.gesture.center.x);
		game.setMouseY(e.gesture.center.y);
	}).on('tap', function (e) {
		game.setMouseX(e.gesture.center.x);
		game.setMouseY(e.gesture.center.y);
	}).on('pan', function (e) {
		game.setMouseX(e.gesture.center.x);
		game.setMouseY(e.gesture.center.y);
		player.resetDirection();
		player.startMovingIfPossible();
	}).on('doubletap', function (e) {
		player.speedBoost();
	});

	player.isMoving = false;
	player.setDirection(270);

	game.start();
}

function resizeCanvas() {
	mainCanvas.width = window.innerWidth;
	mainCanvas.height = window.innerHeight;
}

window.addEventListener('resize', resizeCanvas, false);

resizeCanvas();

loadImages(imageSources, startNeverEndingGame);

this.exports = window;

},{"./lib/canvasRenderingContext2DExtensions":2,"./lib/game":3,"./lib/infoBox":5,"./lib/isMobileDevice":6,"./lib/monster":7,"./lib/plugins":8,"./lib/skier":9,"./lib/snowboarder":10,"./lib/sprite":11,"./lib/spriteArray":12,"./spriteInfo":14,"br-mousetrap":15,"hammerjs":103}],14:[function(require,module,exports){
(function (global) {
	var sprites = {
		'skier' : {
			$imageFile : 'sprite-characters.png',
			parts : {
				blank : [ 0, 0, 0, 0 ],
				east : [ 0, 0, 24, 34 ],
				esEast : [ 24, 0, 24, 34 ],
				sEast : [ 49, 0, 17, 34 ],
				south : [ 65, 0, 17, 34 ],
				sWest : [ 49, 37, 17, 34 ],
				wsWest : [ 24, 37, 24, 34 ],
				west : [ 0, 37, 24, 34 ],
				hit : [ 0, 78, 31, 31 ],
				jumping : [ 84, 0, 32, 34 ],
				somersault1 : [ 116, 0, 32, 34 ],
				somersault2 : [ 148, 0, 32, 34 ]
			},
			hitBoxes: {
				0: [ 7, 20, 27, 34 ]
			},
			id : 'player',
			hitBehaviour: {}
		},
		'smallTree' : {
			$imageFile : 'skifree-objects.png',
			parts : {
				main : [ 0, 28, 30, 34 ]
			},
			hitBoxes: {
				0: [ 0, 18, 30, 34 ]
			},
			hitBehaviour: {}
		},
		'tallTree' : {
			$imageFile : 'skifree-objects.png',
			parts : {
				main : [ 95, 66, 32, 64 ]
			},
			zIndexesOccupied : [0, 1],
			hitBoxes: {
				0: [0, 54, 32, 64],
				1: [0, 10, 32, 54]
			},
			hitBehaviour: {}
		},
		'thickSnow' : {
			$imageFile : 'skifree-objects.png',
			parts : {
				main : [ 143, 53, 43, 10 ]
			},
			hitBehaviour: {}
		},
		'rock' : {
			$imageFile : 'skifree-objects.png',
			parts : {
				main : [ 30, 52, 23, 11 ]
			},
			hitBehaviour: {}
		},
		'monster' : {
			$imageFile : 'sprite-characters.png',
			parts : {
				sEast1 : [ 64, 112, 26, 43 ],
				sEast2 : [ 90, 112, 32, 43 ],
				sWest1 : [ 64, 158, 26, 43 ],
				sWest2 : [ 90, 158, 32, 43 ],
				eating1 : [ 122, 112, 34, 43 ],
				eating2 : [ 156, 112, 31, 43 ],
				eating3 : [ 187, 112, 31, 43 ],
				eating4 : [ 219, 112, 25, 43 ],
				eating5 : [ 243, 112, 26, 43 ]
			},
			hitBehaviour: {}
		},
		'jump' : {
			$imageFile : 'skifree-objects.png',
			parts : {
				main : [ 109, 55, 32, 8 ]
			},
			hitBehaviour: {}
		},
		'signStart' : {
			$imageFile : 'skifree-objects.png',
			parts : {
				main : [ 260, 103, 42, 27 ]
			},
			hitBehaviour: {}
		},
		'snowboarder' : {
			$imageFile : 'sprite-characters.png',
			parts : {
				sEast : [ 73, 229, 20, 29 ],
				sWest : [ 95, 228, 26, 30 ]
			},
			hitBehaviour: {}
		},
		'emptyChairLift': {
			$imageFile : 'skifree-objects.png',
			parts: {
				main : [ 92, 136, 26, 30 ]
			},
			zIndexesOccupied : [1],
		}
	};

	function monsterHitsTreeBehaviour(monster) {
		monster.deleteOnNextCycle();
	}

	sprites.monster.hitBehaviour.tree = monsterHitsTreeBehaviour;

	function treeHitsMonsterBehaviour(tree, monster) {
		monster.deleteOnNextCycle();
	}

	sprites.smallTree.hitBehaviour.monster = treeHitsMonsterBehaviour;
	sprites.tallTree.hitBehaviour.monster = treeHitsMonsterBehaviour;

	function skierHitsTreeBehaviour(skier, tree) {
		skier.hasHitObstacle(tree);
	}

	function treeHitsSkierBehaviour(tree, skier) {
		skier.hasHitObstacle(tree);
	}

	sprites.smallTree.hitBehaviour.skier = treeHitsSkierBehaviour;
	sprites.tallTree.hitBehaviour.skier = treeHitsSkierBehaviour;

	function rockHitsSkierBehaviour(rock, skier) {
		skier.hasHitObstacle(rock);
	}

	sprites.rock.hitBehaviour.skier = rockHitsSkierBehaviour;

	function skierHitsJumpBehaviour(skier, jump) {
		skier.hasHitJump(jump);
	}

	function jumpHitsSkierBehaviour(jump, skier) {
		skier.hasHitJump(jump);
	}

	sprites.jump.hitBehaviour.skier = jumpHitsSkierBehaviour;

// Really not a fan of this behaviour.
/*	function skierHitsThickSnowBehaviour(skier, thickSnow) {
		// Need to implement this properly
		skier.setSpeed(2);
		setTimeout(function() {
			skier.resetSpeed();
		}, 700);
	}

	function thickSnowHitsSkierBehaviour(thickSnow, skier) {
		// Need to implement this properly
		skier.setSpeed(2);
		setTimeout(function() {
			skier.resetSpeed();
		}, 300);
	}*/

	// sprites.thickSnow.hitBehaviour.skier = thickSnowHitsSkierBehaviour;

	function snowboarderHitsSkierBehaviour(snowboarder, skier) {
		skier.hasHitObstacle(snowboarder);
	}

	sprites.snowboarder.hitBehaviour.skier = snowboarderHitsSkierBehaviour;

	global.spriteInfo = sprites;
})( this );


if (typeof module !== 'undefined') {
	module.exports = this.spriteInfo;
}
},{}],15:[function(require,module,exports){
/**
 * Copyright 2012 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.1.3
 * @url craig.is/killing/mice
 */
(function() {

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
            8: 'backspace',
            9: 'tab',
            13: 'enter',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'ins',
            46: 'del',
            91: 'meta',
            93: 'meta',
            224: 'meta'
        },

        /**
         * mapping for special characters so they can support
         *
         * this dictionary is only used incase you want to bind a
         * keyup or keydown event to one of these keys
         *
         * @type {Object}
         */
        _KEYCODE_MAP = {
            106: '*',
            107: '+',
            109: '-',
            110: '.',
            111 : '/',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: '\''
        },

        /**
         * this is a mapping of keys that require shift on a US keypad
         * back to the non shift equivelents
         *
         * this is so you can use keyup events with these keys
         *
         * note that this will only work reliably on US keyboards
         *
         * @type {Object}
         */
        _SHIFT_MAP = {
            '~': '`',
            '!': '1',
            '@': '2',
            '#': '3',
            '$': '4',
            '%': '5',
            '^': '6',
            '&': '7',
            '*': '8',
            '(': '9',
            ')': '0',
            '_': '-',
            '+': '=',
            ':': ';',
            '\"': '\'',
            '<': ',',
            '>': '.',
            '?': '/',
            '|': '\\'
        },

        /**
         * this is a list of special strings you can use to map
         * to modifier keys when you specify your keyboard shortcuts
         *
         * @type {Object}
         */
        _SPECIAL_ALIASES = {
            'option': 'alt',
            'command': 'meta',
            'return': 'enter',
            'escape': 'esc'
        },

        /**
         * variable to store the flipped version of _MAP from above
         * needed to check if we should use keypress or not when no action
         * is specified
         *
         * @type {Object|undefined}
         */
        _REVERSE_MAP,

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        _callbacks = {},

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        _direct_map = {},

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        _sequence_levels = {},

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        _reset_timer,

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        _ignore_next_keyup = false,

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        _inside_sequence = false;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {
        _MAP[i + 96] = i;
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            return String.fromCharCode(e.which);
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * resets all sequence counters except for the ones passed in
     *
     * @param {Object} do_not_reset
     * @returns void
     */
    function _resetSequences(do_not_reset) {
        do_not_reset = do_not_reset || {};

        var active_sequences = false,
            key;

        for (key in _sequence_levels) {
            if (do_not_reset[key]) {
                active_sequences = true;
                continue;
            }
            _sequence_levels[key] = 0;
        }

        if (!active_sequences) {
            _inside_sequence = false;
        }
    }

    /**
     * finds all callbacks that match based on the keycode, modifiers,
     * and action
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event|Object} e
     * @param {boolean=} remove - should we remove any matches
     * @param {string=} combination
     * @returns {Array}
     */
    function _getMatches(character, modifiers, e, remove, combination) {
        var i,
            callback,
            matches = [],
            action = e.type;

        // if there are no events related to this keycode
        if (!_callbacks[character]) {
            return [];
        }

        // if a modifier key is coming up on its own we should allow it
        if (action == 'keyup' && _isModifier(character)) {
            modifiers = [character];
        }

        // loop through all callbacks for the key that was pressed
        // and see if any of them match
        for (i = 0; i < _callbacks[character].length; ++i) {
            callback = _callbacks[character][i];

            // if this is a sequence but it is not at the right level
            // then move onto the next match
            if (callback.seq && _sequence_levels[callback.seq] != callback.level) {
                continue;
            }

            // if the action we are looking for doesn't match the action we got
            // then we should keep going
            if (action != callback.action) {
                continue;
            }

            // if this is a keypress event and the meta key and control key
            // are not pressed that means that we need to only look at the
            // character, otherwise check the modifiers as well
            //
            // chrome will not fire a keypress if meta or control is down
            // safari will fire a keypress if meta or meta+shift is down
            // firefox will fire a keypress if meta or control is down
            if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                // remove is used so if you change your mind and call bind a
                // second time with a new function the first one is overwritten
                if (remove && callback.combo == combination) {
                    _callbacks[character].splice(i, 1);
                }

                matches.push(callback);
            }
        }

        return matches;
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * actually calls the callback function
     *
     * if your callback function returns false this will use the jquery
     * convention - prevent default and stop propogation on the event
     *
     * @param {Function} callback
     * @param {Event} e
     * @returns void
     */
    function _fireCallback(callback, e) {
        if (callback(e) === false) {
            if (e.preventDefault) {
                e.preventDefault();
            }

            if (e.stopPropagation) {
                e.stopPropagation();
            }

            e.returnValue = false;
            e.cancelBubble = true;
        }
    }

    /**
     * handles a character key event
     *
     * @param {string} character
     * @param {Event} e
     * @returns void
     */
    function _handleCharacter(character, e) {

        // if this event should not happen stop here
        if (Mousetrap.stopCallback(e, e.target || e.srcElement)) {
            return;
        }

        var callbacks = _getMatches(character, _eventModifiers(e), e),
            i,
            do_not_reset = {},
            processed_sequence_callback = false;

        // loop through matching callbacks for this key event
        for (i = 0; i < callbacks.length; ++i) {

            // fire for all sequence callbacks
            // this is because if for example you have multiple sequences
            // bound such as "g i" and "g t" they both need to fire the
            // callback for matching g cause otherwise you can only ever
            // match the first one
            if (callbacks[i].seq) {
                processed_sequence_callback = true;

                // keep a list of which sequences were matches for later
                do_not_reset[callbacks[i].seq] = 1;
                _fireCallback(callbacks[i].callback, e);
                continue;
            }

            // if there were no sequence matches but we are still here
            // that means this is a regular match so we should fire that
            if (!processed_sequence_callback && !_inside_sequence) {
                _fireCallback(callbacks[i].callback, e);
            }
        }

        // if you are inside of a sequence and the key you are pressing
        // is not a modifier key then we should reset all sequences
        // that were not matched by this key event
        if (e.type == _inside_sequence && !_isModifier(character)) {
            _resetSequences(do_not_reset);
        }
    }

    /**
     * handles a keydown event
     *
     * @param {Event} e
     * @returns void
     */
    function _handleKey(e) {

        // normalize e.which for key events
        // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
        e.which = typeof e.which == "number" ? e.which : e.keyCode;

        var character = _characterFromEvent(e);

        // no character found then stop
        if (!character) {
            return;
        }

        if (e.type == 'keyup' && _ignore_next_keyup == character) {
            _ignore_next_keyup = false;
            return;
        }

        _handleCharacter(character, e);
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * called to set a 1 second timeout on the specified sequence
     *
     * this is so after each key press in the sequence you have 1 second
     * to press the next key before you have to start over
     *
     * @returns void
     */
    function _resetSequenceTimer() {
        clearTimeout(_reset_timer);
        _reset_timer = setTimeout(_resetSequences, 1000);
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * binds a key sequence to an event
     *
     * @param {string} combo - combo specified in bind call
     * @param {Array} keys
     * @param {Function} callback
     * @param {string=} action
     * @returns void
     */
    function _bindSequence(combo, keys, callback, action) {

        // start off by adding a sequence level record for this combination
        // and setting the level to 0
        _sequence_levels[combo] = 0;

        // if there is no action pick the best one for the first key
        // in the sequence
        if (!action) {
            action = _pickBestAction(keys[0], []);
        }

        /**
         * callback to increase the sequence level for this sequence and reset
         * all other sequences that were active
         *
         * @param {Event} e
         * @returns void
         */
        var _increaseSequence = function(e) {
                _inside_sequence = action;
                ++_sequence_levels[combo];
                _resetSequenceTimer();
            },

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            _callbackAndReset = function(e) {
                _fireCallback(callback, e);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignore_next_keyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            },
            i;

        // loop through keys one at a time and bind the appropriate callback
        // function.  for any key leading up to the final one it should
        // increase the sequence. after the final, it should reset all sequences
        for (i = 0; i < keys.length; ++i) {
            _bindSingle(keys[i], i < keys.length - 1 ? _increaseSequence : _callbackAndReset, action, combo, i);
        }
    }

    /**
     * binds a single keyboard combination
     *
     * @param {string} combination
     * @param {Function} callback
     * @param {string=} action
     * @param {string=} sequence_name - name of sequence if part of sequence
     * @param {number=} level - what part of the sequence the command is
     * @returns void
     */
    function _bindSingle(combination, callback, action, sequence_name, level) {

        // make sure multiple spaces in a row become a single space
        combination = combination.replace(/\s+/g, ' ');

        var sequence = combination.split(' '),
            i,
            key,
            keys,
            modifiers = [];

        // if this pattern is a sequence of keys then run through this method
        // to reprocess each pattern one key at a time
        if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action);
            return;
        }

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = combination === '+' ? ['+'] : combination.split('+');

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        // make sure to initialize array if this is the first time
        // a callback is added for this key
        if (!_callbacks[key]) {
            _callbacks[key] = [];
        }

        // remove an existing match if there is one
        _getMatches(key, modifiers, {type: action}, !sequence_name, combination);

        // add this call back to the array
        // if it is a sequence put it at the beginning
        // if not put it at the end
        //
        // this is important because the way these are processed expects
        // the sequence ones to come first
        _callbacks[key][sequence_name ? 'unshift' : 'push']({
            callback: callback,
            modifiers: modifiers,
            action: action,
            seq: sequence_name,
            level: level,
            combo: combination
        });
    }

    /**
     * binds multiple combinations to the same callback
     *
     * @param {Array} combinations
     * @param {Function} callback
     * @param {string|undefined} action
     * @returns void
     */
    function _bindMultiple(combinations, callback, action) {
        for (var i = 0; i < combinations.length; ++i) {
            _bindSingle(combinations[i], callback, action);
        }
    }

    // start!
    _addEvent(document, 'keypress', _handleKey);
    _addEvent(document, 'keydown', _handleKey);
    _addEvent(document, 'keyup', _handleKey);

    var Mousetrap = {

        /**
         * binds an event to mousetrap
         *
         * can be a single key, a combination of keys separated with +,
         * an array of keys, or a sequence of keys separated by spaces
         *
         * be sure to list the modifier keys first to make sure that the
         * correct key ends up getting bound (the last key in the pattern)
         *
         * @param {string|Array} keys
         * @param {Function} callback
         * @param {string=} action - 'keypress', 'keydown', or 'keyup'
         * @returns void
         */
        bind: function(keys, callback, action) {
            _bindMultiple(keys instanceof Array ? keys : [keys], callback, action);
            _direct_map[keys + ':' + action] = callback;
            return this;
        },

        /**
         * unbinds an event to mousetrap
         *
         * the unbinding sets the callback function of the specified key combo
         * to an empty function and deletes the corresponding key in the
         * _direct_map dict.
         *
         * the keycombo+action has to be exactly the same as
         * it was defined in the bind method
         *
         * TODO: actually remove this from the _callbacks dictionary instead
         * of binding an empty function
         *
         * @param {string|Array} keys
         * @param {string} action
         * @returns void
         */
        unbind: function(keys, action) {
            if (_direct_map[keys + ':' + action]) {
                delete _direct_map[keys + ':' + action];
                this.bind(keys, function() {}, action);
            }
            return this;
        },

        /**
         * triggers an event that has already been bound
         *
         * @param {string} keys
         * @param {string=} action
         * @returns void
         */
        trigger: function(keys, action) {
            _direct_map[keys + ':' + action]();
            return this;
        },

        /**
         * resets the library back to its initial state.  this is useful
         * if you want to clear out the current keyboard shortcuts and bind
         * new ones - for example if you switch to another page
         *
         * @returns void
         */
        reset: function() {
            _callbacks = {};
            _direct_map = {};
            return this;
        },

       /**
        * should we stop this event before firing off callbacks
        *
        * @param {Event} e
        * @param {Element} element
        * @return {boolean}
        */
        stopCallback: function(e, element) {

            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }

            // stop for input, select, and textarea
            return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || (element.contentEditable && element.contentEditable == 'true');
        }
    };

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose mousetrap as an AMD module
    if (typeof define == 'function' && define.amd) {
        define('mousetrap', function() { return Mousetrap; });
    }
    // browserify support
    if(typeof module === 'object' && module.exports) {
        module.exports = Mousetrap;
    }
}) ();

},{}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CrossValidate = function () {

  /**
   *
   * @param {NeuralNetwork|constructor} Classifier
   * @param {object} [options]
   */
  function CrossValidate(Classifier, options) {
    _classCallCheck(this, CrossValidate);

    this.Classifier = Classifier;
    this.options = options;
    this.json = null;
  }

  /**
   *
   * @param {object} trainOpts
   * @param {object} trainSet
   * @param {object} testSet
   * @returns {void|*}
   */


  _createClass(CrossValidate, [{
    key: 'testPartition',
    value: function testPartition(trainOpts, trainSet, testSet) {
      var classifier = new this.Classifier(this.options);
      var beginTrain = Date.now();
      var trainingStats = classifier.train(trainSet, trainOpts);
      var beginTest = Date.now();
      var testStats = classifier.test(testSet);
      var endTest = Date.now();
      var stats = Object.assign({}, testStats, {
        trainTime: beginTest - beginTrain,
        testTime: endTest - beginTest,
        iterations: trainingStats.iterations,
        error: trainingStats.error,
        total: testStats.total,
        learningRate: classifier.trainOpts.learningRate,
        hiddenLayers: classifier.hiddenLayers,
        network: classifier.toJSON()
      });

      return stats;
    }

    /**
     * Randomize array element order in-place.
     * Using Durstenfeld shuffle algorithm.
     * source: http://stackoverflow.com/a/12646864/1324039
     */

  }, {
    key: 'shuffleArray',
    value: function shuffleArray(array) {
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      return array;
    }

    /**
     *
     * @param {object} data
     * @param {object} trainOpts
     * @param {number} [k]
     * @returns {
     *  {
     *    avgs: {
     *      error: number,
     *      trainTime: number,
     *      testTime: number,
     *      iterations: number,
     *      error: number
     *    },
     *    stats: {
     *      truePos: number,
     *      trueNeg: number,
     *      falsePos: number,
     *      falseNeg: number,
     *      total: number
     *    },
     *    sets: Array
     *  }
     * }
     */

  }, {
    key: 'train',
    value: function train(data) {
      var trainOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var k = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

      if (data.length < k) {
        throw new Error('Training set size is too small for ' + data.length + ' k folds of ' + k);
      }

      var size = data.length / k;

      if (data.constructor === Array) {
        this.shuffleArray(data);
      } else {
        var newData = {};
        this.shuffleArray(Object.keys(data)).forEach(function (key) {
          newData[key] = data[key];
        });
        data = newData;
      }

      var avgs = {
        trainTime: 0,
        testTime: 0,
        iterations: 0,
        error: 0
      };

      var stats = {
        total: 0
      };

      var binaryStats = {
        total: 0,
        truePos: 0,
        trueNeg: 0,
        falsePos: 0,
        falseNeg: 0
      };

      var results = [];
      var stat = void 0;
      var isBinary = null;

      for (var i = 0; i < k; i++) {
        var dclone = data.slice(0);
        var testSet = dclone.splice(i * size, size);
        var trainSet = dclone;
        var result = this.testPartition(trainOpts, trainSet, testSet);

        if (isBinary === null) {
          isBinary = result.hasOwnProperty('falseNeg') && result.hasOwnProperty('falsePos') && result.hasOwnProperty('trueNeg') && result.hasOwnProperty('truePos');
          if (isBinary) {
            Object.assign(stats, binaryStats);
          }
        }

        for (stat in avgs) {
          if (stat in avgs) {
            avgs[stat] += result[stat];
          }
        }

        for (stat in stats) {
          if (stat in stats) {
            stats[stat] += result[stat];
          }
        }

        results.push(result);
      }

      for (stat in avgs) {
        if (stat in avgs) {
          avgs[stat] /= k;
        }
      }

      if (isBinary) {
        stats.precision = stats.truePos / (stats.truePos + stats.falsePos);
        stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);
        stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;
      }

      stats.testSize = size;
      stats.trainSize = data.length - size;

      return this.json = {
        avgs: avgs,
        stats: stats,
        sets: results
      };
    }
  }, {
    key: 'toNeuralNetwork',
    value: function toNeuralNetwork() {
      return this.fromJSON(this.json);
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this.json;
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(crossValidateJson) {
      var Classifier = this.Classifier;
      var json = crossValidateJson.sets.reduce(function (prev, cur) {
        return prev.error < cur.error ? prev : cur;
      }, { error: Infinity }).network;
      if (Classifier.fromJSON) {
        return Classifier.fromJSON(json);
      }
      var instance = new Classifier();
      instance.fromJSON(json);
      return instance;
    }
  }]);

  return CrossValidate;
}();

exports.default = CrossValidate;

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = likely;
/**
 *
 * @param {*} input
 * @param {brain.NeuralNetwork} net
 * @returns {*}
 */
function likely(input, net) {
  var output = net.run(input);
  var maxProp = null;
  var maxValue = -1;
  for (var prop in output) {
    var value = output[prop];
    if (value > maxValue) {
      maxProp = prop;
      maxValue = value;
    }
  }
  return maxProp;
}

},{}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* Functions for turning sparse hashes into arrays and vice versa */
var lookup = function () {
  function lookup() {
    _classCallCheck(this, lookup);
  }

  _createClass(lookup, null, [{
    key: 'toTable',

    /**
     * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
     * @param {Object} hashes
     * @returns {Object}
     */
    value: function toTable(hashes) {
      var hash = hashes.reduce(function (memo, hash) {
        return Object.assign(memo, hash);
      }, {});

      return lookup.toHash(hash);
    }

    /**
     * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
     * @param {Object} objects2D
     * @returns {Object}
     */

  }, {
    key: 'toTable2D',
    value: function toTable2D(objects2D) {
      var table = {};
      var valueIndex = 0;
      for (var i = 0; i < objects2D.length; i++) {
        var objects = objects2D[i];
        for (var j = 0; j < objects.length; j++) {
          var object = objects[j];
          for (var p in object) {
            if (object.hasOwnProperty(p) && !table.hasOwnProperty(p)) {
              table[p] = valueIndex++;
            }
          }
        }
      }
      return table;
    }
  }, {
    key: 'toInputTable',
    value: function toInputTable(data) {
      var table = {};
      var tableIndex = 0;
      for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {
        for (var p in data[dataIndex].input) {
          if (!table.hasOwnProperty(p)) {
            table[p] = tableIndex++;
          }
        }
      }
      return table;
    }
  }, {
    key: 'toInputTable2D',
    value: function toInputTable2D(data) {
      var table = {};
      var tableIndex = 0;
      for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {
        var input = data[dataIndex].input;
        for (var i = 0; i < input.length; i++) {
          var object = input[i];
          for (var p in object) {
            if (!table.hasOwnProperty(p)) {
              table[p] = tableIndex++;
            }
          }
        }
      }
      return table;
    }
  }, {
    key: 'toOutputTable',
    value: function toOutputTable(data) {
      var table = {};
      var tableIndex = 0;
      for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {
        for (var p in data[dataIndex].output) {
          if (!table.hasOwnProperty(p)) {
            table[p] = tableIndex++;
          }
        }
      }
      return table;
    }
  }, {
    key: 'toOutputTable2D',
    value: function toOutputTable2D(data) {
      var table = {};
      var tableIndex = 0;
      for (var dataIndex = 0; dataIndex < data.length; dataIndex++) {
        var output = data[dataIndex].output;
        for (var i = 0; i < output.length; i++) {
          var object = output[i];
          for (var p in object) {
            if (!table.hasOwnProperty(p)) {
              table[p] = tableIndex++;
            }
          }
        }
      }
      return table;
    }

    /**
     * performs `{a: 6, b: 7} -> {a: 0, b: 1}`
     * @param {Object} hash
     * @returns {Object}
     */

  }, {
    key: 'toHash',
    value: function toHash(hash) {
      var lookup = {};
      var index = 0;
      for (var i in hash) {
        lookup[i] = index++;
      }
      return lookup;
    }

    /**
     * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`
     * @param {*} lookup
     * @param {*} object
     * @param {*} arrayLength
     * @returns {Float32Array}
     */

  }, {
    key: 'toArray',
    value: function toArray(lookup, object, arrayLength) {
      var result = new Float32Array(arrayLength);
      for (var p in lookup) {
        result[lookup[p]] = object.hasOwnProperty(p) ? object[p] : 0;
      }
      return result;
    }
  }, {
    key: 'toArrayShort',
    value: function toArrayShort(lookup, object) {
      var result = [];
      for (var p in lookup) {
        if (!object.hasOwnProperty(p)) break;
        result[lookup[p]] = object[p];
      }
      return Float32Array.from(result);
    }
  }, {
    key: 'toArrays',
    value: function toArrays(lookup, objects, arrayLength) {
      var result = [];
      for (var i = 0; i < objects.length; i++) {
        result.push(this.toArray(lookup, objects[i], arrayLength));
      }
      return result;
    }

    /**
     * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`
     * @param {Object} lookup
     * @param {Array} array
     * @returns {Object}
     */

  }, {
    key: 'toObject',
    value: function toObject(lookup, array) {
      var object = {};
      for (var p in lookup) {
        object[p] = array[lookup[p]];
      }
      return object;
    }
  }, {
    key: 'toObjectPartial',
    value: function toObjectPartial(lookup, array) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var object = {};
      var i = 0;
      for (var p in lookup) {
        if (offset > 0) {
          if (i++ < offset) continue;
        }
        if (limit > 0) {
          if (i++ >= limit) continue;
        }
        object[p] = array[lookup[p] - offset];
      }
      return object;
    }

    /**
     *
     * @param {Array} array
     * @returns {*}
     */

  }, {
    key: 'lookupFromArray',
    value: function lookupFromArray(array) {
      var lookup = {};
      var z = 0;
      var i = array.length;
      while (i-- > 0) {
        lookup[array[i]] = z++;
      }
      return lookup;
    }
  }, {
    key: 'dataShape',
    value: function dataShape(data) {
      var shape = [];

      if (data.input) {
        shape.push('datum');
        data = data.input;
      } else if (Array.isArray(data)) {
        if (data[0].input) {
          shape.push('array', 'datum');
          data = data[0].input;
        } else {
          shape.push('array');
          data = data[0];
        }
      }

      var p = void 0;
      while (data) {
        for (p in data) {
          break;
        }
        if (!data.hasOwnProperty(p)) break;
        if (Array.isArray(data) || data.buffer instanceof ArrayBuffer) {
          shape.push('array');
          data = data[p];
        } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
          shape.push('object');
          data = data[p];
        } else {
          throw new Error('unhandled signature');
        }
      }
      shape.push(typeof data === 'undefined' ? 'undefined' : _typeof(data));
      return shape;
    }
  }, {
    key: 'addKeys',
    value: function addKeys(value, table) {
      if (Array.isArray(value)) return;
      table = table || {};
      var i = Object.keys(table).length;
      for (var p in value) {
        if (!value.hasOwnProperty(p)) continue;
        if (table.hasOwnProperty(p)) continue;
        table[p] = i++;
      }
      return table;
    }
  }]);

  return lookup;
}();

exports.default = lookup;

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _neuralNetwork = require('./neural-network');

var _neuralNetwork2 = _interopRequireDefault(_neuralNetwork);

var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

var _gpu = require('gpu.js');

var _gpu2 = _interopRequireDefault(_gpu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @param {object} options
 * @constructor
 */
var NeuralNetworkGPU = function (_NeuralNetwork) {
  _inherits(NeuralNetworkGPU, _NeuralNetwork);

  function NeuralNetworkGPU() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NeuralNetworkGPU);

    var _this = _possibleConstructorReturn(this, (NeuralNetworkGPU.__proto__ || Object.getPrototypeOf(NeuralNetworkGPU)).call(this, options));

    _this.forwardPropagate = [];
    _this.backwardPropagate = [];
    _this.changesPropagate = [];
    _this.biasesPropagate = [];
    _this.biasCopies = [];
    _this.copyBias = [];
    _this.changesCopies = [];
    _this.copyChanges = [];
    _this.weightsCopies = [];
    _this.copyWeights = [];
    _this.errorCheckInterval = 100;
    _this.gpu = new _gpu2.default({ mode: options.mode });
    return _this;
  }

  /**
   *
   */


  _createClass(NeuralNetworkGPU, [{
    key: 'initialize',
    value: function initialize() {
      _get(NeuralNetworkGPU.prototype.__proto__ || Object.getPrototypeOf(NeuralNetworkGPU.prototype), 'initialize', this).call(this);
      this.buildRunInput();
      this.buildCalculateDeltas();
      this.buildGetChanges();
      this.buildChangeBiases();
      this.buildGetMSE();
    }
  }, {
    key: 'setActivation',
    value: function setActivation() {}

    /**
     *
     * @param value
     * @param logErrorRate
     */

  }, {
    key: 'trainPattern',
    value: function trainPattern(value, logErrorRate) {
      // forward propagate
      this.runInput(value.input);

      // back propagate
      this.calculateDeltas(value.output);
      this.adjustWeights();

      if (logErrorRate) {
        return this.getMSE(this.errors[this.outputLayer])[0];
      } else {
        return null;
      }
    }
  }, {
    key: 'adjustWeights',
    value: function adjustWeights() {
      this.getChanges();
      this.changeBiases();
    }
  }, {
    key: 'buildRunInput',
    value: function buildRunInput() {
      var weightedSum = null;

      switch (this.activation) {
        case 'sigmoid':
          weightedSum = weightedSumSigmoid;
          break;
        case 'relu':
          weightedSum = weightedSumRelu;
          break;
        case 'leaky-relu':
          weightedSum = weightedSumLeakyRelu;
          break;
        case 'tanh':
          weightedSum = weightedSumTanh;
          break;
        default:
          throw new Error('unknown activation ' + this.activation);
      }

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.forwardPropagate[layer] = this.gpu.createKernel(weightedSum, {
          output: [this.sizes[layer]],
          outputToTexture: true,
          hardcodeConstants: true,
          constants: {
            size: this.sizes[layer - 1]
          }
        });
      }

      this.texturizeInputData = this.gpu.createKernel(function (value) {
        return value[this.thread.x];
      }, {
        output: [this.sizes[1]],
        outputToTexture: true,
        hardcodeConstants: true,
        outputImmutable: true
      });
    }

    /**
     *
     * @param input
     * @returns {*}
     */

  }, {
    key: 'runInput',
    value: function runInput(input) {
      var output = void 0;
      this.outputs[0] = input;
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.outputs[layer] = this.forwardPropagate[layer](this.weights[layer], this.biases[layer], input);
        output = input = this.outputs[layer];
      }
      return output;
    }
  }, {
    key: 'buildCalculateDeltas',
    value: function buildCalculateDeltas() {
      var calcDeltas = null;

      switch (this.activation) {
        case 'sigmoid':
          calcDeltas = calcDeltasSigmoid;
          break;
        case 'relu':
          calcDeltas = calcDeltasRelu;
          break;
        case 'leaky-relu':
          calcDeltas = calcDeltasLeakyRelu;
          break;
        case 'tanh':
          calcDeltas = calcDeltasTanh;
          break;
        default:
          throw new Error('unknown activation ' + this.activation);
      }

      for (var layer = this.outputLayer; layer > 0; layer--) {
        if (layer === this.outputLayer) {
          this.backwardPropagate[layer] = this.gpu.createKernelMap({
            error: _gpu2.default.alias('calcErrorOutput', calcErrorOutput),
            deltas: _gpu2.default.alias('calcDeltas', calcDeltas)
          }, function (outputs, targets) {
            var output = outputs[this.thread.x];
            return calcDeltas(calcErrorOutput(output, targets), output);
          }, {
            output: [this.sizes[layer]],
            outputToTexture: true,
            hardcodeConstants: true
          });
        } else {
          this.backwardPropagate[layer] = this.gpu.createKernelMap({
            error: _gpu2.default.alias('calcError', calcError),
            deltas: _gpu2.default.alias('calcDeltas', calcDeltas)
          }, function (nextWeights, outputs, nextDeltas) {
            var output = outputs[this.thread.x];
            return calcDeltas(calcError(nextWeights, nextDeltas), output);
          }, {
            output: [this.sizes[layer]],
            outputToTexture: true,
            hardcodeConstants: true,
            constants: {
              size: this.deltas[layer + 1].length
            }
          });
        }
      }
    }
  }, {
    key: 'calculateDeltas',
    value: function calculateDeltas(target) {
      for (var layer = this.outputLayer; layer > 0; layer--) {
        var output = void 0;

        if (layer === this.outputLayer) {
          output = this.backwardPropagate[layer](this.outputs[layer], target);
        } else {
          output = this.backwardPropagate[layer](this.weights[layer + 1], this.outputs[layer], this.deltas[layer + 1]);
        }

        this.deltas[layer] = output.deltas;
        this.errors[layer] = output.error;
      }
    }
  }, {
    key: 'buildGetChanges',
    value: function buildGetChanges() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.changesPropagate[layer] = this.gpu.createKernelMap({
          weights: _gpu2.default.alias('addWeights', addWeights),
          changes: _gpu2.default.alias('calcChanges', calcChanges)
        }, function (previousOutputs, deltas, weights, changes) {
          var change = calcChanges(changes, deltas, previousOutputs);

          return addWeights(change, weights);
        }, {
          output: [this.sizes[layer - 1], this.sizes[layer]],
          outputToTexture: true,
          hardcodeConstants: true,
          constants: {
            size: this.outputs[layer - 1].length,
            learningRate: this.trainOpts.learningRate,
            momentum: this.trainOpts.momentum
          }
        });

        this.copyChanges[layer] = this.gpu.createKernel(function (value) {
          return value[this.thread.y][this.thread.x];
        }, {
          output: this.changesPropagate[layer].output,
          outputToTexture: true,
          hardCodeConstants: true
        });

        this.copyWeights[layer] = this.gpu.createKernel(function (value) {
          return value[this.thread.y][this.thread.x];
        }, {
          output: this.changesPropagate[layer].output,
          outputToTexture: true,
          hardCodeConstants: true
        });
      }
    }
  }, {
    key: 'getChanges',
    value: function getChanges() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        var output = this.changesPropagate[layer](this.outputs[layer - 1], this.deltas[layer], this.weightsCopies[layer] || this.weights[layer], this.changesCopies[layer] || this.changes[layer]);
        this.changes[layer] = output.changes;
        this.weights[layer] = output.weights;

        this.changesCopies[layer] = this.copyChanges[layer](output.changes);
        this.weightsCopies[layer] = this.copyWeights[layer](output.weights);
      }
    }
  }, {
    key: 'buildChangeBiases',
    value: function buildChangeBiases() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.biasesPropagate[layer] = this.gpu.createKernel(addBiases, {
          output: [this.sizes[layer]],
          outputToTexture: true,
          hardcodeConstants: true,
          constants: {
            learningRate: this.trainOpts.learningRate
          }
        });
        this.copyBias[layer] = this.gpu.createKernel(function (value) {
          return value[this.thread.x];
        }, {
          output: this.biasesPropagate[layer].output,
          outputToTexture: true,
          hardCodeConstants: true
        });
      }
    }
  }, {
    key: 'changeBiases',
    value: function changeBiases() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        this.biases[layer] = this.biasesPropagate[layer](this.biasCopies[layer] || this.biases[layer], this.deltas[layer]);
        this.biasCopies[layer] = this.copyBias[layer](this.biases[layer]);
      }
    }
  }, {
    key: 'buildGetMSE',
    value: function buildGetMSE() {
      this.getMSE = this.gpu.createKernel(mse, {
        output: [1],
        hardcodeConstants: true,
        constants: {
          size: this.sizes[this.outputLayer]
        }
      });
    }

    /**
     *
     * @param input
     * @returns {*}
     */

  }, {
    key: 'run',
    value: function run(input) {
      if (!this.isRunnable) return null;
      if (this.inputLookup) {
        input = _lookup2.default.toArray(this.inputLookup, input, this.inputLookupLength);
      }
      var inputTexture = this.texturizeInputData(input);
      var outputTextures = this.runInput(inputTexture);
      var output = void 0;
      if (outputTextures.toArray) {
        output = outputTextures.toArray(this.gpu);
      } else {
        output = outputTextures;
      }

      if (this.outputLookup) {
        output = _lookup2.default.toObject(this.outputLookup, output);
      }
      return output;
    }

    /**
     *
     * @param data
     * @param options
     * @protected
     * @return { data, status, endTime }
     */

  }, {
    key: 'prepTraining',
    value: function prepTraining(data, options) {
      var _this2 = this;

      this.updateTrainingOptions(options);
      data = this.formatData(data);
      var endTime = Date.now() + this.trainOpts.timeout;

      var status = {
        error: 1,
        iterations: 0
      };

      this.verifyIsInitialized(data);

      var texturizeOutputData = this.gpu.createKernel(function (value) {
        return value[this.thread.x];
      }, {
        output: [data[0].output.length],
        outputToTexture: true,
        hardcodeConstants: true,
        outputImmutable: true
      });

      return {
        data: data.map(function (set) {
          return {
            input: _this2.texturizeInputData(set.input),
            output: texturizeOutputData(set.output)
          };
        }),
        status: status,
        endTime: endTime
      };
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      var _this3 = this;

      if (!this.weights[1].toArray) {
        // in fallback mode
        return _get(NeuralNetworkGPU.prototype.__proto__ || Object.getPrototypeOf(NeuralNetworkGPU.prototype), 'toJSON', this).call(this);
      }

      // in GPU mode
      var weights = [];
      var biases = [];
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        weights[layer] = Array.from(this.weights[layer].toArray(this.gpu));
        biases[layer] = Array.from(this.biases[layer].toArray(this.gpu));
      }

      // pseudo lo-fi decorator
      return _neuralNetwork2.default.prototype.toJSON.call({
        inputLookup: this.inputLookup,
        outputLookup: this.outputLookup,
        outputLayer: this.outputLayer,
        sizes: this.sizes,
        getTrainOptsJSON: function getTrainOptsJSON() {
          return _this3.getTrainOptsJSON();
        },
        weights: weights,
        biases: biases
      });
    }
  }]);

  return NeuralNetworkGPU;
}(_neuralNetwork2.default);

exports.default = NeuralNetworkGPU;


function weightedSumSigmoid(weights, biases, inputs) {
  var sum = biases[this.thread.x];
  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  }
  //sigmoid
  return 1 / (1 + Math.exp(-sum));
}

function weightedSumRelu(weights, biases, inputs) {
  var sum = biases[this.thread.x];
  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  }
  //relu
  return sum < 0 ? 0 : sum;
}

function weightedSumLeakyRelu(weights, biases, inputs) {
  var sum = biases[this.thread.x];
  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  }
  //leaky relu
  return sum < 0 ? 0 : 0.01 * sum;
}

function weightedSumTanh(weights, biases, inputs) {
  var sum = biases[this.thread.x];
  for (var k = 0; k < this.constants.size; k++) {
    sum += weights[this.thread.x][k] * inputs[k];
  }
  //tanh
  return Math.tanh(sum);
}

function calcErrorOutput(output, targets) {
  return targets[this.thread.x] - output;
}

function calcDeltasSigmoid(error, output) {
  //sigmoid derivative
  return error * output * (1 - output);
}

function calcDeltasRelu(error, output) {
  //relu derivative
  return output > 0 ? error : 0;
}

function calcDeltasLeakyRelu(error, output) {
  //leaky relu derivative
  return output > 0 ? error : 0.01 * error;
}

function calcDeltasTanh(error, output) {
  //tanh derivative
  return (1 - output * output) * error;
}

function calcError(nextWeights, nextDeltas) {
  var error = 0;
  for (var k = 0; k < this.constants.size; k++) {
    error += nextDeltas[k] * nextWeights[k][this.thread.x];
  }
  return error;
}

function calcChanges(previousChanges, deltas, previousOutputs) {
  return this.constants.learningRate * deltas[this.thread.y] * previousOutputs[this.thread.x] + this.constants.momentum * previousChanges[this.thread.y][this.thread.x];
}

function addWeights(change, weights) {
  return change + weights[this.thread.y][this.thread.x];
}

function addBiases(biases, deltas) {
  return biases[this.thread.x] + deltas[this.thread.x] * this.constants.learningRate;
}

// mean squared error, reimplemented for GPU
function mse(errors) {
  var sum = 0;
  for (var i = 0; i < this.constants.size; i++) {
    sum += Math.pow(errors[i], 2);
  }
  return sum / this.constants.size;
}

},{"./lookup":18,"./neural-network":20,"gpu.js":101}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _thaw = require('thaw.js');

var _thaw2 = _interopRequireDefault(_thaw);

var _lookup2 = require('./lookup');

var _lookup3 = _interopRequireDefault(_lookup2);

var _max = require('./utilities/max');

var _max2 = _interopRequireDefault(_max);

var _mse = require('./utilities/mse');

var _mse2 = _interopRequireDefault(_mse);

var _randos = require('./utilities/randos');

var _randos2 = _interopRequireDefault(_randos);

var _range = require('./utilities/range');

var _range2 = _interopRequireDefault(_range);

var _toArray = require('./utilities/to-array');

var _toArray2 = _interopRequireDefault(_toArray);

var _zeros = require('./utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _lookupTable = require('./utilities/lookup-table');

var _lookupTable2 = _interopRequireDefault(_lookupTable);

var _cast = require('./utilities/cast');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @param {object} options
 * @constructor
 */
var NeuralNetwork = function () {
  _createClass(NeuralNetwork, null, [{
    key: 'trainDefaults',
    get: function get() {
      return {
        iterations: 20000, // the maximum times to iterate the training data
        errorThresh: 0.005, // the acceptable error percentage from training data
        log: false, // true to use console.log, when a function is supplied it is used
        logPeriod: 10, // iterations between logging out
        learningRate: 0.3, // multiply's against the input and the delta then adds to momentum
        momentum: 0.1, // multiply's against the specified "change" then adds to learning rate for change
        callback: null, // a periodic call back that can be triggered while training
        callbackPeriod: 10, // the number of iterations through the training data between callback calls
        timeout: Infinity, // the max number of milliseconds to train for
        praxis: null,
        beta1: 0.9,
        beta2: 0.999,
        epsilon: 1e-8
      };
    }
  }, {
    key: 'defaults',
    get: function get() {
      return {
        leakyReluAlpha: 0.01,
        binaryThresh: 0.5,
        hiddenLayers: null, // array of ints for the sizes of the hidden layers in the network
        activation: 'sigmoid' // Supported activation types ['sigmoid', 'relu', 'leaky-relu', 'tanh']
      };
    }
  }]);

  function NeuralNetwork() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NeuralNetwork);

    Object.assign(this, this.constructor.defaults, options);
    this.trainOpts = {};
    this.updateTrainingOptions(Object.assign({}, this.constructor.trainDefaults, options));

    this.sizes = null;
    this.outputLayer = null;
    this.biases = null; // weights for bias nodes
    this.weights = null;
    this.outputs = null;

    // state for training
    this.deltas = null;
    this.changes = null; // for momentum
    this.errors = null;
    this.errorCheckInterval = 1;
    if (!this.constructor.prototype.hasOwnProperty('runInput')) {
      this.runInput = null;
    }
    if (!this.constructor.prototype.hasOwnProperty('calculateDeltas')) {
      this.calculateDeltas = null;
    }
    this.inputLookup = null;
    this.inputLookupLength = null;
    this.outputLookup = null;
    this.outputLookupLength = null;
  }

  /**
   *
   * Expects this.sizes to have been set
   */


  _createClass(NeuralNetwork, [{
    key: 'initialize',
    value: function initialize() {
      if (!this.sizes) throw new Error('Sizes must be set before initializing');

      this.outputLayer = this.sizes.length - 1;
      this.biases = []; // weights for bias nodes
      this.weights = [];
      this.outputs = [];

      // state for training
      this.deltas = [];
      this.changes = []; // for momentum
      this.errors = [];

      for (var layer = 0; layer <= this.outputLayer; layer++) {
        var size = this.sizes[layer];
        this.deltas[layer] = (0, _zeros2.default)(size);
        this.errors[layer] = (0, _zeros2.default)(size);
        this.outputs[layer] = (0, _zeros2.default)(size);

        if (layer > 0) {
          this.biases[layer] = (0, _randos2.default)(size);
          this.weights[layer] = new Array(size);
          this.changes[layer] = new Array(size);

          for (var node = 0; node < size; node++) {
            var prevSize = this.sizes[layer - 1];
            this.weights[layer][node] = (0, _randos2.default)(prevSize);
            this.changes[layer][node] = (0, _zeros2.default)(prevSize);
          }
        }
      }

      this.setActivation();
      if (this.trainOpts.praxis === 'adam') {
        this._setupAdam();
      }
    }

    /**
     *
     * @param activation supported inputs: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
     */

  }, {
    key: 'setActivation',
    value: function setActivation(activation) {
      this.activation = activation ? activation : this.activation;
      switch (this.activation) {
        case 'sigmoid':
          this.runInput = this.runInput || this._runInputSigmoid;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasSigmoid;
          break;
        case 'relu':
          this.runInput = this.runInput || this._runInputRelu;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasRelu;
          break;
        case 'leaky-relu':
          this.runInput = this.runInput || this._runInputLeakyRelu;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasLeakyRelu;
          break;
        case 'tanh':
          this.runInput = this.runInput || this._runInputTanh;
          this.calculateDeltas = this.calculateDeltas || this._calculateDeltasTanh;
          break;
        default:
          throw new Error('unknown activation ' + this.activation + ', The activation should be one of [\'sigmoid\', \'relu\', \'leaky-relu\', \'tanh\']');
      }
    }

    /**
     *
     * @returns boolean
     */

  }, {
    key: 'run',


    /**
     *
     * @param input
     * @returns {*}
     */
    value: function run(input) {
      if (!this.isRunnable) return null;
      if (this.inputLookup) {
        input = _lookup3.default.toArray(this.inputLookup, input, this.inputLookupLength);
      }

      var output = this.runInput(input).slice(0);

      if (this.outputLookup) {
        output = _lookup3.default.toObject(this.outputLookup, output);
      }
      return output;
    }

    /**
     * trains via sigmoid
     * @param input
     * @returns {*}
     */

  }, {
    key: '_runInputSigmoid',
    value: function _runInputSigmoid(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];

          var sum = this.biases[layer][node];
          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          }
          //sigmoid
          this.outputs[layer][node] = 1 / (1 + Math.exp(-sum));
        }
        output = input = this.outputs[layer];
      }
      return output;
    }
  }, {
    key: '_runInputRelu',
    value: function _runInputRelu(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];

          var sum = this.biases[layer][node];
          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          }
          //relu
          this.outputs[layer][node] = sum < 0 ? 0 : sum;
        }
        output = input = this.outputs[layer];
      }
      return output;
    }
  }, {
    key: '_runInputLeakyRelu',
    value: function _runInputLeakyRelu(input) {
      this.outputs[0] = input; // set output state of input layer
      var alpha = this.leakyReluAlpha;
      var output = null;
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];

          var sum = this.biases[layer][node];
          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          }
          //leaky relu
          this.outputs[layer][node] = sum < 0 ? 0 : alpha * sum;
        }
        output = input = this.outputs[layer];
      }
      return output;
    }
  }, {
    key: '_runInputTanh',
    value: function _runInputTanh(input) {
      this.outputs[0] = input; // set output state of input layer

      var output = null;
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var weights = this.weights[layer][node];

          var sum = this.biases[layer][node];
          for (var k = 0; k < weights.length; k++) {
            sum += weights[k] * input[k];
          }
          //tanh
          this.outputs[layer][node] = Math.tanh(sum);
        }
        output = input = this.outputs[layer];
      }
      return output;
    }

    /**
     *
     * @param data
     * Verifies network sizes are initialized
     * If they are not it will initialize them based off the data set.
     */

  }, {
    key: 'verifyIsInitialized',
    value: function verifyIsInitialized(data) {
      var _this = this;

      if (this.sizes) return;

      this.sizes = [];
      this.sizes.push(data[0].input.length);
      if (!this.hiddenLayers) {
        this.sizes.push(Math.max(3, Math.floor(data[0].input.length / 2)));
      } else {
        this.hiddenLayers.forEach(function (size) {
          _this.sizes.push(size);
        });
      }
      this.sizes.push(data[0].output.length);

      this.initialize();
    }

    /**
     *
     * @param options
     *    Supports all `trainDefaults` properties
     *    also supports:
     *       learningRate: (number),
     *       momentum: (number),
     *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
     */

  }, {
    key: 'updateTrainingOptions',
    value: function updateTrainingOptions(options) {
      var trainDefaults = this.constructor.trainDefaults;
      for (var p in trainDefaults) {
        if (!trainDefaults.hasOwnProperty(p)) continue;
        this.trainOpts[p] = options.hasOwnProperty(p) ? options[p] : trainDefaults[p];
      }
      this.validateTrainingOptions(this.trainOpts);
      this.setLogMethod(options.log || this.trainOpts.log);
      this.activation = options.activation || this.activation;
    }

    /**
     *
     * @param options
     */

  }, {
    key: 'validateTrainingOptions',
    value: function validateTrainingOptions(options) {
      var validations = {
        iterations: function iterations(val) {
          return typeof val === 'number' && val > 0;
        },
        errorThresh: function errorThresh(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        log: function log(val) {
          return typeof val === 'function' || typeof val === 'boolean';
        },
        logPeriod: function logPeriod(val) {
          return typeof val === 'number' && val > 0;
        },
        learningRate: function learningRate(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        momentum: function momentum(val) {
          return typeof val === 'number' && val > 0 && val < 1;
        },
        callback: function callback(val) {
          return typeof val === 'function' || val === null;
        },
        callbackPeriod: function callbackPeriod(val) {
          return typeof val === 'number' && val > 0;
        },
        timeout: function timeout(val) {
          return typeof val === 'number' && val > 0;
        }
      };
      for (var p in validations) {
        if (!validations.hasOwnProperty(p)) continue;
        if (!options.hasOwnProperty(p)) continue;
        if (!validations[p](options[p])) {
          throw new Error('[' + p + ', ' + options[p] + '] is out of normal training range, your network will probably not train.');
        }
      }
    }

    /**
     *
     *  Gets JSON of trainOpts object
     *    NOTE: Activation is stored directly on JSON object and not in the training options
     */

  }, {
    key: 'getTrainOptsJSON',
    value: function getTrainOptsJSON() {
      var _this2 = this;

      return Object.keys(this.constructor.trainDefaults).reduce(function (opts, opt) {
        if (opt === 'timeout' && _this2.trainOpts[opt] === Infinity) return opts;
        if (opt === 'callback') return opts;
        if (_this2.trainOpts[opt]) opts[opt] = _this2.trainOpts[opt];
        if (opt === 'log') opts.log = typeof opts.log === 'function';
        return opts;
      }, {});
    }

    /**
     *
     * @param log
     * if a method is passed in method is used
     * if false passed in nothing is logged
     * @returns error
     */

  }, {
    key: 'setLogMethod',
    value: function setLogMethod(log) {
      if (typeof log === 'function') {
        this.trainOpts.log = log;
      } else if (log) {
        this.trainOpts.log = console.log;
      } else {
        this.trainOpts.log = false;
      }
    }

    /**
     *
     * @param data
     * @returns {Number} error
     */

  }, {
    key: 'calculateTrainingError',
    value: function calculateTrainingError(data) {
      var sum = 0;
      for (var i = 0; i < data.length; ++i) {
        sum += this.trainPattern(data[i], true);
      }
      return sum / data.length;
    }

    /**
     * @param data
     */

  }, {
    key: 'trainPatterns',
    value: function trainPatterns(data) {
      for (var i = 0; i < data.length; ++i) {
        this.trainPattern(data[i]);
      }
    }

    /**
     *
     * @param {object} data
     * @param {object} status { iterations: number, error: number }
     * @param endTime
     */

  }, {
    key: 'trainingTick',
    value: function trainingTick(data, status, endTime) {
      if (status.iterations >= this.trainOpts.iterations || status.error <= this.trainOpts.errorThresh || Date.now() >= endTime) {
        return false;
      }

      status.iterations++;

      if (this.trainOpts.log && status.iterations % this.trainOpts.logPeriod === 0) {
        status.error = this.calculateTrainingError(data);
        this.trainOpts.log('iterations: ' + status.iterations + ', training error: ' + status.error);
      } else {
        if (status.iterations % this.errorCheckInterval === 0) {
          status.error = this.calculateTrainingError(data);
        } else {
          this.trainPatterns(data);
        }
      }

      if (this.trainOpts.callback && status.iterations % this.trainOpts.callbackPeriod === 0) {
        this.trainOpts.callback({
          iterations: status.iterations,
          error: status.error
        });
      }
      return true;
    }

    /**
     *
     * @param data
     * @param options
     * @protected
     * @return {object} { data, status, endTime }
     */

  }, {
    key: 'prepTraining',
    value: function prepTraining(data, options) {
      this.updateTrainingOptions(options);
      data = this.formatData(data);
      var endTime = Date.now() + this.trainOpts.timeout;

      var status = {
        error: 1,
        iterations: 0
      };

      this.verifyIsInitialized(data);

      return {
        data: data,
        status: status,
        endTime: endTime
      };
    }

    /**
     *
     * @param data
     * @param options
     * @returns {object} {error: number, iterations: number}
     */

  }, {
    key: 'train',
    value: function train(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var status = void 0,
          endTime = void 0;

      var _prepTraining = this.prepTraining(data, options);

      data = _prepTraining.data;
      status = _prepTraining.status;
      endTime = _prepTraining.endTime;


      while (this.trainingTick(data, status, endTime)) {}
      return status;
    }

    /**
     *
     * @param data
     * @param options
     * @returns {Promise}
     * @resolves {{error: number, iterations: number}}
     * @rejects {{trainError: string, status: {error: number, iterations: number}}
     */

  }, {
    key: 'trainAsync',
    value: function trainAsync(data) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var status = void 0,
          endTime = void 0;

      var _prepTraining2 = this.prepTraining(data, options);

      data = _prepTraining2.data;
      status = _prepTraining2.status;
      endTime = _prepTraining2.endTime;


      return new Promise(function (resolve, reject) {
        try {
          var thawedTrain = new _thaw2.default(new Array(_this3.trainOpts.iterations), {
            delay: true,
            each: function each() {
              return _this3.trainingTick(data, status, endTime) || thawedTrain.stop();
            },
            done: function done() {
              return resolve(status);
            }
          });
          thawedTrain.tick();
        } catch (trainError) {
          reject({ trainError: trainError, status: status });
        }
      });
    }

    /**
     *
     * @param {object} value
     * @param {boolean} [logErrorRate]
     */

  }, {
    key: 'trainPattern',
    value: function trainPattern(value, logErrorRate) {
      // forward propagate
      this.runInput(value.input);

      // back propagate
      this.calculateDeltas(value.output);
      this.adjustWeights();

      if (logErrorRate) {
        return (0, _mse2.default)(this.errors[this.outputLayer]);
      } else {
        return null;
      }
    }

    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasSigmoid',
    value: function _calculateDeltasSigmoid(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];

          var error = 0;
          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];
            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }
          this.errors[layer][node] = error;
          this.deltas[layer][node] = error * output * (1 - output);
        }
      }
    }

    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasRelu',
    value: function _calculateDeltasRelu(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];

          var error = 0;
          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];
            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }
          this.errors[layer][node] = error;
          this.deltas[layer][node] = output > 0 ? error : 0;
        }
      }
    }

    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasLeakyRelu',
    value: function _calculateDeltasLeakyRelu(target) {
      var alpha = this.leakyReluAlpha;
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];

          var error = 0;
          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];
            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }
          this.errors[layer][node] = error;
          this.deltas[layer][node] = output > 0 ? error : alpha * error;
        }
      }
    }

    /**
     *
     * @param target
     */

  }, {
    key: '_calculateDeltasTanh',
    value: function _calculateDeltasTanh(target) {
      for (var layer = this.outputLayer; layer >= 0; layer--) {
        for (var node = 0; node < this.sizes[layer]; node++) {
          var output = this.outputs[layer][node];

          var error = 0;
          if (layer === this.outputLayer) {
            error = target[node] - output;
          } else {
            var deltas = this.deltas[layer + 1];
            for (var k = 0; k < deltas.length; k++) {
              error += deltas[k] * this.weights[layer + 1][k][node];
            }
          }
          this.errors[layer][node] = error;
          this.deltas[layer][node] = (1 - output * output) * error;
        }
      }
    }

    /**
     *
     * Changes weights of networks
     */

  }, {
    key: 'adjustWeights',
    value: function adjustWeights() {
      for (var layer = 1; layer <= this.outputLayer; layer++) {
        var incoming = this.outputs[layer - 1];

        for (var node = 0; node < this.sizes[layer]; node++) {
          var delta = this.deltas[layer][node];

          for (var k = 0; k < incoming.length; k++) {
            var change = this.changes[layer][node][k];

            change = this.trainOpts.learningRate * delta * incoming[k] + this.trainOpts.momentum * change;

            this.changes[layer][node][k] = change;
            this.weights[layer][node][k] += change;
          }
          this.biases[layer][node] += this.trainOpts.learningRate * delta;
        }
      }
    }
  }, {
    key: '_setupAdam',
    value: function _setupAdam() {
      this.biasChangesLow = [];
      this.biasChangesHigh = [];
      this.changesLow = [];
      this.changesHigh = [];
      this.iterations = 0;

      for (var layer = 0; layer <= this.outputLayer; layer++) {
        var size = this.sizes[layer];
        if (layer > 0) {
          this.biasChangesLow[layer] = (0, _zeros2.default)(size);
          this.biasChangesHigh[layer] = (0, _zeros2.default)(size);
          this.changesLow[layer] = new Array(size);
          this.changesHigh[layer] = new Array(size);

          for (var node = 0; node < size; node++) {
            var prevSize = this.sizes[layer - 1];
            this.changesLow[layer][node] = (0, _zeros2.default)(prevSize);
            this.changesHigh[layer][node] = (0, _zeros2.default)(prevSize);
          }
        }
      }

      this.adjustWeights = this._adjustWeightsAdam;
    }
  }, {
    key: '_adjustWeightsAdam',
    value: function _adjustWeightsAdam() {
      var trainOpts = this.trainOpts;
      this.iterations++;

      for (var layer = 1; layer <= this.outputLayer; layer++) {
        var incoming = this.outputs[layer - 1];

        for (var node = 0; node < this.sizes[layer]; node++) {
          var delta = this.deltas[layer][node];

          for (var k = 0; k < incoming.length; k++) {
            var gradient = delta * incoming[k];
            var changeLow = this.changesLow[layer][node][k] * trainOpts.beta1 + (1 - trainOpts.beta1) * gradient;
            var changeHigh = this.changesHigh[layer][node][k] * trainOpts.beta2 + (1 - trainOpts.beta2) * gradient * gradient;

            var momentumCorrection = changeLow / (1 - Math.pow(trainOpts.beta1, this.iterations));
            var gradientCorrection = changeHigh / (1 - Math.pow(trainOpts.beta2, this.iterations));

            this.changesLow[layer][node][k] = changeLow;
            this.changesHigh[layer][node][k] = changeHigh;
            this.weights[layer][node][k] += this.trainOpts.learningRate * momentumCorrection / (Math.sqrt(gradientCorrection) + trainOpts.epsilon);
          }

          var biasGradient = this.deltas[layer][node];
          var biasChangeLow = this.biasChangesLow[layer][node] * trainOpts.beta1 + (1 - trainOpts.beta1) * biasGradient;
          var biasChangeHigh = this.biasChangesHigh[layer][node] * trainOpts.beta2 + (1 - trainOpts.beta2) * biasGradient * biasGradient;

          var biasMomentumCorrection = this.biasChangesLow[layer][node] / (1 - Math.pow(trainOpts.beta1, this.iterations));
          var biasGradientCorrection = this.biasChangesHigh[layer][node] / (1 - Math.pow(trainOpts.beta2, this.iterations));

          this.biasChangesLow[layer][node] = biasChangeLow;
          this.biasChangesHigh[layer][node] = biasChangeHigh;
          this.biases[layer][node] += trainOpts.learningRate * biasMomentumCorrection / (Math.sqrt(biasGradientCorrection) + trainOpts.epsilon);
        }
      }
    }

    /**
     *
     * @param data
     * @returns {*}
     */

  }, {
    key: 'formatData',
    value: function formatData(data) {
      if (!Array.isArray(data)) {
        // turn stream datum into array
        data = [data];
      }

      if (!Array.isArray(data[0].input)) {
        if (this.inputLookup) {
          this.inputLookupLength = Object.keys(this.inputLookup).length;
        } else {
          var inputLookup = new _lookupTable2.default(data, 'input');
          this.inputLookup = inputLookup.table;
          this.inputLookupLength = inputLookup.length;
        }
      }

      if (!Array.isArray(data[0].output)) {
        if (this.outputLookup) {
          this.outputLookupLength = Object.keys(this.outputLookup).length;
        } else {
          var _lookup = new _lookupTable2.default(data, 'output');
          this.outputLookup = _lookup.table;
          this.outputLookupLength = _lookup.length;
        }
      }

      if (typeof this._formatInput === 'undefined') {
        this._formatInput = getTypedArrayFn(data[0].input, this.inputLookup);
        this._formatOutput = getTypedArrayFn(data[0].output, this.outputLookup);
      }

      // turn sparse hash input into arrays with 0s as filler
      if (this._formatInput && this._formatOutput) {
        var result = [];
        for (var i = 0; i < data.length; i++) {
          result.push({
            input: this._formatInput(data[i].input),
            output: this._formatOutput(data[i].output)
          });
        }
        return result;
      } else if (this._formatInput) {
        var _result = [];
        for (var _i = 0; _i < data.length; _i++) {
          _result.push({
            input: this._formatInput(data[_i].input),
            output: data[_i].output
          });
        }
        return _result;
      } else if (this._formatOutput) {
        var _result2 = [];
        for (var _i2 = 0; _i2 < data.length; _i2++) {
          _result2.push({
            input: data[_i2].input,
            output: this._formatOutput(data[_i2].output)
          });
        }
        return _result2;
      }
      return data;
    }
  }, {
    key: 'addFormat',
    value: function addFormat(data) {
      this.inputLookup = _lookup3.default.addKeys(data.input, this.inputLookup);
      if (this.inputLookup) {
        this.inputLookupLength = Object.keys(this.inputLookup).length;
      }
      this.outputLookup = _lookup3.default.addKeys(data.output, this.outputLookup);
      if (this.outputLookup) {
        this.outputLookupLength = Object.keys(this.outputLookup).length;
      }
    }

    /**
     *
     * @param data
     * @returns {
     *  {
     *    error: number,
     *    misclasses: Array,
     *  }
     * }
     */

  }, {
    key: 'test',
    value: function test(data) {
      var _this4 = this;

      data = this.formatData(data);
      // for binary classification problems with one output node
      var isBinary = data[0].output.length === 1;
      // for classification problems
      var misclasses = [];
      // run each pattern through the trained network and collect
      // error and misclassification statistics
      var errorSum = 0;

      if (isBinary) {
        var falsePos = 0;
        var falseNeg = 0;
        var truePos = 0;
        var trueNeg = 0;

        var _loop = function _loop(i) {
          var output = _this4.runInput(data[i].input);
          var target = data[i].output;
          var actual = output[0] > _this4.binaryThresh ? 1 : 0;
          var expected = target[0];

          if (actual !== expected) {
            var misclass = data[i];
            misclasses.push({
              input: misclass.input,
              output: misclass.output,
              actual: actual,
              expected: expected
            });
          }

          if (actual === 0 && expected === 0) {
            trueNeg++;
          } else if (actual === 1 && expected === 1) {
            truePos++;
          } else if (actual === 0 && expected === 1) {
            falseNeg++;
          } else if (actual === 1 && expected === 0) {
            falsePos++;
          }

          errorSum += (0, _mse2.default)(output.map(function (value, i) {
            return target[i] - value;
          }));
        };

        for (var i = 0; i < data.length; i++) {
          _loop(i);
        }

        return {
          error: errorSum / data.length,
          misclasses: misclasses,
          total: data.length,
          trueNeg: trueNeg,
          truePos: truePos,
          falseNeg: falseNeg,
          falsePos: falsePos,
          precision: truePos > 0 ? truePos / (truePos + falsePos) : 0,
          recall: truePos > 0 ? truePos / (truePos + falseNeg) : 0,
          accuracy: (trueNeg + truePos) / data.length
        };
      }

      var _loop2 = function _loop2(i) {
        var output = _this4.runInput(data[i].input);
        var target = data[i].output;
        var actual = output.indexOf((0, _max2.default)(output));
        var expected = target.indexOf((0, _max2.default)(target));

        if (actual !== expected) {
          var misclass = data[i];
          misclasses.push({
            input: misclass.input,
            output: misclass.output,
            actual: actual,
            expected: expected
          });
        }

        errorSum += (0, _mse2.default)(output.map(function (value, i) {
          return target[i] - value;
        }));
      };

      for (var i = 0; i < data.length; i++) {
        _loop2(i);
      }
      return {
        error: errorSum / data.length,
        misclasses: misclasses,
        total: data.length
      };
    }

    /**
     *
     * @returns
     *  {
     *    layers: [
     *      {
     *        x: {},
     *        y: {}
     *      },
     *      {
     *        '0': {
     *          bias: -0.98771313,
     *          weights: {
     *            x: 0.8374838,
     *            y: 1.245858
     *          },
     *        '1': {
     *          bias: 3.48192004,
     *          weights: {
     *            x: 1.7825821,
     *            y: -2.67899
     *          }
     *        }
     *      },
     *      {
     *        f: {
     *          bias: 0.27205739,
     *          weights: {
     *            '0': 1.3161821,
     *            '1': 2.00436
     *          }
     *        }
     *      }
     *    ]
     *  }
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var layers = [];
      for (var layer = 0; layer <= this.outputLayer; layer++) {
        layers[layer] = {};

        var nodes = void 0;
        // turn any internal arrays back into hashes for readable json
        if (layer === 0 && this.inputLookup) {
          nodes = Object.keys(this.inputLookup);
        } else if (this.outputLookup && layer === this.outputLayer) {
          nodes = Object.keys(this.outputLookup);
        } else {
          nodes = (0, _range2.default)(0, this.sizes[layer]);
        }

        for (var j = 0; j < nodes.length; j++) {
          var node = nodes[j];
          layers[layer][node] = {};

          if (layer > 0) {
            layers[layer][node].bias = this.biases[layer][j];
            layers[layer][node].weights = {};
            for (var k in layers[layer - 1]) {
              var index = k;
              if (layer === 1 && this.inputLookup) {
                index = this.inputLookup[k];
              }
              layers[layer][node].weights[k] = this.weights[layer][j][index];
            }
          }
        }
      }
      return {
        sizes: this.sizes.slice(0),
        layers: layers,
        outputLookup: this.outputLookup !== null,
        inputLookup: this.inputLookup !== null,
        activation: this.activation,
        trainOpts: this.getTrainOptsJSON()
      };
    }

    /**
     *
     * @param json
     * @returns {NeuralNetwork}
     */

  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      Object.assign(this, this.constructor.defaults, json);
      this.sizes = json.sizes;
      this.initialize();

      for (var i = 0; i <= this.outputLayer; i++) {
        var layer = json.layers[i];
        if (i === 0 && (!layer[0] || json.inputLookup)) {
          this.inputLookup = _lookup3.default.toHash(layer);
          this.inputLookupLength = Object.keys(this.inputLookup).length;
        } else if (i === this.outputLayer && (!layer[0] || json.outputLookup)) {
          this.outputLookup = _lookup3.default.toHash(layer);
        }
        if (i > 0) {
          var nodes = Object.keys(layer);
          this.sizes[i] = nodes.length;
          for (var j in nodes) {
            var node = nodes[j];
            this.biases[i][j] = layer[node].bias;
            this.weights[i][j] = (0, _toArray2.default)(layer[node].weights);
          }
        }
      }
      if (json.hasOwnProperty('trainOpts')) {
        this.updateTrainingOptions(json.trainOpts);
      }
      return this;
    }

    /**
     *
     * @returns {Function}
     */

  }, {
    key: 'toFunction',
    value: function toFunction() {
      var activation = this.activation;
      var leakyReluAlpha = this.leakyReluAlpha;
      var needsVar = false;
      function nodeHandle(layers, layerNumber, nodeKey) {
        if (layerNumber === 0) {
          return typeof nodeKey === 'string' ? 'input[\'' + nodeKey + '\']' : 'input[' + nodeKey + ']';
        }

        var layer = layers[layerNumber];
        var node = layer[nodeKey];
        var result = ['(', node.bias];
        for (var w in node.weights) {
          if (node.weights[w] < 0) {
            result.push(node.weights[w] + '*' + nodeHandle(layers, layerNumber - 1, w));
          } else {
            result.push('+' + node.weights[w] + '*' + nodeHandle(layers, layerNumber - 1, w));
          }
        }
        result.push(')');

        switch (activation) {
          case 'sigmoid':
            return '1/(1+1/Math.exp(' + result.join('') + '))';
          case 'relu':
            {
              needsVar = true;
              return '((v=' + result.join('') + ')<0?0:v)';
            }
          case 'leaky-relu':
            {
              needsVar = true;
              return '((v=' + result.join('') + ')<0?0:' + leakyReluAlpha + '*v)';
            }
          case 'tanh':
            return 'Math.tanh(' + result.join('') + ')';
          default:
            throw new Error('unknown activation type ' + activation);
        }
      }

      var layers = this.toJSON().layers;
      var layersAsMath = [];
      var result = void 0;
      for (var i in layers[layers.length - 1]) {
        layersAsMath.push(nodeHandle(layers, layers.length - 1, i));
      }
      if (this.outputLookup) {
        result = '{' + Object.keys(this.outputLookup).map(function (key, i) {
          return '\'' + key + '\':' + layersAsMath[i];
        }) + '}';
      } else {
        result = '[' + layersAsMath.join(',') + ']';
      }

      return new Function('input', (needsVar ? 'var v;' : '') + 'return ' + result + ';');
    }
  }, {
    key: 'isRunnable',
    get: function get() {
      var _this5 = this;

      if (!this.runInput) {
        console.error('Activation function has not been initialized, did you run train()?');
        return false;
      }

      var checkFns = ['sizes', 'outputLayer', 'biases', 'weights', 'outputs', 'deltas', 'changes', 'errors'].filter(function (c) {
        return _this5[c] === null;
      });

      if (checkFns.length > 0) {
        console.error('Some settings have not been initialized correctly, did you run train()? Found issues with: ' + checkFns.join(', '));
        return false;
      }
      return true;
    }
  }]);

  return NeuralNetwork;
}();

exports.default = NeuralNetwork;


function getTypedArrayFn(value, table) {
  if (value.buffer instanceof ArrayBuffer) {
    return null;
  } else if (Array.isArray(value)) {
    return _cast.arrayToFloat32Array;
  } else {
    var length = Object.keys(table).length;
    return function (v) {
      var array = new Float32Array(length);
      for (var p in table) {
        array[table[p]] = v[p] || 0;
      }
      return array;
    };
  }
}

},{"./lookup":18,"./utilities/cast":53,"./utilities/lookup-table":55,"./utilities/max":56,"./utilities/mse":57,"./utilities/randos":61,"./utilities/range":62,"./utilities/to-array":63,"./utilities/zeros":65,"thaw.js":105}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _gru = require('./gru');

var _gru2 = _interopRequireDefault(_gru);

var _rnnTimeStep = require('./rnn-time-step');

var _rnnTimeStep2 = _interopRequireDefault(_rnnTimeStep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GRUTimeStep = function (_RNNTimeStep) {
  _inherits(GRUTimeStep, _RNNTimeStep);

  function GRUTimeStep() {
    _classCallCheck(this, GRUTimeStep);

    return _possibleConstructorReturn(this, (GRUTimeStep.__proto__ || Object.getPrototypeOf(GRUTimeStep)).apply(this, arguments));
  }

  _createClass(GRUTimeStep, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return _gru2.default.prototype.getModel(hiddenSize, prevSize);
    }

    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      return _gru2.default.prototype.getEquation(equation, inputMatrix, previousResult, hiddenLayer);
    }
  }]);

  return GRUTimeStep;
}(_rnnTimeStep2.default);

exports.default = GRUTimeStep;

},{"./gru":22,"./matrix":31,"./rnn-time-step":49}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _rnn = require('./rnn');

var _rnn2 = _interopRequireDefault(_rnn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GRU = function (_RNN) {
  _inherits(GRU, _RNN);

  function GRU() {
    _classCallCheck(this, GRU);

    return _possibleConstructorReturn(this, (GRU.__proto__ || Object.getPrototypeOf(GRU)).apply(this, arguments));
  }

  _createClass(GRU, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return {
        // update Gate
        //wzxh
        updateGateInputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //wzhh
        updateGateHiddenMatrix: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bz
        updateGateBias: new _matrix2.default(hiddenSize, 1),

        // reset Gate
        //wrxh
        resetGateInputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //wrhh
        resetGateHiddenMatrix: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //br
        resetGateBias: new _matrix2.default(hiddenSize, 1),

        // cell write parameters
        //wcxh
        cellWriteInputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //wchh
        cellWriteHiddenMatrix: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bc
        cellWriteBias: new _matrix2.default(hiddenSize, 1)
      };
    }

    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      var sigmoid = equation.sigmoid.bind(equation);
      var add = equation.add.bind(equation);
      var multiply = equation.multiply.bind(equation);
      var multiplyElement = equation.multiplyElement.bind(equation);
      var tanh = equation.tanh.bind(equation);
      var allOnes = equation.allOnes.bind(equation);
      var cloneNegative = equation.cloneNegative.bind(equation);

      // update gate
      var updateGate = sigmoid(add(add(multiply(hiddenLayer.updateGateInputMatrix, inputMatrix), multiply(hiddenLayer.updateGateHiddenMatrix, previousResult)), hiddenLayer.updateGateBias));

      // reset gate
      var resetGate = sigmoid(add(add(multiply(hiddenLayer.resetGateInputMatrix, inputMatrix), multiply(hiddenLayer.resetGateHiddenMatrix, previousResult)), hiddenLayer.resetGateBias));

      // cell
      var cell = tanh(add(add(multiply(hiddenLayer.cellWriteInputMatrix, inputMatrix), multiply(hiddenLayer.cellWriteHiddenMatrix, multiplyElement(resetGate, previousResult))), hiddenLayer.cellWriteBias));

      // compute hidden state as gated, saturated cell activations
      // negate updateGate
      return add(multiplyElement(add(allOnes(updateGate.rows, updateGate.columns), cloneNegative(updateGate)), cell), multiplyElement(previousResult, updateGate));
    }
  }]);

  return GRU;
}(_rnn2.default);

exports.default = GRU;

},{"./matrix":31,"./matrix/random-matrix":38,"./rnn":50}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _lstm = require('./lstm');

var _lstm2 = _interopRequireDefault(_lstm);

var _rnnTimeStep = require('./rnn-time-step');

var _rnnTimeStep2 = _interopRequireDefault(_rnnTimeStep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LSTMTimeStep = function (_RNNTimeStep) {
  _inherits(LSTMTimeStep, _RNNTimeStep);

  function LSTMTimeStep() {
    _classCallCheck(this, LSTMTimeStep);

    return _possibleConstructorReturn(this, (LSTMTimeStep.__proto__ || Object.getPrototypeOf(LSTMTimeStep)).apply(this, arguments));
  }

  _createClass(LSTMTimeStep, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return _lstm2.default.prototype.getModel.call(this, hiddenSize, prevSize);
    }

    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      return _lstm2.default.prototype.getEquation.call(this, equation, inputMatrix, previousResult, hiddenLayer);
    }
  }]);

  return LSTMTimeStep;
}(_rnnTimeStep2.default);

exports.default = LSTMTimeStep;

},{"./lstm":24,"./matrix":31,"./rnn-time-step":49}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _rnn = require('./rnn');

var _rnn2 = _interopRequireDefault(_rnn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LSTM = function (_RNN) {
  _inherits(LSTM, _RNN);

  function LSTM() {
    _classCallCheck(this, LSTM);

    return _possibleConstructorReturn(this, (LSTM.__proto__ || Object.getPrototypeOf(LSTM)).apply(this, arguments));
  }

  _createClass(LSTM, [{
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return {
        // gates parameters
        //wix
        inputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //wih
        inputHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bi
        inputBias: new _matrix2.default(hiddenSize, 1),

        //wfx
        forgetMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //wfh
        forgetHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bf
        forgetBias: new _matrix2.default(hiddenSize, 1),

        //wox
        outputMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //woh
        outputHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bo
        outputBias: new _matrix2.default(hiddenSize, 1),

        // cell write params
        //wcx
        cellActivationMatrix: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //wch
        cellActivationHidden: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bc
        cellActivationBias: new _matrix2.default(hiddenSize, 1)
      };
    }

    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      var sigmoid = equation.sigmoid.bind(equation);
      var add = equation.add.bind(equation);
      var multiply = equation.multiply.bind(equation);
      var multiplyElement = equation.multiplyElement.bind(equation);
      var tanh = equation.tanh.bind(equation);

      var inputGate = sigmoid(add(add(multiply(hiddenLayer.inputMatrix, inputMatrix), multiply(hiddenLayer.inputHidden, previousResult)), hiddenLayer.inputBias));

      var forgetGate = sigmoid(add(add(multiply(hiddenLayer.forgetMatrix, inputMatrix), multiply(hiddenLayer.forgetHidden, previousResult)), hiddenLayer.forgetBias));

      // output gate
      var outputGate = sigmoid(add(add(multiply(hiddenLayer.outputMatrix, inputMatrix), multiply(hiddenLayer.outputHidden, previousResult)), hiddenLayer.outputBias));

      // write operation on cells
      var cellWrite = tanh(add(add(multiply(hiddenLayer.cellActivationMatrix, inputMatrix), multiply(hiddenLayer.cellActivationHidden, previousResult)), hiddenLayer.cellActivationBias));

      // compute new cell activation
      var retainCell = multiplyElement(forgetGate, previousResult); // what do we keep from cell
      var writeCell = multiplyElement(inputGate, cellWrite); // what do we write to cell
      var cell = add(retainCell, writeCell); // new cell contents

      // compute hidden state as gated, saturated cell activations
      return multiplyElement(outputGate, tanh(cell));
    }
  }]);

  return LSTM;
}(_rnn2.default);

exports.default = LSTM;

},{"./matrix":31,"./matrix/random-matrix":38,"./rnn":50}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addB;
/**
 * adds {from} deltas to {left} and {right} deltas
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */
function addB(product, left, right) {
  for (var i = 0; i < product.deltas.length; i++) {
    left.deltas[i] = product.deltas[i];
    right.deltas[i] = product.deltas[i];
  }
}

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = add;
/**
 * add {left} and {right} matrix weights into {into}
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */
function add(product, left, right) {
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = left.weights[i] + right.weights[i];
    product.deltas[i] = 0;
  }
}

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = allOnes;
/**
 * makes matrix weights and deltas all ones
 * @param {Matrix} product
 */
function allOnes(product) {
  for (var i = 0; i < product.weights.length; i++) {
    product.weights[i] = 1;
    product.deltas[i] = 0;
  }
}

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNegative;
/**
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */
function cloneNegative(product, left) {
  product.rows = parseInt(left.rows);
  product.columns = parseInt(left.columns);
  product.weights = left.weights.slice(0);
  product.deltas = left.deltas.slice(0);
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = -left.weights[i];
    product.deltas[i] = 0;
  }
}

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = copy;
/*
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */
function copy(product, left) {
  product.rows = parseInt(left.rows);
  product.columns = parseInt(left.columns);
  product.weights = left.weights.slice(0);
  product.deltas = left.deltas.slice(0);
}

},{}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = require('./');

var _2 = _interopRequireDefault(_);

var _onesMatrix = require('./ones-matrix');

var _onesMatrix2 = _interopRequireDefault(_onesMatrix);

var _copy = require('./copy');

var _copy2 = _interopRequireDefault(_copy);

var _cloneNegative2 = require('./clone-negative');

var _cloneNegative3 = _interopRequireDefault(_cloneNegative2);

var _add2 = require('./add');

var _add3 = _interopRequireDefault(_add2);

var _addB = require('./add-b');

var _addB2 = _interopRequireDefault(_addB);

var _allOnes2 = require('./all-ones');

var _allOnes3 = _interopRequireDefault(_allOnes2);

var _multiply2 = require('./multiply');

var _multiply3 = _interopRequireDefault(_multiply2);

var _multiplyB = require('./multiply-b');

var _multiplyB2 = _interopRequireDefault(_multiplyB);

var _multiplyElement2 = require('./multiply-element');

var _multiplyElement3 = _interopRequireDefault(_multiplyElement2);

var _multiplyElementB = require('./multiply-element-b');

var _multiplyElementB2 = _interopRequireDefault(_multiplyElementB);

var _relu2 = require('./relu');

var _relu3 = _interopRequireDefault(_relu2);

var _reluB = require('./relu-b');

var _reluB2 = _interopRequireDefault(_reluB);

var _rowPluck = require('./row-pluck');

var _rowPluck2 = _interopRequireDefault(_rowPluck);

var _rowPluckB = require('./row-pluck-b');

var _rowPluckB2 = _interopRequireDefault(_rowPluckB);

var _sigmoid2 = require('./sigmoid');

var _sigmoid3 = _interopRequireDefault(_sigmoid2);

var _sigmoidB = require('./sigmoid-b');

var _sigmoidB2 = _interopRequireDefault(_sigmoidB);

var _tanh2 = require('./tanh');

var _tanh3 = _interopRequireDefault(_tanh2);

var _tanhB = require('./tanh-b');

var _tanhB2 = _interopRequireDefault(_tanhB);

var _softmax = require('./softmax');

var _softmax2 = _interopRequireDefault(_softmax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Equation = function () {
  function Equation() {
    _classCallCheck(this, Equation);

    this.inputRow = 0;
    this.inputValue = null;
    this.states = [];
  }

  /**
   * connects two matrices together by add
   * @param {Matrix} left
   * @param {Matrix} right
   * @returns {Matrix}
   */


  _createClass(Equation, [{
    key: 'add',
    value: function add(left, right) {
      if (left.weights.length !== right.weights.length) {
        throw new Error('misaligned matrices');
      }
      var product = new _2.default(left.rows, left.columns);
      this.states.push({
        left: left,
        right: right,
        product: product,
        forwardFn: _add3.default,
        backpropagationFn: _addB2.default
      });
      return product;
    }

    /**
     *
     * @param {Number} rows
     * @param {Number} columns
     * @returns {Matrix}
     */

  }, {
    key: 'allOnes',
    value: function allOnes(rows, columns) {
      var product = new _2.default(rows, columns);
      this.states.push({
        left: product,
        product: product,
        forwardFn: _allOnes3.default
      });
      return product;
    }

    /**
     *
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'cloneNegative',
    value: function cloneNegative(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _cloneNegative3.default
      });
      return product;
    }

    /**
     * connects two matrices together by subtract
     * @param {Matrix} left
     * @param {Matrix} right
     * @returns {Matrix}
     */

  }, {
    key: 'subtract',
    value: function subtract(left, right) {
      if (left.weights.length !== right.weights.length) {
        throw new Error('misaligned matrices');
      }
      return this.add(this.add(this.allOnes(left.rows, left.columns), this.cloneNegative(left)), right);
    }

    /**
     * connects two matrices together by multiply
     * @param {Matrix} left
     * @param {Matrix} right
     * @returns {Matrix}
     */

  }, {
    key: 'multiply',
    value: function multiply(left, right) {
      if (left.columns !== right.rows) {
        throw new Error('misaligned matrices');
      }
      var product = new _2.default(left.rows, right.columns);
      this.states.push({
        left: left,
        right: right,
        product: product,
        forwardFn: _multiply3.default,
        backpropagationFn: _multiplyB2.default
      });
      return product;
    }

    /**
     * connects two matrices together by multiplyElement
     * @param {Matrix} left
     * @param {Matrix} right
     * @returns {Matrix}
     */

  }, {
    key: 'multiplyElement',
    value: function multiplyElement(left, right) {
      if (left.weights.length !== right.weights.length) {
        throw new Error('misaligned matrices');
      }
      var product = new _2.default(left.rows, left.columns);
      this.states.push({
        left: left,
        right: right,
        product: product,
        forwardFn: _multiplyElement3.default,
        backpropagationFn: _multiplyElementB2.default
      });
      return product;
    }

    /**
     * connects a matrix to relu
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'relu',
    value: function relu(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _relu3.default,
        backpropagationFn: _reluB2.default
      });
      return product;
    }

    /**
     * copy a matrix
     * @param {Matrix} input
     * @returns {Matrix}
     */

  }, {
    key: 'input',
    value: function input(_input) {
      var _this = this;

      this.states.push({
        product: _input,
        forwardFn: function forwardFn(product) {
          product.weights = _input.weights = _this.inputValue;
        }
      });
      return _input;
    }

    /**
     * connects a matrix via a row
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'inputMatrixToRow',
    value: function inputMatrixToRow(m) {
      var self = this;
      var product = new _2.default(m.columns, 1);
      this.states.push({
        left: m,
        get right() {
          return self.inputRow;
        },
        product: product,
        forwardFn: _rowPluck2.default,
        backpropagationFn: _rowPluckB2.default
      });
      return product;
    }

    /**
     * connects a matrix to sigmoid
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'sigmoid',
    value: function sigmoid(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _sigmoid3.default,
        backpropagationFn: _sigmoidB2.default
      });
      return product;
    }

    /**
     * connects a matrix to tanh
     * @param {Matrix} m
     * @returns {Matrix}
     */

  }, {
    key: 'tanh',
    value: function tanh(m) {
      var product = new _2.default(m.rows, m.columns);
      this.states.push({
        left: m,
        product: product,
        forwardFn: _tanh3.default,
        backpropagationFn: _tanhB2.default
      });
      return product;
    }

    /**
     *
     * @param m
     * @returns {Matrix}
     */

  }, {
    key: 'observe',
    value: function observe(m) {
      var iForward = 0;
      var iBackpropagate = 0;
      this.states.push({
        forwardFn: function forwardFn() {
          iForward++;
        },
        backpropagationFn: function backpropagationFn() {
          iBackpropagate++;
        }
      });
      return m;
    }

    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'runIndex',
    value: function runIndex() {
      var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.inputRow = rowIndex;
      var state = void 0;
      for (var i = 0, max = this.states.length; i < max; i++) {
        state = this.states[i];
        if (!state.hasOwnProperty('forwardFn')) {
          continue;
        }
        state.forwardFn(state.product, state.left, state.right);
      }

      return state.product;
    }

    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'runInput',
    value: function runInput(inputValue) {
      this.inputValue = inputValue;
      var state = void 0;
      for (var i = 0, max = this.states.length; i < max; i++) {
        state = this.states[i];
        if (!state.hasOwnProperty('forwardFn')) {
          continue;
        }
        state.forwardFn(state.product, state.left, state.right);
      }

      return state.product;
    }

    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'backpropagate',
    value: function backpropagate() {
      var i = this.states.length;
      var state = void 0;
      while (i-- > 0) {
        state = this.states[i];
        if (!state.hasOwnProperty('backpropagationFn')) {
          continue;
        }
        state.backpropagationFn(state.product, state.left, state.right);
      }

      return state.product;
    }

    /**
     * @patam {Number} [rowIndex]
     * @output {Matrix}
     */

  }, {
    key: 'backpropagateIndex',
    value: function backpropagateIndex() {
      var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      this.inputRow = rowIndex;

      var i = this.states.length;
      var state = void 0;
      while (i-- > 0) {
        state = this.states[i];
        if (!state.hasOwnProperty('backpropagationFn')) {
          continue;
        }
        state.backpropagationFn(state.product, state.left, state.right);
      }

      return state.product;
    }
  }, {
    key: 'predictTarget',
    value: function predictTarget(input, target) {
      var output = this.runInput(input);
      var errorSum = 0;
      for (var i = 0; i < output.weights.length; i++) {
        var error = output.weights[i] - target[i];
        // set gradients into log probabilities
        errorSum += Math.abs(error);
        // write gradients into log probabilities
        output.deltas[i] = error;
      }
      return errorSum;
    }
  }, {
    key: 'predictTargetIndex',
    value: function predictTargetIndex(input, target) {
      var output = this.runIndex(input);
      // set gradients into log probabilities
      var logProbabilities = output; // interpret output as log probabilities
      var probabilities = (0, _softmax2.default)(output); // compute the softmax probabilities

      // write gradients into log probabilities
      logProbabilities.deltas = probabilities.weights.slice(0);
      logProbabilities.deltas[target] -= 1;

      // accumulate base 2 log prob and do smoothing
      return -Math.log2(probabilities.weights[target]);
    }
  }]);

  return Equation;
}();

exports.default = Equation;

},{"./":31,"./add":26,"./add-b":25,"./all-ones":27,"./clone-negative":28,"./copy":29,"./multiply":36,"./multiply-b":33,"./multiply-element":35,"./multiply-element-b":34,"./ones-matrix":37,"./relu":40,"./relu-b":39,"./row-pluck":42,"./row-pluck-b":41,"./sigmoid":45,"./sigmoid-b":44,"./softmax":46,"./tanh":48,"./tanh-b":47}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _zeros = require('../../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A matrix
 * @param {Number} [rows]
 * @param {Number} [columns]
 * @constructor
 */
var Matrix = function () {
  function Matrix(rows, columns) {
    _classCallCheck(this, Matrix);

    if (rows === undefined) return;
    if (columns === undefined) return;

    this.rows = rows;
    this.columns = columns;
    this.weights = (0, _zeros2.default)(rows * columns);
    this.deltas = (0, _zeros2.default)(rows * columns);
  }

  /**
   *
   * @param {Number} row
   * @param {Number} col
   * @returns {Float32Array|Array}
   */


  _createClass(Matrix, [{
    key: 'getWeights',
    value: function getWeights(row, col) {
      // slow but careful accessor function
      // we want row-major order
      var ix = this.columns * row + col;
      if (ix < 0 && ix >= this.weights.length) throw new Error('get accessor is skewed');
      return this.weights[ix];
    }

    /**
     *
     * @param {Number} row
     * @param {Number} col
     * @param v
     * @returns {Matrix}
     */

  }, {
    key: 'setWeight',
    value: function setWeight(row, col, v) {
      // slow but careful accessor function
      var ix = this.columns * row + col;
      if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');
      this.weights[ix] = v;
    }

    /**
     *
     * @param {Number} row
     * @param {Number} col
     * @param v
     * @returns {Matrix}
     */

  }, {
    key: 'setDeltas',
    value: function setDeltas(row, col, v) {
      // slow but careful accessor function
      var ix = this.columns * row + col;
      if (ix < 0 && ix >= this.weights.length) throw new Error('set accessor is skewed');
      this.deltas[ix] = v;
    }

    /**
     *
     * @returns {{rows: *, columns: *, weights: Array}}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        rows: this.rows,
        columns: this.columns,
        weights: this.weights.slice(0)
      };
    }
  }, {
    key: 'weightsToArray',
    value: function weightsToArray() {
      var deltas = [];
      var row = 0;
      var column = 0;
      for (var i = 0; i < this.weights.length; i++) {
        if (column === 0) {
          deltas.push([]);
        }
        deltas[row].push(this.weights[i]);
        column++;
        if (column >= this.columns) {
          column = 0;
          row++;
        }
      }
      return deltas;
    }
  }, {
    key: 'deltasToArray',
    value: function deltasToArray() {
      var deltas = [];
      var row = 0;
      var column = 0;
      for (var i = 0; i < this.deltas.length; i++) {
        if (column === 0) {
          deltas.push([]);
        }
        deltas[row].push(this.deltas[i]);
        column++;
        if (column >= this.columns) {
          column = 0;
          row++;
        }
      }
      return deltas;
    }
  }], [{
    key: 'fromJSON',
    value: function fromJSON(json) {
      var matrix = new Matrix(json.rows, json.columns);
      for (var i = 0, max = json.rows * json.columns; i < max; i++) {
        matrix.weights[i] = json.weights[i]; // copy over weights
      }
      return matrix;
    }

    /**
     *
     * @param weightRows
     * @param [deltasRows]
     * @returns {Matrix}
     */

  }, {
    key: 'fromArray',
    value: function fromArray(weightRows, deltasRows) {
      var rows = weightRows.length;
      var columns = weightRows[0].length;
      var m = new Matrix(rows, columns);

      deltasRows = deltasRows || weightRows;

      for (var rowIndex = 0; rowIndex < rows; rowIndex++) {
        var weightValues = weightRows[rowIndex];
        var deltasValues = deltasRows[rowIndex];
        for (var columnIndex = 0; columnIndex < columns; columnIndex++) {
          m.setWeight(rowIndex, columnIndex, weightValues[columnIndex]);
          m.setDeltas(rowIndex, columnIndex, deltasValues[columnIndex]);
        }
      }

      return m;
    }
  }]);

  return Matrix;
}();

exports.default = Matrix;

},{"../../utilities/zeros":65}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = maxI;
/**
 *
 * @param {Matrix} m
 * @returns {number}
 */
function maxI(m) {
  // argmax of array w
  var weights = m.weights;

  var maxv = weights[0];
  var maxix = 0;
  for (var i = 1; i < weights.length; i++) {
    var v = weights[i];
    if (v < maxv) continue;

    maxix = i;
    maxv = v;
  }
  return maxix;
};

},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiplyB;
/**
 * multiplies {from} deltas to {left} and {right}
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */
function multiplyB(product, left, right) {
  var leftRows = left.rows;
  var leftColumns = left.columns;
  var rightColumns = right.columns;

  // loop over rows of left
  for (var leftRow = 0; leftRow < leftRows; leftRow++) {
    var leftRowBase = leftColumns * leftRow;
    var rightRowBase = rightColumns * leftRow;
    // loop over cols of right
    for (var rightColumn = 0; rightColumn < rightColumns; rightColumn++) {

      //loop over columns of left
      for (var leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
        var rightColumnBase = rightColumns * leftColumn;
        var _leftRow = leftRowBase + leftColumn;
        var rightRow = rightColumnBase + rightColumn;
        var backPropagateValue = product.deltas[rightRowBase + rightColumn];
        left.deltas[_leftRow] += right.weights[rightRow] * backPropagateValue;
        right.deltas[rightRow] += left.weights[_leftRow] * backPropagateValue;
      }
    }
  }
}

},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiplyElementB;
/**
 * multiplies {left} and {right} weight by {from} deltas into {left} and {right} deltas
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */
function multiplyElementB(product, left, right) {
  for (var i = 0; i < left.weights.length; i++) {
    left.deltas[i] = right.weights[i] * product.deltas[i];
    right.deltas[i] = left.weights[i] * product.deltas[i];
  }
}

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiplyElement;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */
function multiplyElement(product, left, right) {
  var weights = left.weights;

  for (var i = 0; i < weights.length; i++) {
    product.weights[i] = left.weights[i] * right.weights[i];
    product.deltas[i] = 0;
  }
}

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiply;
/**
 * multiply {left} and {right} matrix weights to {into}
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Matrix} right
 */
function multiply(product, left, right) {
  var leftRows = left.rows;
  var leftColumns = left.columns;
  var rightColumns = right.columns;

  // loop over rows of left
  for (var leftRow = 0; leftRow < leftRows; leftRow++) {
    var leftRowBase = leftColumns * leftRow;
    var rightRowBase = rightColumns * leftRow;
    // loop over cols of right
    for (var rightColumn = 0; rightColumn < rightColumns; rightColumn++) {

      // dot product loop
      var dot = 0;
      //loop over columns of left
      for (var leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
        var rightColumnBase = rightColumns * leftColumn;
        var leftIndex = leftRowBase + leftColumn;
        var rightIndex = rightColumnBase + rightColumn;
        dot += left.weights[leftIndex] * right.weights[rightIndex];
        left.deltas[leftIndex] = 0;
        right.deltas[rightIndex] = 0;
      }
      product.weights[rightRowBase + rightColumn] = dot;
    }
  }
}

},{}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('./');

var _2 = _interopRequireDefault(_);

var _ones = require('../../utilities/ones');

var _ones2 = _interopRequireDefault(_ones);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** return Matrix but filled with random numbers from gaussian
 * @param {Number} [rows]
 * @param {Number} [columns]
 * @constructor
 */
var OnesMatrix = function (_Matrix) {
  _inherits(OnesMatrix, _Matrix);

  function OnesMatrix(rows, columns) {
    _classCallCheck(this, OnesMatrix);

    var _this = _possibleConstructorReturn(this, (OnesMatrix.__proto__ || Object.getPrototypeOf(OnesMatrix)).call(this, rows, columns));

    _this.rows = rows;
    _this.columns = columns;
    _this.weights = (0, _ones2.default)(rows * columns);
    _this.deltas = (0, _ones2.default)(rows * columns);
    return _this;
  }

  return OnesMatrix;
}(_2.default);

exports.default = OnesMatrix;

},{"../../utilities/ones":58,"./":31}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ = require('./');

var _2 = _interopRequireDefault(_);

var _random = require('../../utilities/random');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** return Matrix but filled with random numbers from gaussian
 * @param {Number} [rows]
 * @param {Number} [columns]
 * @param std
 * @constructor
 */
var RandomMatrix = function (_Matrix) {
  _inherits(RandomMatrix, _Matrix);

  function RandomMatrix(rows, columns, std) {
    _classCallCheck(this, RandomMatrix);

    var _this = _possibleConstructorReturn(this, (RandomMatrix.__proto__ || Object.getPrototypeOf(RandomMatrix)).call(this, rows, columns));

    _this.rows = rows;
    _this.columns = columns;
    _this.std = std;
    for (var i = 0, max = _this.weights.length; i < max; i++) {
      _this.weights[i] = (0, _random.randomF)(-std, std);
    }
    return _this;
  }

  return RandomMatrix;
}(_2.default);

exports.default = RandomMatrix;

},{"../../utilities/random":60,"./":31}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reluB;
/**
 * adds {from} deltas to {m} deltas when {m} weights are above other a threshold of 0
 * @param {Matrix} product
 * @param {Matrix} m
 */
function reluB(product, left) {
  for (var i = 0; i < product.deltas.length; i++) {
    left.deltas[i] = left.weights[i] > 0 ? product.deltas[i] : 0;
  }
}

},{}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = relu;
/**
 *
 * relu {m} weights to {into} weights
 * @param {Matrix} product
 * @param {Matrix} left
 */
function relu(product, left) {
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = Math.max(0, left.weights[i]); // relu
    product.deltas[i] = 0;
  }
}

},{}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rowPluckB;
/**
 * adds {from} deltas into {m} deltas
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Number} rowIndex
 */
function rowPluckB(product, left, rowIndex) {
  var columns = left.columns;
  var rowBase = columns * rowIndex;
  for (var column = 0; column < columns; column++) {
    left.deltas[rowBase + column] = product.deltas[column];
  }
}

},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rowPluck;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 * @param {Number} rowPluckIndex
 */
function rowPluck(product, left, rowPluckIndex) {
  var columns = left.columns;
  var rowBase = columns * rowPluckIndex;
  for (var column = 0; column < columns; column++) {
    product.weights[column] = left.weights[rowBase + column];
    product.deltas[column] = 0;
  }
}

},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sampleI;

var _random = require('../../utilities/random');

//prevent parser from renaming when calling toString() method later
var randomF = _random.randomF;
/**
 *
 * @param {Matrix} m
 * @returns {number}
 */
function sampleI(m) {
  // sample argmax from w, assuming w are
  // probabilities that sum to one
  var r = randomF(0, 1);
  var x = 0;
  var i = 0;
  var w = m.weights;

  while (true) {
    x += w[i];
    if (x > r) {
      return i;
    }
    i++;
  }
}

},{"../../utilities/random":60}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sigmoidB;
/**
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */
function sigmoidB(product, left) {
  for (var i = 0; i < product.deltas.length; i++) {
    var mwi = product.weights[i];
    left.deltas[i] = mwi * (1 - mwi) * product.deltas[i];
  }
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sigmoid;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 */
function sigmoid(product, left) {
  // sigmoid nonlinearity
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = 1 / (1 + Math.exp(-left.weights[i]));
    product.deltas[i] = 0;
  }
}

function sig(x) {
  // helper function for computing sigmoid
  return 1 / (1 + Math.exp(-x));
}

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = softmax;

var _ = require('./');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @param {Matrix} m
 * @returns {Matrix}
 */
function softmax(m) {
  var result = new _2.default(m.rows, m.columns); // probability volume
  var maxVal = -999999;
  for (var i = 0; i < m.weights.length; i++) {
    if (m.weights[i] > maxVal) {
      maxVal = m.weights[i];
    }
  }

  var s = 0;
  for (var _i = 0; _i < m.weights.length; _i++) {
    result.weights[_i] = Math.exp(m.weights[_i] - maxVal);
    s += result.weights[_i];
  }

  for (var _i2 = 0; _i2 < m.weights.length; _i2++) {
    result.weights[_i2] /= s;
  }

  // no backward pass here needed
  // since we will use the computed probabilities outside
  // to set gradients directly on m
  return result;
}

},{"./":31}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tanhB;
/**
 *
 * @param {Matrix} product
 * @param {Matrix} left
 */
function tanhB(product, left) {
  for (var i = 0; i < product.deltas.length; i++) {
    // grad for z = tanh(x) is (1 - z^2)
    var mwi = product.weights[i];
    left.deltas[i] = (1 - mwi * mwi) * product.deltas[i];
  }
}

},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = tanh;
/**
 * @param {Matrix} product
 * @param {Matrix} left
 */
function tanh(product, left) {
  // tanh nonlinearity
  for (var i = 0; i < left.weights.length; i++) {
    product.weights[i] = Math.tanh(left.weights[i]);
    product.deltas[i] = 0;
  }
}

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _equation = require('./matrix/equation');

var _equation2 = _interopRequireDefault(_equation);

var _rnn = require('./rnn');

var _rnn2 = _interopRequireDefault(_rnn);

var _zeros = require('../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _softmax = require('./matrix/softmax');

var _softmax2 = _interopRequireDefault(_softmax);

var _random = require('../utilities/random');

var _sampleI = require('./matrix/sample-i');

var _sampleI2 = _interopRequireDefault(_sampleI);

var _maxI = require('./matrix/max-i');

var _maxI2 = _interopRequireDefault(_maxI);

var _lookup = require('../lookup');

var _lookup2 = _interopRequireDefault(_lookup);

var _lookupTable2 = require('../utilities/lookup-table');

var _lookupTable3 = _interopRequireDefault(_lookupTable2);

var _arrayLookupTable = require('../utilities/array-lookup-table');

var _arrayLookupTable2 = _interopRequireDefault(_arrayLookupTable);

var _cast = require('../utilities/cast');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RNNTimeStep = function (_RNN) {
  _inherits(RNNTimeStep, _RNN);

  function RNNTimeStep() {
    _classCallCheck(this, RNNTimeStep);

    return _possibleConstructorReturn(this, (RNNTimeStep.__proto__ || Object.getPrototypeOf(RNNTimeStep)).apply(this, arguments));
  }

  _createClass(RNNTimeStep, [{
    key: 'createOutputMatrix',
    value: function createOutputMatrix() {
      var model = this.model;
      var outputSize = this.outputSize;
      var lastHiddenSize = this.hiddenLayers[this.hiddenLayers.length - 1];

      //whd
      model.outputConnector = new _randomMatrix2.default(outputSize, lastHiddenSize, 0.08);
      //bd
      model.output = new _randomMatrix2.default(outputSize, 1, 0.08);
    }
  }, {
    key: 'bindEquation',
    value: function bindEquation() {
      var model = this.model;
      var hiddenLayers = this.hiddenLayers;
      var layers = model.hiddenLayers;
      var equation = new _equation2.default();
      var outputs = [];
      var equationConnection = model.equationConnections.length > 0 ? model.equationConnections[model.equationConnections.length - 1] : this.initialLayerInputs;

      // 0 index
      var output = this.getEquation(equation, equation.input(new _matrix2.default(this.inputSize, 1)), equationConnection[0], layers[0]);
      outputs.push(output);
      // 1+ indices
      for (var i = 1, max = hiddenLayers.length; i < max; i++) {
        output = this.getEquation(equation, output, equationConnection[i], layers[i]);
        outputs.push(output);
      }

      model.equationConnections.push(outputs);
      equation.add(equation.multiply(model.outputConnector, output), model.output);
      model.equations.push(equation);
    }
  }, {
    key: 'mapModel',
    value: function mapModel() {
      var model = this.model;
      var hiddenLayers = model.hiddenLayers;
      var allMatrices = model.allMatrices;
      this.initialLayerInputs = this.hiddenLayers.map(function (size) {
        return new _matrix2.default(size, 1);
      });

      this.createHiddenLayers();
      if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');
      for (var i = 0, max = hiddenLayers.length; i < max; i++) {
        var hiddenMatrix = hiddenLayers[i];
        for (var property in hiddenMatrix) {
          if (!hiddenMatrix.hasOwnProperty(property)) continue;
          allMatrices.push(hiddenMatrix[property]);
        }
      }

      this.createOutputMatrix();
      if (!model.outputConnector) throw new Error('net.model.outputConnector not set');
      if (!model.output) throw new Error('net.model.output not set');

      allMatrices.push(model.outputConnector);
      allMatrices.push(model.output);
    }
  }, {
    key: 'backpropagate',
    value: function backpropagate() {
      for (var i = this.model.equations.length - 1; i > -1; i--) {
        this.model.equations[i].backpropagate();
      }
    }

    /**
     *
     * @param {number[]|number[][]|object|object[][]} [rawInput]
     * @returns {number[]|number|object|object[]|object[][]}
     */

  }, {
    key: 'run',
    value: function run(rawInput) {
      if (this.inputSize === 1) {
        if (this.outputLookup) {
          this.run = this.runObject;
          return this.runObject(rawInput);
        }
        this.run = this.runNumbers;
        return this.runNumbers(rawInput);
      }
      this.run = this.runArrays;
      return this.runArrays(rawInput);
    }
  }, {
    key: 'forecast',
    value: function forecast(input, count) {
      if (this.inputSize === 1) {
        if (this.outputLookup) {
          this.forecast = this.runObject;
          return this.runObject(input);
        }
        this.forecast = this.forecastNumbers;
        return this.forecastNumbers(input, count);
      }
      if (this.outputLookup) {
        this.forecast = this.forecastObjects;
        return this.forecastObjects(input, count);
      }
      this.forecast = this.forecastArrays;
      return this.forecastArrays(input, count);
    }

    /**
     *
     * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings
     * @param {Object} [options]
     * @returns {{error: number, iterations: number}}
     */

  }, {
    key: 'train',
    value: function train(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.trainOpts = options = Object.assign({}, this.constructor.trainDefaults, options);
      var iterations = options.iterations;
      var errorThresh = options.errorThresh;
      var log = options.log === true ? console.log : options.log;
      var logPeriod = options.logPeriod;
      var callback = options.callback;
      var callbackPeriod = options.callbackPeriod;

      if (this.inputSize === 1 || !this.inputSize) {
        this.setSize(data);
      }

      data = this.formatData(data);
      var error = Infinity;
      var i = void 0;

      this.verifyIsInitialized(data);

      for (i = 0; i < iterations && error > errorThresh; i++) {
        var sum = 0;
        for (var j = 0; j < data.length; j++) {
          var err = this.trainPattern(data[j], true);
          sum += err;
        }
        error = sum / data.length;

        if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');
        if (log && i % logPeriod === 0) {
          log('iterations: ' + i + ', training error: ' + error);
        }
        if (callback && i % callbackPeriod === 0) {
          callback({ error: error, iterations: i });
        }
      }

      return {
        error: error,
        iterations: i
      };
    }

    /**
     *
     * @param data
     * Verifies network sizes are initialized
     * If they are not it will initialize them based off the data set.
     */

  }, {
    key: 'verifyIsInitialized',
    value: function verifyIsInitialized(data) {
      if (data[0].input) {
        this.trainInput = this.trainInputOutput;
      } else if (data[0].length > 0) {
        if (data[0][0].length > 0) {
          this.trainInput = this.trainArrays;
        } else {
          if (this.inputSize > 1) {
            this.trainInput = this.trainArrays;
          } else {
            this.trainInput = this.trainNumbers;
          }
        }
      }

      if (!this.model) {
        this.initialize();
      }
    }
  }, {
    key: 'setSize',
    value: function setSize(data) {
      var dataShape = _lookup2.default.dataShape(data).join(',');
      switch (dataShape) {
        case 'array,array,number':
        case 'array,object,number':
        case 'array,datum,array,number':
        case 'array,datum,object,number':
          // probably 1
          break;
        case 'array,array,array,number':
          this.inputSize = this.outputSize = data[0][0].length;
          break;
        case 'array,array,object,number':
          this.inputSize = this.outputSize = Object.keys(_lookup2.default.toTable2D(data)).length;
          break;
        case 'array,datum,array,array,number':
          this.inputSize = this.outputSize = data[0].input[0].length;
          break;
        case 'array,datum,array,object,number':
          this.inputSize = Object.keys(_lookup2.default.toInputTable2D(data)).length;
          this.outputSize = Object.keys(_lookup2.default.toOutputTable2D(data)).length;
          break;
        default:
          throw new Error('unknown data shape or configuration');
      }
    }
  }, {
    key: 'trainNumbers',
    value: function trainNumbers(input) {
      var model = this.model;
      var equations = model.equations;
      while (equations.length < input.length) {
        this.bindEquation();
      }
      var errorSum = 0;
      for (var i = 0, max = input.length - 1; i < max; i++) {
        errorSum += equations[i].predictTarget(input[i], input[i + 1]);
      }
      this.end();
      return errorSum / input.length;
    }
  }, {
    key: 'runNumbers',
    value: function runNumbers(input) {
      if (!this.isRunnable) return null;
      var model = this.model;
      var equations = model.equations;
      if (this.inputLookup) {
        input = _lookup2.default.toArray(this.inputLookup, input, this.inputLookupLength);
      }
      while (equations.length <= input.length) {
        this.bindEquation();
      }
      var lastOutput = void 0;
      for (var i = 0; i < input.length; i++) {
        lastOutput = equations[i].runInput([input[i]]);
      }
      this.end();
      return lastOutput.weights[0];
    }
  }, {
    key: 'forecastNumbers',
    value: function forecastNumbers(input, count) {
      if (!this.isRunnable) return null;
      var model = this.model;
      var equations = model.equations;
      var length = input.length + count;
      while (equations.length <= length) {
        this.bindEquation();
      }
      var lastOutput = void 0;
      var equationIndex = 0;
      for (var i = 0; i < input.length; i++) {
        lastOutput = equations[equationIndex++].runInput([input[i]]);
      }
      var result = [lastOutput.weights[0]];
      for (var _i = 0, max = count - 1; _i < max; _i++) {
        lastOutput = equations[equationIndex++].runInput(lastOutput.weights);
        result.push(lastOutput.weights[0]);
      }
      this.end();
      return result;
    }
  }, {
    key: 'runObject',
    value: function runObject(input) {
      if (this.inputLookup === this.outputLookup) {
        var inputArray = _lookup2.default.toArrayShort(this.inputLookup, input);
        return _lookup2.default.toObjectPartial(this.outputLookup, this.forecastNumbers(inputArray, this.outputLookupLength - inputArray.length), inputArray.length);
      }
      return _lookup2.default.toObject(this.outputLookup, this.forecastNumbers(_lookup2.default.toArray(this.inputLookup, input, this.inputLookupLength), this.outputLookupLength));
    }
  }, {
    key: 'forecastObjects',
    value: function forecastObjects(input, count) {
      var _this2 = this;

      input = input.map(function (value) {
        return _lookup2.default.toArray(_this2.outputLookup, value, _this2.outputLookupLength);
      });
      return this.forecastArrays(input, count).map(function (value) {
        return _lookup2.default.toObject(_this2.outputLookup, value);
      });
    }
  }, {
    key: 'trainInputOutput',
    value: function trainInputOutput(object) {
      var model = this.model;
      var input = object.input;
      var output = object.output;
      var totalSize = input.length + output.length;
      var equations = model.equations;
      while (equations.length < totalSize) {
        this.bindEquation();
      }
      var errorSum = 0;
      var equationIndex = 0;
      for (var inputIndex = 0, max = input.length - 1; inputIndex < max; inputIndex++) {
        errorSum += equations[equationIndex++].predictTarget(input[inputIndex], input[inputIndex + 1]);
      }
      errorSum += equations[equationIndex++].predictTarget(input[input.length - 1], output[0]);
      for (var outputIndex = 0, _max = output.length - 1; outputIndex < _max; outputIndex++) {
        errorSum += equations[equationIndex++].predictTarget(output[outputIndex], output[outputIndex + 1]);
      }
      this.end();
      return errorSum / totalSize;
    }
  }, {
    key: 'trainArrays',
    value: function trainArrays(input) {
      var model = this.model;
      var equations = model.equations;
      while (equations.length < input.length) {
        this.bindEquation();
      }
      var errorSum = 0;
      for (var i = 0, max = input.length - 1; i < max; i++) {
        errorSum += equations[i].predictTarget(input[i], input[i + 1]);
      }
      this.end();
      return errorSum / input.length;
    }
  }, {
    key: 'runArrays',
    value: function runArrays(input) {
      if (!this.isRunnable) return null;
      var model = this.model;
      var equations = model.equations;
      while (equations.length <= input.length) {
        this.bindEquation();
      }
      if (this.inputLookup) {
        input = _lookup2.default.toArrays(this.inputLookup, input, this.inputLookupLength);
      }
      var lastOutput = void 0;
      for (var i = 0; i < input.length; i++) {
        var outputMatrix = equations[i].runInput(input[i]);
        lastOutput = outputMatrix.weights;
      }
      this.end();
      if (this.outputLookup) {
        return _lookup2.default.toObject(this.outputLookup, lastOutput);
      }
      return lastOutput;
    }
  }, {
    key: 'forecastArrays',
    value: function forecastArrays(input, count) {
      if (!this.isRunnable) return null;
      var model = this.model;
      var equations = model.equations;
      var length = input.length + count;
      while (equations.length <= length) {
        this.bindEquation();
      }
      var lastOutput = void 0;
      var equationIndex = 0;
      for (var i = 0; i < input.length; i++) {
        lastOutput = equations[equationIndex++].runInput(input[i]);
      }
      var result = [lastOutput.weights];
      for (var _i2 = 0, max = count - 1; _i2 < max; _i2++) {
        lastOutput = equations[equationIndex++].runInput(lastOutput.weights);
        result.push(lastOutput.weights.slice(0));
      }
      this.end();
      return result;
    }
  }, {
    key: 'end',
    value: function end() {
      this.model.equations[this.model.equations.length - 1].runInput(new Float32Array(this.outputSize));
    }

    /**
     *
     * @param data
     * @returns {*}
     */

  }, {
    key: 'formatData',
    value: function formatData(data) {
      var dataShape = _lookup2.default.dataShape(data).join(',');
      var result = [];
      switch (dataShape) {
        case 'array,number':
          {
            if (this.inputSize !== 1) {
              throw new Error('inputSize must be 1 for this data size');
            }
            if (this.outputSize !== 1) {
              throw new Error('outputSize must be 1 for this data size');
            }
            for (var i = 0; i < data.length; i++) {
              result.push(Float32Array.from([data[i]]));
            }
            return [result];
          }
        case 'array,array,number':
          {
            if (this.inputSize === 1 && this.outputSize === 1) {
              for (var _i3 = 0; _i3 < data.length; _i3++) {
                result.push((0, _cast.arrayToFloat32Arrays)(data[_i3]));
              }
              return result;
            }
            if (this.inputSize !== data[0].length) {
              throw new Error('inputSize must match data input size');
            }
            if (this.outputSize !== data[0].length) {
              throw new Error('outputSize must match data input size');
            }
            for (var _i4 = 0; _i4 < data.length; _i4++) {
              result.push(Float32Array.from(data[_i4]));
            }
            return [result];
          }
        case 'array,object,number':
          {
            if (this.inputSize !== 1) {
              throw new Error('inputSize must be 1 for this data size');
            }
            if (this.outputSize !== 1) {
              throw new Error('outputSize must be 1 for this data size');
            }
            if (!this.inputLookup) {
              var lookupTable = new _lookupTable3.default(data);
              this.inputLookup = this.outputLookup = lookupTable.table;
              this.inputLookupLength = this.outputLookupLength = lookupTable.length;
            }
            for (var _i5 = 0; _i5 < data.length; _i5++) {
              result.push((0, _cast.objectToFloat32Arrays)(data[_i5]));
            }
            return result;
          }
        case 'array,datum,array,number':
          {
            if (this.inputSize !== 1) {
              throw new Error('inputSize must be 1 for this data size');
            }
            if (this.outputSize !== 1) {
              throw new Error('outputSize must be 1 for this data size');
            }
            for (var _i6 = 0; _i6 < data.length; _i6++) {
              var datum = data[_i6];
              result.push({
                input: (0, _cast.arrayToFloat32Arrays)(datum.input),
                output: (0, _cast.arrayToFloat32Arrays)(datum.output)
              });
            }
            return result;
          }
        case 'array,datum,object,number':
          {
            if (this.inputSize !== 1) {
              throw new Error('inputSize must be 1 for this data size');
            }
            if (this.outputSize !== 1) {
              throw new Error('outputSize must be 1 for this data size');
            }
            if (!this.inputLookup) {
              var inputLookup = new _lookupTable3.default(data, 'input');
              this.inputLookup = inputLookup.table;
              this.inputLookupLength = inputLookup.length;
            }
            if (!this.outputLookup) {
              var outputLookup = new _lookupTable3.default(data, 'output');
              this.outputLookup = outputLookup.table;
              this.outputLookupLength = outputLookup.length;
            }
            for (var _i7 = 0; _i7 < data.length; _i7++) {
              var _datum = data[_i7];
              result.push({
                input: (0, _cast.objectToFloat32Arrays)(_datum.input),
                output: (0, _cast.objectToFloat32Arrays)(_datum.output)
              });
            }
            return result;
          }
        case 'array,array,array,number':
          {
            for (var _i8 = 0; _i8 < data.length; _i8++) {
              result.push((0, _cast.arraysToFloat32Arrays)(data[_i8]));
            }
            return result;
          }
        case 'array,array,object,number':
          {
            if (!this.inputLookup) {
              var _lookupTable = new _lookupTable3.default(data);
              this.inputLookup = this.outputLookup = _lookupTable.table;
              this.inputLookupLength = this.outputLookupLength = _lookupTable.length;
            }
            for (var _i9 = 0; _i9 < data.length; _i9++) {
              var array = [];
              for (var j = 0; j < data[_i9].length; j++) {
                array.push((0, _cast.objectToFloat32Array)(data[_i9][j], this.inputLookup, this.inputLookupLength));
              }
              result.push(array);
            }
            return result;
          }
        case 'array,datum,array,array,number':
          {
            if (this.inputSize === 1 && this.outputSize === 1) {
              for (var _i10 = 0; _i10 < data.length; _i10++) {
                var _datum2 = data[_i10];
                result.push({
                  input: Float32Array.from(_datum2.input),
                  output: Float32Array.from(_datum2.output)
                });
              }
            } else {
              if (this.inputSize !== data[0].input[0].length) {
                throw new Error('inputSize must match data input size');
              }
              if (this.outputSize !== data[0].output[0].length) {
                throw new Error('outputSize must match data output size');
              }
              for (var _i11 = 0; _i11 < data.length; _i11++) {
                var _datum3 = data[_i11];
                result.push({
                  input: (0, _cast.arraysToFloat32Arrays)(_datum3.input),
                  output: (0, _cast.arraysToFloat32Arrays)(_datum3.output)
                });
              }
            }
            return result;
          }
        case 'array,datum,array,object,number':
          {
            if (!this.inputLookup) {
              var _inputLookup = new _arrayLookupTable2.default(data, 'input');
              this.inputLookup = _inputLookup.table;
              this.inputLookupLength = _inputLookup.length;
            }
            if (!this.outputLookup) {
              var _outputLookup = new _arrayLookupTable2.default(data, 'output');
              this.outputLookup = _outputLookup.table;
              this.outputLookupLength = _outputLookup.length;
            }
            for (var _i12 = 0; _i12 < data.length; _i12++) {
              var _datum4 = data[_i12];
              result.push({
                input: (0, _cast.objectsToFloat32Arrays)(_datum4.input, this.inputLookup, this.inputLookupLength),
                output: (0, _cast.objectsToFloat32Arrays)(_datum4.output, this.outputLookup, this.outputLookupLength)
              });
            }
            return result;
          }
        default:
          throw new Error('unknown data shape or configuration');
      }
    }

    /**
     *
     * @param data
     * @returns {
     *  {
     *    error: number,
     *    misclasses: Array
     *  }
     * }
     */

  }, {
    key: 'test',
    value: function test(data) {
      var formattedData = this.formatData(data);
      // for classification problems
      var misclasses = [];
      // run each pattern through the trained network and collect
      // error and misclassification statistics
      var errorSum = 0;
      var dataShape = _lookup2.default.dataShape(data).join(',');
      switch (dataShape) {
        case 'array,array,number':
          {
            if (this.inputSize === 1) {
              for (var i = 0; i < formattedData.length; i++) {
                var input = formattedData[i];
                var output = this.run(input.splice(0, input.length - 1));
                var target = input[input.length - 1][0];
                var error = target - output;
                var errorMSE = error * error;
                errorSum += errorMSE;
                var errorsAbs = Math.abs(errorMSE);
                if (errorsAbs > this.trainOpts.errorThresh) {
                  var misclass = data[i];
                  Object.assign(misclass, {
                    value: input,
                    actual: output
                  });
                  misclasses.push(misclass);
                }
              }
              break;
            }
            throw new Error('unknown data shape or configuration');
          }
        case 'array,array,array,number':
          {
            for (var _i13 = 0; _i13 < formattedData.length; _i13++) {
              var _input = formattedData[_i13];
              var _output = this.run(_input.splice(0, _input.length - 1));
              var _target = _input[_input.length - 1];
              var errors = 0;
              var errorCount = 0;
              for (var j = 0; j < _output.length; j++) {
                errorCount++;
                var _error = _target[j] - _output[j];
                // mse
                errors += _error * _error;
              }
              errorSum += errors / errorCount;
              var _errorsAbs = Math.abs(errors);
              if (_errorsAbs > this.trainOpts.errorThresh) {
                var _misclass = data[_i13];
                misclasses.push({
                  value: _misclass,
                  actual: _output
                });
              }
            }
            break;
          }
        case 'array,object,number':
          {
            for (var _i14 = 0; _i14 < formattedData.length; _i14++) {
              var _input2 = formattedData[_i14];
              var _output2 = this.run(_lookup2.default.toObjectPartial(this.outputLookup, _input2, 0, _input2.length - 1));
              var _target2 = _input2[_input2.length - 1];
              var _errors = 0;
              var p = void 0;
              for (p in _output2) {}
              var _error2 = _target2[_i14] - _output2[p];
              // mse
              _errors += _error2 * _error2;
              errorSum += _errors;
              var _errorsAbs2 = Math.abs(_errors);
              if (_errorsAbs2 > this.trainOpts.errorThresh) {
                var _misclass2 = data[_i14];
                misclasses.push({
                  value: _misclass2,
                  actual: _output2
                });
              }
            }
            break;
          }
        case 'array,array,object,number':
          {
            for (var _i15 = 0; _i15 < formattedData.length; _i15++) {
              var _input3 = formattedData[_i15];
              var _output3 = this.run(_input3.slice(0, _input3.length - 1));
              var _target3 = data[_i15][_input3.length - 1];
              var _errors2 = 0;
              var _errorCount = 0;
              for (var _p in _output3) {
                var _error3 = _target3[_p] - _output3[_p];
                // mse
                _errors2 += _error3 * _error3;
                _errorCount++;
              }
              errorSum += _errors2 / _errorCount;
              var _errorsAbs3 = Math.abs(_errors2);
              if (_errorsAbs3 > this.trainOpts.errorThresh) {
                var _misclass3 = data[_i15];
                misclasses.push({
                  value: _misclass3,
                  actual: _output3
                });
              }
            }
            break;
          }
        case 'array,datum,array,number':
        case 'array,datum,object,number':
          {
            for (var _i16 = 0; _i16 < formattedData.length; _i16++) {
              var datum = formattedData[_i16];
              var _output4 = this.forecast(datum.input, datum.output.length);
              var _errors3 = 0;
              var _errorCount2 = 0;
              for (var _j = 0; _j < _output4.length; _j++) {
                var _error4 = datum.output[_j][0] - _output4[_j];
                _errors3 += _error4 * _error4;
                _errorCount2++;
              }

              errorSum += _errors3 / _errorCount2;
              var _errorsAbs4 = Math.abs(_errors3);
              if (_errorsAbs4 > this.trainOpts.errorThresh) {
                var _misclass4 = data[_i16];
                Object.assign(_misclass4, {
                  actual: this.outputLookup ? _lookup2.default.toObject(this.outputLookup, _output4) : _output4
                });
                misclasses.push(_misclass4);
              }
            }
            break;
          }
        case 'array,datum,array,array,number':
          {
            for (var _i17 = 0; _i17 < formattedData.length; _i17++) {
              var _datum5 = formattedData[_i17];
              var _output5 = this.forecast(_datum5.input, _datum5.output.length);
              var _errors4 = 0;
              for (var _j2 = 0; _j2 < _output5.length; _j2++) {
                for (var k = 0; k < _output5[_j2].length; k++) {
                  var _error5 = _datum5.output[_j2][k] - _output5[_j2][k];
                  _errors4 += _error5 * _error5;
                }
              }

              errorSum += _errors4;
              var _errorsAbs5 = Math.abs(_errors4);
              if (_errorsAbs5 > this.trainOpts.errorThresh) {
                var _misclass5 = data[_i17];
                misclasses.push({
                  input: _misclass5.input,
                  output: _misclass5.output,
                  actual: _output5
                });
              }
            }
            break;
          }
        case 'array,datum,array,object,number':
          {
            for (var _i18 = 0; _i18 < formattedData.length; _i18++) {
              var _datum6 = formattedData[_i18];
              var _output6 = this.forecast(_datum6.input, _datum6.output.length);
              var _errors5 = 0;
              for (var _j3 = 0; _j3 < _output6.length; _j3++) {
                for (var _p2 in _output6[_j3]) {
                  var _error6 = data[_i18].output[_j3][_p2] - _output6[_j3][_p2];
                  _errors5 += _error6 * _error6;
                }
              }

              errorSum += _errors5;
              var _errorsAbs6 = Math.abs(_errors5);
              if (_errorsAbs6 > this.trainOpts.errorThresh) {
                var _misclass6 = data[_i18];
                misclasses.push({
                  input: _misclass6.input,
                  output: _misclass6.output,
                  actual: _output6
                });
              }
            }
            break;
          }
        default:
          throw new Error('unknown data shape or configuration');
      }

      return {
        error: errorSum / formattedData.length,
        misclasses: misclasses,
        total: formattedData.length
      };
    }
  }, {
    key: 'addFormat',
    value: function addFormat(value) {
      var dataShape = _lookup2.default.dataShape(value).join(',');
      switch (dataShape) {
        case 'array,array,number':
        case 'datum,array,array,number':
        case 'array,number':
        case 'datum,array,number':
          return;
        case 'datum,object,number':
          {
            this.inputLookup = _lookup2.default.addKeys(value.input, this.inputLookup);
            if (this.inputLookup) {
              this.inputLookupLength = Object.keys(this.inputLookup).length;
            }
            this.outputLookup = _lookup2.default.addKeys(value.output, this.outputLookup);
            if (this.outputLookup) {
              this.outputLookupLength = Object.keys(this.outputLookup).length;
            }
            break;
          }
        case 'object,number':
          {
            this.inputLookup = this.outputLookup = _lookup2.default.addKeys(value, this.inputLookup);
            if (this.inputLookup) {
              this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;
            }
            break;
          }
        case 'array,object,number':
          {
            for (var i = 0; i < value.length; i++) {
              this.inputLookup = this.outputLookup = _lookup2.default.addKeys(value[i], this.inputLookup);
              if (this.inputLookup) {
                this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;
              }
            }
            break;
          }
        case 'datum,array,object,number':
          {
            for (var _i19 = 0; _i19 < value.input.length; _i19++) {
              this.inputLookup = _lookup2.default.addKeys(value.input[_i19], this.inputLookup);
              if (this.inputLookup) {
                this.inputLookupLength = Object.keys(this.inputLookup).length;
              }
            }
            for (var _i20 = 0; _i20 < value.output.length; _i20++) {
              this.outputLookup = _lookup2.default.addKeys(value.output[_i20], this.outputLookup);
              if (this.outputLookup) {
                this.outputLookupLength = Object.keys(this.outputLookup).length;
              }
            }
            break;
          }

        default:
          throw new Error('unknown data shape or configuration');
      }
    }

    /**
     *
     * @returns {Object}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var defaults = this.constructor.defaults;
      if (!this.model) {
        this.initialize();
      }
      var model = this.model;
      var options = {};
      for (var p in defaults) {
        if (defaults.hasOwnProperty(p)) {
          options[p] = this[p];
        }
      }

      return {
        type: this.constructor.name,
        options: options,
        hiddenLayers: model.hiddenLayers.map(function (hiddenLayer) {
          var layers = {};
          for (var _p3 in hiddenLayer) {
            layers[_p3] = hiddenLayer[_p3].toJSON();
          }
          return layers;
        }),
        outputConnector: this.model.outputConnector.toJSON(),
        output: this.model.output.toJSON()
      };
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var defaults = this.constructor.defaults;
      var options = json.options;
      this.model = null;
      this.hiddenLayers = null;
      var allMatrices = [];
      var hiddenLayers = [];

      // backward compatibility for hiddenSizes
      (json.hiddenLayers || json.hiddenSizes).forEach(function (hiddenLayer) {
        var layers = {};
        for (var p in hiddenLayer) {
          layers[p] = _matrix2.default.fromJSON(hiddenLayer[p]);
          allMatrices.push(layers[p]);
        }
        hiddenLayers.push(layers);
      });

      var outputConnector = _matrix2.default.fromJSON(json.outputConnector);
      allMatrices.push(outputConnector);
      var output = _matrix2.default.fromJSON(json.output);
      allMatrices.push(output);

      Object.assign(this, defaults, options);

      // backward compatibility
      if (options.hiddenSizes) {
        this.hiddenLayers = options.hiddenSizes;
      }

      this.model = {
        hiddenLayers: hiddenLayers,
        output: output,
        allMatrices: allMatrices,
        outputConnector: outputConnector,
        equations: [],
        equationConnections: []
      };
      this.initialLayerInputs = this.hiddenLayers.map(function (size) {
        return new _matrix2.default(size, 1);
      });
      this.bindEquation();
    }

    /**
     *
     * @returns {Function}
     */

  }, {
    key: 'toFunction',
    value: function toFunction() {
      var model = this.model;
      var equations = this.model.equations;
      var inputSize = this.inputSize;
      var inputLookup = this.inputLookup;
      var inputLookupLength = this.inputLookupLength;
      var outputLookup = this.outputLookup;
      var outputLookupLength = this.outputLookupLength;
      var equation = equations[1];
      var states = equation.states;
      var jsonString = JSON.stringify(this.toJSON());

      function matrixOrigin(m, stateIndex) {
        for (var i = 0, max = states.length; i < max; i++) {
          var state = states[i];

          if (i === stateIndex) {
            var j = previousConnectionIndex(m);
            switch (m) {
              case state.left:
                if (j > -1) {
                  return 'typeof prevStates[' + j + '] === \'object\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';
                }
              case state.right:
                if (j > -1) {
                  return 'typeof prevStates[' + j + '] === \'object\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';
                }
              case state.product:
                return 'new Matrix(' + m.rows + ', ' + m.columns + ')';
              default:
                throw Error('unknown state');
            }
          }

          if (m === state.product) return 'states[' + i + '].product';
          if (m === state.right) return 'states[' + i + '].right';
          if (m === state.left) return 'states[' + i + '].left';
        }
      }

      function previousConnectionIndex(m) {
        var connection = model.equationConnections[0];
        var states = equations[0].states;
        for (var i = 0, max = states.length; i < max; i++) {
          if (states[i].product === m) {
            return i;
          }
        }
        return connection.indexOf(m);
      }

      function matrixToString(m, stateIndex) {
        if (!m || !m.rows || !m.columns) return 'null';
        if (m === model.outputConnector) return 'json.outputConnector';
        if (m === model.output) return 'json.output';

        for (var i = 0, max = model.hiddenLayers.length; i < max; i++) {
          var hiddenLayer = model.hiddenLayers[i];
          for (var p in hiddenLayer) {
            if (!hiddenLayer.hasOwnProperty(p)) continue;
            if (hiddenLayer[p] !== m) continue;
            return 'json.hiddenLayers[' + i + '].' + p;
          }
        }

        return matrixOrigin(m, stateIndex);
      }

      function formatInputData() {
        if (!inputLookup) return '';
        if (inputSize === 1) {
          if (inputLookup === outputLookup) {
            return 'function lookupInput(input) {\n            var table = ' + JSON.stringify(inputLookup) + ';\n            var result = [];\n            for (var p in table) {\n              if (!input.hasOwnProperty(p)) break;\n              result.push(Float32Array.from([input[p]]));\n            }\n            return result;\n          }';
          }
          return 'function lookupInput(input) {\n          var table = ' + JSON.stringify(inputLookup) + ';\n          var result = [];\n          for (var p in table) {\n            result.push(Float32Array.from([input[p]]));\n          }\n          return result;\n        }';
        }
        return 'function lookupInput(rawInputs) {\n        var table = ' + JSON.stringify(inputLookup) + ';\n        var result = [];\n        for (var i = 0; i < rawInputs.length; i++) {\n          var rawInput = rawInputs[i];\n          var input = new Float32Array(' + inputLookupLength + ');\n          for (var p in table) {\n            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;\n          }\n          result.push(input);\n        }\n        return result;\n      }';
      }

      function formatOutputData() {
        if (!outputLookup) return '';
        if (inputSize === 1) {
          if (inputLookup === outputLookup) {
            return 'function lookupOutputPartial(output, input) {\n            var table = ' + JSON.stringify(outputLookup) + ';\n            var offset = input.length;\n            var result = {};\n            var i = 0;\n            for (var p in table) {\n              if (i++ < offset) continue;\n              result[p] = output[table[p] - offset][0];\n            }\n            return result;\n          }';
          }
          return 'function lookupOutput(output) {\n          var table = ' + JSON.stringify(outputLookup) + ';\n          var result = {};\n          for (var p in table) {\n            result[p] = output[table[p]][0];\n          }\n          return result;\n        }';
        }
        return 'function lookupOutput(output) {\n        var table = ' + JSON.stringify(outputLookup) + ';\n        var result = {};\n        for (var p in table) {\n          result[p] = output[table[p]];\n        }\n        return result;\n      }';
      }

      function toInner(fnString) {
        // crude, but should be sufficient for now
        // function() { body }
        fnString = fnString.toString().split('{');
        fnString.shift();
        // body }
        fnString = fnString.join('{');
        fnString = fnString.split('}');
        fnString.pop();
        // body

        return fnString.join('}').split('\n').join('\n        ').replace('product.weights = _input.weights = _this.inputValue;', inputLookup && inputSize === 1 ? 'product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;' : inputSize === 1 ? 'product.weights = [input[_i]];' : 'product.weights = input[_i];').replace('product.deltas[i] = 0;', '').replace('product.deltas[column] = 0;', '').replace('left.deltas[leftIndex] = 0;', '').replace('right.deltas[rightIndex] = 0;', '').replace('product.deltas = left.deltas.slice(0);', '');
      }

      function fileName(fnName) {
        return 'src/recurrent/matrix/' + fnName.replace(/[A-Z]/g, function (value) {
          return '-' + value.toLowerCase();
        }) + '.js';
      }

      var statesRaw = [];
      var usedFunctionNames = {};
      var innerFunctionsSwitch = [];
      for (var i = 0, max = states.length; i < max; i++) {
        var state = states[i];
        statesRaw.push('states[' + i + '] = {\n      name: \'' + state.forwardFn.name + '\',\n      left: ' + matrixToString(state.left, i) + ',\n      right: ' + matrixToString(state.right, i) + ',\n      product: ' + matrixToString(state.product, i) + '\n    }');

        var fnName = state.forwardFn.name;
        if (!usedFunctionNames[fnName]) {
          usedFunctionNames[fnName] = true;
          innerFunctionsSwitch.push('        case \'' + fnName + '\':' + (fnName !== 'forwardFn' ? ' //compiled from ' + fileName(fnName) : '') + '\n          ' + toInner(state.forwardFn.toString()) + '\n          break;');
        }
      }

      var forceForecast = this.inputSize === 1 && this.outputLookup;
      var src = '\n  var input = ' + (this.inputLookup ? 'lookupInput(rawInput)' : 'rawInput') + ';\n  var json = ' + jsonString + ';\n  var output = [];\n  var states = [];\n  var prevStates;\n  var state;\n  var max = ' + (forceForecast ? inputLookup === outputLookup ? inputLookupLength : 'input.length + ' + (outputLookupLength - 1) : 'input.length') + ';\n  for (var _i = 0; _i < max; _i++) {\n    prevStates = states;\n    states = [];\n    ' + statesRaw.join(';\n    ') + ';\n    for (var stateIndex = 0, stateMax = ' + statesRaw.length + '; stateIndex < stateMax; stateIndex++) {\n      state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      \n      switch (state.name) {\n' + innerFunctionsSwitch.join('\n') + '\n      }\n    }\n    ' + (inputSize === 1 && inputLookup ? 'if (_i >= input.length - 1) { output.push(state.product.weights); }' : 'output = state.product.weights;') + '\n  }\n  ' + (outputLookup ? outputLookup === inputLookup ? 'return lookupOutputPartial(output, input)' : 'return lookupOutput(output)' : inputSize === 1 ? 'return output[0]' : 'return output') + ';\n  ' + formatInputData() + '\n  ' + formatOutputData() + '\n  \n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ' + _zeros2.default.toString() + '\n  ' + _softmax2.default.toString().replace('_2.default', 'Matrix') + '\n  ' + _random.randomF.toString() + '\n  ' + _sampleI2.default.toString() + '\n  ' + _maxI2.default.toString();
      return new Function('rawInput', src);
    }
  }]);

  return RNNTimeStep;
}(_rnn2.default);

exports.default = RNNTimeStep;


RNNTimeStep.defaults = {
  inputSize: 1,
  hiddenLayers: [20],
  outputSize: 1,
  learningRate: _rnn2.default.defaults.learningRate,
  decayRate: _rnn2.default.defaults.decayRate,
  smoothEps: _rnn2.default.defaults.smoothEps,
  regc: _rnn2.default.defaults.regc,
  clipval: _rnn2.default.defaults.clipval
};

RNNTimeStep.trainDefaults = _rnn2.default.trainDefaults;

},{"../lookup":18,"../utilities/array-lookup-table":52,"../utilities/cast":53,"../utilities/lookup-table":55,"../utilities/random":60,"../utilities/zeros":65,"./matrix":31,"./matrix/equation":30,"./matrix/max-i":32,"./matrix/random-matrix":38,"./matrix/sample-i":43,"./matrix/softmax":46,"./rnn":50}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _matrix = require('./matrix');

var _matrix2 = _interopRequireDefault(_matrix);

var _randomMatrix = require('./matrix/random-matrix');

var _randomMatrix2 = _interopRequireDefault(_randomMatrix);

var _equation = require('./matrix/equation');

var _equation2 = _interopRequireDefault(_equation);

var _sampleI = require('./matrix/sample-i');

var _sampleI2 = _interopRequireDefault(_sampleI);

var _maxI = require('./matrix/max-i');

var _maxI2 = _interopRequireDefault(_maxI);

var _softmax = require('./matrix/softmax');

var _softmax2 = _interopRequireDefault(_softmax);

var _copy = require('./matrix/copy');

var _copy2 = _interopRequireDefault(_copy);

var _random = require('../utilities/random');

var _zeros = require('../utilities/zeros');

var _zeros2 = _interopRequireDefault(_zeros);

var _dataFormatter = require('../utilities/data-formatter');

var _dataFormatter2 = _interopRequireDefault(_dataFormatter);

var _neuralNetwork = require('../neural-network');

var _neuralNetwork2 = _interopRequireDefault(_neuralNetwork);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RNN = function () {
  function RNN() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, RNN);

    var defaults = this.constructor.defaults;

    Object.assign(this, defaults, options);
    this.trainOpts = {};
    this.updateTrainingOptions(Object.assign({}, this.constructor.trainDefaults, options));

    this.stepCache = {};
    this.runs = 0;
    this.ratioClipped = null;
    this.model = null;
    this.inputLookup = null;
    this.inputLookupLength = null;
    this.outputLookup = null;
    this.outputLookupLength = null;

    if (options.json) {
      this.fromJSON(options.json);
    }
  }

  _createClass(RNN, [{
    key: 'initialize',
    value: function initialize() {
      this.model = {
        input: null,
        hiddenLayers: [],
        output: null,
        equations: [],
        allMatrices: [],
        equationConnections: [],
        outputConnector: null
      };

      if (this.dataFormatter) {
        this.inputSize = this.inputRange = this.outputSize = this.dataFormatter.characters.length;
      }
      this.mapModel();
    }
  }, {
    key: 'createHiddenLayers',
    value: function createHiddenLayers() {
      //0 is end, so add 1 to offset
      this.model.hiddenLayers.push(this.getModel(this.hiddenLayers[0], this.inputSize));
      var prevSize = this.hiddenLayers[0];

      for (var d = 1; d < this.hiddenLayers.length; d++) {
        // loop over depths
        var hiddenSize = this.hiddenLayers[d];
        this.model.hiddenLayers.push(this.getModel(hiddenSize, prevSize));
        prevSize = hiddenSize;
      }
    }

    /**
     *
     * @param {Number} hiddenSize
     * @param {Number} prevSize
     * @returns {object}
     */

  }, {
    key: 'getModel',
    value: function getModel(hiddenSize, prevSize) {
      return {
        //wxh
        weight: new _randomMatrix2.default(hiddenSize, prevSize, 0.08),
        //whh
        transition: new _randomMatrix2.default(hiddenSize, hiddenSize, 0.08),
        //bhh
        bias: new _matrix2.default(hiddenSize, 1)
      };
    }

    /**
     *
     * @param {Equation} equation
     * @param {Matrix} inputMatrix
     * @param {Matrix} previousResult
     * @param {Object} hiddenLayer
     * @returns {Matrix}
     */

  }, {
    key: 'getEquation',
    value: function getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
      var relu = equation.relu.bind(equation);
      var add = equation.add.bind(equation);
      var multiply = equation.multiply.bind(equation);

      return relu(add(add(multiply(hiddenLayer.weight, inputMatrix), multiply(hiddenLayer.transition, previousResult)), hiddenLayer.bias));
    }
  }, {
    key: 'createInputMatrix',
    value: function createInputMatrix() {
      //0 is end, so add 1 to offset
      this.model.input = new _randomMatrix2.default(this.inputRange + 1, this.inputSize, 0.08);
    }
  }, {
    key: 'createOutputMatrix',
    value: function createOutputMatrix() {
      var model = this.model;
      var outputSize = this.outputSize;
      var lastHiddenSize = this.hiddenLayers[this.hiddenLayers.length - 1];

      //0 is end, so add 1 to offset
      //whd
      model.outputConnector = new _randomMatrix2.default(outputSize + 1, lastHiddenSize, 0.08);
      //0 is end, so add 1 to offset
      //bd
      model.output = new _matrix2.default(outputSize + 1, 1);
    }
  }, {
    key: 'bindEquation',
    value: function bindEquation() {
      var model = this.model;
      var equation = new _equation2.default();
      var outputs = [];
      var equationConnection = model.equationConnections.length > 0 ? model.equationConnections[model.equationConnections.length - 1] : this.initialLayerInputs;

      // 0 index
      var output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], model.hiddenLayers[0]);
      outputs.push(output);
      // 1+ indices
      for (var i = 1, max = this.hiddenLayers.length; i < max; i++) {
        output = this.getEquation(equation, output, equationConnection[i], model.hiddenLayers[i]);
        outputs.push(output);
      }

      model.equationConnections.push(outputs);
      equation.add(equation.multiply(model.outputConnector, output), model.output);
      model.equations.push(equation);
    }
  }, {
    key: 'mapModel',
    value: function mapModel() {
      var model = this.model;
      var hiddenLayers = model.hiddenLayers;
      var allMatrices = model.allMatrices;
      this.initialLayerInputs = this.hiddenLayers.map(function (size) {
        return new _matrix2.default(size, 1);
      });

      this.createInputMatrix();
      if (!model.input) throw new Error('net.model.input not set');
      allMatrices.push(model.input);

      this.createHiddenLayers();
      if (!model.hiddenLayers.length) throw new Error('net.hiddenLayers not set');
      for (var i = 0, max = hiddenLayers.length; i < max; i++) {
        var hiddenMatrix = hiddenLayers[i];
        for (var property in hiddenMatrix) {
          if (!hiddenMatrix.hasOwnProperty(property)) continue;
          allMatrices.push(hiddenMatrix[property]);
        }
      }

      this.createOutputMatrix();
      if (!model.outputConnector) throw new Error('net.model.outputConnector not set');
      if (!model.output) throw new Error('net.model.output not set');

      allMatrices.push(model.outputConnector);
      allMatrices.push(model.output);
    }

    /**
     *
     * @param {Number[]|string[]|string} input
     * @param {boolean} [logErrorRate]
     * @returns {number}
     */

  }, {
    key: 'trainPattern',
    value: function trainPattern(input, logErrorRate) {
      var error = this.trainInput(input);
      this.backpropagate(input);
      this.adjustWeights();

      if (logErrorRate) {
        return error;
      }
    }

    /**
     *
     * @param {Number[]} input
     * @returns {number}
     */

  }, {
    key: 'trainInput',
    value: function trainInput(input) {
      this.runs++;
      var model = this.model;
      var max = input.length;
      var log2ppl = 0;
      var equation = void 0;
      while (model.equations.length <= input.length + 1) {
        //last is zero
        this.bindEquation();
      }
      for (var inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {
        // start and end tokens are zeros
        var equationIndex = inputIndex + 1;
        equation = model.equations[equationIndex];

        var source = inputIndex === -1 ? 0 : input[inputIndex] + 1; // first step: start with START token
        var target = inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1; // last step: end with END token
        log2ppl += equation.predictTargetIndex(source, target);
      }
      return Math.pow(2, log2ppl / (max - 1)) / 100;
    }

    /**
     * @param {Number[]} input
     */

  }, {
    key: 'backpropagate',
    value: function backpropagate(input) {
      var i = input.length;
      var model = this.model;
      var equations = model.equations;
      while (i > 0) {
        equations[i].backpropagateIndex(input[i - 1] + 1);
        i--;
      }
      equations[0].backpropagateIndex(0);
    }
  }, {
    key: 'adjustWeights',
    value: function adjustWeights() {
      var regc = this.regc,
          clipval = this.clipval,
          model = this.model,
          decayRate = this.decayRate,
          stepCache = this.stepCache,
          smoothEps = this.smoothEps,
          trainOpts = this.trainOpts;
      var learningRate = trainOpts.learningRate;
      var allMatrices = model.allMatrices;

      var numClipped = 0;
      var numTot = 0;
      for (var matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {
        var matrix = allMatrices[matrixIndex];
        var weights = matrix.weights,
            deltas = matrix.deltas;

        if (!(matrixIndex in stepCache)) {
          stepCache[matrixIndex] = (0, _zeros2.default)(matrix.rows * matrix.columns);
        }
        var cache = stepCache[matrixIndex];
        for (var i = 0; i < weights.length; i++) {
          var r = deltas[i];
          var w = weights[i];
          // rmsprop adaptive learning rate
          cache[i] = cache[i] * decayRate + (1 - decayRate) * r * r;
          // gradient clip
          if (r > clipval) {
            r = clipval;
            numClipped++;
          }
          if (r < -clipval) {
            r = -clipval;
            numClipped++;
          }
          numTot++;
          // update (and regularize)
          weights[i] = w + -learningRate * r / Math.sqrt(cache[i] + smoothEps) - regc * w;
        }
      }
      this.ratioClipped = numClipped / numTot;
    }

    /**
     *
     * @returns boolean
     */

  }, {
    key: 'run',


    /**
     *
     * @param {Number[]|*} [rawInput]
     * @param {Boolean} [isSampleI]
     * @param {Number} temperature
     * @returns {*}
     */
    value: function run() {
      var rawInput = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var isSampleI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var temperature = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      var maxPredictionLength = this.maxPredictionLength + rawInput.length + (this.dataFormatter ? this.dataFormatter.specialIndexes.length : 0);
      if (!this.isRunnable) return null;
      var input = this.formatDataIn(rawInput);
      var model = this.model;
      var output = [];
      var i = 0;
      while (true) {
        var previousIndex = i === 0 ? 0 : i < input.length ? input[i - 1] + 1 : output[i - 1];
        while (model.equations.length <= i) {
          this.bindEquation();
        }
        var equation = model.equations[i];
        // sample predicted letter
        var outputMatrix = equation.runIndex(previousIndex);
        var logProbabilities = new _matrix2.default(model.output.rows, model.output.columns);
        (0, _copy2.default)(logProbabilities, outputMatrix);
        if (temperature !== 1 && isSampleI) {
          /**
           * scale log probabilities by temperature and re-normalize
           * if temperature is high, logProbabilities will go towards zero
           * and the softmax outputs will be more diffuse. if temperature is
           * very low, the softmax outputs will be more peaky
           */
          for (var j = 0, max = logProbabilities.weights.length; j < max; j++) {
            logProbabilities.weights[j] /= temperature;
          }
        }

        var probs = (0, _softmax2.default)(logProbabilities);
        var nextIndex = isSampleI ? (0, _sampleI2.default)(probs) : (0, _maxI2.default)(probs);

        i++;
        if (nextIndex === 0) {
          // END token predicted, break out
          break;
        }
        if (i >= maxPredictionLength) {
          // something is wrong
          break;
        }

        output.push(nextIndex);
      }

      /**
       * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the
       * network what is contained in input, so the data is essentially guessed by the network what could be next, till it
       * locks in on a value.
       * Kind of like this, values are from input:
       * 0 -> 4 (or in English: "beginning on input" -> "I have no idea? I'll guess what they want next!")
       * 2 -> 2 (oh how interesting, I've narrowed down values...)
       * 1 -> 9 (oh how interesting, I've now know what the values are...)
       * then the output looks like: [4, 2, 9,...]
       * so we then remove the erroneous data to get our true output
       */
      return this.formatDataOut(input, output.slice(input.length).map(function (value) {
        return value - 1;
      }));
    }

    /**
     *
     * @param data
     * Verifies network sizes are initilaized
     * If they are not it will initialize them based off the data set.
     */

  }, {
    key: 'verifyIsInitialized',
    value: function verifyIsInitialized(data) {
      if (!this.model) {
        this.initialize();
      }
    }

    /**
     *
     * @param options
     *    Supports all `trainDefaults` properties
     *    also supports:
     *       learningRate: (number),
     *       momentum: (number),
     *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
     */

  }, {
    key: 'updateTrainingOptions',
    value: function updateTrainingOptions(options) {
      var _this = this;

      Object.keys(this.constructor.trainDefaults).forEach(function (p) {
        return _this.trainOpts[p] = options.hasOwnProperty(p) ? options[p] : _this.trainOpts[p];
      });
      this.validateTrainingOptions(this.trainOpts);
      this.setLogMethod(options.log || this.trainOpts.log);
      this.activation = options.activation || this.activation;
    }
  }, {
    key: 'validateTrainingOptions',
    value: function validateTrainingOptions(options) {
      _neuralNetwork2.default.prototype.validateTrainingOptions.call(this, options);
    }

    /**
     *
     * @param log
     * if a method is passed in method is used
     * if false passed in nothing is logged
     * @returns error
     */

  }, {
    key: 'setLogMethod',
    value: function setLogMethod(log) {
      if (typeof log === 'function') {
        this.trainOpts.log = log;
      } else if (log) {
        this.trainOpts.log = console.log;
      } else {
        this.trainOpts.log = false;
      }
    }

    /**
     *
     * @param data
     * @param options
     * @protected
     * @return {object} { data, status, endTime }
     */

  }, {
    key: 'prepTraining',
    value: function prepTraining(data, options) {
      this.updateTrainingOptions(options);
      data = this.formatData(data);
      var endTime = Date.now() + this.trainOpts.timeout;

      var status = {
        error: 1,
        iterations: 0
      };

      this.verifyIsInitialized(data);

      return {
        data: data,
        status: status,
        endTime: endTime
      };
    }

    /**
     *
     * @param {Object[]|String[]} data an array of objects: `{input: 'string', output: 'string'}` or an array of strings
     * @param {Object} [options]
     * @returns {{error: number, iterations: number}}
     */

  }, {
    key: 'train',
    value: function train(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this.trainOpts = options = Object.assign({}, this.constructor.trainDefaults, options);
      var iterations = options.iterations;
      var errorThresh = options.errorThresh;
      var log = options.log === true ? console.log : options.log;
      var logPeriod = options.logPeriod;
      var callback = options.callback;
      var callbackPeriod = options.callbackPeriod;
      var error = Infinity;
      var i = void 0;

      if (this.hasOwnProperty('setupData')) {
        data = this.setupData(data);
      }

      this.verifyIsInitialized();

      for (i = 0; i < iterations && error > errorThresh; i++) {
        var sum = 0;
        for (var j = 0; j < data.length; j++) {
          var err = this.trainPattern(data[j], true);
          sum += err;
        }
        error = sum / data.length;

        if (isNaN(error)) throw new Error('network error rate is unexpected NaN, check network configurations and try again');
        if (log && i % logPeriod === 0) {
          log('iterations: ' + i + ', training error: ' + error);
        }
        if (callback && i % callbackPeriod === 0) {
          callback({ error: error, iterations: i });
        }
      }

      return {
        error: error,
        iterations: i
      };
    }
  }, {
    key: 'addFormat',
    value: function addFormat() {
      throw new Error('not yet implemented');
    }

    /**
     *
     * @returns {Object}
     */

  }, {
    key: 'toJSON',
    value: function toJSON() {
      var defaults = this.constructor.defaults;
      if (!this.model) {
        this.initialize();
      }
      var model = this.model;
      var options = {};
      for (var p in defaults) {
        if (defaults.hasOwnProperty(p)) {
          options[p] = this[p];
        }
      }

      return {
        type: this.constructor.name,
        options: options,
        input: model.input.toJSON(),
        hiddenLayers: model.hiddenLayers.map(function (hiddenLayer) {
          var layers = {};
          for (var _p in hiddenLayer) {
            layers[_p] = hiddenLayer[_p].toJSON();
          }
          return layers;
        }),
        outputConnector: this.model.outputConnector.toJSON(),
        output: this.model.output.toJSON()
      };
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var defaults = this.constructor.defaults;
      var options = json.options;
      this.model = null;
      this.hiddenLayers = null;
      var allMatrices = [];
      var input = _matrix2.default.fromJSON(json.input);
      allMatrices.push(input);
      var hiddenLayers = [];

      // backward compatibility for hiddenSizes
      (json.hiddenLayers || json.hiddenSizes).forEach(function (hiddenLayer) {
        var layers = {};
        for (var p in hiddenLayer) {
          layers[p] = _matrix2.default.fromJSON(hiddenLayer[p]);
          allMatrices.push(layers[p]);
        }
        hiddenLayers.push(layers);
      });

      var outputConnector = _matrix2.default.fromJSON(json.outputConnector);
      allMatrices.push(outputConnector);
      var output = _matrix2.default.fromJSON(json.output);
      allMatrices.push(output);

      Object.assign(this, defaults, options);

      // backward compatibility
      if (options.hiddenSizes) {
        this.hiddenLayers = options.hiddenSizes;
      }

      if (options.dataFormatter) {
        this.dataFormatter = _dataFormatter2.default.fromJSON(options.dataFormatter);
      }

      this.model = {
        input: input,
        hiddenLayers: hiddenLayers,
        output: output,
        allMatrices: allMatrices,
        outputConnector: outputConnector,
        equations: [],
        equationConnections: []
      };
      this.initialLayerInputs = this.hiddenLayers.map(function (size) {
        return new _matrix2.default(size, 1);
      });
      this.bindEquation();
    }

    /**
     *
     * @returns {Function}
     */

  }, {
    key: 'toFunction',
    value: function toFunction() {
      var model = this.model;
      var equations = this.model.equations;
      var equation = equations[1];
      var states = equation.states;
      var jsonString = JSON.stringify(this.toJSON());

      function matrixOrigin(m, stateIndex) {
        for (var i = 0, max = states.length; i < max; i++) {
          var state = states[i];

          if (i === stateIndex) {
            var j = previousConnectionIndex(m);
            switch (m) {
              case state.left:
                if (j > -1) {
                  return 'typeof prevStates[' + j + '] === \'object\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';
                }
              case state.right:
                if (j > -1) {
                  return 'typeof prevStates[' + j + '] === \'object\' ? prevStates[' + j + '].product : new Matrix(' + m.rows + ', ' + m.columns + ')';
                }
              case state.product:
                return 'new Matrix(' + m.rows + ', ' + m.columns + ')';
              default:
                throw Error('unknown state');
            }
          }

          if (m === state.product) return 'states[' + i + '].product';
          if (m === state.right) return 'states[' + i + '].right';
          if (m === state.left) return 'states[' + i + '].left';
        }
      }

      function previousConnectionIndex(m) {
        var connection = model.equationConnections[0];
        var states = equations[0].states;
        for (var i = 0, max = states.length; i < max; i++) {
          if (states[i].product === m) {
            return i;
          }
        }
        return connection.indexOf(m);
      }

      function matrixToString(m, stateIndex) {
        if (!m || !m.rows || !m.columns) return 'null';

        if (m === model.input) return 'json.input';
        if (m === model.outputConnector) return 'json.outputConnector';
        if (m === model.output) return 'json.output';

        for (var i = 0, max = model.hiddenLayers.length; i < max; i++) {
          var hiddenLayer = model.hiddenLayers[i];
          for (var p in hiddenLayer) {
            if (!hiddenLayer.hasOwnProperty(p)) continue;
            if (hiddenLayer[p] !== m) continue;
            return 'json.hiddenLayers[' + i + '].' + p;
          }
        }

        return matrixOrigin(m, stateIndex);
      }

      function toInner(fnString) {
        // crude, but should be sufficient for now
        // function() { body }
        fnString = fnString.toString().split('{');
        fnString.shift();
        // body }
        fnString = fnString.join('{');
        fnString = fnString.split('}');
        fnString.pop();
        // body
        return fnString.join('}').split('\n').join('\n        ').replace('product.deltas[i] = 0;', '').replace('product.deltas[column] = 0;', '').replace('left.deltas[leftIndex] = 0;', '').replace('right.deltas[rightIndex] = 0;', '').replace('product.deltas = left.deltas.slice(0);', '');
      }

      function fileName(fnName) {
        return 'src/recurrent/matrix/' + fnName.replace(/[A-Z]/g, function (value) {
          return '-' + value.toLowerCase();
        }) + '.js';
      }

      var statesRaw = [];
      var usedFunctionNames = {};
      var innerFunctionsSwitch = [];
      for (var i = 0, max = states.length; i < max; i++) {
        var state = states[i];
        statesRaw.push('states[' + i + '] = {\n      name: \'' + state.forwardFn.name + '\',\n      left: ' + matrixToString(state.left, i) + ',\n      right: ' + matrixToString(state.right, i) + ',\n      product: ' + matrixToString(state.product, i) + '\n    }');

        var fnName = state.forwardFn.name;
        if (!usedFunctionNames[fnName]) {
          usedFunctionNames[fnName] = true;
          innerFunctionsSwitch.push('        case \'' + fnName + '\': //compiled from ' + fileName(fnName) + '\n          ' + toInner(state.forwardFn.toString()) + '\n          break;');
        }
      }

      var src = '\n  if (typeof rawInput === \'undefined\') rawInput = [];\n  if (typeof isSampleI === \'undefined\') isSampleI = false;\n  if (typeof temperature === \'undefined\') temperature = 1;\n  ' + (this.dataFormatter ? this.dataFormatter.toFunctionString() : '') + '\n  \n  var input = ' + (this.dataFormatter && typeof this.formatDataIn === 'function' ? 'formatDataIn(rawInput)' : 'rawInput') + ';\n  var json = ' + jsonString + ';\n  var maxPredictionLength = input.length + ' + this.maxPredictionLength + ';\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = (_i === 0\n        ? 0\n        : _i < input.length\n          ? input[_i - 1] + 1\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    var state;\n    prevStates = states;\n    states = [];\n    ' + statesRaw.join(';\n    ') + ';\n    for (var stateIndex = 0, stateMax = ' + statesRaw.length + '; stateIndex < stateMax; stateIndex++) {\n      state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      \n      switch (state.name) {\n' + innerFunctionsSwitch.join('\n') + '\n      }\n    }\n    \n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n    \n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ' + (this.dataFormatter && typeof this.formatDataOut === 'function' ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))' : 'return output.slice(input.length).map(function(value) { return value - 1; })') + ';\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ' + (this.dataFormatter && typeof this.formatDataIn === 'function' ? 'function formatDataIn(input, output) { ' + toInner(this.formatDataIn.toString()).replace(/this[.]dataFormatter[\n\s]+[.]/g, '').replace(/this[.]dataFormatter[.]/g, '').replace(/this[.]dataFormatter/g, 'true') + ' }' : '') + '\n  ' + (this.dataFormatter !== null && typeof this.formatDataOut === 'function' ? 'function formatDataOut(input, output) { ' + toInner(this.formatDataOut.toString()).replace(/this[.]dataFormatter[\n\s]+[.]/g, '').replace(/this[.]dataFormatter[.]/g, '').replace(/this[.]dataFormatter/g, 'true') + ' }' : '') + '\n  ' + _zeros2.default.toString() + '\n  ' + _softmax2.default.toString().replace('_2.default', 'Matrix') + '\n  ' + _random.randomF.toString() + '\n  ' + _sampleI2.default.toString() + '\n  ' + _maxI2.default.toString();
      return new Function('rawInput', 'isSampleI', 'temperature', src);
    }
  }, {
    key: 'isRunnable',
    get: function get() {
      if (this.model.equations.length === 0) {
        console.error('No equations bound, did you run train()?');
        return false;
      }

      return true;
    }
  }]);

  return RNN;
}();

exports.default = RNN;


RNN.defaults = {
  inputSize: 20,
  inputRange: 20,
  hiddenLayers: [20, 20],
  outputSize: 20,
  decayRate: 0.999,
  smoothEps: 1e-8,
  regc: 0.000001,
  clipval: 5,
  maxPredictionLength: 100,
  /**
   *
   * @param {*[]} data
   * @returns {Number[]}
   */
  setupData: function setupData(data) {
    if (typeof data[0] !== 'string' && !Array.isArray(data[0]) && (!data[0].hasOwnProperty('input') || !data[0].hasOwnProperty('output'))) {
      return data;
    }
    var values = [];
    var result = [];
    if (typeof data[0] === 'string' || Array.isArray(data[0])) {
      if (!this.dataFormatter) {
        for (var i = 0; i < data.length; i++) {
          values.push(data[i]);
        }
        this.dataFormatter = new _dataFormatter2.default(values);
      }
      for (var _i = 0, max = data.length; _i < max; _i++) {
        result.push(this.formatDataIn(data[_i]));
      }
    } else {
      if (!this.dataFormatter) {
        for (var _i2 = 0; _i2 < data.length; _i2++) {
          values.push(data[_i2].input);
          values.push(data[_i2].output);
        }
        this.dataFormatter = _dataFormatter2.default.fromArrayInputOutput(values);
        this.dataFormatter.addUnrecognized();
      }
      for (var _i3 = 0, _max = data.length; _i3 < _max; _i3++) {
        result.push(this.formatDataIn(data[_i3].input, data[_i3].output));
      }
    }
    return result;
  },
  /**
   *
   * @param {*[]} input
   * @param {*[]} output
   * @returns {Number[]}
   */
  formatDataIn: function formatDataIn(input) {
    var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (this.dataFormatter) {
      if (this.dataFormatter.indexTable.hasOwnProperty('stop-input')) {
        return this.dataFormatter.toIndexesInputOutput(input, output);
      } else {
        return this.dataFormatter.toIndexes(input);
      }
    }
    return input;
  },
  /**
   *
   * @param {Number[]} input
   * @param {Number[]} output
   * @returns {*}
   */
  formatDataOut: function formatDataOut(input, output) {
    if (this.dataFormatter) {
      return this.dataFormatter.toCharacters(output).join('');
    }
    return output;
  },
  dataFormatter: null
};

RNN.trainDefaults = {
  iterations: 20000,
  errorThresh: 0.005,
  log: false,
  logPeriod: 10,
  learningRate: 0.01,
  callback: null,
  callbackPeriod: 10
};

},{"../neural-network":20,"../utilities/data-formatter":54,"../utilities/random":60,"../utilities/zeros":65,"./matrix":31,"./matrix/copy":29,"./matrix/equation":30,"./matrix/max-i":32,"./matrix/random-matrix":38,"./matrix/sample-i":43,"./matrix/softmax":46}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stream = require('stream');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 *
 * @param opts
 * @returns {TrainStream}
 * @constructor
 */
var TrainStream = function (_Writable) {
  _inherits(TrainStream, _Writable);

  function TrainStream(options) {
    _classCallCheck(this, TrainStream);

    var _this = _possibleConstructorReturn(this, (TrainStream.__proto__ || Object.getPrototypeOf(TrainStream)).call(this, {
      objectMode: true
    }));

    options = options || {};

    // require the neuralNetwork
    if (!options.neuralNetwork) {
      throw new Error('no neural network specified');
    }

    var _options = options,
        neuralNetwork = _options.neuralNetwork;

    _this.neuralNetwork = neuralNetwork;
    _this.dataFormatDetermined = false;
    _this.i = 0; // keep track of internal iterations
    _this.size = 0;
    _this.count = 0;
    _this.sum = 0;
    _this.floodCallback = options.floodCallback;
    _this.doneTrainingCallback = options.doneTrainingCallback;

    // inherit trainOpts settings from neuralNetwork
    neuralNetwork.updateTrainingOptions(options);
    var trainOpts = neuralNetwork.trainOpts;

    _this.iterations = trainOpts.iterations;
    _this.errorThresh = trainOpts.errorThresh;
    _this.log = trainOpts.log;
    _this.logPeriod = trainOpts.logPeriod;
    _this.callbackPeriod = trainOpts.callbackPeriod;
    _this.callback = trainOpts.callback;

    _this.on('finish', _this.finishStreamIteration.bind(_this));
    return _this;
  }

  _createClass(TrainStream, [{
    key: 'endInputs',
    value: function endInputs() {
      this.write(false);
    }

    /**
     * _write expects data to be in the form of a datum. ie. {input: {a: 1 b: 0}, output: {z: 0}}
     * @param chunk
     * @param enc
     * @param next
     * @returns {*}
     * @private
     */

  }, {
    key: '_write',
    value: function _write(chunk, enc, next) {
      if (!chunk) {
        // check for the end of one iteration of the stream
        this.emit('finish');
        return next();
      }

      if (!this.dataFormatDetermined) {
        this.size++;
        this.neuralNetwork.addFormat(chunk);
        this.firstDatum = this.firstDatum || chunk;
        return next();
      }

      this.count++;

      var data = this.neuralNetwork.formatData(chunk);
      this.sum += this.neuralNetwork.trainPattern(data[0], true);

      // tell the Readable Stream that we are ready for more data
      next();
    }

    /**
     *
     * @returns {*}
     */

  }, {
    key: 'finishStreamIteration',
    value: function finishStreamIteration() {
      if (this.dataFormatDetermined && this.size !== this.count) {
        this.log('This iteration\'s data length was different from the first.');
      }

      if (!this.dataFormatDetermined) {
        var data = this.neuralNetwork.formatData(this.firstDatum);
        this.neuralNetwork.verifyIsInitialized(data);
        this.dataFormatDetermined = true;

        if (typeof this.floodCallback === 'function') {
          this.floodCallback();
        }
        return;
      }

      var error = this.sum / this.size;

      if (this.log && this.i % this.logPeriod === 0) {
        this.log('iterations: ' + this.i + ', training error: ' + error);
      }
      if (this.callback && this.i % this.callbackPeriod === 0) {
        this.callback({
          error: error,
          iterations: this.i
        });
      }

      this.sum = 0;
      this.count = 0;
      // update the iterations
      this.i++;

      // do a check here to see if we need the stream again
      if (this.i < this.iterations && error > this.errorThresh) {
        if (typeof this.floodCallback === 'function') {
          return this.floodCallback();
        }
      } else {
        // done training
        if (typeof this.doneTrainingCallback === 'function') {
          return this.doneTrainingCallback({
            error: error,
            iterations: this.i
          });
        }
      }
    }
  }]);

  return TrainStream;
}(_stream.Writable);

exports.default = TrainStream;

},{"stream":133}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ArrayLookupTable;
function ArrayLookupTable(data, prop) {
  this.length = 0;
  this.prop = prop;
  var table = this.table = {};
  for (var i = 0; i < data.length; i++) {
    var datum = data[i];
    var input = datum[prop];
    for (var j = 0; j < input.length; j++) {
      for (var p in input[j]) {
        if (table.hasOwnProperty(p)) continue;
        table[p] = this.length++;
      }
    }
  }
};

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arraysToFloat32Arrays = arraysToFloat32Arrays;
exports.arrayToFloat32Arrays = arrayToFloat32Arrays;
exports.arrayToFloat32Array = arrayToFloat32Array;
exports.objectsToFloat32Arrays = objectsToFloat32Arrays;
exports.objectToFloat32Arrays = objectToFloat32Arrays;
exports.objectToFloat32Array = objectToFloat32Array;
function arraysToFloat32Arrays(arrays) {
  var result = [];
  for (var i = 0; i < arrays.length; i++) {
    result.push(Float32Array.from(arrays[i]));
  }
  return result;
}
function arrayToFloat32Arrays(array) {
  var result = [];
  for (var i = 0; i < array.length; i++) {
    result.push(Float32Array.from([array[i]]));
  }
  return result;
}
function arrayToFloat32Array(array) {
  return Float32Array.from(array);
}
function objectsToFloat32Arrays(objects, table, length) {
  var results = [];
  for (var i = 0; i < objects.length; i++) {
    var object = objects[i];
    var result = new Float32Array(length);
    for (var p in object) {
      if (object.hasOwnProperty(p)) {
        result[table[p]] = object[p];
      }
    }
    results.push(result);
  }
  return results;
}
function objectToFloat32Arrays(object) {
  var result = [];
  for (var p in object) {
    result.push(Float32Array.from([object[p]]));
  }
  return result;
}
function objectToFloat32Array(object, table, length) {
  var result = new Float32Array(length);
  for (var p in object) {
    if (object.hasOwnProperty(p)) {
      result[table[p]] = object[p];
    }
  }
  return result;
}

},{}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * @param {String[]|Number[]} values
 * @param maxThreshold
 * @constructor
 */
var DataFormatter = function () {
  function DataFormatter(values) {
    var maxThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    _classCallCheck(this, DataFormatter);

    if (values === undefined) return;

    this.values = values;
    // go over all characters and keep track of all unique ones seen
    // count up all characters
    this.indexTable = {};
    this.characterTable = {};
    this.characters = [];
    this.specialIndexes = [];
    this.buildCharactersFromIterable(values);
    this.buildTables(maxThreshold);
  }

  _createClass(DataFormatter, [{
    key: 'buildCharactersFromIterable',
    value: function buildCharactersFromIterable(values) {
      var tempCharactersTable = {};
      for (var dataFormatterIndex = 0, dataFormatterLength = values.length; dataFormatterIndex < dataFormatterLength; dataFormatterIndex++) {
        var characters = values[dataFormatterIndex];

        if (characters.hasOwnProperty('length')) {
          for (var characterIndex = 0, charactersLength = characters.length; characterIndex < charactersLength; characterIndex++) {
            var character = characters[characterIndex];
            if (tempCharactersTable.hasOwnProperty(character)) continue;
            tempCharactersTable[character] = true;
            this.characters.push(character);
          }
        } else {
          var _character = values[dataFormatterIndex];
          if (tempCharactersTable.hasOwnProperty(_character)) continue;
          tempCharactersTable[dataFormatterIndex] = true;
          this.characters.push(_character);
        }
      }
    }
  }, {
    key: 'buildTables',
    value: function buildTables(maxThreshold) {
      // filter by count threshold and create pointers
      var charactersLength = this.characters.length;
      for (var characterIndex = 0; characterIndex < charactersLength; characterIndex++) {
        var character = this.characters[characterIndex];
        if (characterIndex >= maxThreshold) {
          // add character to dataFormatter
          this.indexTable[character] = characterIndex;
          this.characterTable[characterIndex] = character;
        }
      }
    }
  }, {
    key: 'toIndexes',
    value: function toIndexes(value) {
      var maxThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var result = [];
      var indexTable = this.indexTable;

      for (var i = 0, max = value.length; i < max; i++) {
        var character = value[i];
        var index = indexTable[character];
        if (index === undefined) {
          if (indexTable['unrecognized']) {
            index = indexTable['unrecognized'];
          } else {
            throw new Error('unrecognized character "' + character + '"');
          }
        }
        if (index < maxThreshold) continue;
        result.push(index);
      }

      return result;
    }
  }, {
    key: 'toIndexesInputOutput',
    value: function toIndexesInputOutput(value1) {
      var value2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var maxThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var result = void 0;
      if (typeof value1 === 'string') {
        result = this.toIndexes(value1.split('').concat(['stop-input', 'start-output']), maxThreshold);
      } else {
        result = this.toIndexes(value1.concat(['stop-input', 'start-output']), maxThreshold);
      }

      if (value2 === null) return result;

      if (typeof value2 === 'string') {
        return result.concat(this.toIndexes(value2.split(''), maxThreshold));
      } else {
        return result.concat(this.toIndexes(value2, maxThreshold));
      }
    }
  }, {
    key: 'toCharacters',
    value: function toCharacters(indices) {
      var maxThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var result = [];
      var characterTable = this.characterTable;
      var indexTable = this.indexTable;

      for (var i = 0, max = indices.length; i < max; i++) {
        var index = indices[i];
        if (index < maxThreshold) continue;
        var character = characterTable[index];
        if (character === undefined) {
          if (indexTable['unrecognized']) {
            character = characterTable[indexTable['unrecognized']];
          } else {
            throw new Error('unrecognized index "' + index + '"');
          }
        } else if (character !== null) {
          result.push(character);
        }
      }

      return result;
    }
  }, {
    key: 'toString',
    value: function toString(indices, maxThreshold) {
      return this.toCharacters(indices, maxThreshold).join('');
    }
  }, {
    key: 'addInputOutput',
    value: function addInputOutput() {
      this.addSpecial('stop-input');
      this.addSpecial('start-output');
    }
  }, {
    key: 'addUnrecognized',
    value: function addUnrecognized() {
      this.addSpecial('unrecognized');
    }
  }, {
    key: 'addSpecial',
    value: function addSpecial(special) {
      var character = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var specialIndex = this.indexTable[special] = this.characters.length;
      this.characterTable[specialIndex] = character;
      this.specialIndexes.push(this.characters.length);
      this.characters.push(special);
    }
  }, {
    key: 'countSpecial',
    value: function countSpecial(output) {
      var sum = 0;
      for (var i = 0; i < this.specialIndexes; i++) {
        var index = -1;
        while (index = output.indexOf(this.specialIndexes[i], index) > -1) {
          sum++;
        }
      }
      return sum;
    }
  }, {
    key: 'toFunctionString',
    value: function toFunctionString() {
      return '\nvar characterTable = ' + JSON.stringify(this.characterTable) + ';\nvar indexTable = ' + JSON.stringify(this.indexTable) + ';\nvar characters = ' + JSON.stringify(this.characters) + ';\n' + this.toIndexes.toString().replace(/(let|var) indexTable = this[.]indexTable;\n/, '').replace(/this[.]/g, '') + '\n' + this.toIndexesInputOutput.toString().replace(/this[.]/g, '') + '\n' + this.toCharacters.toString().replace(/(let|var) characterTable = this[.]characterTable;\n/g, '').replace(/this[.]/, '') + '\n';
    }
  }], [{
    key: 'fromAllPrintable',
    value: function fromAllPrintable(maxThreshold) {
      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['\n'];

      for (var i = 32; i <= 126; i++) {
        values.push(String.fromCharCode(i));
      }
      return new DataFormatter(values, maxThreshold);
    }
  }, {
    key: 'fromAllPrintableInputOutput',
    value: function fromAllPrintableInputOutput(maxThreshold) {
      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['\n'];

      var dataFormatter = DataFormatter.fromAllPrintable(maxThreshold, values);
      dataFormatter.addInputOutput();
      return dataFormatter;
    }
  }, {
    key: 'fromStringInputOutput',
    value: function fromStringInputOutput(string, maxThreshold) {
      var _String$prototype;

      var values = (_String$prototype = String.prototype).concat.apply(_String$prototype, _toConsumableArray(new Set(string)));
      var dataFormatter = new DataFormatter(values, maxThreshold);
      dataFormatter.addInputOutput();
      return dataFormatter;
    }
  }, {
    key: 'fromArrayInputOutput',
    value: function fromArrayInputOutput(array, maxThreshold) {
      var dataFormatter = new DataFormatter(array.filter(function (v, i, a) {
        return a.indexOf(v) === i;
      }).sort(), maxThreshold);
      dataFormatter.addInputOutput();
      return dataFormatter;
    }
  }, {
    key: 'fromString',
    value: function fromString(string, maxThreshold) {
      var _String$prototype2;

      var values = (_String$prototype2 = String.prototype).concat.apply(_String$prototype2, _toConsumableArray(new Set(string)));
      return new DataFormatter(values, maxThreshold);
    }
  }, {
    key: 'fromJSON',
    value: function fromJSON(json) {
      var dataFormatter = new DataFormatter();
      dataFormatter.indexTable = json.indexTable;
      dataFormatter.characterTable = json.characterTable;
      dataFormatter.values = json.values;
      dataFormatter.characters = json.characters;
      dataFormatter.specialIndexes = json.specialIndexes;
      return dataFormatter;
    }
  }]);

  return DataFormatter;
}();

exports.default = DataFormatter;

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LookupTable;
function LookupTable(data, prop) {
  this.length = 0;
  if (prop) {
    this.prop = prop;
    var table = this.table = {};
    for (var i = 0; i < data.length; i++) {
      var datum = data[i];
      var object = datum[prop];
      for (var p in object) {
        if (table.hasOwnProperty(p)) continue;
        table[p] = this.length++;
      }
    }
  } else if (Array.isArray(data[0])) {
    var _table = this.table = {};
    for (var _i = 0; _i < data.length; _i++) {
      var array = data[_i];
      for (var j = 0; j < array.length; j++) {
        var _object = array[j];
        for (var _p in _object) {
          if (_table.hasOwnProperty(_p)) continue;
          _table[_p] = this.length++;
        }
      }
    }
  } else {
    var _table2 = this.table = {};
    for (var _i2 = 0; _i2 < data.length; _i2++) {
      var _object2 = data[_i2];
      for (var _p2 in _object2) {
        if (_table2.hasOwnProperty(_p2)) continue;
        _table2[_p2] = this.length++;
      }
    }
  }
};

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = max;

var _toArray = require('./to-array');

var _toArray2 = _interopRequireDefault(_toArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 *
 * @param values
 * @returns {number}
 */
function max(values) {
  return Math.max.apply(Math, (0, _toArray2.default)(values));
}

},{"./to-array":63}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mse;
function mse(errors) {
  // mean squared error
  var sum = 0;
  for (var i = 0; i < errors.length; i++) {
    sum += errors[i] * errors[i];
  }
  return sum / errors.length;
}

},{}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ones;
function ones(size) {
  if (typeof Float32Array !== 'undefined') return new Float32Array(size).fill(1);
  var array = new Array(size);
  for (var i = 0; i < size; i++) {
    array[i] = 1;
  }
  return array;
}

},{}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = randomWeight;
function randomWeight() {
  return Math.random() * 0.4 - 0.2;
}

},{}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomF = randomF;
exports.randomI = randomI;
exports.randomN = randomN;
function randomF(a, b) {
  return Math.random() * (b - a) + a;
}

function randomI(a, b) {
  return Math.floor(Math.random() * (b - a) + a);
}

function randomN(mu, std) {
  return mu + gaussRandom() * std;
}

// Random numbers utils
function gaussRandom() {
  if (gaussRandom.returnV) {
    gaussRandom.returnV = false;
    return gaussRandom.vVal;
  }
  var u = 2 * Math.random() - 1;
  var v = 2 * Math.random() - 1;
  var r = u * u + v * v;
  if (r == 0 || r > 1) {
    return gaussRandom();
  }
  var c = Math.sqrt(-2 * Math.log(r) / r);
  gaussRandom.vVal = v * c; // cache this
  gaussRandom.returnV = true;
  return u * c;
}
gaussRandom.returnV = false;
gaussRandom.vVal = 0;

},{}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = randos;

var _randomWeight = require('./random-weight');

var _randomWeight2 = _interopRequireDefault(_randomWeight);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function randos(size) {
  var array = new Float32Array(size);
  for (var i = 0; i < size; i++) {
    array[i] = (0, _randomWeight2.default)();
  }
  return array;
}

},{"./random-weight":59}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = range;
/**
 *
 * @param start
 * @param end
 * @returns {Array}
 */
function range(start, end) {
  var result = [];
  for (; start < end; start++) {
    result.push(start);
  }
  return result;
}

},{}],63:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toArray;
/**
 *
 * @param values
 * @returns {*}
 */
function toArray(values) {
  if (Array.isArray(values)) {
    return values;
  } else {
    var keys = Object.keys(values);
    var result = new Float32Array(keys.length);
    for (var i in keys) {
      result[i] = values[keys[i]];
    }
    return result;
  }
}

},{}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toSVG;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function toSVG(network, options) {
    //default values
    var defaultOptions = {
        line: {
            width: '0.5',
            color: 'black'
        },
        inputs: {
            color: 'rgba(0, 128, 0, 0.5)',
            label: false
        },
        outputs: {
            color: 'rgba(100, 149, 237, 0.5)'
        },
        hidden: {
            color: 'rgba(255, 127, 80, 0.5)'
        },
        fontSize: '14px',
        radius: '8',
        width: '400',
        height: '250'
    };

    var size = typeof network.inputSize == 'number' && typeof network.outputSize == 'number' && network.inputSize > 0 && network.outputSize > 0 ? [network.inputSize].concat(_toConsumableArray(network.hiddenLayers), [network.outputSize]) : false;
    options = Object.assign(defaultOptions, options);
    options.inputs.label = options.inputs.label.length == network.inputSize ? options.inputs.label : false;
    if (size) {
        var svg = '<svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="' + options.width + '" height="' + options.height + '">';
        var sh = options.width / size.length;
        size.forEach(function (neuronsNu, i) {
            var sv = options.height / neuronsNu;
            [].concat(_toConsumableArray(Array(neuronsNu))).forEach(function (_, j) {
                if (i == 0) {
                    svg += '<rect x="' + (sh / 2 - options.radius) + '" y="' + (sv / 2 + j * sv - options.radius) + '" width="' + 2 * options.radius + '" height="' + 2 * options.radius + '" stroke="black" stroke-width="1" fill="' + options.inputs.color + '" />';
                    svg += '<line x1="' + sh / 4 + '" y1="' + (sv / 2 + j * sv) + '" x2="' + (sh / 2 - options.radius) + '" y2="' + (sv / 2 + j * sv) + '" style="stroke:' + options.line.color + ';stroke-width:' + options.line.width + '" />';
                    if (options.inputs.label) {
                        svg += '<text x="' + sh / 8 + '" y="' + (sv / 2 + j * sv - 5) + '" fill="black" font-size= "' + options.fontSize + '">' + options.inputs.label[j] + '</text>';
                    }
                } else {
                    var sv_1 = options.height / size[i - 1];
                    if (i == size.length - 1) {
                        svg += '<circle cx="' + (sh / 2 + i * sh) + '" cy="' + (sv / 2 + j * sv) + '" r="' + options.radius + '" stroke="black" stroke-width="1" fill="' + options.outputs.color + '" />';
                        svg += '<line x1="' + (sh / 2 + i * sh + options.radius) + '" y1="' + (sv / 2 + j * sv) + '" x2="' + (sh / 2 + i * sh + sh / 4) + '" y2="' + (sv / 2 + j * sv) + '" style="stroke:' + options.line.color + ';stroke-width:' + options.line.width + '" />';
                    } else {
                        svg += '<circle cx="' + (sh / 2 + i * sh) + '" cy="' + (sv / 2 + j * sv) + '" r="' + options.radius + '" stroke="black" stroke-width="1" fill="' + options.hidden.color + '" />';
                    }
                    for (var k = 0; k < size[i - 1]; k++) {
                        svg += '<line x1="' + (sh / 2 + (i - 1) * sh + options.radius) + '" y1="' + (sv_1 / 2 + k * sv_1) + '" x2="' + (sh / 2 + i * sh - options.radius) + '" y2="' + (sv / 2 + j * sv) + '" style="stroke:' + options.line.color + ';stroke-width:' + options.line.width + '" />';
                    }
                }
            });
        });
        svg += '</svg>';
        return svg;
    } else {
        return false;
    }
}

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = zeros;
function zeros(size) {
  return new Float32Array(size);
}

},{}],66:[function(require,module,exports){
var CrossValidate = require('./dist/cross-validate').default;
var likely = require('./dist/likely').default;
var lookup = require('./dist/lookup').default;
var NeuralNetwork = require('./dist/neural-network').default;
var NeuralNetworkGPU = require('./dist/neural-network-gpu').default;
var TrainStream = require('./dist/train-stream').default;
var RNNTimeStep = require('./dist/recurrent/rnn-time-step').default;
var LSTMTimeStep = require('./dist/recurrent/lstm-time-step').default;
var GRUTimeStep = require('./dist/recurrent/gru-time-step').default;
var RNN = require('./dist/recurrent/rnn').default;
var LSTM = require('./dist/recurrent/lstm').default;
var GRU = require('./dist/recurrent/gru').default;
var utilities = {
  max: require('./dist/utilities/max').default,
  mse: require('./dist/utilities/mse').default,
  ones: require('./dist/utilities/ones').default,
  random: require('./dist/utilities/random').default,
  randomWeight: require('./dist/utilities/random-weight').default,
  randos: require('./dist/utilities/randos').default,
  range: require('./dist/utilities/range').default,
  toArray: require('./dist/utilities/to-array').default,
  DataFormatter: require('./dist/utilities/data-formatter').default,
  zeros: require('./dist/utilities/zeros').default,
  toSVG: require('./dist/utilities/to-svg').default
};

var brain = {
  CrossValidate: CrossValidate,
  likely: likely,
  lookup: lookup,
  NeuralNetwork: NeuralNetwork,
  NeuralNetworkGPU: NeuralNetworkGPU,
  TrainStream: TrainStream,
  recurrent: {
    RNNTimeStep: RNNTimeStep,
    LSTMTimeStep: LSTMTimeStep,
    GRUTimeStep: GRUTimeStep,
    RNN: RNN,
    LSTM: LSTM,
    GRU: GRU,
  },
  utilities: utilities
};

if (typeof window !== 'undefined') {
  window.brain = brain;
}
if (typeof self !== 'undefined') {
  self.brain = brain;
}
if (typeof module !== 'undefined') {
  module.exports = brain;
}

},{"./dist/cross-validate":16,"./dist/likely":17,"./dist/lookup":18,"./dist/neural-network":20,"./dist/neural-network-gpu":19,"./dist/recurrent/gru":22,"./dist/recurrent/gru-time-step":21,"./dist/recurrent/lstm":24,"./dist/recurrent/lstm-time-step":23,"./dist/recurrent/rnn":50,"./dist/recurrent/rnn-time-step":49,"./dist/train-stream":51,"./dist/utilities/data-formatter":54,"./dist/utilities/max":56,"./dist/utilities/mse":57,"./dist/utilities/ones":58,"./dist/utilities/random":60,"./dist/utilities/random-weight":59,"./dist/utilities/randos":61,"./dist/utilities/range":62,"./dist/utilities/to-array":63,"./dist/utilities/to-svg":64,"./dist/utilities/zeros":65}],67:[function(require,module,exports){
(function (global){
(function() {
    var root = this;
    var EventEmitter = require('events').EventEmitter;
	var _ = require('underscore');
	var intervalParser = /([0-9\.]+)(ms|s|m|h)?/;
	var root = global || window;

	// Lil bit of useful polyfill...
	if (typeof(Function.prototype.inherits) === 'undefined') {
		Function.prototype.inherits = function(parent) {
			this.prototype = Object.create(parent.prototype);
		};
	}

	if (typeof(Array.prototype.removeOne) === 'undefined') {
		Array.prototype.removeOne = function() {
			var what, a = arguments, L = a.length, ax;
			while (L && this.length) {
				what = a[--L];
				while ((ax = this.indexOf(what)) !== -1) {
					return this.splice(ax, 1);
				}
			}
		};
	}

	function greatestCommonFactor(intervals) {
		var sumOfModuli = 1;
		var interval = _.min(intervals);
		while (sumOfModuli !== 0) {
			sumOfModuli = _.reduce(intervals, function(memo, i){ return memo + (i % interval); }, 0);
			if (sumOfModuli !== 0) {
				interval -= 10;
			}
		}
		return interval;
	}

	function parseEvent(e) {
		var intervalGroups = intervalParser.exec(e);
		if (!intervalGroups) {
			throw new Error('I don\'t understand that particular interval');
		}
		var intervalAmount = +intervalGroups[1];
		var intervalType = intervalGroups[2] || 'ms';
		if (intervalType === 's') {
			intervalAmount = intervalAmount * 1000;
		} else if (intervalType === 'm') {
			intervalAmount = intervalAmount * 1000 * 60;
		} else if (intervalType === 'h') {
			intervalAmount = intervalAmount * 1000 * 60 * 60;
		} else if (!!intervalType && intervalType !== 'ms') {
			throw new Error('You can only specify intervals of ms, s, m, or h');
		}
		if (intervalAmount < 10 || intervalAmount % 10 !== 0) {
			// We only deal in 10's of milliseconds for simplicity
			throw new Error('You can only specify 10s of milliseconds, trust me on this one');
		}
		return {
			amount:intervalAmount,
			type:intervalType
		};
	}

	function EventedLoop() {
		this.intervalId = undefined;
		this.intervalLength = undefined;
		this.intervalsToEmit = {};
		this.currentTick = 1;
		this.maxTicks = 0;
		this.listeningForFocus = false;

		// Private method
		var determineIntervalLength = function () {
			var potentialIntervalLength = greatestCommonFactor(_.keys(this.intervalsToEmit));
			var changed = false;

			if (this.intervalLength) {
				if (potentialIntervalLength !== this.intervalLength) {
					// Looks like we need a new interval
					this.intervalLength = potentialIntervalLength;
					changed = true;
				}
			} else {
				this.intervalLength = potentialIntervalLength;
			}

			this.maxTicks = _.max(_.map(_.keys(this.intervalsToEmit), function(a) { return +a; })) / this.intervalLength;
			return changed;
		}.bind(this);

		this.on('newListener', function (e) {
			if (e === 'removeListener' || e === 'newListener') return; // We don't care about that one
			var intervalInfo = parseEvent(e);
			var intervalAmount = intervalInfo.amount;

			this.intervalsToEmit[+intervalAmount] = _.union(this.intervalsToEmit[+intervalAmount] || [], [e]);
			
			if (determineIntervalLength() && this.isStarted()) {
				this.stop().start();
			}
		});

		this.on('removeListener', function (e) {
			if (EventEmitter.listenerCount(this, e) > 0) return;
			var intervalInfo = parseEvent(e);
			var intervalAmount = intervalInfo.amount;

			var removedEvent = this.intervalsToEmit[+intervalAmount].removeOne(e);
			if (this.intervalsToEmit[+intervalAmount].length === 0) {
				delete this.intervalsToEmit[+intervalAmount];
			}
			console.log('Determining interval length after removal of', removedEvent);
			determineIntervalLength();

			if (determineIntervalLength() && this.isStarted()) {
				this.stop().start();
			}
		});
	}

	EventedLoop.inherits(EventEmitter);

	// Public methods
	EventedLoop.prototype.tick = function () {
		var milliseconds = this.currentTick * this.intervalLength;
		_.each(this.intervalsToEmit, function (events, key) {
			if (milliseconds % key === 0) {
				_.each(events, function(e) { this.emit(e, e, key); }.bind(this));
			}
		}.bind(this));
		this.currentTick += 1;
		if (this.currentTick > this.maxTicks) {
			this.currentTick = 1;
		}
		return this;
	};

	EventedLoop.prototype.start = function () {
		if (!this.intervalLength) {
			throw new Error('You haven\'t specified any interval callbacks. Use EventedLoop.on(\'500ms\', function () { ... }) to do so, and then you can start');
		}
		if (this.intervalId) {
			return console.log('No need to start the loop again, it\'s already started.');
		}

		this.intervalId = setInterval(this.tick.bind(this), this.intervalLength);

		if (root && !this.listeningForFocus && root.addEventListener) {
			root.addEventListener('focus', function() {
				this.start();
			}.bind(this));

			root.addEventListener('blur', function() {
				this.stop();
			}.bind(this));

			this.listeningForFocus = true;
		}
		return this;
	};

	EventedLoop.prototype.stop = function () {
		clearInterval(this.intervalId);
		this.intervalId = undefined;
		return this;
	};

	EventedLoop.prototype.isStarted = function () {
		return !!this.intervalId;
	};

	EventedLoop.prototype.every = EventedLoop.prototype.on;

    // Export the EventedLoop object for **Node.js** or other
    // commonjs systems. Otherwise, add it as a global object to the root
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = EventedLoop;
        }
        exports.EventedLoop = EventedLoop;
    }
    if (typeof window !== 'undefined') {
        window.EventedLoop = EventedLoop;
    }
}).call(this);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"events":111,"underscore":68}],68:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],69:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FunctionBuilderBase = require('../function-builder-base');
var CPUFunctionNode = require('./function-node');

/**
 * @class CPUFunctionBuilder
 *
 * @extends FunctionBuilderBase
 *
 * @desc Builds functions to execute on CPU from JavaScript function Strings
 *
 */
module.exports = function (_FunctionBuilderBase) {
  _inherits(CPUFunctionBuilder, _FunctionBuilderBase);

  function CPUFunctionBuilder() {
    _classCallCheck(this, CPUFunctionBuilder);

    var _this = _possibleConstructorReturn(this, (CPUFunctionBuilder.__proto__ || Object.getPrototypeOf(CPUFunctionBuilder)).call(this));

    _this.Node = CPUFunctionNode;
    return _this;
  }

  return CPUFunctionBuilder;
}(FunctionBuilderBase);
},{"../function-builder-base":74,"./function-node":70}],70:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseFunctionNode = require('../function-node-base');
var utils = require('../../core/utils');

/**
 * @class CPUFunctionNode
 *
 * @extends BaseFunctionNode#
 *
 * @desc [INTERNAL] Represents a single function, inside JS
 *
 * <p>This handles all the raw state, converted state, etc. Of a single function.</p>
 *
 * @prop functionName         - {String}        Name of the function
 * @prop jsFunction           - {Function}   The JS Function the node represents
 * @prop jsFunctionString     - {String}        jsFunction.toString()
 * @prop paramNames           - {String[]}  Parameter names of the function
 * @prop paramTypes           - {String[]}  Shader land parameters type assumption
 * @prop isRootKernel         - {Boolean}       Special indicator, for kernel function
 * @prop webglFunctionString  - {String}        webgl converted function string
 * @prop openglFunctionString - {String}        opengl converted function string
 * @prop calledFunctions      - {String[]}  List of all the functions called
 * @prop initVariables        - {String[]}  List of variables initialized in the function
 * @prop readVariables        - {String[]}  List of variables read operations occur
 * @prop writeVariables       - {String[]}  List of variables write operations occur
 *
 */
module.exports = function (_BaseFunctionNode) {
	_inherits(CPUFunctionNode, _BaseFunctionNode);

	function CPUFunctionNode(functionName, jsFunction, options) {
		_classCallCheck(this, CPUFunctionNode);

		var _this = _possibleConstructorReturn(this, (CPUFunctionNode.__proto__ || Object.getPrototypeOf(CPUFunctionNode)).call(this, functionName, jsFunction, options));

		_this.paramSizes = options ? options.paramSizes : [];
		_this.memberStates = [];
		return _this;
	}

	_createClass(CPUFunctionNode, [{
		key: 'pushMemberState',
		value: function pushMemberState(name) {
			this.memberStates.push(name);
		}
	}, {
		key: 'popMemberState',
		value: function popMemberState(name) {
			if (this.memberState === name) {
				this.memberStates.pop();
			} else {
				throw new Error('Cannot popMemberState ' + name + ' when in ' + this.memberState);
			}
		}
	}, {
		key: 'generate',
		value: function generate() {
			if (this.debug) {
				console.log(this);
			}
			this.functionStringArray = this.astGeneric(this.getJsAST(), []);
			this.functionString = this.functionStringArray.join('').trim();
			return this.functionString;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name getFunctionPrototypeString
   *
   * @desc Returns the converted JS function
   *
   * @returns {String} function string, result is cached under this.getFunctionPrototypeString
   *
   */

	}, {
		key: 'getFunctionPrototypeString',
		value: function getFunctionPrototypeString() {
			if (this.webGlFunctionPrototypeString) {
				return this.webGlFunctionPrototypeString;
			}
			return this.webGlFunctionPrototypeString = this.generate();
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astFunctionDeclaration
   *
   * @desc Parses the abstract syntax tree for to its *named function declaration*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astFunctionDeclaration',
		value: function astFunctionDeclaration(ast, retArr) {
			this.builder.addFunction(null, utils.getAstString(this.jsFunctionString, ast));
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astFunctionPrototype
   *
   * @desc Parses the abstract syntax tree for to its *named function prototype*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astFunctionPrototype',
		value: function astFunctionPrototype(ast, retArr) {
			// Setup function return type and name
			if (this.isRootKernel || this.isSubKernel) {
				return retArr;
			}

			retArr.push(this.returnType);
			retArr.push(' ');
			retArr.push(this.functionName);
			retArr.push('(');

			// Arguments handling
			for (var i = 0; i < this.paramNames.length; ++i) {
				if (i > 0) {
					retArr.push(', ');
				}
				retArr.push('user_');
				retArr.push(this.paramNames[i]);
			}

			retArr.push(');\n');

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astFunctionExpression
   *
   * @desc Parses the abstract syntax tree for to its *named function*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astFunctionExpression',
		value: function astFunctionExpression(ast, retArr) {

			// Setup function return type and name
			if (!this.isRootKernel) {
				retArr.push('function');
				retArr.push(' ');
				retArr.push(this.functionName);
				retArr.push('(');

				// Arguments handling
				for (var i = 0; i < this.paramNames.length; ++i) {
					var paramName = this.paramNames[i];

					if (i > 0) {
						retArr.push(', ');
					}
					retArr.push('user_');
					retArr.push(paramName);
				}

				// Function opening
				retArr.push(') {\n');
			}

			// Body statement iteration
			for (var _i = 0; _i < ast.body.body.length; ++_i) {
				this.astGeneric(ast.body.body[_i], retArr);
				retArr.push('\n');
			}

			if (!this.isRootKernel) {
				// Function closing
				retArr.push('}\n');
			}
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astReturnStatement
   *
   * @desc Parses the abstract syntax tree for to *return* statement
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astReturnStatement',
		value: function astReturnStatement(ast, retArr) {
			if (this.isRootKernel) {
				retArr.push('kernelResult = ');
				this.astGeneric(ast.argument, retArr);
				retArr.push(';');
			} else if (this.isSubKernel) {
				retArr.push(this.functionName + 'Result = ');
				this.astGeneric(ast.argument, retArr);
				retArr.push(';');
				retArr.push('return ' + this.functionName + 'Result;');
			} else {
				retArr.push('return ');
				this.astGeneric(ast.argument, retArr);
				retArr.push(';');
			}

			//throw this.astErrorOutput(
			//	'Non main function return, is not supported : '+this.currentFunctionNamespace,
			//	ast
			//);

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astLiteral
   *
   * @desc Parses the abstract syntax tree for *literal value*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astLiteral',
		value: function astLiteral(ast, retArr) {

			// Reject non numeric literals
			if (isNaN(ast.value)) {
				throw this.astErrorOutput('Non-numeric literal not supported : ' + ast.value, ast);
			}

			retArr.push(ast.value);

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astBinaryExpression
   *
   * @desc Parses the abstract syntax tree for *binary* expression
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astBinaryExpression',
		value: function astBinaryExpression(ast, retArr) {
			retArr.push('(');
			this.astGeneric(ast.left, retArr);
			retArr.push(ast.operator);
			this.astGeneric(ast.right, retArr);
			retArr.push(')');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astIdentifierExpression
   *
   * @desc Parses the abstract syntax tree for *identifier* expression
   *
   * @param {Object} idtNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astIdentifierExpression',
		value: function astIdentifierExpression(idtNode, retArr) {
			if (idtNode.type !== 'Identifier') {
				throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
			}

			switch (this.state) {
				case 'input-index-y':
				case 'input-index-z':
					retArr.push('(');
			}

			switch (idtNode.name) {
				case 'gpu_threadX':
					retArr.push('threadId.x');
					break;
				case 'gpu_threadY':
					retArr.push('threadId.y');
					break;
				case 'gpu_threadZ':
					retArr.push('threadId.z');
					break;
				case 'gpu_outputX':
					retArr.push('uOutputDim.x');
					break;
				case 'gpu_outputY':
					retArr.push('uOutputDim.y');
					break;
				case 'gpu_outputZ':
					retArr.push('uOutputDim.z');
					break;
				case 'Infinity':
					retArr.push('Infinity');
					break;
				default:
					if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
						retArr.push('constants_' + idtNode.name);
					} else {
						var userParamName = this.getUserParamName(idtNode.name);
						if (userParamName !== null) {
							retArr.push('user_' + userParamName);
						} else {
							retArr.push('user_' + idtNode.name);
						}
					}
			}

			switch (this.state) {
				case 'input-index-y':
					{
						var size = this.paramSizes[this.paramNames.indexOf(this.memberState)];
						retArr.push(' * ' + size[0] + ')');
						break;
					}
				case 'input-index-z':
					{
						var _size = this.paramSizes[this.paramNames.indexOf(this.memberState)];
						retArr.push(' * ' + _size[0] * _size[1] + ')');
						break;
					}
			}

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astForStatement
   *
   * @desc Parses the abstract syntax tree forfor *for-loop* expression
   *
   * @param {Object} forNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed cpu string
   */

	}, {
		key: 'astForStatement',
		value: function astForStatement(forNode, retArr) {
			if (forNode.type !== 'ForStatement') {
				throw this.astErrorOutput('Invalid for statement', forNode);
			}

			if (forNode.test && forNode.test.type === 'BinaryExpression') {
				if ((forNode.test.right.type === 'Identifier' || forNode.test.right.type === 'Literal') && forNode.test.operator === '<' && this.isIdentifierConstant(forNode.test.right.name) === false) {

					if (!this.loopMaxIterations) {
						console.warn('Warning: loopMaxIterations is not set! Using default of 1000 which may result in unintended behavior.');
						console.warn('Set loopMaxIterations or use a for loop of fixed length to silence this message.');
					}

					retArr.push('for (');
					this.astGeneric(forNode.init, retArr);
					if (retArr[retArr.length - 1] !== ';') {
						retArr.push(';');
					}
					this.astGeneric(forNode.test.left, retArr);
					retArr.push(forNode.test.operator);
					retArr.push('LOOP_MAX');
					retArr.push(';');
					this.astGeneric(forNode.update, retArr);
					retArr.push(')');

					retArr.push('{\n');
					retArr.push('if (');
					this.astGeneric(forNode.test.left, retArr);
					retArr.push(forNode.test.operator);
					this.astGeneric(forNode.test.right, retArr);
					retArr.push(') {\n');
					if (forNode.body.type === 'BlockStatement') {
						for (var i = 0; i < forNode.body.body.length; i++) {
							this.astGeneric(forNode.body.body[i], retArr);
						}
					} else {
						this.astGeneric(forNode.body, retArr);
					}
					retArr.push('} else {\n');
					retArr.push('break;\n');
					retArr.push('}\n');
					retArr.push('}\n');

					return retArr;
				} else if (forNode.init.declarations) {
					var declarations = JSON.parse(JSON.stringify(forNode.init.declarations));
					var updateArgument = forNode.update.argument;
					if (!Array.isArray(declarations) || declarations.length < 1) {
						console.log(this.jsFunctionString);
						throw new Error('Error: Incompatible for loop declaration');
					}

					if (declarations.length > 1) {
						var initArgument = null;
						for (var _i2 = 0; _i2 < declarations.length; _i2++) {
							var declaration = declarations[_i2];
							if (declaration.id.name === updateArgument.name) {
								initArgument = declaration;
								declarations.splice(_i2, 1);
							} else {
								retArr.push('var ');
								this.astGeneric(declaration, retArr);
								retArr.push(';');
							}
						}

						retArr.push('for (let ');
						this.astGeneric(initArgument, retArr);
						retArr.push(';');
					} else {
						retArr.push('for (');
						this.astGeneric(forNode.init, retArr);
					}

					this.astGeneric(forNode.test, retArr);
					retArr.push(';');
					this.astGeneric(forNode.update, retArr);
					retArr.push(')');
					this.astGeneric(forNode.body, retArr);
					return retArr;
				}
			}

			throw this.astErrorOutput('Invalid for statement', forNode);
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astWhileStatement
   *
   * @desc Parses the abstract syntax tree for *while* loop
   *
   *
   * @param {Object} whileNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed openclgl string
   */

	}, {
		key: 'astWhileStatement',
		value: function astWhileStatement(whileNode, retArr) {
			if (whileNode.type !== 'WhileStatement') {
				throw this.astErrorOutput('Invalid while statement', whileNode);
			}

			retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
			retArr.push('if (');
			this.astGeneric(whileNode.test, retArr);
			retArr.push(') {\n');
			this.astGeneric(whileNode.body, retArr);
			retArr.push('} else {\n');
			retArr.push('break;\n');
			retArr.push('}\n');
			retArr.push('}\n');

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astWhileStatement
   *
   * @desc Parses the abstract syntax tree for *do while* loop
   *
   *
   * @param {Object} doWhileNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed webgl string
   */

	}, {
		key: 'astDoWhileStatement',
		value: function astDoWhileStatement(doWhileNode, retArr) {
			if (doWhileNode.type !== 'DoWhileStatement') {
				throw this.astErrorOutput('Invalid while statement', doWhileNode);
			}

			retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
			this.astGeneric(doWhileNode.body, retArr);
			retArr.push('if (!');
			this.astGeneric(doWhileNode.test, retArr);
			retArr.push(') {\n');
			retArr.push('break;\n');
			retArr.push('}\n');
			retArr.push('}\n');

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astAssignmentExpression
   *
   * @desc Parses the abstract syntax tree for *Assignment* Expression
   *
   * @param {Object} assNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astAssignmentExpression',
		value: function astAssignmentExpression(assNode, retArr) {
			this.astGeneric(assNode.left, retArr);
			retArr.push(assNode.operator);
			this.astGeneric(assNode.right, retArr);
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astEmptyStatement
   *
   * @desc Parses the abstract syntax tree for an *Empty* Statement
   *
   * @param {Object} eNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astEmptyStatement',
		value: function astEmptyStatement(eNode, retArr) {
			//retArr.push(';\n');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astBlockStatement
   *
   * @desc Parses the abstract syntax tree for *Block* statement
   *
   * @param {Object} bNode - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astBlockStatement',
		value: function astBlockStatement(bNode, retArr) {
			retArr.push('{\n');
			for (var i = 0; i < bNode.body.length; i++) {
				this.astGeneric(bNode.body[i], retArr);
			}
			retArr.push('}\n');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astExpressionStatement
   *
   * @desc Parses the abstract syntax tree for *generic expression* statement
   *
   * @param {Object} esNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astExpressionStatement',
		value: function astExpressionStatement(esNode, retArr) {
			this.astGeneric(esNode.expression, retArr);
			retArr.push(';');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astVariableDeclaration
   *
   * @desc Parses the abstract syntax tree for *Variable Declaration*
   *
   * @param {Object} vardecNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astVariableDeclaration',
		value: function astVariableDeclaration(vardecNode, retArr) {
			retArr.push('var ');
			for (var i = 0; i < vardecNode.declarations.length; i++) {
				this.declarations[vardecNode.declarations[i].id.name] = 'var';
				if (i > 0) {
					retArr.push(',');
				}
				this.astGeneric(vardecNode.declarations[i], retArr);
			}
			retArr.push(';');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astVariableDeclarator
   *
   * @desc Parses the abstract syntax tree for *Variable Declarator*
   *
   * @param {Object} ivardecNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astVariableDeclarator',
		value: function astVariableDeclarator(ivardecNode, retArr) {
			this.astGeneric(ivardecNode.id, retArr);
			if (ivardecNode.init !== null) {
				retArr.push('=');
				this.astGeneric(ivardecNode.init, retArr);
			}
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astIfStatement
   *
   * @desc Parses the abstract syntax tree for *If* Statement
   *
   * @param {Object} ifNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astIfStatement',
		value: function astIfStatement(ifNode, retArr) {
			retArr.push('if (');
			this.astGeneric(ifNode.test, retArr);
			retArr.push(')');
			if (ifNode.consequent.type === 'BlockStatement') {
				this.astGeneric(ifNode.consequent, retArr);
			} else {
				retArr.push(' {\n');
				this.astGeneric(ifNode.consequent, retArr);
				retArr.push('\n}\n');
			}

			if (ifNode.alternate) {
				retArr.push('else ');
				if (ifNode.alternate.type === 'BlockStatement') {
					this.astGeneric(ifNode.alternate, retArr);
				} else {
					retArr.push(' {\n');
					this.astGeneric(ifNode.alternate, retArr);
					retArr.push('\n}\n');
				}
			}
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astBreakStatement
   *
   * @desc Parses the abstract syntax tree for *Break* Statement
   *
   * @param {Object} brNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astBreakStatement',
		value: function astBreakStatement(brNode, retArr) {
			retArr.push('break;\n');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astContinueStatement
   *
   * @desc Parses the abstract syntax tree for *Continue* Statement
   *
   * @param {Object} crNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astContinueStatement',
		value: function astContinueStatement(crNode, retArr) {
			retArr.push('continue;\n');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astLogicalExpression
   *
   * @desc Parses the abstract syntax tree for *Logical* Expression
   *
   * @param {Object} logNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astLogicalExpression',
		value: function astLogicalExpression(logNode, retArr) {
			retArr.push('(');
			this.astGeneric(logNode.left, retArr);
			retArr.push(logNode.operator);
			this.astGeneric(logNode.right, retArr);
			retArr.push(')');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astUpdateExpression
   *
   * @desc Parses the abstract syntax tree for *Update* Expression
   *
   * @param {Object} uNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astUpdateExpression',
		value: function astUpdateExpression(uNode, retArr) {
			if (uNode.prefix) {
				retArr.push(uNode.operator);
				this.astGeneric(uNode.argument, retArr);
			} else {
				this.astGeneric(uNode.argument, retArr);
				retArr.push(uNode.operator);
			}

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astUnaryExpression
   *
   * @desc Parses the abstract syntax tree for *Unary* Expression
   *
   * @param {Object} uNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astUnaryExpression',
		value: function astUnaryExpression(uNode, retArr) {
			if (uNode.prefix) {
				retArr.push(uNode.operator);
				this.astGeneric(uNode.argument, retArr);
			} else {
				this.astGeneric(uNode.argument, retArr);
				retArr.push(uNode.operator);
			}

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astThisExpression
   *
   * @desc Parses the abstract syntax tree for *This* expression
   *
   * @param {Object} tNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astThisExpression',
		value: function astThisExpression(tNode, retArr) {
			retArr.push('_this');
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astMemberExpression
   *
   * @desc Parses the abstract syntax tree for *Member* Expression
   *
   * @param {Object} mNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astMemberExpression',
		value: function astMemberExpression(mNode, retArr) {
			if (mNode.computed) {
				if (mNode.object.type === 'Identifier' || mNode.object.type === 'MemberExpression' && mNode.object.object.object && mNode.object.object.object.type === 'ThisExpression' && mNode.object.object.property.name === 'constants') {
					this.pushState('identifier');
					this.astGeneric(mNode.object, retArr);
					this.popState('identifier');
					retArr.push('[');
					if (this.isInput(mNode.object.name)) {
						this.astGeneric(mNode.property, retArr);
					} else {
						this.astGeneric(mNode.property, retArr);
					}
					retArr.push(']');
				} else {
					if (mNode.object.object) {
						if (mNode.object.object.object && this.isInput(mNode.object.object.object.name)) {
							this.pushMemberState(mNode.object.object.object.name);
							this.pushState('input-index-z');
							this.astGeneric(mNode.object, retArr);
							var last = retArr.pop();
							retArr.push(' + ');
							this.popState('input-index-z');
							this.pushState('input-index');
							this.astGeneric(mNode.property, retArr);
							this.popState('input-index');
							retArr.push(last);
							this.popMemberState(mNode.object.object.object.name);
						} else if (this.isInput(mNode.object.object.name)) {
							this.pushMemberState(mNode.object.object.name);
							if (!this.isState('input-index-z')) {
								this.pushState('input-index-y');
							}
							this.astGeneric(mNode.object, retArr);
							var _last = retArr.pop();
							retArr.push(' + ');
							if (!this.isState('input-index-z')) {
								this.popState('input-index-y');
							}

							var isInputIndexZ = this.isState('input-index-z');
							if (isInputIndexZ) {
								this.pushState('input-index-y');
							} else {
								this.pushState('input-index');
							}
							this.astGeneric(mNode.property, retArr);
							if (isInputIndexZ) {
								this.popState('input-index-y');
							} else {
								this.popState('input-index');
							}
							retArr.push(_last);
							this.popMemberState(mNode.object.object.name);
						} else {
							this.astGeneric(mNode.object, retArr);
							var _last2 = retArr.pop();
							retArr.push('][');
							this.astGeneric(mNode.property, retArr);
							retArr.push(_last2);
						}
					} else {
						this.astGeneric(mNode.object, retArr);
						var _last3 = retArr.pop();
						retArr.push('][');
						this.astGeneric(mNode.property, retArr);
						retArr.push(_last3);
					}
				}
			} else {
				var unrolled = this.astMemberExpressionUnroll(mNode);
				if (mNode.property.type === 'Identifier' && mNode.computed) {
					unrolled = 'user_' + unrolled;
				}

				if (unrolled.indexOf('this.constants') === 0) {
					// remove 'this.constants' from beginning
					unrolled = 'constants_' + unrolled.substring(15);
				} else if (unrolled.indexOf('this') === 0) {
					// Its a reference to `this`, add '_' before
					unrolled = '_' + unrolled;
				}

				switch (this.state) {
					case 'input-index-y':
					case 'input-index-z':
						retArr.push('(');
				}

				switch (unrolled) {
					case '_this.output.x':
						retArr.push(this.output[0]);
						break;
					case '_this.output.y':
						retArr.push(this.output[1]);
						break;
					case '_this.output.z':
						retArr.push(this.output[2]);
						break;
					default:
						if (mNode.object && mNode.object.name && this.declarations[mNode.object.name]) {
							retArr.push('user_');
						}
						retArr.push(unrolled);
				}

				switch (this.state) {
					case 'input-index-y':
						{
							var size = this.paramSizes[this.paramNames.indexOf(this.memberState)];
							retArr.push(' * ' + size[0] + ')');
							break;
						}
					case 'input-index-z':
						{
							var _size2 = this.paramSizes[this.paramNames.indexOf(this.memberState)];
							retArr.push(' * ' + _size2[0] * _size2[1] + ')');
							break;
						}
				}
			}
			return retArr;
		}
	}, {
		key: 'astSequenceExpression',
		value: function astSequenceExpression(sNode, retArr) {
			for (var i = 0; i < sNode.expressions.length; i++) {
				if (i > 0) {
					retArr.push(',');
				}
				this.astGeneric(sNode.expressions, retArr);
			}
			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astCallExpression
   *
   * @desc Parses the abstract syntax tree for *call* expression
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns  {Array} the append retArr
   */

	}, {
		key: 'astCallExpression',
		value: function astCallExpression(ast, retArr) {
			if (ast.callee) {
				// Get the full function call, unrolled
				var funcName = this.astMemberExpressionUnroll(ast.callee);

				// Register the function into the called registry
				if (this.calledFunctions.indexOf(funcName) < 0) {
					this.calledFunctions.push(funcName);
				}
				if (!this.hasOwnProperty('funcName')) {
					this.calledFunctionsArguments[funcName] = [];
				}

				var functionArguments = [];
				this.calledFunctionsArguments[funcName].push(functionArguments);

				// Call the function
				retArr.push(funcName);

				// Open arguments space
				retArr.push('(');

				// Add the vars
				for (var i = 0; i < ast.arguments.length; ++i) {
					var argument = ast.arguments[i];
					if (i > 0) {
						retArr.push(', ');
					}
					this.astGeneric(argument, retArr);
					if (argument.type === 'Identifier') {
						var paramIndex = this.paramNames.indexOf(argument.name);
						if (paramIndex === -1) {
							functionArguments.push(null);
						} else {
							functionArguments.push({
								name: argument.name,
								type: this.paramTypes[paramIndex]
							});
						}
					} else {
						functionArguments.push(null);
					}
				}

				// Close arguments space
				retArr.push(')');

				return retArr;
			}

			// Failure, unknown expression
			throw this.astErrorOutput('Unknown CallExpression', ast);

			return retArr;
		}

		/**
   * @memberOf CPUFunctionNode#
   * @function
   * @name astArrayExpression
   *
   * @desc Parses the abstract syntax tree for *Array* Expression
   *
   * @param {Object} arrNode - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astArrayExpression',
		value: function astArrayExpression(arrNode, retArr) {
			var arrLen = arrNode.elements.length;

			retArr.push('[');
			for (var i = 0; i < arrLen; ++i) {
				if (i > 0) {
					retArr.push(', ');
				}
				var subNode = arrNode.elements[i];
				this.astGeneric(subNode, retArr);
			}
			retArr.push(']');

			return retArr;

			// // Failure, unknown expression
			// throw this.astErrorOutput(
			// 	'Unknown  ArrayExpression',
			// 	arrNode
			//);
		}
	}, {
		key: 'astDebuggerStatement',
		value: function astDebuggerStatement(arrNode, retArr) {
			retArr.push('debugger;');
			return retArr;
		}
	}, {
		key: 'memberState',
		get: function get() {
			return this.memberStates[this.memberStates.length - 1];
		}
	}]);

	return CPUFunctionNode;
}(BaseFunctionNode);
},{"../../core/utils":100,"../function-node-base":75}],71:[function(require,module,exports){
'use strict';

var utils = require('../../core/utils');
var kernelRunShortcut = require('../kernel-run-shortcut');

function removeFnNoise(fn) {
  if (/^function /.test(fn)) {
    fn = fn.substring(9);
  }
  return fn.replace(/[_]typeof/g, 'typeof');
}

function removeNoise(str) {
  return str.replace(/[_]typeof/g, 'typeof');
}

module.exports = function (cpuKernel, name) {
  return '() => {\n    ' + kernelRunShortcut.toString() + ';\n    const utils = {\n      allPropertiesOf: ' + removeNoise(utils.allPropertiesOf.toString()) + ',\n      clone: ' + removeNoise(utils.clone.toString()) + ',\n      checkOutput: ' + removeNoise(utils.checkOutput.toString()) + '\n    };\n    const Utils = utils;\n    let Input = function() {};\n    class ' + (name || 'Kernel') + ' {\n      constructor() {        \n        this.argumentsLength = 0;\n        this._canvas = null;\n        this._webGl = null;\n        this.built = false;\n        this.program = null;\n        this.paramNames = ' + JSON.stringify(cpuKernel.paramNames) + ';\n        this.paramTypes = ' + JSON.stringify(cpuKernel.paramTypes) + ';\n        this.texSize = ' + JSON.stringify(cpuKernel.texSize) + ';\n        this.output = ' + JSON.stringify(cpuKernel.output) + ';\n        this._kernelString = `' + cpuKernel._kernelString + '`;\n        this.output = ' + JSON.stringify(cpuKernel.output) + ';\n\t\t    this.run = function() {\n          this.run = null;\n          this.build();\n          return this.run.apply(this, arguments);\n        }.bind(this);\n        this.thread = {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n      setCanvas(canvas) { this._canvas = canvas; return this; }\n      setWebGl(webGl) { this._webGl = webGl; return this; }\n      setInput(Type) { Input = Type; }\n      ' + removeFnNoise(cpuKernel.build.toString()) + '\n      ' + removeFnNoise(cpuKernel.setupParams.toString()) + '\n      ' + removeFnNoise(cpuKernel.setupConstants.toString()) + '\n      run () { ' + cpuKernel.kernelString + ' }\n      getKernelString() { return this._kernelString; }\n      ' + removeFnNoise(cpuKernel.validateOptions.toString()) + '\n    };\n    return kernelRunShortcut(new Kernel());\n  };';
};
},{"../../core/utils":100,"../kernel-run-shortcut":77}],72:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KernelBase = require('../kernel-base');
var utils = require('../../core/utils');
var kernelString = require('./kernel-string');

module.exports = function (_KernelBase) {
	_inherits(CPUKernel, _KernelBase);

	/**
  * @constructor CPUKernel
  *
  * @desc Kernel Implementation for CPU.
  *
  * <p>Instantiates properties to the CPU Kernel.</p>
  *
  * @extends KernelBase
  *
  * @prop {Object} thread - The thread dimensions, x, y and z
  * @prop {Object} output - The canvas dimensions
  * @prop {Object} functionBuilder - Function Builder instance bound to this Kernel
  * @prop {Function} run - Method to run the kernel
  *
  */
	function CPUKernel(fnString, settings) {
		_classCallCheck(this, CPUKernel);

		var _this = _possibleConstructorReturn(this, (CPUKernel.__proto__ || Object.getPrototypeOf(CPUKernel)).call(this, fnString, settings));

		_this._fn = null;
		_this.run = null;
		_this._canvasCtx = null;
		_this._imageData = null;
		_this._colorData = null;
		_this._kernelString = null;
		_this.thread = {
			x: 0,
			y: 0,
			z: 0
		};

		_this.run = function () {
			this.run = null;
			this.build.apply(this, arguments);
			return this.run.apply(this, arguments);
		}.bind(_this);
		return _this;
	}

	/**
  * @memberOf CPUKernel#
  * @function
  * @name validateOptions
  *
  * @desc Validate options related to CPU Kernel, such as
  * dimensions size, and auto dimension support.
  *
  */


	_createClass(CPUKernel, [{
		key: 'validateOptions',
		value: function validateOptions() {
			if (!this.output || this.output.length === 0) {
				if (arguments.length !== 1) {
					throw 'Auto dimensions only supported for kernels with only one input';
				}

				var argType = utils.getArgumentType(arguments[0]);
				if (argType === 'Array') {
					this.output = utils.getDimensions(argType);
				} else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
					this.output = arguments[0].output;
				} else {
					throw 'Auto dimensions not supported for input type: ' + argType;
				}
			}

			utils.checkOutput(this.output);
		}

		/**
   * @memberOf CPUKernel#
   * @function
   * @name build
   *
   * @desc Builds the Kernel, by generating the kernel
   * string using thread dimensions, and arguments
   * supplied to the kernel.
   *
   * <p>If the graphical flag is enabled, canvas is used.</p>
   *
   */

	}, {
		key: 'build',
		value: function build() {
			this.setupConstants();
			this.setupParams(arguments);
			this.validateOptions();
			var canvas = this._canvas;
			if (canvas) {
				// if node or canvas is not found, don't die
				this._canvasCtx = canvas.getContext('2d');
			}
			var threadDim = this.threadDim = utils.clone(this.output);

			while (threadDim.length < 3) {
				threadDim.push(1);
			}

			if (this.graphical) {
				var _canvas = this._canvas;
				if (!_canvas) {
					throw new Error('no canvas available for using graphical output');
				}
				_canvas.width = threadDim[0];
				_canvas.height = threadDim[1];
				this._imageData = this._canvasCtx.createImageData(threadDim[0], threadDim[1]);
				this._colorData = new Uint8ClampedArray(threadDim[0] * threadDim[1] * 4);
			}

			var kernelString = this.getKernelString();

			if (this.debug) {
				console.log('Options:');
				console.dir(this);
				console.log('Function output:');
				console.log(kernelString);
			}

			this.kernelString = kernelString;
			this.run = new Function([], kernelString).bind(this)();
		}
	}, {
		key: 'color',
		value: function color(r, g, b, a) {
			if (typeof a === 'undefined') {
				a = 1;
			}

			r = Math.floor(r * 255);
			g = Math.floor(g * 255);
			b = Math.floor(b * 255);
			a = Math.floor(a * 255);

			var width = this.output[0];
			var height = this.output[1];

			var x = this.thread.x;
			var y = height - this.thread.y - 1;

			var index = x + y * width;

			this._colorData[index * 4 + 0] = r;
			this._colorData[index * 4 + 1] = g;
			this._colorData[index * 4 + 2] = b;
			this._colorData[index * 4 + 3] = a;
		}

		/**
   * @memberOf CPUKernel#
   * @function
   * @name getKernelString
   *
   * @desc Generates kernel string for this kernel program.
   *
   * <p>If sub-kernels are supplied, they are also factored in.
   * This string can be saved by calling the `toString` method
   * and then can be reused later.</p>
   *
   * @returns {String} result
   *
   */

	}, {
		key: 'getKernelString',
		value: function getKernelString() {
			if (this._kernelString !== null) return this._kernelString;

			var builder = this.functionBuilder;

			// Thread dim fix (to make compilable)
			var threadDim = this.threadDim || (this.threadDim = utils.clone(this.output));
			while (threadDim.length < 3) {
				threadDim.push(1);
			}

			builder.addKernel(this.fnString, {
				prototypeOnly: false,
				constants: this.constants,
				output: threadDim,
				debug: this.debug,
				loopMaxIterations: this.loopMaxIterations,
				paramNames: this.paramNames,
				paramTypes: this.paramTypes,
				paramSizes: this.paramSizes,
				constantTypes: this.constantTypes
			});

			builder.addFunctions(this.functions, {
				constants: this.constants,
				output: threadDim
			});

			builder.addNativeFunctions(this.nativeFunctions);

			if (this.subKernels !== null) {
				this.subKernelOutputTextures = [];
				this.subKernelOutputVariableNames = [];
				for (var i = 0; i < this.subKernels.length; i++) {
					var subKernel = this.subKernels[i];
					builder.addSubKernel(subKernel, {
						prototypeOnly: false,
						constants: this.constants,
						output: this.output,
						debug: this.debug,
						loopMaxIterations: this.loopMaxIterations
					});
					this.subKernelOutputVariableNames.push(subKernel.name + 'Result');
				}
			} else if (this.subKernelProperties !== null) {
				this.subKernelOutputVariableNames = [];
				var _i = 0;
				for (var p in this.subKernelProperties) {
					if (!this.subKernelProperties.hasOwnProperty(p)) continue;
					var _subKernel = this.subKernelProperties[p];
					builder.addSubKernel(_subKernel);
					this.subKernelOutputVariableNames.push(_subKernel.name + 'Result');
					_i++;
				}
			}

			var prototypes = builder.getPrototypes('kernel');
			var kernel = null;
			if (prototypes.length > 1) {
				prototypes = prototypes.filter(function (fn) {
					if (/^function/.test(fn)) return fn;
					kernel = fn;
					return false;
				});
			} else {
				kernel = prototypes.shift();
			}
			var kernelString = this._kernelString = '\n\t\tvar LOOP_MAX = ' + this._getLoopMaxString() + '\n\t\tvar constants = this.constants;\n\t\tvar _this = this;\n    return function (' + this.paramNames.map(function (paramName) {
				return 'user_' + paramName;
			}).join(', ') + ') {\n      ' + this._processConstants() + '\n      ' + this._processParams() + '\n      ' + this._kernelLoop(kernel) + '\n      if (this.graphical) {\n        this._imageData.data.set(this._colorData);\n        this._canvasCtx.putImageData(this._imageData, 0, 0);\n        return;\n      }\n      ' + this._kernelOutput() + '\n      ' + (prototypes.length > 0 ? prototypes.join('\n') : '') + '\n    }.bind(this);';
			return kernelString;
		}

		/**
   * @memberOf CPUKernel#
   * @function
   * @name toString
   *
   * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
   *
   */

	}, {
		key: 'toString',
		value: function toString() {
			return kernelString(this);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getLoopMaxString
   *
   * @desc Get the maximum loop size String.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getLoopMaxString',
		value: function _getLoopMaxString() {
			return this.loopMaxIterations ? ' ' + parseInt(this.loopMaxIterations) + ';\n' : ' 1000;\n';
		}
	}, {
		key: '_processConstants',
		value: function _processConstants() {
			if (!this.constants) return '';

			var result = [];
			for (var p in this.constants) {
				var type = this.constantTypes[p];
				switch (type) {
					case 'HTMLImage':
						result.push('  var constants_' + p + ' = this._imageTo2DArray(this.constants.' + p + ')');
						break;
					case 'HTMLImageArray':
						result.push('  var constants_' + p + ' = this._imageTo3DArray(this.constants.' + p + ')');
						break;
					case 'Input':
						result.push('  var constants_' + p + ' = this.constants.' + p + '.value');
						break;
					default:
						result.push('  var constants_' + p + ' = this.constants.' + p);
				}
			}
			return result.join('\n');
		}
	}, {
		key: '_processParams',
		value: function _processParams() {
			var result = [];
			for (var i = 0; i < this.paramTypes.length; i++) {
				switch (this.paramTypes[i]) {
					case 'HTMLImage':
						result.push('  user_' + this.paramNames[i] + ' = this._imageTo2DArray(user_' + this.paramNames[i] + ')');
						break;
					case 'HTMLImageArray':
						result.push('  user_' + this.paramNames[i] + ' = this._imageTo3DArray(user_' + this.paramNames[i] + ')');
						break;
					case 'Input':
						result.push('  user_' + this.paramNames[i] + ' = user_' + this.paramNames[i] + '.value');
						break;
				}
			}
			return result.join(';\n');
		}
	}, {
		key: '_imageTo2DArray',
		value: function _imageTo2DArray(image) {
			var canvas = this._canvas;
			if (canvas.width < image.width) {
				canvas.width = image.width;
			}
			if (canvas.height < image.height) {
				canvas.height = image.height;
			}
			var ctx = this._canvasCtx;
			ctx.drawImage(image, 0, 0, image.width, image.height);
			var pixelsData = ctx.getImageData(0, 0, image.width, image.height).data;
			var imageArray = new Array(image.height);
			var index = 0;
			for (var y = image.height - 1; y >= 0; y--) {
				imageArray[y] = new Array(image.width);
				for (var x = 0; x < image.width; x++) {
					var r = pixelsData[index++] / 255;
					var g = pixelsData[index++] / 255;
					var b = pixelsData[index++] / 255;
					var a = pixelsData[index++] / 255;
					var result = [r, g, b, a];
					result.r = r;
					result.g = g;
					result.b = b;
					result.a = a;
					imageArray[y][x] = result;
				}
			}
			return imageArray;
		}
	}, {
		key: '_imageTo3DArray',
		value: function _imageTo3DArray(images) {
			var imagesArray = new Array(images.length);
			for (var i = 0; i < images.length; i++) {
				imagesArray[i] = this._imageTo2DArray(images[i]);
			}
			return imagesArray;
		}
	}, {
		key: '_kernelLoop',
		value: function _kernelLoop(kernelString) {
			switch (this.output.length) {
				case 1:
					return this._kernel1DLoop(kernelString);
				case 2:
					return this._kernel2DLoop(kernelString);
				case 3:
					return this._kernel3DLoop(kernelString);
				default:
					throw new Error('unsupported size kernel');
			}
		}
	}, {
		key: '_kernel1DLoop',
		value: function _kernel1DLoop(kernelString) {
			var threadDim = this.threadDim;
			return '\n    var result = new Float32Array(' + threadDim[0] + ');\n    ' + this._mapSubKernels(function (name) {
				return 'var result_' + name + ' = new Float32Array(' + threadDim[0] + ');\n';
			}).join('') + '\n    for (var x = 0; x < ' + threadDim[0] + '; x++) {\n      this.thread.x = x;\n      this.thread.y = 0;\n      this.thread.z = 0;\n      var kernelResult;\n      ' + kernelString + '\n      result[x] = kernelResult;\n      ' + this._mapSubKernels(function (name) {
				return 'result_' + name + '[x] = ' + name + ';\n';
			}).join('') + '\n    }';
		}
	}, {
		key: '_kernel2DLoop',
		value: function _kernel2DLoop(kernelString) {
			var threadDim = this.threadDim;
			return '\n    var result = new Array(' + threadDim[1] + ');\n    ' + this._mapSubKernels(function (name) {
				return 'var result_' + name + ' = new Array(' + threadDim[1] + ');\n';
			}).join('') + '\n    for (var y = 0; y < ' + threadDim[1] + '; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      var resultX = result[y] = new Float32Array(' + threadDim[0] + ');\n      ' + this._mapSubKernels(function (name) {
				return 'var result_' + name + 'X = result_' + name + '[y] = new Float32Array(' + threadDim[0] + ');\n';
			}).join('') + '\n      for (var x = 0; x < ' + threadDim[0] + '; x++) {\n      \tthis.thread.x = x;\n        var kernelResult;\n        ' + kernelString + '\n        resultX[x] = kernelResult;\n        ' + this._mapSubKernels(function (name) {
				return 'result_' + name + 'X[x] = ' + name + ';\n';
			}).join('') + '\n      }\n    }';
		}
	}, {
		key: '_kernel3DLoop',
		value: function _kernel3DLoop(kernelString) {
			var threadDim = this.threadDim;
			return '\n    var result = new Array(' + threadDim[2] + ');\n    ' + this._mapSubKernels(function (name) {
				return 'var result_' + name + ' = new Array(' + threadDim[2] + ');\n';
			}).join('') + '\n    for (var z = 0; z < ' + threadDim[2] + '; z++) {\n      this.thread.z = z;\n      var resultY = result[z] = new Array(' + threadDim[1] + ');\n      ' + this._mapSubKernels(function (name) {
				return 'var result_' + name + 'Y = result_' + name + '[z] = new Array(' + threadDim[1] + ');\n';
			}).join('') + '\n      for (var y = 0; y < ' + threadDim[1] + '; y++) {\n        this.thread.y = y;\n        var resultX = resultY[y] = new Float32Array(' + threadDim[0] + ');\n        ' + this._mapSubKernels(function (name) {
				return 'var result_' + name + 'X = result_' + name + 'Y[y] = new Float32Array(' + threadDim[0] + ');\n';
			}).join('') + '\n        for (var x = 0; x < ' + threadDim[0] + '; x++) {\n        \tthis.thread.x = x;\n          var kernelResult;\n          ' + kernelString + '\n          resultX[x] = kernelResult;\n          ' + this._mapSubKernels(function (name) {
				return 'result_' + name + 'X[x] = ' + name + ';\n';
			}).join('') + '\n        }\n      }\n    }';
		}
	}, {
		key: '_kernelOutput',
		value: function _kernelOutput() {
			var _this2 = this;

			if (!this.subKernelOutputVariableNames) {
				return 'return result;';
			}
			return 'return {\n      result: result,\n      ' + Object.keys(this.subKernelProperties || this.subKernelOutputVariableNames).map(function (name, i) {
				return name + ': result_' + _this2.subKernelOutputVariableNames[i];
			}).join(',\n') + '\n    };';
		}
	}, {
		key: '_mapSubKernels',
		value: function _mapSubKernels(fn) {
			return this.subKernelOutputVariableNames === null ? [''] : this.subKernelOutputVariableNames.map(fn);
		}
	}]);

	return CPUKernel;
}(KernelBase);
},{"../../core/utils":100,"../kernel-base":76,"./kernel-string":71}],73:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var utils = require('../../core/utils');
var RunnerBase = require('../runner-base');
var CPUKernel = require('./kernel');
var CPUFunctionBuilder = require('./function-builder');

module.exports = function (_RunnerBase) {
	_inherits(CPURunner, _RunnerBase);

	/**
  * @constructor CPURunner
  *
  * @desc Instantiates a Runner instance for the kernel.
  * 
  * @extends RunnerBase
  *
  * @param {Object} settings - Settings to instantiate properties in RunnerBase, with given values
  *
  */

	function CPURunner(settings) {
		_classCallCheck(this, CPURunner);

		var _this = _possibleConstructorReturn(this, (CPURunner.__proto__ || Object.getPrototypeOf(CPURunner)).call(this, new CPUFunctionBuilder(), settings));

		_this.Kernel = CPUKernel;
		_this.kernel = null;
		return _this;
	}

	/**
  * @memberOf CPURunner#
  * @function
  * @name getMode()
  *
  * Return the current mode in which gpu.js is executing.
  * 
  * @returns {String} The current mode; "cpu".
  *
  */


	_createClass(CPURunner, [{
		key: 'getMode',
		value: function getMode() {
			return 'cpu';
		}
	}]);

	return CPURunner;
}(RunnerBase);
},{"../../core/utils":100,"../runner-base":78,"./function-builder":69,"./kernel":72}],74:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {

	/**
  * @constructor FunctionBuilderBase
  *
  * @desc This handles all the raw state, converted state, etc. of a single function.
  * [INTERNAL] A collection of functionNodes.
  * 
  * @prop {Object} nodeMap - Object map, where nodeMap[function] = new FunctionNode;
  * @prop {Object} gpu - The current gpu instance bound to this builder
  * @prop {Object} rootKernel - The root kernel object, contains the paramNames, dimensions etc.
  * 
  */
	function FunctionBuilderBase(gpu) {
		_classCallCheck(this, FunctionBuilderBase);

		this.nodeMap = {};
		this.nativeFunctions = {};
		this.gpu = gpu;
		this.rootKernel = null;
		this.Node = null;
	}

	_createClass(FunctionBuilderBase, [{
		key: 'addNativeFunction',
		value: function addNativeFunction(functionName, glslFunctionString) {
			this.nativeFunctions[functionName] = glslFunctionString;
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name addFunction
   *
   * @desc Instantiates a FunctionNode, and add it to the nodeMap
   *
   * @param {String} functionName - Function name to assume, if its null, it attempts to extract from the function
   * @param {Function} jsFunction - JS Function to do conversion
   * @param {Object} [options]
   *
   */

	}, {
		key: 'addFunction',
		value: function addFunction(functionName, jsFunction, options) {
			this.addFunctionNode(new this.Node(functionName, jsFunction, options).setBuilder(this));
		}
	}, {
		key: 'addFunctions',
		value: function addFunctions(functions, options) {
			if (functions) {
				if (Array.isArray(functions)) {
					for (var i = 0; i < functions.length; i++) {
						this.addFunction(null, functions[i], options);
					}
				} else {
					for (var p in functions) {
						this.addFunction(p, functions[p], options);
					}
				}
			}
		}
	}, {
		key: 'addNativeFunctions',
		value: function addNativeFunctions(nativeFunctions) {
			for (var functionName in nativeFunctions) {
				if (!nativeFunctions.hasOwnProperty(functionName)) continue;
				this.addNativeFunction(functionName, nativeFunctions[functionName]);
			}
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name addFunctionNode
   *
   * @desc Add the function node directly
   *
   * @param {functionNode} inNode - functionNode to add
   *
   */

	}, {
		key: 'addFunctionNode',
		value: function addFunctionNode(inNode) {
			this.nodeMap[inNode.functionName] = inNode;
			if (inNode.isRootKernel) {
				this.rootKernel = inNode;
			}
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name traceFunctionCalls
   *
   * @desc Trace all the depending functions being called, from a single function
   *
   * This allow for 'unneeded' functions to be automatically optimized out.
   * Note that the 0-index, is the starting function trace.
   *
   * @param {String} functionName - Function name to trace from, default to 'kernel'
   * @param {String[]} retList - Returning list of function names that is traced. Including itself.
   * @param {Object} [parent] - Parent node
   *
   * @returns {String[]}  Returning list of function names that is traced. Including itself.
   */

	}, {
		key: 'traceFunctionCalls',
		value: function traceFunctionCalls(functionName, retList, parent) {
			functionName = functionName || 'kernel';
			retList = retList || [];

			var fNode = this.nodeMap[functionName];
			if (fNode) {
				// Check if function already exists
				var functionIndex = retList.indexOf(functionName);
				if (functionIndex === -1) {
					retList.push(functionName);
					if (parent) {
						fNode.parent = parent;
					}
					fNode.getFunctionString(); //ensure JS trace is done
					for (var i = 0; i < fNode.calledFunctions.length; ++i) {
						this.traceFunctionCalls(fNode.calledFunctions[i], retList, fNode);
					}
				} else {
					/**
      * https://github.com/gpujs/gpu.js/issues/207
      * if dependent function is already in the list, because a function depends on it, and because it has
      * already been traced, we know that we must move the dependent function to the end of the the retList.
      * */
					var dependantFunctionName = retList.splice(functionIndex, 1)[0];
					retList.push(dependantFunctionName);
				}
			}

			if (this.nativeFunctions[functionName]) {
				if (retList.indexOf(functionName) >= 0) {
					// Does nothing if already traced
				} else {
					retList.push(functionName);
				}
			}

			return retList;
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name addKernel
   *
   * @desc Add a new kernel to this instance
   *
   * @param {String} fnString - Kernel function as a String
   * @param {Object} options - Settings object to set constants, debug mode, etc.
   *
   *
   * @returns {Object} The inserted kernel as a Kernel Node
   *
   */

	}, {
		key: 'addKernel',
		value: function addKernel(fnString, options) {
			var kernelNode = new this.Node('kernel', fnString, options);
			kernelNode.setBuilder(this);
			kernelNode.isRootKernel = true;
			this.addFunctionNode(kernelNode);
			return kernelNode;
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name addSubKernel
   *
   * @desc Add a new sub-kernel to the current kernel instance
   *
   * @param {Function} jsFunction - Sub-kernel function (JavaScript)
   * @param {Object} options - Settings object to set constants, debug mode, etc.
   *
   * @returns {Object} The inserted sub-kernel as a Kernel Node
   *
   */

	}, {
		key: 'addSubKernel',
		value: function addSubKernel(jsFunction, options) {
			var kernelNode = new this.Node(null, jsFunction, options);
			kernelNode.setBuilder(this);
			kernelNode.isSubKernel = true;
			this.addFunctionNode(kernelNode);
			return kernelNode;
		}

		/**
   * @memberOf CPUFunctionBuilder#
   * @name getPrototypeString
   * @function
   *
   * @desc Return the string for a function
   *
   * @param {String} functionName - Function name to trace from. If null, it returns the WHOLE builder stack
   *
   * @returns {String} The full string, of all the various functions. Trace optimized if functionName given
   *
   */

	}, {
		key: 'getPrototypeString',
		value: function getPrototypeString(functionName) {
			return this.getPrototypes(functionName).join('\n');
		}

		/**
   * @memberOf CPUFunctionBuilder#
   * @name getPrototypeString
   * @function
   *
   * @desc Return the string for a function
   *
   * @param {String} [functionName] - Function name to trace from. If null, it returns the WHOLE builder stack
   *
   * @returns {Array} The full string, of all the various functions. Trace optimized if functionName given
   *
   */

	}, {
		key: 'getPrototypes',
		value: function getPrototypes(functionName) {
			this.rootKernel.generate();
			if (functionName) {
				return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
			}
			return this.getPrototypesFromFunctionNames(Object.keys(this.nodeMap));
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name getStringFromFunctionNames
   *
   * @desc Get string from function names
   *
   * @param {String[]} functionList - List of function to build string
   *
   * @returns {String} The string, of all the various functions. Trace optimized if functionName given
   *
   */

	}, {
		key: 'getStringFromFunctionNames',
		value: function getStringFromFunctionNames(functionList) {
			var ret = [];
			for (var i = 0; i < functionList.length; ++i) {
				var node = this.nodeMap[functionList[i]];
				if (node) {
					ret.push(this.nodeMap[functionList[i]].getFunctionString());
				}
			}
			return ret.join('\n');
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name getPrototypeStringFromFunctionNames
   *
   * @desc Return string of all functions converted
   *
   * @param {String[]} functionList - List of function names to build the string.
   * @param {Object} [opt - Settings object passed to functionNode. See functionNode for more details.
   *
   * @returns {Array} Prototypes of all functions converted
   *
   */

	}, {
		key: 'getPrototypesFromFunctionNames',
		value: function getPrototypesFromFunctionNames(functionList, opt) {
			var ret = [];
			for (var i = 0; i < functionList.length; ++i) {
				var functionName = functionList[i];
				var node = this.nodeMap[functionName];
				if (node) {
					ret.push(node.getFunctionPrototypeString(opt));
				} else if (this.nativeFunctions[functionName]) {
					ret.push(this.nativeFunctions[functionName]);
				}
			}
			return ret;
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name getPrototypeStringFromFunctionNames
   *
   * @desc Return string of all functions converted
   *
   * @param {String[]} functionList - List of function names to build the string.
   * @param {Object} opt - Settings object passed to functionNode. See functionNode for more details.
   *
   * @returns {String} Prototype string of all functions converted
   *
   */

	}, {
		key: 'getPrototypeStringFromFunctionNames',
		value: function getPrototypeStringFromFunctionNames(functionList, opt) {
			return this.getPrototypesFromFunctionNames(functionList, opt).toString();
		}

		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name getString
   *
   * Get string for a particular function name
   *
   * @param {String} functionName - Function name to trace from. If null, it returns the WHOLE builder stack
   *
   * @returns {String} The string, of all the various functions. Trace optimized if functionName given
   *
   */

	}, {
		key: 'getString',
		value: function getString(functionName, opt) {
			if (opt === undefined) {
				opt = {};
			}

			if (functionName) {
				return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName, [], opt).reverse(), opt);
			}
			return this.getStringFromFunctionNames(Object.keys(this.nodeMap), opt);
		}
	}]);

	return FunctionBuilderBase;
}();
},{}],75:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var utils = require('../core/utils');
var acorn = require('acorn');

module.exports = function () {

	/**
  * @constructor FunctionNodeBase
  * 
  * @desc Represents a single function, inside JS, webGL, or openGL.
  * 
  * <p>This handles all the raw state, converted state, etc. Of a single function.</p>
  * 
  * @prop {String} functionName - Name of the function
  * @prop {Function} jsFunction - The JS Function the node represents
  * @prop {String} jsFunctionString - jsFunction.toString()
  * @prop {String[]} paramNames - Parameter names of the function
  * @prop {String[]} paramTypes - Shader land parameters type assumption
  * @prop {Boolean} isRootKernel - Special indicator, for kernel function
  * @prop {String} webglFunctionString - webgl converted function string
  * @prop {String} openglFunctionString - opengl converted function string
  * @prop {String[]} calledFunctions - List of all the functions called
  * @param {String} functionName - Function name to assume, if its null, it attempts to extract from the function
  * @param {Function|String} jsFunction - JS Function to do conversion
  * @param {Object} options
  *
  */
	function BaseFunctionNode(functionName, jsFunction, options) {
		_classCallCheck(this, BaseFunctionNode);

		this.calledFunctions = [];
		this.calledFunctionsArguments = {};
		this.builder = null;
		this.isRootKernel = false;
		this.isSubKernel = false;
		this.parent = null;
		this.debug = null;
		this.prototypeOnly = null;
		this.constants = null;
		this.output = null;
		this.declarations = {};
		this.states = [];
		this.fixIntegerDivisionAccuracy = null;

		var paramTypes = void 0;
		var returnType = void 0;
		if (options) {
			if (options.hasOwnProperty('debug')) {
				this.debug = options.debug;
			}
			if (options.hasOwnProperty('prototypeOnly')) {
				this.prototypeOnly = options.prototypeOnly;
			}
			if (options.hasOwnProperty('constants')) {
				this.constants = options.constants;
			}
			if (options.hasOwnProperty('output')) {
				this.output = options.output;
			}
			if (options.hasOwnProperty('loopMaxIterations')) {
				this.loopMaxIterations = options.loopMaxIterations;
			}
			if (options.hasOwnProperty('paramTypes')) {
				this.paramTypes = paramTypes = options.paramTypes;
			}
			if (options.hasOwnProperty('constantTypes')) {
				this.constantTypes = options.constantTypes;
			} else {
				this.constantTypes = {};
			}
			if (options.hasOwnProperty('returnType')) {
				returnType = options.returnType;
			}
			if (options.hasOwnProperty('fixIntegerDivisionAccuracy')) {
				this.fixIntegerDivisionAccuracy = options.fixIntegerDivisionAccuracy;
			}
		}

		//
		// Missing jsFunction object exception
		//
		if (!jsFunction) {
			throw 'jsFunction, parameter is missing';
		}

		//
		// Setup jsFunction and its string property + validate them
		//
		this.jsFunctionString = jsFunction.toString();
		if (!utils.isFunctionString(this.jsFunctionString)) {
			console.error('jsFunction, to string conversion check failed: not a function?', this.jsFunctionString);
			throw 'jsFunction, to string conversion check failed: not a function?';
		}

		if (!utils.isFunction(jsFunction)) {
			//throw 'jsFunction, is not a valid JS Function';
			this.jsFunction = null;
		} else {
			this.jsFunction = jsFunction;
		}

		//
		// Setup the function name property
		//
		this.functionName = functionName || jsFunction && jsFunction.name || utils.getFunctionNameFromString(this.jsFunctionString);

		if (!this.functionName) {
			throw 'jsFunction, missing name argument or value';
		}

		//
		// Extract parameter name, and its argument types
		//
		this.paramNames = utils.getParamNamesFromString(this.jsFunctionString);
		if (paramTypes) {
			if (Array.isArray(paramTypes)) {
				if (paramTypes.length !== this.paramNames.length) {
					throw 'Invalid argument type array length, against function length -> (' + paramTypes.length + ',' + this.paramNames.length + ')';
				}
				this.paramTypes = paramTypes;
			} else if ((typeof paramTypes === 'undefined' ? 'undefined' : _typeof(paramTypes)) === 'object') {
				var paramVariableNames = Object.keys(paramTypes);
				if (paramTypes.hasOwnProperty('returns')) {
					this.returnType = paramTypes.returns;
					paramVariableNames.splice(paramVariableNames.indexOf('returns'), 1);
				}
				if (paramVariableNames.length > 0 && paramVariableNames.length !== this.paramNames.length) {
					throw 'Invalid argument type array length, against function length -> (' + paramVariableNames.length + ',' + this.paramNames.length + ')';
				} else {
					this.paramTypes = this.paramNames.map(function (key) {
						if (paramTypes.hasOwnProperty(key)) {
							return paramTypes[key];
						} else {
							return 'Number';
						}
					});
				}
			}
		} else {
			this.paramTypes = [];
		}

		//
		// Return type handling
		//
		if (!this.returnType) {
			this.returnType = returnType || 'Number';
		}
	}

	_createClass(BaseFunctionNode, [{
		key: 'isIdentifierConstant',
		value: function isIdentifierConstant(paramName) {
			if (!this.constants) return false;
			return this.constants.hasOwnProperty(paramName);
		}
	}, {
		key: 'isInput',
		value: function isInput(paramName) {
			return this.paramTypes[this.paramNames.indexOf(paramName)] === 'Input';
		}
	}, {
		key: 'setBuilder',
		value: function setBuilder(builder) {
			this.builder = builder;
			return this;
		}
	}, {
		key: 'pushState',
		value: function pushState(state) {
			this.states.push(state);
		}
	}, {
		key: 'popState',
		value: function popState(state) {
			if (this.state !== state) {
				throw new Error('Cannot popState ' + state + ' when in ' + this.state);
			}
			this.states.pop();
		}
	}, {
		key: 'isState',
		value: function isState(state) {
			return this.state === state;
		}
	}, {
		key: 'getJsFunction',

		/**
   * 
   * Core Functions
   * 
   */

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name getJSFunction
   *
   * @desc Gets and return the stored JS Function.
   * Note: that this internally eval the function, if only the string was provided on construction
   *
   * @returns {Function} The function object
   *
   */
		value: function getJsFunction() {
			if (this.jsFunction) {
				return this.jsFunction;
			}

			if (this.jsFunctionString) {
				this.jsFunction = eval(this.jsFunctionString);
				return this.jsFunction;
			}

			throw 'Missing jsFunction, and jsFunctionString parameter';
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name astMemberExpressionUnroll
   * @desc Parses the abstract syntax tree for binary expression.
   *
   * <p>Utility function for astCallExpression.</p>
   *
   * @param {Object} ast - the AST object to parse
   *
   * @returns {String} the function namespace call, unrolled
   */

	}, {
		key: 'astMemberExpressionUnroll',
		value: function astMemberExpressionUnroll(ast) {
			if (ast.type === 'Identifier') {
				return ast.name;
			} else if (ast.type === 'ThisExpression') {
				return 'this';
			}

			if (ast.type === 'MemberExpression') {
				if (ast.object && ast.property) {
					//babel sniffing
					if (ast.object.hasOwnProperty('name') && ast.object.name[0] === '_') {
						return this.astMemberExpressionUnroll(ast.property);
					}

					return this.astMemberExpressionUnroll(ast.object) + '.' + this.astMemberExpressionUnroll(ast.property);
				}
			}

			//babel sniffing
			if (ast.hasOwnProperty('expressions')) {
				var firstExpression = ast.expressions[0];
				if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
					return this.astMemberExpressionUnroll(ast.expressions[1]);
				}
			}

			// Failure, unknown expression
			throw this.astErrorOutput('Unknown CallExpression_unroll', ast);
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name getJsAST
   *
   * @desc Parses the class function JS, and returns its Abstract Syntax Tree object.
   *
   * This is used internally to convert to shader code
   *
   * @param {Object} [inParser] - Parser to use, assumes in scope 'parser' if null or undefined
   *
   * @returns {Object} The function AST Object, note that result is cached under this.jsFunctionAST;
   *
   */

	}, {
		key: 'getJsAST',
		value: function getJsAST(inParser) {
			if (this.jsFunctionAST) {
				return this.jsFunctionAST;
			}

			inParser = inParser || acorn;
			if (inParser === null) {
				throw 'Missing JS to AST parser';
			}

			var ast = inParser.parse('var ' + this.functionName + ' = ' + this.jsFunctionString + ';', {
				locations: true
			});
			if (ast === null) {
				throw 'Failed to parse JS code';
			}

			// take out the function object, outside the var declarations
			var funcAST = ast.body[0].declarations[0].init;
			this.jsFunctionAST = funcAST;

			return funcAST;
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name getFunctionString
   *
   * @desc Returns the converted webgl shader function equivalent of the JS function
   *
   * @returns {String} webgl function string, result is cached under this.webGlFunctionString
   *
   */

	}, {
		key: 'getFunctionString',
		value: function getFunctionString() {
			this.generate();
			return this.functionString;
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name setFunctionString
   *
   * @desc Set the functionString value, overwriting it
   *
   * @param {String} functionString - Shader code string, representing the function
   *
   */

	}, {
		key: 'setFunctionString',
		value: function setFunctionString(functionString) {
			this.functionString = functionString;
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name getParamType
   *
   * @desc Return the type of parameter sent to subKernel/Kernel.
   *
   * @param {String} paramName - Name of the parameter
   *
   * @returns {String} Type of the parameter
   *
   */

	}, {
		key: 'getParamType',
		value: function getParamType(paramName) {
			var paramIndex = this.paramNames.indexOf(paramName);
			if (paramIndex === -1) {
				if (this.declarations.hasOwnProperty(paramName)) {
					return this.declarations[paramName];
				} else {
					return 'Number';
				}
			} else {
				if (!this.parent) {
					if (this.paramTypes[paramIndex]) return this.paramTypes[paramIndex];
				} else {
					if (this.paramTypes[paramIndex]) return this.paramTypes[paramIndex];
					var calledFunctionArguments = this.parent.calledFunctionsArguments[this.functionName];
					for (var i = 0; i < calledFunctionArguments.length; i++) {
						var calledFunctionArgument = calledFunctionArguments[i];
						if (calledFunctionArgument[paramIndex] !== null) {
							return this.paramTypes[paramIndex] = calledFunctionArgument[paramIndex].type;
						}
					}
				}
			}
			return 'Number';
		}
	}, {
		key: 'getConstantType',
		value: function getConstantType(constantName) {
			if (this.constantTypes[constantName]) {
				return this.constantTypes[constantName];
			}
			return null;
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name getUserParamName
   *
   * @desc Return the name of the *user parameter*(subKernel parameter) corresponding 
   * to the parameter supplied to the kernel
   *
   * @param {String} paramName - Name of the parameter
   *
   * @returns {String} Name of the parameter
   *
   */

	}, {
		key: 'getUserParamName',
		value: function getUserParamName(paramName) {
			var paramIndex = this.paramNames.indexOf(paramName);
			if (paramIndex === -1) return null;
			if (!this.parent || !this.isSubKernel) return null;
			var calledFunctionArguments = this.parent.calledFunctionsArguments[this.functionName];
			for (var i = 0; i < calledFunctionArguments.length; i++) {
				var calledFunctionArgument = calledFunctionArguments[i];
				var param = calledFunctionArgument[paramIndex];
				if (param !== null && param.type !== 'Integer') {
					return param.name;
				}
			}
			return null;
		}
	}, {
		key: 'generate',
		value: function generate(options) {
			throw new Error('generate not defined on BaseFunctionNode');
		}

		/**
   * @memberOf FunctionNodeBase#
   * @function
   * @name astGeneric
   *
   * @desc Parses the abstract syntax tree for generically to its respective function
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed string array
   */

	}, {
		key: 'astGeneric',
		value: function astGeneric(ast, retArr) {
			if (ast === null) {
				throw this.astErrorOutput('NULL ast', ast);
			} else {
				if (Array.isArray(ast)) {
					for (var i = 0; i < ast.length; i++) {
						this.astGeneric(ast[i], retArr);
					}
					return retArr;
				}

				switch (ast.type) {
					case 'FunctionDeclaration':
						return this.astFunctionDeclaration(ast, retArr);
					case 'FunctionExpression':
						return this.astFunctionExpression(ast, retArr);
					case 'ReturnStatement':
						return this.astReturnStatement(ast, retArr);
					case 'Literal':
						return this.astLiteral(ast, retArr);
					case 'BinaryExpression':
						return this.astBinaryExpression(ast, retArr);
					case 'Identifier':
						return this.astIdentifierExpression(ast, retArr);
					case 'AssignmentExpression':
						return this.astAssignmentExpression(ast, retArr);
					case 'ExpressionStatement':
						return this.astExpressionStatement(ast, retArr);
					case 'EmptyStatement':
						return this.astEmptyStatement(ast, retArr);
					case 'BlockStatement':
						return this.astBlockStatement(ast, retArr);
					case 'IfStatement':
						return this.astIfStatement(ast, retArr);
					case 'BreakStatement':
						return this.astBreakStatement(ast, retArr);
					case 'ContinueStatement':
						return this.astContinueStatement(ast, retArr);
					case 'ForStatement':
						return this.astForStatement(ast, retArr);
					case 'WhileStatement':
						return this.astWhileStatement(ast, retArr);
					case 'DoWhileStatement':
						return this.astDoWhileStatement(ast, retArr);
					case 'VariableDeclaration':
						return this.astVariableDeclaration(ast, retArr);
					case 'VariableDeclarator':
						return this.astVariableDeclarator(ast, retArr);
					case 'ThisExpression':
						return this.astThisExpression(ast, retArr);
					case 'SequenceExpression':
						return this.astSequenceExpression(ast, retArr);
					case 'UnaryExpression':
						return this.astUnaryExpression(ast, retArr);
					case 'UpdateExpression':
						return this.astUpdateExpression(ast, retArr);
					case 'LogicalExpression':
						return this.astLogicalExpression(ast, retArr);
					case 'MemberExpression':
						return this.astMemberExpression(ast, retArr);
					case 'CallExpression':
						return this.astCallExpression(ast, retArr);
					case 'ArrayExpression':
						return this.astArrayExpression(ast, retArr);
					case 'DebuggerStatement':
						return this.astDebuggerStatement(ast, retArr);
				}

				throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
			}
		}
		/**
   * @function
   * @name astErrorOutput
   * @ignore
   * @desc To throw the AST error, with its location.
   *
   * @todo add location support fpr the AST error
   *
   * @param {Object} error - the error message output
   * @param {Object} ast - the AST object where the error is
   */

	}, {
		key: 'astErrorOutput',
		value: function astErrorOutput(error, ast) {
			console.error(utils.getAstString(this.jsFunctionString, ast));
			console.error(error, ast, this);
			return error;
		}
	}, {
		key: 'astDebuggerStatement',
		value: function astDebuggerStatement(arrNode, retArr) {
			return retArr;
		}
	}, {
		key: 'astFunctionDeclaration',
		value: function astFunctionDeclaration(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astFunctionExpression',
		value: function astFunctionExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astReturnStatement',
		value: function astReturnStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astLiteral',
		value: function astLiteral(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astBinaryExpression',
		value: function astBinaryExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astIdentifierExpression',
		value: function astIdentifierExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astAssignmentExpression',
		value: function astAssignmentExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astExpressionStatement',
		value: function astExpressionStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astEmptyStatement',
		value: function astEmptyStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astBlockStatement',
		value: function astBlockStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astIfStatement',
		value: function astIfStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astBreakStatement',
		value: function astBreakStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astContinueStatement',
		value: function astContinueStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astForStatement',
		value: function astForStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astWhileStatement',
		value: function astWhileStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astDoWhileStatement',
		value: function astDoWhileStatement(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astVariableDeclaration',
		value: function astVariableDeclaration(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astVariableDeclarator',
		value: function astVariableDeclarator(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astThisExpression',
		value: function astThisExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astSequenceExpression',
		value: function astSequenceExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astUnaryExpression',
		value: function astUnaryExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astUpdateExpression',
		value: function astUpdateExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astLogicalExpression',
		value: function astLogicalExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astMemberExpression',
		value: function astMemberExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astCallExpression',
		value: function astCallExpression(ast, retArr) {
			return retArr;
		}
	}, {
		key: 'astArrayExpression',
		value: function astArrayExpression(ast, retArr) {
			return retArr;
		}

		/**
   * @ignore
   * @function
   * @name pushParameter
   *
   * @desc [INTERNAL] pushes a fn parameter onto retArr and 'casts' to int if necessary
   *  i.e. deal with force-int-parameter state
   * 			
   * @param {Array} retArr - return array string
   * @param {String} parameter - the parameter name  
   *
   */

	}, {
		key: 'pushParameter',
		value: function pushParameter(retArr, parameter) {
			if (this.isState('in-get-call-parameters')) {
				retArr.push('int(' + parameter + ')');
			} else {
				retArr.push(parameter);
			}
		}
	}, {
		key: 'state',
		get: function get() {
			return this.states[this.states.length - 1];
		}
	}]);

	return BaseFunctionNode;
}();
},{"../core/utils":100,"acorn":102}],76:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var utils = require('../core/utils');
var Input = require('../core/input');

module.exports = function () {

	/**
  * @constructor KernelBase
  * 
  * @desc Implements the base class for Kernels, and is used as a 
  * parent class for all Kernel implementations.
  *
  * This contains the basic methods needed by all Kernel implementations, 
  * like setDimensions, addSubKernel, etc.
  * 
  * @prop {Array} paramNames - Name of the parameters of the kernel function
  * @prop {String} fnString - Kernel function as a String
  * @prop {Array} dimensions - Dimensions of the kernel function, this.thread.x, etc.
  * @prop {Boolean} debug - Toggle debug mode
  * @prop {String} graphical - Toggle graphical mode
  * @prop {number} loopMaxIterations - Maximum number of loop iterations
  * @prop {Object} constants - Global constants
  * @prop {Array} subKernels - Sub kernels bound to this kernel instance
  * @prop {Object} subKernelProperties - Sub kernels bound to this kernel instance as key/value pairs
  * @prop {Array} subKernelOutputVariableNames - Names of the variables outputted by the subkerls
  * @prop {Boolean} fixIntegerDivisionAccuracy - fix issues with some graphics cards not returning whole numbers when dividing by factors of 3
  *
  */
	function KernelBase(fnString, settings) {
		_classCallCheck(this, KernelBase);

		this.paramNames = utils.getParamNamesFromString(fnString);
		this.fnString = fnString;
		this.output = null;
		this.debug = false;
		this.graphical = false;
		this.loopMaxIterations = 0;
		this.constants = null;
		this.wraparound = null;
		this.hardcodeConstants = null;
		this.outputToTexture = null;
		this.outputImmutable = null;
		this.texSize = null;
		this._canvas = null;
		this._webGl = null;
		this.threadDim = null;
		this.floatTextures = null;
		this.floatOutput = null;
		this.floatOutputForce = null;
		this.addFunction = null;
		this.functions = null;
		this.nativeFunctions = null;
		this.subKernels = null;
		this.subKernelProperties = null;
		this.subKernelNames = null;
		this.subKernelOutputVariableNames = null;
		this.functionBuilder = null;
		this.paramTypes = null;
		this.paramSizes = null;
		this.constantTypes = null;
		this.fixIntegerDivisionAccuracy = null;

		for (var p in settings) {
			if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
			this[p] = settings[p];
		}
		if (settings.hasOwnProperty('canvas')) {
			this._canvas = settings.canvas;
		}
		if (settings.hasOwnProperty('webGl')) {
			this._webGl = settings.webGl;
		}
		if (settings.hasOwnProperty('output')) {
			this.setOutput(settings.output); // Flatten output object
		}

		if (!this._canvas) this._canvas = utils.initCanvas();
	}

	_createClass(KernelBase, [{
		key: 'build',
		value: function build() {
			throw new Error('"build" not defined on Base');
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setupParams
   *
   * @desc Setup the parameter types for the parameters
   * supplied to the Kernel function
   *
   * @param {IArguments} args - The actual parameters sent to the Kernel
   *
   */

	}, {
		key: 'setupParams',
		value: function setupParams(args) {
			this.paramTypes = [];
			this.paramSizes = [];
			for (var i = 0; i < args.length; i++) {
				var arg = args[i];

				this.paramTypes.push(utils.getArgumentType(arg));
				this.paramSizes.push(arg.constructor === Input ? arg.size : null);
			}
		}
	}, {
		key: 'setupConstants',
		value: function setupConstants() {
			this.constantTypes = {};
			if (this.constants) {
				for (var p in this.constants) {
					this.constantTypes[p] = utils.getArgumentType(this.constants[p]);
				}
			}
		}
	}, {
		key: 'setFunctions',
		value: function setFunctions(functions) {
			this.functions = functions;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setOutput
   *
   * @desc Set dimensions of the kernel function
   *
   * @param {Array|Object} output - The output array to set the kernel output size to
   *
   */

	}, {
		key: 'setOutput',
		value: function setOutput(output) {
			if (output.hasOwnProperty('x')) {
				if (output.hasOwnProperty('y')) {
					if (output.hasOwnProperty('z')) {
						this.output = [output.x, output.y, output.z];
					} else {
						this.output = [output.x, output.y];
					}
				} else {
					this.output = [output.x];
				}
			} else {
				this.output = output;
			}
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setDebug
   *
   * @desc Toggle debug mode
   *
   * @param {Boolean} flag - true to enable debug
   *
   */

	}, {
		key: 'setDebug',
		value: function setDebug(flag) {
			this.debug = flag;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setGraphical
   *
   * @desc Toggle graphical output mode
   *
   * @param {Boolean} flag - true to enable graphical output
   *
   */

	}, {
		key: 'setGraphical',
		value: function setGraphical(flag) {
			this.graphical = flag;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setLoopMaxIterations
   *
   * @desc Set the maximum number of loop iterations
   *
   * @param {number} max - iterations count
   *
   */

	}, {
		key: 'setLoopMaxIterations',
		value: function setLoopMaxIterations(max) {
			this.loopMaxIterations = max;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setFixIntegerDivisionAccuracy
   *
   * @desc Fix division by factor of 3 FP accuracy bug
   *
   * @param {Boolean} fix - should fix 
   *
   */

	}, {
		key: 'setFixIntegerDivisionAccuracy',
		value: function setFixIntegerDivisionAccuracy(fix) {
			this.fixIntegerDivisionAccuracy = fix;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setConstants
   * @desc Set Constants
   */

	}, {
		key: 'setConstants',
		value: function setConstants(constants) {
			this.constants = constants;
			return this;
		}
	}, {
		key: 'setWraparound',
		value: function setWraparound(flag) {
			console.warn('Wraparound mode is not supported and undocumented.');
			this.wraparound = flag;
			return this;
		}
	}, {
		key: 'setHardcodeConstants',
		value: function setHardcodeConstants(flag) {
			this.hardcodeConstants = flag;
			return this;
		}
	}, {
		key: 'setOutputToTexture',
		value: function setOutputToTexture(flag) {
			this.outputToTexture = flag;
			return this;
		}
	}, {
		key: 'setOutputImmutable',
		value: function setOutputImmutable(flag) {
			this.outputImmutable = flag;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setFloatTextures
   *
   * @desc Toggle texture output mode
   *
   * @param {Boolean} flag - true to enable floatTextures
   *
   */

	}, {
		key: 'setFloatTextures',
		value: function setFloatTextures(flag) {
			this.floatTextures = flag;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setFloatOutput
   *
   * @desc Toggle output mode
   *
   * @param {Boolean} flag - true to enable float
   *
   */

	}, {
		key: 'setFloatOutput',
		value: function setFloatOutput(flag) {
			this.floatOutput = flag;
			return this;
		}
	}, {
		key: 'setFloatOutputForce',
		value: function setFloatOutputForce(flag) {
			this.floatOutputForce = flag;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setCanvas
   *
   * @desc Bind the canvas to kernel
   * 
   * @param {Canvas} canvas - Canvas to bind
   *
   */

	}, {
		key: 'setCanvas',
		value: function setCanvas(canvas) {
			this._canvas = canvas;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name setCanvas
   *
   * @desc Bind the webGL instance to kernel
   * 
   * @param {Canvas} webGL - webGL instance to bind
   *
   */

	}, {
		key: 'setWebGl',
		value: function setWebGl(webGl) {
			this._webGl = webGl;
			return this;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name getCanvas()
   *
   * @desc Returns the current canvas instance bound to the kernel
   *
   */

	}, {
		key: 'getCanvas',
		value: function getCanvas() {
			return this._canvas;
		}

		/**
   * @memberOf KernelBase#
   * @function
   * @name getWebGl()
   *
   * @desc Returns the current webGl instance bound to the kernel
   *
   */

	}, {
		key: 'getWebGl',
		value: function getWebGl() {
			return this._webGl;
		}
	}, {
		key: 'validateOptions',
		value: function validateOptions() {
			throw new Error('validateOptions not defined');
		}
	}, {
		key: 'exec',
		value: function exec() {
			return this.execute.apply(this, arguments);
		}
	}, {
		key: 'execute',
		value: function execute() {
			var _this = this;

			//
			// Prepare the required objects
			//
			var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);

			//
			// Setup and return the promise, and execute the function, in synchronous mode
			//
			return utils.newPromise(function (accept, reject) {
				try {
					accept(_this.run.apply(_this, args));
				} catch (e) {
					//
					// Error : throw rejection
					//
					reject(e);
				}
			});
		}

		/** 
   * @memberOf KernelBase#
   * @function
   * @name addSubKernel
   *
   * @desc Add a sub kernel to the root kernel instance.
   * This is what `createKernelMap` uses.
   *
   * @param {String} fnString - function (as a String) of the subKernel to add
   *
   */

	}, {
		key: 'addSubKernel',
		value: function addSubKernel(fnString) {
			if (this.subKernels === null) {
				this.subKernels = [];
				this.subKernelNames = [];
			}
			this.subKernels.push(fnString);
			this.subKernelNames.push(utils.getFunctionNameFromString(fnString));
			return this;
		}

		/** 
   * @memberOf KernelBase#
   * @function
   * @name addSubKernelProperty
   *
   * @desc Add a sub kernel to the root kernel instance, indexed by a property name
   * This is what `createKernelMap` uses.
   *
   * @param {String} property - property key for the subKernel
   * @param {String} fnString - function (as a String) of the subKernel to add
   *
   */

	}, {
		key: 'addSubKernelProperty',
		value: function addSubKernelProperty(property, fnString) {
			if (this.subKernelProperties === null) {
				this.subKernelProperties = {};
				this.subKernelNames = [];
			}
			if (this.subKernelProperties.hasOwnProperty(property)) {
				throw new Error('cannot add sub kernel ' + property + ', already defined');
			}
			this.subKernelProperties[property] = fnString;
			this.subKernelNames.push(utils.getFunctionNameFromString(fnString));
			return this;
		}
	}, {
		key: 'addNativeFunction',
		value: function addNativeFunction(name, source) {
			this.functionBuilder.addNativeFunction(name, source);
		}

		/**
   *
   * Destroys all memory associated with this kernel
   *
   * @name destroy
   * @function
   * @memberOf KernelBase#
   *
   * * @param {Boolean} removeCanvasReferences remve any associated canvas references?
   *
   */

	}, {
		key: 'destroy',
		value: function destroy() {}
	}]);

	return KernelBase;
}();
},{"../core/input":97,"../core/utils":100}],77:[function(require,module,exports){
'use strict';

var utils = require('../core/utils');

module.exports = function kernelRunShortcut(kernel) {
	var shortcut = function shortcut() {
		return kernel.run.apply(kernel, arguments);
	};

	utils.allPropertiesOf(kernel).forEach(function (key) {
		if (key[0] === '_' && key[1] === '_') return;
		if (typeof kernel[key] === 'function') {
			if (key.substring(0, 3) === 'add' || key.substring(0, 3) === 'set') {
				shortcut[key] = function () {
					kernel[key].apply(kernel, arguments);
					return shortcut;
				};
			} else {
				shortcut[key] = kernel[key].bind(kernel);
			}
		} else {
			shortcut.__defineGetter__(key, function () {
				return kernel[key];
			});
			shortcut.__defineSetter__(key, function (value) {
				kernel[key] = value;
			});
		}
	});

	shortcut.kernel = kernel;

	return shortcut;
};
},{"../core/utils":100}],78:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var utils = require('../core/utils');
var kernelRunShortcut = require('./kernel-run-shortcut');

module.exports = function () {

	/**
  * @constructor BaseRunner
  *
  * @desc Represents the 'private/protected' namespace of the GPU class
  *
  * <p>I know @private makes more sense, but since the documentation engine state is undetirmined.
  * (See https://github.com/gpujs/gpu.js/issues/19 regarding documentation engine issue)
  * File isolation is currently the best way to go. </p>
  *
  * *base.js* internal functions namespace <br>
  * *gpu.js* PUBLIC function namespace <br>
  *
  * @prop {Object} settings - Settings object used to set Dimensions, etc.
  * @prop {String} kernel - Current kernel instance
  * @prop {Object} canvas - Canvas instance attached to the kernel
  * @prop {Object} webGl - WebGl instance attached to the kernel
  * @prop {Function} fn - Kernel function to run
  * @prop {Object} functionBuilder - FunctionBuilder instance
  * @prop {String} fnString - Kernel function (as a String)
  * @prop {String} endianness - endian information like Little-endian, Big-endian.
  *
  */

	function BaseRunner(functionBuilder, settings) {
		_classCallCheck(this, BaseRunner);

		settings = settings || {};
		this.kernel = settings.kernel;
		this.canvas = settings.canvas;
		this.webGl = settings.webGl;
		this.fn = null;
		this.functionBuilder = functionBuilder;
		this.fnString = null;
		this.endianness = utils.systemEndianness();
	}

	/**
  * @memberOf BaseRunner#
  * @function
  * @name textureToArray
  *
  * @desc Converts the provided Texture instance to a JavaScript Array
  *
  * @param {Object} texture - Texture Object
  *
  */


	_createClass(BaseRunner, [{
		key: 'textureToArray',
		value: function textureToArray(texture) {
			var copy = this.createKernel(function (x) {
				return x[this.thread.z][this.thread.y][this.thread.x];
			});

			return copy(texture);
		}

		/**
   * @memberOf BaseRunner#
   * @function
   *
   * @name deleteTexture
   *
   * @desc Deletes the provided Texture instance
   *
   * @param {Object} texture - Texture Object
   */

	}, {
		key: 'deleteTexture',
		value: function deleteTexture(texture) {
			this.webGl.deleteTexture(texture.texture);
		}

		/**
   * @memberOf BaseRunner#
   * @function
   * @name buildPromiseKernel
   *
   * @desc Get and returns the ASYNCHRONOUS executor, of a class and kernel
   * This returns a Promise object from an argument set.
   *
   * Note that there is no current implementation.
   *
   */

	}, {
		key: 'buildPromiseKernel',
		value: function buildPromiseKernel() {
			throw new Error('not yet implemented');
		}
	}, {
		key: 'getMode',
		value: function getMode() {
			throw new Error('"mode" not implemented on BaseRunner');
		}

		/**
   * @memberOf BaseRunner#
   * @function
   *
   * @name buildKernel
   *
   * @desc Get and returns the Synchronous executor, of a class and kernel
   * Which returns the result directly after passing the arguments.
   *
   */

	}, {
		key: 'buildKernel',
		value: function buildKernel(fn, settings) {
			settings = Object.assign({}, settings || {});
			var fnString = fn.toString();
			if (!settings.functionBuilder) {
				settings.functionBuilder = this.functionBuilder;
			}

			if (!settings.canvas) {
				settings.canvas = this.canvas;
			}

			if (!settings.webGl) {
				settings.webGl = this.webgl;
			}

			return kernelRunShortcut(new this.Kernel(fnString, settings));
		}
	}]);

	return BaseRunner;
}();
},{"../core/utils":100,"./kernel-run-shortcut":77}],79:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FunctionBuilderBase = require('../function-builder-base');
var WebGLFunctionNode = require('./function-node');

/**
 * @class WebGLFunctionBuilder
 *
 * @extends FunctionBuilderBase
 *
 * @desc Builds webGl functions (shaders) from JavaScript function Strings
 *
 */
module.exports = function (_FunctionBuilderBase) {
	_inherits(WebGLFunctionBuilder, _FunctionBuilderBase);

	function WebGLFunctionBuilder() {
		_classCallCheck(this, WebGLFunctionBuilder);

		var _this = _possibleConstructorReturn(this, (WebGLFunctionBuilder.__proto__ || Object.getPrototypeOf(WebGLFunctionBuilder)).call(this));

		_this.Node = WebGLFunctionNode;
		return _this;
	}

	//---------------------------------------------------------
	//
	//  Polyfill stuff
	//
	//---------------------------------------------------------

	// Round function used in polyfill


	_createClass(WebGLFunctionBuilder, [{
		key: 'polyfillStandardFunctions',


		/**
   * @memberOf FunctionBuilderBase#
   * @function
   * @name polyfillStandardFunctions
   *
   * @desc Polyfill in the missing Math functions (round)
   *
   */
		value: function polyfillStandardFunctions() {
			this.addFunction('round', _round);
		}
	}], [{
		key: 'round',
		value: function round(a) {
			return _round(a);
		}
	}]);

	return WebGLFunctionBuilder;
}(FunctionBuilderBase);

function _round(a) {
	return Math.floor(a + 0.5);
}
},{"../function-builder-base":74,"./function-node":80}],80:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FunctionNodeBase = require('../function-node-base');
var utils = require('../../core/utils');
// Closure capture for the ast function, prevent collision with existing AST functions
// The prefixes to use
var jsMathPrefix = 'Math.';
var localPrefix = 'this.';
var constantsPrefix = 'this.constants.';

var DECODE32_ENCODE32 = /decode32\(\s+encode32\(/g;
var ENCODE32_DECODE32 = /encode32\(\s+decode32\(/g;

// these debugs were hugely usefull...
// TODO: optimise out - webpack/babel options? maybe some generic logging support in core/utils?
// const debugLog = console.log
var debugLog = function debugLog() {};
/**
 * @class WebGLFunctionNode
 *
 * @desc [INTERNAL] Takes in a function node, and does all the AST voodoo required to generate its respective webGL code.
 *
 * @extends FunctionNodeBase
 *
 * @param {functionNode} inNode - The function node object
 *
 * @returns the converted webGL function string
 *
 */
module.exports = function (_FunctionNodeBase) {
	_inherits(WebGLFunctionNode, _FunctionNodeBase);

	function WebGLFunctionNode() {
		_classCallCheck(this, WebGLFunctionNode);

		return _possibleConstructorReturn(this, (WebGLFunctionNode.__proto__ || Object.getPrototypeOf(WebGLFunctionNode)).apply(this, arguments));
	}

	_createClass(WebGLFunctionNode, [{
		key: 'generate',
		value: function generate() {
			if (this.debug) {
				debugLog(this);
			}
			if (this.prototypeOnly) {
				return this.astFunctionPrototype(this.getJsAST(), []).join('').trim();
			} else {
				this.functionStringArray = this.astGeneric(this.getJsAST(), []);
			}
			this.functionString = webGlRegexOptimize(this.functionStringArray.join('').trim());
			return this.functionString;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astFunctionDeclaration
   *
   * @desc Parses the abstract syntax tree for to its *named function declaration*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astFunctionDeclaration',
		value: function astFunctionDeclaration(ast, retArr) {
			this.builder.addFunction(null, utils.getAstString(this.jsFunctionString, ast));
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astFunctionPrototype
   * @static
   *
   * @desc Parses the abstract syntax tree for to its *named function prototype*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astFunctionPrototype',
		value: function astFunctionPrototype(ast, retArr) {
			// Setup function return type and name
			if (this.isRootKernel || this.isSubKernel) {
				return retArr;
			}

			var returnType = this.returnType;
			var type = typeMap[returnType];
			if (!type) {
				throw new Error('unknown type ' + returnType);
			}
			retArr.push(type);
			retArr.push(' ');
			retArr.push(this.functionName);
			retArr.push('(');

			// Arguments handling
			for (var i = 0; i < this.paramNames.length; ++i) {
				if (i > 0) {
					retArr.push(', ');
				}

				retArr.push(this.paramTypes[i]);
				retArr.push(' ');
				retArr.push('user_');
				retArr.push(this.paramNames[i]);
			}

			retArr.push(');\n');

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astFunctionExpression
   *
   * @desc Parses the abstract syntax tree for to its *named function*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astFunctionExpression',
		value: function astFunctionExpression(ast, retArr) {

			// Setup function return type and name
			if (this.isRootKernel) {
				retArr.push('void');
			} else {
				var returnType = this.returnType;
				var type = typeMap[returnType];
				if (!type) {
					throw new Error('unknown type ' + returnType);
				}
				retArr.push(type);
			}
			retArr.push(' ');
			retArr.push(this.functionName);
			retArr.push('(');

			if (!this.isRootKernel) {
				// Arguments handling
				for (var i = 0; i < this.paramNames.length; ++i) {
					var paramName = this.paramNames[i];

					if (i > 0) {
						retArr.push(', ');
					}
					var paramType = this.getParamType(paramName);
					var _type = typeMap[paramType];
					if (!_type) {
						throw new Error('unknown type ' + paramType);
					}
					retArr.push(_type);
					retArr.push(' ');
					retArr.push('user_');
					retArr.push(paramName);
				}
			}

			// Function opening
			retArr.push(') {\n');

			// Body statement iteration
			for (var _i = 0; _i < ast.body.body.length; ++_i) {
				this.astGeneric(ast.body.body[_i], retArr);
				retArr.push('\n');
			}

			// Function closing
			retArr.push('}\n');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astReturnStatement
   *
   * @desc Parses the abstract syntax tree for to *return* statement
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astReturnStatement',
		value: function astReturnStatement(ast, retArr) {
			if (this.isRootKernel) {
				retArr.push('kernelResult = ');
				this.astGeneric(ast.argument, retArr);
				retArr.push(';');
				retArr.push('return;');
			} else if (this.isSubKernel) {
				retArr.push(this.functionName + 'Result = ');
				this.astGeneric(ast.argument, retArr);
				retArr.push(';');
				retArr.push('return ' + this.functionName + 'Result;');
			} else {
				retArr.push('return ');
				this.astGeneric(ast.argument, retArr);
				retArr.push(';');
			}

			//throw this.astErrorOutput(
			//	'Non main function return, is not supported : '+this.currentFunctionNamespace,
			//	ast
			//);

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astLiteral
   *
   * @desc Parses the abstract syntax tree for *literal value*
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astLiteral',
		value: function astLiteral(ast, retArr) {

			// Reject non numeric literals
			if (isNaN(ast.value)) {
				throw this.astErrorOutput('Non-numeric literal not supported : ' + ast.value, ast);
			}

			// Push the literal value as a float/int
			retArr.push(ast.value);

			var inGetParams = this.isState('in-get-call-parameters');
			// If it was an int, node made a float if necessary
			if (Number.isInteger(ast.value)) {
				if (!inGetParams) {
					retArr.push('.0');
				}
			} else if (inGetParams) {
				// or cast to an int as we are addressing an input array
				retArr.pop();
				retArr.push('int(');
				retArr.push(ast.value);
				retArr.push(')');
			}

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astBinaryExpression
   *
   * @desc Parses the abstract syntax tree for *binary* expression
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astBinaryExpression',
		value: function astBinaryExpression(ast, retArr) {
			var inGetParams = this.isState('in-get-call-parameters');
			if (inGetParams) {
				this.pushState('not-in-get-call-parameters');
				retArr.push('int');
			}
			retArr.push('(');

			if (ast.operator === '%') {
				retArr.push('mod(');
				this.astGeneric(ast.left, retArr);
				retArr.push(',');
				this.astGeneric(ast.right, retArr);
				retArr.push(')');
			} else if (ast.operator === '===') {
				this.astGeneric(ast.left, retArr);
				retArr.push('==');
				this.astGeneric(ast.right, retArr);
			} else if (ast.operator === '!==') {
				this.astGeneric(ast.left, retArr);
				retArr.push('!=');
				this.astGeneric(ast.right, retArr);
			} else if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
				retArr.push('div_with_int_check(');
				this.astGeneric(ast.left, retArr);
				retArr.push(', ');
				this.astGeneric(ast.right, retArr);
				retArr.push(')');
			} else {
				this.astGeneric(ast.left, retArr);
				retArr.push(ast.operator);
				this.astGeneric(ast.right, retArr);
			}

			retArr.push(')');

			if (inGetParams) {
				this.popState('not-in-get-call-parameters');
			}

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astIdentifierExpression
   *
   * @desc Parses the abstract syntax tree for *identifier* expression
   *
   * @param {Object} idtNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astIdentifierExpression',
		value: function astIdentifierExpression(idtNode, retArr) {
			if (idtNode.type !== 'Identifier') {
				throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
			}
			// do we need to cast addressing vales to float?
			var castFloat = !this.isState('in-get-call-parameters');

			switch (idtNode.name) {
				case 'gpu_threadX':
					castFloat && retArr.push('float(');
					retArr.push('threadId.x');
					castFloat && retArr.push(')');
					break;
				case 'gpu_threadY':
					castFloat && retArr.push('float(');
					retArr.push('threadId.y');
					castFloat && retArr.push(')');
					break;
				case 'gpu_threadZ':
					castFloat && retArr.push('float(');
					retArr.push('threadId.z');
					castFloat && retArr.push(')');
					break;
				case 'gpu_outputX':
					retArr.push('uOutputDim.x');
					break;
				case 'gpu_outputY':
					retArr.push('uOutputDim.y');
					break;
				case 'gpu_outputZ':
					retArr.push('uOutputDim.z');
					break;
				case 'Infinity':
					// https://stackoverflow.com/a/47543127/1324039
					retArr.push('3.402823466e+38');
					break;
				default:
					var userParamName = this.getUserParamName(idtNode.name);
					if (userParamName !== null) {
						this.pushParameter(retArr, 'user_' + userParamName);
					} else {
						this.pushParameter(retArr, 'user_' + idtNode.name);
					}
			}

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astForStatement
   *
   * @desc Parses the abstract syntax tree forfor *for-loop* expression
   *
   * @param {Object} forNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed webgl string
   */

	}, {
		key: 'astForStatement',
		value: function astForStatement(forNode, retArr) {
			if (forNode.type !== 'ForStatement') {
				throw this.astErrorOutput('Invalid for statment', forNode);
			}

			if (forNode.test && forNode.test.type === 'BinaryExpression') {
				if (forNode.test.right.type === 'Identifier' && forNode.test.operator === '<' && this.isIdentifierConstant(forNode.test.right.name) === false) {

					if (!this.loopMaxIterations) {
						console.warn('Warning: loopMaxIterations is not set! Using default of 1000 which may result in unintended behavior.');
						console.warn('Set loopMaxIterations or use a for loop of fixed length to silence this message.');
					}

					retArr.push('for (');
					this.astGeneric(forNode.init, retArr);
					this.astGeneric(forNode.test.left, retArr);
					retArr.push(forNode.test.operator);
					retArr.push('LOOP_MAX');
					retArr.push(';');
					this.astGeneric(forNode.update, retArr);
					retArr.push(')');

					retArr.push('{\n');
					retArr.push('if (');
					this.astGeneric(forNode.test.left, retArr);
					retArr.push(forNode.test.operator);
					this.astGeneric(forNode.test.right, retArr);
					retArr.push(') {\n');
					if (forNode.body.type === 'BlockStatement') {
						for (var i = 0; i < forNode.body.body.length; i++) {
							this.astGeneric(forNode.body.body[i], retArr);
						}
					} else {
						this.astGeneric(forNode.body, retArr);
					}
					retArr.push('\n} else {\n');
					retArr.push('break;\n');
					retArr.push('}\n');
					retArr.push('}\n');

					return retArr;
				} else {
					var declarations = JSON.parse(JSON.stringify(forNode.init.declarations));
					var updateArgument = forNode.update.argument;
					if (!Array.isArray(declarations) || declarations.length < 1) {
						debugLog(this.jsFunctionString);
						throw new Error('Error: Incompatible for loop declaration');
					}

					if (declarations.length > 1) {
						var initArgument = null;
						for (var _i2 = 0; _i2 < declarations.length; _i2++) {
							var declaration = declarations[_i2];
							if (declaration.id.name === updateArgument.name) {
								initArgument = declaration;
								declarations.splice(_i2, 1);
							} else {
								retArr.push('float ');
								this.astGeneric(declaration, retArr);
								retArr.push(';');
							}
						}

						retArr.push('for (float ');
						this.astGeneric(initArgument, retArr);
						retArr.push(';');
					} else {
						retArr.push('for (');
						this.astGeneric(forNode.init, retArr);
					}

					this.astGeneric(forNode.test, retArr);
					retArr.push(';');
					this.astGeneric(forNode.update, retArr);
					retArr.push(')');
					this.astGeneric(forNode.body, retArr);
					return retArr;
				}
			}

			throw this.astErrorOutput('Invalid for statement', forNode);
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astWhileStatement
   *
   * @desc Parses the abstract syntax tree for *while* loop
   *
   *
   * @param {Object} whileNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed webgl string
   */

	}, {
		key: 'astWhileStatement',
		value: function astWhileStatement(whileNode, retArr) {
			if (whileNode.type !== 'WhileStatement') {
				throw this.astErrorOutput('Invalid while statment', whileNode);
			}

			retArr.push('for (float i = 0.0; i < LOOP_MAX; i++) {');
			retArr.push('if (');
			this.astGeneric(whileNode.test, retArr);
			retArr.push(') {\n');
			this.astGeneric(whileNode.body, retArr);
			retArr.push('} else {\n');
			retArr.push('break;\n');
			retArr.push('}\n');
			retArr.push('}\n');

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astWhileStatement
   *
   * @desc Parses the abstract syntax tree for *do while* loop
   *
   *
   * @param {Object} doWhileNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the parsed webgl string
   */

	}, {
		key: 'astDoWhileStatement',
		value: function astDoWhileStatement(doWhileNode, retArr) {
			if (doWhileNode.type !== 'DoWhileStatement') {
				throw this.astErrorOutput('Invalid while statment', doWhileNode);
			}

			retArr.push('for (float i = 0.0; i < LOOP_MAX; i++) {');
			this.astGeneric(doWhileNode.body, retArr);
			retArr.push('if (!');
			this.astGeneric(doWhileNode.test, retArr);
			retArr.push(') {\n');
			retArr.push('break;\n');
			retArr.push('}\n');
			retArr.push('}\n');

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astAssignmentExpression
   *
   * @desc Parses the abstract syntax tree for *Assignment* Expression
   *
   * @param {Object} assNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astAssignmentExpression',
		value: function astAssignmentExpression(assNode, retArr) {
			if (assNode.operator === '%=') {
				this.astGeneric(assNode.left, retArr);
				retArr.push('=');
				retArr.push('mod(');
				this.astGeneric(assNode.left, retArr);
				retArr.push(',');
				this.astGeneric(assNode.right, retArr);
				retArr.push(')');
			} else {
				this.astGeneric(assNode.left, retArr);
				retArr.push(assNode.operator);
				this.astGeneric(assNode.right, retArr);
				return retArr;
			}
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astEmptyStatement
   *
   * @desc Parses the abstract syntax tree for an *Empty* Statement
   *
   * @param {Object} eNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astEmptyStatement',
		value: function astEmptyStatement(eNode, retArr) {
			//retArr.push(';\n');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astBlockStatement
   *
   * @desc Parses the abstract syntax tree for *Block* statement
   *
   * @param {Object} bNode - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astBlockStatement',
		value: function astBlockStatement(bNode, retArr) {
			retArr.push('{\n');
			for (var i = 0; i < bNode.body.length; i++) {
				this.astGeneric(bNode.body[i], retArr);
			}
			retArr.push('}\n');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astExpressionStatement
   *
   * @desc Parses the abstract syntax tree for *generic expression* statement
   *
   * @param {Object} esNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astExpressionStatement',
		value: function astExpressionStatement(esNode, retArr) {
			this.astGeneric(esNode.expression, retArr);
			retArr.push(';');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astVariableDeclaration
   *
   * @desc Parses the abstract syntax tree for *Variable Declaration*
   *
   * @param {Object} vardecNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astVariableDeclaration',
		value: function astVariableDeclaration(vardecNode, retArr) {
			for (var i = 0; i < vardecNode.declarations.length; i++) {
				var declaration = vardecNode.declarations[i];
				if (i > 0) {
					retArr.push(',');
				}
				var retDeclaration = [];
				this.astGeneric(declaration, retDeclaration);
				var declarationType = 'Number';
				if (i === 0) {
					var init = declaration.init;
					if (init) {
						if (init.object) {
							if (init.object.type === 'MemberExpression' && init.object.object) {
								// this.thread.x, this.thread.y, this.thread.z
								if (init.object.object.type === 'ThisExpression' && init.object.property && (init.object.property.name === 'thread' || init.object.property.name === 'output')) {
									declarationType = 'Integer';
								}
								// param[]
								else if (init.object.object.type === 'Identifier') {
										var _type2 = this.getParamType(init.object.object.name);
										declarationType = typeLookupMap[_type2];
									}
									// param[][]
									else if (init.object.object.object && init.object.object.object.type === 'Identifier') {
											var _type3 = this.getParamType(init.object.object.object.name);
											declarationType = typeLookupMap[_type3];
										}
										// this.constants.param[]
										else if (init.object.object.object && init.object.object.object.object && init.object.object.object.object.type === 'ThisExpression' && init.object.object.object.property.name === 'constants') {
												var _type4 = this.getConstantType(init.object.object.property.name);
												declarationType = typeLookupMap[_type4];
											}
											// this.constants.param[][]
											else if (init.object.object.object && init.object.object.object.object && init.object.object.object.object.object && init.object.object.object.object.object.type === 'ThisExpression' && init.object.object.object.object.property.name === 'constants') {
													var _type5 = this.getConstantType(init.object.object.object.property.name);
													declarationType = typeLookupMap[_type5];
												}
							}
							if (!declarationType) {
								throw new Error('unknown lookup type ' + typeLookupMap);
							}
						} else {
							if (init.name && this.declarations[init.name]) {
								declarationType = this.declarations[init.name];
							} else if (init.type === 'ArrayExpression') {
								declarationType = 'Array(' + init.elements.length + ')';
							} else if (init.type === 'CallExpression') {
								var node = this.builder.nodeMap[init.callee.name];
								if (node && node.returnType) {
									declarationType = node.returnType;
								}
							}
						}
					}
					var type = typeMap[declarationType];
					if (!type) {
						throw new Error('type ' + declarationType + ' not handled');
					}
					retArr.push(type + ' ');
				}
				this.declarations[declaration.id.name] = declarationType;
				retArr.push.apply(retArr, retDeclaration);
			}
			retArr.push(';');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astVariableDeclarator
   *
   * @desc Parses the abstract syntax tree for *Variable Declarator*
   *
   * @param {Object} ivardecNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astVariableDeclarator',
		value: function astVariableDeclarator(ivardecNode, retArr) {
			this.astGeneric(ivardecNode.id, retArr);
			if (ivardecNode.init !== null) {
				retArr.push('=');
				this.astGeneric(ivardecNode.init, retArr);
			}
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astIfStatement
   *
   * @desc Parses the abstract syntax tree for *If* Statement
   *
   * @param {Object} ifNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astIfStatement',
		value: function astIfStatement(ifNode, retArr) {
			retArr.push('if (');
			this.astGeneric(ifNode.test, retArr);
			retArr.push(')');
			if (ifNode.consequent.type === 'BlockStatement') {
				this.astGeneric(ifNode.consequent, retArr);
			} else {
				retArr.push(' {\n');
				this.astGeneric(ifNode.consequent, retArr);
				retArr.push('\n}\n');
			}

			if (ifNode.alternate) {
				retArr.push('else ');
				if (ifNode.alternate.type === 'BlockStatement') {
					this.astGeneric(ifNode.alternate, retArr);
				} else {
					retArr.push(' {\n');
					this.astGeneric(ifNode.alternate, retArr);
					retArr.push('\n}\n');
				}
			}
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astBreakStatement
   *
   * @desc Parses the abstract syntax tree for *Break* Statement
   *
   * @param {Object} brNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astBreakStatement',
		value: function astBreakStatement(brNode, retArr) {
			retArr.push('break;\n');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astContinueStatement
   *
   * @desc Parses the abstract syntax tree for *Continue* Statement
   *
   * @param {Object} crNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astContinueStatement',
		value: function astContinueStatement(crNode, retArr) {
			retArr.push('continue;\n');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astLogicalExpression
   *
   * @desc Parses the abstract syntax tree for *Logical* Expression
   *
   * @param {Object} logNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astLogicalExpression',
		value: function astLogicalExpression(logNode, retArr) {
			retArr.push('(');
			this.astGeneric(logNode.left, retArr);
			retArr.push(logNode.operator);
			this.astGeneric(logNode.right, retArr);
			retArr.push(')');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astUpdateExpression
   *
   * @desc Parses the abstract syntax tree for *Update* Expression
   *
   * @param {Object} uNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astUpdateExpression',
		value: function astUpdateExpression(uNode, retArr) {
			if (uNode.prefix) {
				retArr.push(uNode.operator);
				this.astGeneric(uNode.argument, retArr);
			} else {
				this.astGeneric(uNode.argument, retArr);
				retArr.push(uNode.operator);
			}

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astUnaryExpression
   *
   * @desc Parses the abstract syntax tree for *Unary* Expression
   *
   * @param {Object} uNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astUnaryExpression',
		value: function astUnaryExpression(uNode, retArr) {
			if (uNode.prefix) {
				retArr.push(uNode.operator);
				this.astGeneric(uNode.argument, retArr);
			} else {
				this.astGeneric(uNode.argument, retArr);
				retArr.push(uNode.operator);
			}

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astThisExpression
   *
   * @desc Parses the abstract syntax tree for *This* expression
   *
   * @param {Object} tNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astThisExpression',
		value: function astThisExpression(tNode, retArr) {
			retArr.push('this');
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astMemberExpression
   *
   * @desc Parses the abstract syntax tree for *Member* Expression
   *
   * @param {Object} mNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astMemberExpression',
		value: function astMemberExpression(mNode, retArr) {
			debugLog("[in] astMemberExpression " + mNode.object.type);
			if (mNode.computed) {
				if (mNode.object.type === 'Identifier' || mNode.object.type === 'MemberExpression' &&
				// mNode.object.object &&
				mNode.object.object.object && mNode.object.object.object.type === 'ThisExpression' && mNode.object.object.property.name === 'constants') {
					// Working logger
					var reqName = mNode.object.name;
					var funcName = this.functionName || 'kernel';
					var assumeNotTexture = false;

					// Possibly an array request - handle it as such
					if (this.paramNames) {
						var idx = this.paramNames.indexOf(reqName);
						if (idx >= 0 && this.paramTypes[idx] === 'Number') {
							assumeNotTexture = true;
						}
					}
					debugLog("- astMemberExpression " + reqName + " " + funcName);
					if (assumeNotTexture) {
						// Get from array
						this.astGeneric(mNode.object, retArr);
						retArr.push('[int(');
						this.astGeneric(mNode.property, retArr);
						retArr.push(')]');
					} else {
						var isInGetParams = this.isState('in-get-call-parameters');
						var multiMemberExpression = this.isState('multi-member-expression');
						if (multiMemberExpression) {
							this.popState('multi-member-expression');
						}
						this.pushState('not-in-get-call-parameters');

						// This normally refers to the global read only input vars
						var variableType = null;
						if (mNode.object.name) {
							if (this.declarations[mNode.object.name]) {
								variableType = this.declarations[mNode.object.name];
							} else {
								variableType = this.getParamType(mNode.object.name);
							}
						} else if (mNode.object && mNode.object.object && mNode.object.object.object && mNode.object.object.object.type === 'ThisExpression') {
							variableType = this.getConstantType(mNode.object.property.name);
						}
						switch (variableType) {
							case 'Array(2)':
							case 'Array(3)':
							case 'Array(4)':
								// Get from local vec4
								this.astGeneric(mNode.object, retArr);
								retArr.push('[');
								retArr.push(mNode.property.raw);
								retArr.push(']');
								if (multiMemberExpression) {
									this.popState('not-in-get-call-parameters');
								}
								break;
							case 'HTMLImageArray':
								// Get from image
								retArr.push('getImage3D(');
								this.astGeneric(mNode.object, retArr);
								retArr.push(', ivec2(');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Size[0],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Size[1]), ivec3(');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[0],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[1],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[2]');
								retArr.push('), ');
								this.popState('not-in-get-call-parameters');
								this.pushState('in-get-call-parameters');
								this.astGeneric(mNode.property, retArr);
								if (!multiMemberExpression) {
									this.popState('in-get-call-parameters');
								}
								retArr.push(')');
								break;
							case 'ArrayTexture(4)':
							case 'HTMLImage':
								// Get from image
								retArr.push('getImage2D(');
								this.astGeneric(mNode.object, retArr);
								retArr.push(', ivec2(');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Size[0],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Size[1]), ivec3(');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[0],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[1],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[2]');
								retArr.push('), ');
								this.popState('not-in-get-call-parameters');
								this.pushState('in-get-call-parameters');
								this.astGeneric(mNode.property, retArr);
								if (!multiMemberExpression) {
									this.popState('in-get-call-parameters');
								}
								retArr.push(')');
								break;
							default:
								// Get from texture
								if (isInGetParams) {
									retArr.push('int(');
								}
								retArr.push('get(');
								this.astGeneric(mNode.object, retArr);
								retArr.push(', ivec2(');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Size[0],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Size[1]), ivec3(');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[0],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[1],');
								this.astGeneric(mNode.object, retArr);
								retArr.push('Dim[2]');
								retArr.push('), ');
								this.astGeneric(mNode.object, retArr);
								retArr.push('BitRatio');
								retArr.push(', ');
								this.popState('not-in-get-call-parameters');
								this.pushState('in-get-call-parameters');
								this.astGeneric(mNode.property, retArr);
								if (!multiMemberExpression) {
									this.popState('in-get-call-parameters');
								}
								retArr.push(')');
								if (isInGetParams) {
									retArr.push(')');
								}
								break;
						}
					}
				} else {

					debugLog("- astMemberExpression obj:", mNode.object);
					var stateStackDepth = this.states.length;
					var startedInGetParamsState = this.isState('in-get-call-parameters');
					if (!startedInGetParamsState) {
						this.pushState('multi-member-expression');
					}
					this.astGeneric(mNode.object, retArr);
					if (this.isState('multi-member-expression')) {
						this.popState('multi-member-expression');
					}
					var changedGetParamsState = !startedInGetParamsState && this.isState('in-get-call-parameters');
					var last = retArr.pop();
					retArr.push(',');
					debugLog("- astMemberExpression prop:", mNode.property);
					var shouldPopParamState = this.isState('should-pop-in-get-call-parameters');
					if (shouldPopParamState) {
						// go back to in-get-call-parameters state
						this.popState('should-pop-in-get-call-parameters');
					}
					this.astGeneric(mNode.property, retArr);
					retArr.push(last);

					if (changedGetParamsState) {
						// calling memberExpression should pop...
						this.pushState('should-pop-in-get-call-parameters');
					} else if (shouldPopParamState) {
						// do the popping!
						this.popState('in-get-call-parameters');
					}
				}
			} else {

				// Unroll the member expression
				var unrolled = this.astMemberExpressionUnroll(mNode);
				var unrolled_lc = unrolled.toLowerCase();
				debugLog("- astMemberExpression unrolled:", unrolled);
				// Its a constant, remove this.constants.
				if (unrolled.indexOf(constantsPrefix) === 0) {
					unrolled = 'constants_' + unrolled.slice(constantsPrefix.length);
				}

				// do we need to cast addressing vales to float?
				var castFloat = !this.isState('in-get-call-parameters');

				switch (unrolled_lc) {
					case 'this.thread.x':
						castFloat && retArr.push('float(');
						retArr.push('threadId.x');
						castFloat && retArr.push(')');
						break;
					case 'this.thread.y':
						castFloat && retArr.push('float(');
						retArr.push('threadId.y');
						castFloat && retArr.push(')');
						break;
					case 'this.thread.z':
						castFloat && retArr.push('float(');
						retArr.push('threadId.z');
						castFloat && retArr.push(')');
						break;
					case 'this.output.x':
						retArr.push(this.output[0] + '.0');
						break;
					case 'this.output.y':
						retArr.push(this.output[1] + '.0');
						break;
					case 'this.output.z':
						retArr.push(this.output[2] + '.0');
						break;
					default:
						if (mNode.object && mNode.object.name && this.declarations[mNode.object.name]) {
							retArr.push('user_');
						}
						retArr.push(unrolled);
				}
			}
			debugLog("[out] astMemberExpression " + mNode.object.type);
			return retArr;
		}
	}, {
		key: 'astSequenceExpression',
		value: function astSequenceExpression(sNode, retArr) {
			for (var i = 0; i < sNode.expressions.length; i++) {
				if (i > 0) {
					retArr.push(',');
				}
				this.astGeneric(sNode.expressions, retArr);
			}
			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astCallExpression
   *
   * @desc Parses the abstract syntax tree for *call* expression
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns  {Array} the append retArr
   */

	}, {
		key: 'astCallExpression',
		value: function astCallExpression(ast, retArr) {
			if (ast.callee) {
				// Get the full function call, unrolled
				var funcName = this.astMemberExpressionUnroll(ast.callee);

				// Its a math operator, remove the prefix
				if (funcName.indexOf(jsMathPrefix) === 0) {
					funcName = funcName.slice(jsMathPrefix.length);
				}

				// Its a local function, remove this
				if (funcName.indexOf(localPrefix) === 0) {
					funcName = funcName.slice(localPrefix.length);
				}

				// if this if grows to more than one, lets use a switch
				if (funcName === 'atan2') {
					funcName = 'atan';
				}

				// Register the function into the called registry
				if (this.calledFunctions.indexOf(funcName) < 0) {
					this.calledFunctions.push(funcName);
				}
				if (!this.hasOwnProperty('funcName')) {
					this.calledFunctionsArguments[funcName] = [];
				}

				var functionArguments = [];
				this.calledFunctionsArguments[funcName].push(functionArguments);

				// Call the function
				retArr.push(funcName);

				// Open arguments space
				retArr.push('(');

				// Add the vars
				for (var i = 0; i < ast.arguments.length; ++i) {
					var argument = ast.arguments[i];
					if (i > 0) {
						retArr.push(', ');
					}
					this.astGeneric(argument, retArr);
					if (argument.type === 'Identifier') {
						var paramIndex = this.paramNames.indexOf(argument.name);
						if (paramIndex === -1) {
							functionArguments.push(null);
						} else {
							functionArguments.push({
								name: argument.name,
								type: this.paramTypes[paramIndex] || 'Number'
							});
						}
					} else {
						functionArguments.push(null);
					}
				}

				// Close arguments space
				retArr.push(')');

				return retArr;
			}

			// Failure, unknown expression
			throw this.astErrorOutput('Unknown CallExpression', ast);

			return retArr;
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name astArrayExpression
   *
   * @desc Parses the abstract syntax tree for *Array* Expression
   *
   * @param {Object} ast - the AST object to parse
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astArrayExpression',
		value: function astArrayExpression(arrNode, retArr) {
			var arrLen = arrNode.elements.length;

			retArr.push('vec' + arrLen + '(');
			for (var i = 0; i < arrLen; ++i) {
				if (i > 0) {
					retArr.push(', ');
				}
				var subNode = arrNode.elements[i];
				this.astGeneric(subNode, retArr);
			}
			retArr.push(')');

			return retArr;

			// // Failure, unknown expression
			// throw this.astErrorOutput(
			// 	'Unknown  ArrayExpression',
			// 	arrNode
			//);
		}

		/**
   * @memberOf WebGLFunctionNode#
   * @function
   * @name getFunctionPrototypeString
   *
   * @desc Returns the converted webgl shader function equivalent of the JS function
   *
   * @returns {String} webgl function string, result is cached under this.getFunctionPrototypeString
   *
   */

	}, {
		key: 'getFunctionPrototypeString',
		value: function getFunctionPrototypeString() {
			if (this.webGlFunctionPrototypeString) {
				return this.webGlFunctionPrototypeString;
			}
			return this.webGlFunctionPrototypeString = this.generate();
		}
	}, {
		key: 'build',
		value: function build() {
			return this.getFunctionPrototypeString().length > 0;
		}
	}]);

	return WebGLFunctionNode;
}(FunctionNodeBase);

var typeMap = {
	'Array': 'sampler2D',
	'Array(2)': 'vec2',
	'Array(3)': 'vec3',
	'Array(4)': 'vec4',
	'Array2D': 'sampler2D',
	'Array3D': 'sampler2D',
	'Float': 'float',
	'Input': 'sampler2D',
	'Integer': 'float',
	'Number': 'float',
	'NumberTexture': 'sampler2D',
	'ArrayTexture(4)': 'sampler2D'
};

var typeLookupMap = {
	'Array': 'Number',
	'Array2D': 'Number',
	'Array3D': 'Number',
	'HTMLImage': 'Array(4)',
	'HTMLImageArray': 'Array(4)',
	'NumberTexture': 'Number',
	'ArrayTexture(4)': 'Array(4)'
};

/**
 * @ignore
 * @function
 * @name webgl_regex_optimize
 *
 * @desc [INTERNAL] Takes the near final webgl function string, and do regex search and replacments.
 * For voodoo optimize out the following:
 *
 * - decode32(encode32( <br>
 * - encode32(decode32( <br>
 *
 * @param {String} inStr - The webGl function String
 *
 */
function webGlRegexOptimize(inStr) {
	return inStr.replace(DECODE32_ENCODE32, '((').replace(ENCODE32_DECODE32, '((');
}
},{"../../core/utils":100,"../function-node-base":75}],81:[function(require,module,exports){
'use strict';

var utils = require('../../core/utils');
var kernelRunShortcut = require('../kernel-run-shortcut');
var Input = require('../../core/input');
var Texture = require('../../core/texture');

function removeFnNoise(fn) {
  if (/^function /.test(fn)) {
    fn = fn.substring(9);
  }
  return fn.replace(/[_]typeof/g, 'typeof');
}

function removeNoise(str) {
  return str.replace(/[_]typeof/g, 'typeof');
}

module.exports = function (gpuKernel, name) {
  return '() => {\n    ' + kernelRunShortcut.toString() + ';\n    const utils = {\n      allPropertiesOf: ' + removeNoise(utils.allPropertiesOf.toString()) + ',\n      clone: ' + removeNoise(utils.clone.toString()) + ',\n      splitArray: ' + removeNoise(utils.splitArray.toString()) + ',\n      getArgumentType: ' + removeNoise(utils.getArgumentType.toString()) + ',\n      getDimensions: ' + removeNoise(utils.getDimensions.toString()) + ',\n      dimToTexSize: ' + removeNoise(utils.dimToTexSize.toString()) + ',\n      flattenTo: ' + removeNoise(utils.flattenTo.toString()) + ',\n      flatten2dArrayTo: ' + removeNoise(utils.flatten2dArrayTo.toString()) + ',\n      flatten3dArrayTo: ' + removeNoise(utils.flatten3dArrayTo.toString()) + ',\n      systemEndianness: \'' + removeNoise(utils.systemEndianness()) + '\',\n      initWebGl: ' + removeNoise(utils.initWebGl.toString()) + ',\n      isArray: ' + removeNoise(utils.isArray.toString()) + ',\n      checkOutput: ' + removeNoise(utils.checkOutput.toString()) + '\n    };\n    const Utils = utils;\n    const canvases = [];\n    const maxTexSizes = {};\n    let Texture = function() {};\n    let Input = function() {}; \n    class ' + (name || 'Kernel') + ' {\n      constructor() {\n        this.maxTexSize = null;\n        this.argumentsLength = 0;\n        this.constantsLength = 0;\n        this._canvas = null;\n        this._webGl = null;\n        this.program = null;\n        this.outputToTexture = ' + (gpuKernel.outputToTexture ? 'true' : 'false') + ';\n        this.paramNames = ' + JSON.stringify(gpuKernel.paramNames) + ';\n        this.paramTypes = ' + JSON.stringify(gpuKernel.paramTypes) + ';\n        this.texSize = ' + JSON.stringify(gpuKernel.texSize) + ';\n        this.output = ' + JSON.stringify(gpuKernel.output) + ';\n        this.compiledFragShaderString = `' + gpuKernel.compiledFragShaderString + '`;\n\t\t    this.compiledVertShaderString = `' + gpuKernel.compiledVertShaderString + '`;\n\t\t    this.programUniformLocationCache = {};\n\t\t    this.textureCache = {};\n\t\t    this.subKernelOutputTextures = null;\n\t\t    this.subKernelOutputVariableNames = null;\n\t\t    this.uniform1fCache = {};\n\t\t    this.uniform1iCache = {};\n\t\t    this.uniform2fCache = {};\n\t\t    this.uniform2fvCache = {};\n\t\t    this.uniform2ivCache = {};\n\t\t    this.uniform3fvCache = {};\n\t\t    this.uniform3ivCache = {};\n      }\n      _getFragShaderString() { return this.compiledFragShaderString; }\n      _getVertShaderString() { return this.compiledVertShaderString; }\n      validateOptions() {}\n      setupParams() {}\n      setupConstants() {}\n      setCanvas(canvas) { this._canvas = canvas; return this; }\n      setWebGl(webGl) { this._webGl = webGl; return this; }\n      setTexture(Type) { Texture = Type; }\n      setInput(Type) { Input = Type; }\n      ' + removeFnNoise(gpuKernel.getUniformLocation.toString()) + '\n      ' + removeFnNoise(gpuKernel.build.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.run.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel._addArgument.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel._formatArrayTransfer.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.getArgumentTexture.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.getTextureCache.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.getOutputTexture.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.renderOutput.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.updateMaxTexSize.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel._setupOutputTexture.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.detachTextureCache.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform1f.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform1i.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform2f.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform2fv.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform2iv.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform3fv.toString()) + '\n\t\t  ' + removeFnNoise(gpuKernel.setUniform3iv.toString()) + '\n    };\n    return kernelRunShortcut(new Kernel());\n  };';
};
},{"../../core/input":97,"../../core/texture":98,"../../core/utils":100,"../kernel-run-shortcut":77}],82:[function(require,module,exports){
'use strict';

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KernelBase = require('../kernel-base');
var utils = require('../../core/utils');
var Texture = require('../../core/texture');
var fragShaderString = require('./shader-frag');
var vertShaderString = require('./shader-vert');
var kernelString = require('./kernel-string');
var canvases = [];
var maxTexSizes = {};

module.exports = function (_KernelBase) {
	_inherits(WebGLKernel, _KernelBase);

	_createClass(WebGLKernel, null, [{
		key: 'fragShaderString',
		get: function get() {
			return fragShaderString;
		}
	}, {
		key: 'vertShaderString',
		get: function get() {
			return vertShaderString;
		}
		/**
   * @constructor WebGLKernel
   *
   * @desc Kernel Implementation for WebGL.
   * <p>This builds the shaders and runs them on the GPU,
   * the outputs the result back as float(enabled by default) and Texture.</p>
   *
   * @extends KernelBase
   *
   * @prop {Object} textureCache - webGl Texture cache
   * @prop {Object} threadDim - The thread dimensions, x, y and z
   * @prop {Object} programUniformLocationCache - Location of program variables in memory
   * @prop {Object} framebuffer - Webgl frameBuffer
   * @prop {Object} buffer - WebGL buffer
   * @prop {Object} program - The webGl Program
   * @prop {Object} functionBuilder - Function Builder instance bound to this Kernel
   * @prop {Boolean} outputToTexture - Set output type to Texture, instead of float
   * @prop {String} endianness - Endian information like Little-endian, Big-endian.
   * @prop {Array} paramTypes - Types of parameters sent to the Kernel
   * @prop {number} argumentsLength - Number of parameters sent to the Kernel
   * @prop {String} compiledFragShaderString - Compiled fragment shader string
   * @prop {String} compiledVertShaderString - Compiled Vertical shader string
   */

	}]);

	function WebGLKernel(fnString, settings) {
		_classCallCheck(this, WebGLKernel);

		var _this = _possibleConstructorReturn(this, (WebGLKernel.__proto__ || Object.getPrototypeOf(WebGLKernel)).call(this, fnString, settings));

		_this.textureCache = {};
		_this.threadDim = {};
		_this.programUniformLocationCache = {};
		_this.framebuffer = null;

		_this.buffer = null;
		_this.program = null;
		_this.outputToTexture = settings.outputToTexture;
		_this.endianness = utils.systemEndianness();
		_this.subKernelOutputTextures = null;
		_this.subKernelOutputVariableNames = null;
		_this.argumentsLength = 0;
		_this.constantsLength = 0;
		_this.compiledFragShaderString = null;
		_this.compiledVertShaderString = null;
		_this.fragShader = null;
		_this.vertShader = null;
		_this.drawBuffersMap = null;
		_this.outputTexture = null;
		_this.maxTexSize = null;
		_this.uniform1fCache = {};
		_this.uniform1iCache = {};
		_this.uniform2fCache = {};
		_this.uniform2fvCache = {};
		_this.uniform2ivCache = {};
		_this.uniform3fvCache = {};
		_this.uniform3ivCache = {};
		if (!_this._webGl) _this._webGl = _this.initWebGl();
		return _this;
	}

	_createClass(WebGLKernel, [{
		key: 'initWebGl',
		value: function initWebGl() {
			return utils.initWebGl(this.getCanvas());
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name validateOptions
   *
   * @desc Validate options related to Kernel, such as
   * floatOutputs and Textures, texSize, output,
   * graphical output.
   *
   */

	}, {
		key: 'validateOptions',
		value: function validateOptions() {
			var isFloatReadPixel = utils.isFloatReadPixelsSupported();
			if (this.floatTextures === true && !utils.OES_texture_float) {
				throw new Error('Float textures are not supported on this browser');
			} else if (this.floatOutput === true && this.floatOutputForce !== true && !isFloatReadPixel) {
				throw new Error('Float texture outputs are not supported on this browser');
			} else if (this.floatTextures === undefined && utils.OES_texture_float) {
				this.floatTextures = true;
				this.floatOutput = isFloatReadPixel;
			}

			var hasIntegerDivisionBug = utils.hasIntegerDivisionAccuracyBug();
			if (this.fixIntegerDivisionAccuracy === null) {
				this.fixIntegerDivisionAccuracy = hasIntegerDivisionBug;
			} else if (this.fixIntegerDivisionAccuracy && !hasIntegerDivisionBug) {
				this.fixIntegerDivisionAccuracy = false;
			}

			utils.checkOutput(this.output);

			if (!this.output || this.output.length === 0) {
				if (arguments.length !== 1) {
					throw new Error('Auto output only supported for kernels with only one input');
				}

				var argType = utils.getArgumentType(arguments[0]);
				if (argType === 'Array') {
					this.output = utils.getDimensions(argType);
				} else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
					this.output = arguments[0].output;
				} else {
					throw new Error('Auto output not supported for input type: ' + argType);
				}
			}

			this.texSize = utils.dimToTexSize({
				floatTextures: this.floatTextures,
				floatOutput: this.floatOutput
			}, this.output, true);

			if (this.graphical) {
				if (this.output.length !== 2) {
					throw new Error('Output must have 2 dimensions on graphical mode');
				}

				if (this.floatOutput) {
					this.floatOutput = false;
					console.warn('Cannot use graphical mode and float output at the same time');
				}

				this.texSize = utils.clone(this.output);
			} else if (this.floatOutput === undefined && utils.OES_texture_float) {
				this.floatOutput = true;
			}
		}
	}, {
		key: 'updateMaxTexSize',
		value: function updateMaxTexSize() {
			var texSize = this.texSize;
			var canvas = this._canvas;
			if (this.maxTexSize === null) {
				var canvasIndex = canvases.indexOf(canvas);
				if (canvasIndex === -1) {
					canvasIndex = canvases.length;
					canvases.push(canvas);
					maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
				}
				this.maxTexSize = maxTexSizes[canvasIndex];
			}
			if (this.maxTexSize[0] < texSize[0]) {
				this.maxTexSize[0] = texSize[0];
			}
			if (this.maxTexSize[1] < texSize[1]) {
				this.maxTexSize[1] = texSize[1];
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name build
   *
   * @desc Builds the Kernel, by compiling Fragment and Vertical Shaders,
   * and instantiates the program.
   *
   */

	}, {
		key: 'build',
		value: function build() {
			this.validateOptions();
			this.setupConstants();
			this.setupParams(arguments);
			this.updateMaxTexSize();
			var texSize = this.texSize;
			var gl = this._webGl;
			var canvas = this._canvas;
			gl.enable(gl.SCISSOR_TEST);
			gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
			canvas.width = this.maxTexSize[0];
			canvas.height = this.maxTexSize[1];
			var threadDim = this.threadDim = utils.clone(this.output);
			while (threadDim.length < 3) {
				threadDim.push(1);
			}

			if (this.functionBuilder) this._addKernels();

			var compiledVertShaderString = this._getVertShaderString(arguments);
			var vertShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vertShader, compiledVertShaderString);
			gl.compileShader(vertShader);
			this.vertShader = vertShader;

			var compiledFragShaderString = this._getFragShaderString(arguments);
			var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fragShader, compiledFragShaderString);
			gl.compileShader(fragShader);
			this.fragShader = fragShader;

			if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
				console.log(compiledVertShaderString);
				console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(vertShader));
				throw new Error('Error compiling vertex shader');
			}
			if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
				console.log(compiledFragShaderString);
				console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(fragShader));
				throw new Error('Error compiling fragment shader');
			}

			if (this.debug) {
				console.log('Options:');
				console.dir(this);
				console.log('GLSL Shader Output:');
				console.log(compiledFragShaderString);
			}

			var program = this.program = gl.createProgram();
			gl.attachShader(program, vertShader);
			gl.attachShader(program, fragShader);
			gl.linkProgram(program);
			this.framebuffer = gl.createFramebuffer();
			this.framebuffer.width = texSize[0];
			this.framebuffer.height = texSize[1];

			var vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
			var texCoords = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);

			var texCoordOffset = vertices.byteLength;

			var buffer = this.buffer;
			if (!buffer) {
				buffer = this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
			} else {
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			}

			gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
			gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

			var aPosLoc = gl.getAttribLocation(this.program, 'aPos');
			gl.enableVertexAttribArray(aPosLoc);
			gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, gl.FALSE, 0, 0);
			var aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
			gl.enableVertexAttribArray(aTexCoordLoc);
			gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, gl.FALSE, 0, texCoordOffset);
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

			for (var p in this.constants) {
				var value = this.constants[p];
				var type = utils.getArgumentType(value);
				if (type === 'Float' || type === 'Integer') {
					continue;
				}
				gl.useProgram(this.program);
				this._addConstant(this.constants[p], type, p);
				this.constantsLength++;
			}

			if (!this.outputImmutable) {
				this._setupOutputTexture();
				if (this.subKernelOutputVariableNames !== null && this.subKernelOutputVariableNames.length > 0) {
					this._setupSubOutputTextures(this.subKernelOutputVariableNames.length);
				}
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name run
   *
   * @desc Run the kernel program, and send the output to renderOutput
   *
   * <p> This method calls a helper method *renderOutput* to return the result. </p>
   *
   * @returns {Object|Undefined} Result The final output of the program, as float, and as Textures for reuse.
   *
   *
   */

	}, {
		key: 'run',
		value: function run() {
			if (this.program === null) {
				this.build.apply(this, arguments);
			}
			var paramNames = this.paramNames;
			var paramTypes = this.paramTypes;
			var texSize = this.texSize;
			var gl = this._webGl;

			gl.useProgram(this.program);
			gl.scissor(0, 0, texSize[0], texSize[1]);

			if (!this.hardcodeConstants) {
				this.setUniform3iv('uOutputDim', this.threadDim);
				this.setUniform2iv('uTexSize', texSize);
			}

			this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

			this.argumentsLength = 0;
			for (var texIndex = 0; texIndex < paramNames.length; texIndex++) {
				this._addArgument(arguments[texIndex], paramTypes[texIndex], paramNames[texIndex]);
			}

			if (this.graphical) {
				if (this.outputToTexture) {
					gl.bindRenderbuffer(gl.RENDERBUFFER, null);
					gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
					if (!this.outputTexture || this.outputImmutable) {
						this._setupOutputTexture();
					}
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
					return new Texture(this.outputTexture, texSize, this.threadDim, this.output, this._webGl, 'ArrayTexture(4)');
				}
				gl.bindRenderbuffer(gl.RENDERBUFFER, null);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				return;
			}

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
			if (this.outputImmutable) {
				this._setupOutputTexture();
			}
			var outputTexture = this.outputTexture;

			if (this.subKernelOutputVariableNames !== null) {
				if (this.outputImmutable) {
					this.subKernelOutputTextures = [];
					this._setupSubOutputTextures(this.subKernelOutputVariableNames.length);
				}
				this.drawBuffers.drawBuffersWEBGL(this.drawBuffersMap);
			}

			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

			if (this.subKernelOutputTextures !== null) {
				if (this.subKernels !== null) {
					var output = [];
					output.result = this.renderOutput(outputTexture);
					for (var i = 0; i < this.subKernels.length; i++) {
						output.push(new Texture(this.subKernelOutputTextures[i], texSize, this.threadDim, this.output, this._webGl));
					}
					return output;
				} else if (this.subKernelProperties !== null) {
					var _output = {
						result: this.renderOutput(outputTexture)
					};
					var _i = 0;
					for (var p in this.subKernelProperties) {
						if (!this.subKernelProperties.hasOwnProperty(p)) continue;
						_output[p] = new Texture(this.subKernelOutputTextures[_i], texSize, this.threadDim, this.output, this._webGl);
						_i++;
					}
					return _output;
				}
			}

			return this.renderOutput(outputTexture);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name renderOutput
   *
   *
   * @desc Helper function to return webGl function's output.
   * Since the program runs on GPU, we need to get the
   * output of the program back to CPU and then return them.
   *
   * *Note*: This should not be called directly.
   *
   * @param {Object} outputTexture - Output Texture returned by webGl program
   *
   * @returns {Object|Array} result
   *
   *
   */

	}, {
		key: 'renderOutput',
		value: function renderOutput(outputTexture) {
			var texSize = this.texSize;
			var gl = this._webGl;
			var threadDim = this.threadDim;
			var output = this.output;
			if (this.outputToTexture) {
				return new Texture(outputTexture, texSize, this.threadDim, output, this._webGl);
			} else {
				var result = void 0;
				if (this.floatOutput) {
					var w = texSize[0];
					var h = Math.ceil(texSize[1] / 4);
					result = new Float32Array(w * h * 4);
					gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
				} else {
					var bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
					gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, bytes);
					result = new Float32Array(bytes.buffer);
				}

				result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

				if (output.length === 1) {
					return result;
				} else if (output.length === 2) {
					return utils.splitArray(result, output[0]);
				} else if (output.length === 3) {
					var cube = utils.splitArray(result, output[0] * output[1]);
					return cube.map(function (x) {
						return utils.splitArray(x, output[0]);
					});
				}
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name getOutputTexture
   *
   * @desc This return defined outputTexture, which is setup in .build(), or if immutable, is defined in .run()
   *
   * @returns {Object} Output Texture Cache
   *
   */

	}, {
		key: 'getOutputTexture',
		value: function getOutputTexture() {
			return this.outputTexture;
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _setupOutputTexture
   * @private
   *
   * @desc Setup and replace output texture
   */

	}, {
		key: '_setupOutputTexture',
		value: function _setupOutputTexture() {
			var gl = this._webGl;
			var texSize = this.texSize;
			var texture = this.outputTexture = this._webGl.createTexture();
			gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			if (this.floatOutput) {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
		}

		/**
   * @memberOf WebGLKernel#
   * @param length
   * @private
   *
   * @desc Setup and replace sub-output textures
   */

	}, {
		key: '_setupSubOutputTextures',
		value: function _setupSubOutputTextures(length) {
			var gl = this._webGl;
			var texSize = this.texSize;
			var drawBuffersMap = this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
			var textures = this.subKernelOutputTextures = [];
			for (var i = 0; i < length; i++) {
				var texture = this._webGl.createTexture();
				textures.push(texture);
				drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
				gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length + i);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				if (this.floatOutput) {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
				} else {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				}
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name getArgumentTexture
   *
   * @desc This uses *getTextureCache** to get the Texture Cache of the argument supplied
   *
   * @param {String} name - Name of the argument
   *
   * 	Texture cache for the supplied argument
   *
   */

	}, {
		key: 'getArgumentTexture',
		value: function getArgumentTexture(name) {
			return this.getTextureCache('ARGUMENT_' + name);
		}

		/**
   * @memberOf WebGLKernel#
   * @name getTextureCache
   * @function
   *
   * @desc Returns the Texture Cache of the supplied parameter (can be kernel, sub-kernel or argument)
   *
   * @param {String} name - Name of the subkernel, argument, or kernel.
   *
   * @returns {Object} Texture cache
   *
   */

	}, {
		key: 'getTextureCache',
		value: function getTextureCache(name) {
			if (this.textureCache.hasOwnProperty(name)) {
				return this.textureCache[name];
			}
			return this.textureCache[name] = this._webGl.createTexture();
		}

		/**
   * @memberOf WebGLKernel#
   * @name detachTextureCache
   * @function
   * @desc removes a texture from the kernel's cache
   * @param {String} name - Name of texture
   */

	}, {
		key: 'detachTextureCache',
		value: function detachTextureCache(name) {
			delete this.textureCache[name];
		}
	}, {
		key: 'setUniform1f',
		value: function setUniform1f(name, value) {
			if (this.uniform1fCache.hasOwnProperty(name)) {
				var cache = this.uniform1fCache[name];
				if (value === cache) {
					return;
				}
			}
			this.uniform1fCache[name] = value;
			var loc = this.getUniformLocation(name);
			this._webGl.uniform1f(loc, value);
		}
	}, {
		key: 'setUniform1i',
		value: function setUniform1i(name, value) {
			if (this.uniform1iCache.hasOwnProperty(name)) {
				var cache = this.uniform1iCache[name];
				if (value === cache) {
					return;
				}
			}
			this.uniform1iCache[name] = value;
			var loc = this.getUniformLocation(name);
			this._webGl.uniform1i(loc, value);
		}
	}, {
		key: 'setUniform2f',
		value: function setUniform2f(name, value1, value2) {
			if (this.uniform2fCache.hasOwnProperty(name)) {
				var cache = this.uniform2fCache[name];
				if (value1 === cache[0] && value2 === cache[1]) {
					return;
				}
			}
			this.uniform2fCache[name] = [value1, value2];
			var loc = this.getUniformLocation(name);
			this._webGl.uniform2f(loc, value1, value2);
		}
	}, {
		key: 'setUniform2fv',
		value: function setUniform2fv(name, value) {
			if (this.uniform2fvCache.hasOwnProperty(name)) {
				var cache = this.uniform2fvCache[name];
				if (value[0] === cache[0] && value[1] === cache[1]) {
					return;
				}
			}
			this.uniform2fvCache[name] = value;
			var loc = this.getUniformLocation(name);
			this._webGl.uniform2fv(loc, value);
		}
	}, {
		key: 'setUniform2iv',
		value: function setUniform2iv(name, value) {
			if (this.uniform2ivCache.hasOwnProperty(name)) {
				var cache = this.uniform2ivCache[name];
				if (value[0] === cache[0] && value[1] === cache[1]) {
					return;
				}
			}
			this.uniform2ivCache[name] = value;
			var loc = this.getUniformLocation(name);
			this._webGl.uniform2iv(loc, value);
		}
	}, {
		key: 'setUniform3fv',
		value: function setUniform3fv(name, value) {
			if (this.uniform3fvCache.hasOwnProperty(name)) {
				var cache = this.uniform3fvCache[name];
				if (value[0] === cache[0] && value[1] === cache[1] && value[2] === cache[2]) {
					return;
				}
			}
			this.uniform3fvCache[name] = value;
			var loc = this.getUniformLocation(name);
			this._webGl.uniform3fv(loc, value);
		}
	}, {
		key: 'setUniform3iv',
		value: function setUniform3iv(name, value) {
			if (this.uniform3ivCache.hasOwnProperty(name)) {
				var cache = this.uniform3ivCache[name];
				if (value[0] === cache[0] && value[1] === cache[1] && value[2] === cache[2]) {
					return;
				}
			}
			this.uniform3ivCache[name] = value;
			var loc = this.getUniformLocation(name);
			this._webGl.uniform3iv(loc, value);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name getUniformLocation
   *
   * @desc Return WebGlUniformLocation for various variables
   * related to webGl program, such as user-defiend variables,
   * as well as, dimension sizes, etc.
   *
   */

	}, {
		key: 'getUniformLocation',
		value: function getUniformLocation(name) {
			if (this.programUniformLocationCache.hasOwnProperty(name)) {
				return this.programUniformLocationCache[name];
			}
			return this.programUniformLocationCache[name] = this._webGl.getUniformLocation(this.program, name);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getFragShaderArtifactMap
   *
   * @desc Generate Shader artifacts for the kernel program.
   * The final object contains HEADER, KERNEL, MAIN_RESULT, and others.
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {Object} An object containing the Shader Artifacts(CONSTANTS, HEADER, KERNEL, etc.)
   *
   */

	}, {
		key: '_getFragShaderArtifactMap',
		value: function _getFragShaderArtifactMap(args) {
			return {
				HEADER: this._getHeaderString(),
				LOOP_MAX: this._getLoopMaxString(),
				CONSTANTS: this._getConstantsString(),
				DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
				ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
				DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
				GET_WRAPAROUND: this._getGetWraparoundString(),
				GET_TEXTURE_CHANNEL: this._getGetTextureChannelString(),
				GET_TEXTURE_INDEX: this._getGetTextureIndexString(),
				GET_RESULT: this._getGetResultString(),
				MAIN_PARAMS: this._getMainParamsString(args),
				MAIN_CONSTANTS: this._getMainConstantsString(),
				KERNEL: this._getKernelString(),
				MAIN_RESULT: this._getMainResultString()
			};
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _addArgument
   *
   * @desc Adds kernel parameters to the Argument Texture,
   * binding it to the webGl instance, etc.
   *
   * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
   * @param {String} type - Type of the argument
   * @param {String} name - Name of the argument
   *
   */

	}, {
		key: '_addArgument',
		value: function _addArgument(value, type, name) {
			var gl = this._webGl;
			var argumentTexture = this.getArgumentTexture(name);
			if (value instanceof Texture) {
				type = value.type;
			}
			switch (type) {
				case 'Array':
				case 'Array(2)':
				case 'Array(3)':
				case 'Array(4)':
				case 'Array2D':
				case 'Array3D':
					{
						var dim = utils.getDimensions(value, true);
						var size = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, dim);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var length = size[0] * size[1];

						var _formatArrayTransfer2 = this._formatArrayTransfer(value, length),
						    valuesFlat = _formatArrayTransfer2.valuesFlat,
						    bitRatio = _formatArrayTransfer2.bitRatio;

						var buffer = void 0;
						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);
						} else {
							buffer = new Uint8Array(valuesFlat.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('user_' + name + 'Dim', dim);
							this.setUniform2iv('user_' + name + 'Size', size);
						}
						this.setUniform1i('user_' + name + 'BitRatio', bitRatio);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'Integer':
				case 'Float':
				case 'Number':
					{
						this.setUniform1f('user_' + name, value);
						break;
					}
				case 'Input':
					{
						var input = value;
						var _dim = input.size;
						var _size = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, _dim);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var _length = _size[0] * _size[1];

						var _formatArrayTransfer3 = this._formatArrayTransfer(value.value, _length),
						    _valuesFlat = _formatArrayTransfer3.valuesFlat,
						    _bitRatio = _formatArrayTransfer3.bitRatio;

						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size[0], _size[1], 0, gl.RGBA, gl.FLOAT, inputArray);
						} else {
							var _buffer = new Uint8Array(_valuesFlat.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size[0] / _bitRatio, _size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('user_' + name + 'Dim', _dim);
							this.setUniform2iv('user_' + name + 'Size', _size);
						}
						this.setUniform1i('user_' + name + 'BitRatio', _bitRatio);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'HTMLImage':
					{
						var inputImage = value;
						var _dim2 = [inputImage.width, inputImage.height, 1];
						var _size2 = [inputImage.width, inputImage.height];

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						// Upload the image into the texture.
						var mipLevel = 0; // the largest mip
						var internalFormat = gl.RGBA; // format we want in the texture
						var srcFormat = gl.RGBA; // format of data we are supplying
						var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);
						this.setUniform3iv('user_' + name + 'Dim', _dim2);
						this.setUniform2iv('user_' + name + 'Size', _size2);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'ArrayTexture(4)':
				case 'NumberTexture':
					{
						var inputTexture = value;
						var _dim3 = inputTexture.dimensions;
						var _size3 = inputTexture.size;

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

						this.setUniform3iv('user_' + name + 'Dim', _dim3);
						this.setUniform2iv('user_' + name + 'Size', _size3);
						this.setUniform1i('user_' + name + 'BitRatio', 1); // aways float32
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				default:
					throw new Error('Input type not supported (WebGL): ' + value);
			}
			this.argumentsLength++;
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _addConstant
   *
   * @desc Adds kernel parameters to the Argument Texture,
   * binding it to the webGl instance, etc.
   *
   * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
   * @param {String} type - Type of the argument
   * @param {String} name - Name of the argument
   *
   */

	}, {
		key: '_addConstant',
		value: function _addConstant(value, type, name) {
			var gl = this._webGl;
			var argumentTexture = this.getArgumentTexture(name);
			if (value instanceof Texture) {
				type = value.type;
			}
			switch (type) {
				case 'Array':
					{
						var dim = utils.getDimensions(value, true);
						var size = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, dim);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var length = size[0] * size[1];

						var _formatArrayTransfer4 = this._formatArrayTransfer(value, length),
						    valuesFlat = _formatArrayTransfer4.valuesFlat,
						    bitRatio = _formatArrayTransfer4.bitRatio;

						var buffer = void 0;
						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);
						} else {
							buffer = new Uint8Array(valuesFlat.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('constants_' + name + 'Dim', dim);
							this.setUniform2iv('constants_' + name + 'Size', size);
						}
						this.setUniform1i('constants_' + name + 'BitRatio', bitRatio);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'Input':
					{
						var input = value;
						var _dim4 = input.size;
						var _size4 = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, _dim4);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var _length2 = _size4[0] * _size4[1];

						var _formatArrayTransfer5 = this._formatArrayTransfer(value.value, _length2),
						    _valuesFlat2 = _formatArrayTransfer5.valuesFlat,
						    _bitRatio2 = _formatArrayTransfer5.bitRatio;

						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size4[0], _size4[1], 0, gl.RGBA, gl.FLOAT, inputArray);
						} else {
							var _buffer2 = new Uint8Array(_valuesFlat2.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size4[0] / _bitRatio2, _size4[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer2);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('constants_' + name + 'Dim', _dim4);
							this.setUniform2iv('constants_' + name + 'Size', _size4);
						}
						this.setUniform1i('constants_' + name + 'BitRatio', _bitRatio2);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'HTMLImage':
					{
						var inputImage = value;
						var _dim5 = [inputImage.width, inputImage.height, 1];
						var _size5 = [inputImage.width, inputImage.height];

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						// Upload the image into the texture.
						var mipLevel = 0; // the largest mip
						var internalFormat = gl.RGBA; // format we want in the texture
						var srcFormat = gl.RGBA; // format of data we are supplying
						var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);
						this.setUniform3iv('constants_' + name + 'Dim', _dim5);
						this.setUniform2iv('constants_' + name + 'Size', _size5);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'ArrayTexture(4)':
				case 'NumberTexture':
					{
						var inputTexture = value;
						var _dim6 = inputTexture.dimensions;
						var _size6 = inputTexture.size;

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

						this.setUniform3iv('constants_' + name + 'Dim', _dim6);
						this.setUniform2iv('constants_' + name + 'Size', _size6);
						this.setUniform1i('constants_' + name + 'BitRatio', 1); // aways float32
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'Integer':
				case 'Float':
				default:
					throw new Error('Input type not supported (WebGL): ' + value);
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _formatArrayTransfer
   *
   * @desc Adds kernel parameters to the Argument Texture,
   * binding it to the webGl instance, etc.
   *
   * @param {Array} value - The actual argument supplied to the kernel
   * @param {String} length - the expected total length of the output array
   *
   * @returns {Object} bitRatio - bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4
   * 				     valuesFlat - flattened array to transfer
   */

	}, {
		key: '_formatArrayTransfer',
		value: function _formatArrayTransfer(value, length) {
			var bitRatio = 1; // bit storage ratio of source to target 'buffer', i.e. if 8bit array -> 32bit tex = 4
			var valuesFlat = value;
			if (utils.isArray(value[0]) || this.floatTextures) {
				// not already flat
				valuesFlat = new Float32Array(length);
				utils.flattenTo(value, valuesFlat);
			} else {

				switch (value.constructor) {
					case Uint8Array:
					case Int8Array:
						bitRatio = 4;
						break;
					case Uint16Array:
					case Int16Array:
						bitRatio = 2;
					case Float32Array:
					case Int32Array:
						break;

					default:
						valuesFlat = new Float32Array(length);
						utils.flattenTo(value, valuesFlat);
				}
			}
			return {
				bitRatio: bitRatio,
				valuesFlat: valuesFlat
			};
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getHeaderString
   *
   * @desc Get the header string for the program.
   * This returns an empty string if no sub-kernels are defined.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getHeaderString',
		value: function _getHeaderString() {
			return this.subKernels !== null || this.subKernelProperties !== null ?
			//webgl2 '#version 300 es\n' :
			'#extension GL_EXT_draw_buffers : require\n' : '';
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getLoopMaxString
   *
   * @desc Get the maximum loop size String.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getLoopMaxString',
		value: function _getLoopMaxString() {
			return this.loopMaxIterations ? ' ' + parseInt(this.loopMaxIterations) + '.0;\n' : ' 1000.0;\n';
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getConstantsString
   *
   * @desc Generate transpiled glsl Strings for constant parameters sent to a kernel
   *
   * They can be defined by *hardcodeConstants*
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getConstantsString',
		value: function _getConstantsString() {
			var result = [];
			var threadDim = this.threadDim;
			var texSize = this.texSize;
			if (this.hardcodeConstants) {
				result.push('ivec3 uOutputDim = ivec3(' + threadDim[0] + ',' + threadDim[1] + ', ' + threadDim[2] + ')', 'ivec2 uTexSize = ivec2(' + texSize[0] + ', ' + texSize[1] + ')');
			} else {
				result.push('uniform ivec3 uOutputDim', 'uniform ivec2 uTexSize');
			}

			return this._linesToString(result);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getTextureCoordinate
   *
   * @desc Get texture coordinate string for the program
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getTextureCoordinate',
		value: function _getTextureCoordinate() {
			var names = this.subKernelOutputVariableNames;
			if (names === null || names.length < 1) {
				return 'varying vec2 vTexCoord;\n';
			} else {
				return 'out vec2 vTexCoord;\n';
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getDecode32EndiannessString
   *
   * @desc Get Decode32 endianness string for little-endian and big-endian
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getDecode32EndiannessString',
		value: function _getDecode32EndiannessString() {
			return this.endianness === 'LE' ? '' : '  rgba.rgba = rgba.abgr;\n';
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getEncode32EndiannessString
   *
   * @desc Get Encode32 endianness string for little-endian and big-endian
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getEncode32EndiannessString',
		value: function _getEncode32EndiannessString() {
			return this.endianness === 'LE' ? '' : '  rgba.rgba = rgba.abgr;\n';
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getDivideWithIntegerCheckString
   *
   * @desc if fixIntegerDivisionAccuracy provide method to replace /
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getDivideWithIntegerCheckString',
		value: function _getDivideWithIntegerCheckString() {
			return this.fixIntegerDivisionAccuracy ? '\n\t\t\t  float div_with_int_check(float x, float y) {\n\t\t\t  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\n\t\t\t    return float(int(x)/int(y));\n\t\t\t  }\n\t\t\t  return x / y;\n\t\t\t}\n\t\t\t' : '';
		}

		/**
   * @function
   * @memberOf WebGLKernel#
   * @name _getGetWraparoundString
   *
   * @returns {String} wraparound string
   */

	}, {
		key: '_getGetWraparoundString',
		value: function _getGetWraparoundString() {
			return this.wraparound ? '  xyz = mod(xyz, texDim);\n' : '';
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getGetTextureChannelString
   *
   */

	}, {
		key: '_getGetTextureChannelString',
		value: function _getGetTextureChannelString() {
			if (!this.floatTextures) return '';

			return this._linesToString(['  int channel = integerMod(index, 4)', '  index = index / 4']);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getGetTextureIndexString
   *
   * @desc Get generic texture index string, if floatTextures flag is true.
   *
   * @example
   * '  index = float(int(index)/4);\n'
   *
   */

	}, {
		key: '_getGetTextureIndexString',
		value: function _getGetTextureIndexString() {
			return this.floatTextures ? '  index = index / 4;\n' : '';
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getGetResultString
   *
   */

	}, {
		key: '_getGetResultString',
		value: function _getGetResultString() {
			if (!this.floatTextures) {
				return '  return decode(texel, x, bitRatio);';
			}
			return this._linesToString(['  if (channel == 0) return texel.r', '  if (channel == 1) return texel.g', '  if (channel == 2) return texel.b', '  if (channel == 3) return texel.a']);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getMainParamsString
   *
   * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getMainParamsString',
		value: function _getMainParamsString(args) {
			var result = [];
			var paramTypes = this.paramTypes;
			var paramNames = this.paramNames;
			for (var i = 0; i < paramNames.length; i++) {
				var param = args[i];
				var paramName = paramNames[i];
				var paramType = paramTypes[i];
				if (this.hardcodeConstants) {
					if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)') {
						var paramDim = utils.getDimensions(param, true);
						var paramSize = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, paramDim);

						result.push('uniform sampler2D user_' + paramName, 'ivec2 user_' + paramName + 'Size = ivec2(' + paramSize[0] + ', ' + paramSize[1] + ')', 'ivec3 user_' + paramName + 'Dim = ivec3(' + paramDim[0] + ', ' + paramDim[1] + ', ' + paramDim[2] + ')', 'uniform int user_' + paramName + 'BitRatio');
					} else if (paramType === 'Integer') {
						result.push('float user_' + paramName + ' = ' + param + '.0');
					} else if (paramType === 'Float') {
						result.push('float user_' + paramName + ' = ' + param);
					}
				} else {
					if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)' || paramType === 'Input' || paramType === 'HTMLImage') {
						result.push('uniform sampler2D user_' + paramName, 'uniform ivec2 user_' + paramName + 'Size', 'uniform ivec3 user_' + paramName + 'Dim');
						if (paramType !== 'HTMLImage') {
							result.push('uniform int user_' + paramName + 'BitRatio');
						}
					} else if (paramType === 'Integer' || paramType === 'Float') {
						result.push('uniform float user_' + paramName);
					} else {
						throw new Error('Param type ' + paramType + ' not supported in WebGL, only WebGL2');
					}
				}
			}
			return this._linesToString(result);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getMainConstantsString
   *
   */

	}, {
		key: '_getMainConstantsString',
		value: function _getMainConstantsString() {
			var result = [];
			if (this.constants) {
				for (var name in this.constants) {
					if (!this.constants.hasOwnProperty(name)) continue;
					var value = this.constants[name];
					var type = utils.getArgumentType(value);
					switch (type) {
						case 'Integer':
							result.push('const float constants_' + name + ' = ' + parseInt(value) + '.0');
							break;
						case 'Float':
							result.push('const float constants_' + name + ' = ' + parseFloat(value));
							break;
						case 'Array':
						case 'Input':
						case 'HTMLImage':
						case 'NumberTexture':
						case 'ArrayTexture(4)':
							result.push('uniform sampler2D constants_' + name, 'uniform ivec2 constants_' + name + 'Size', 'uniform ivec3 constants_' + name + 'Dim', 'uniform int constants_' + name + 'BitRatio');
							break;
						default:
							throw new Error('Unsupported constant ' + name + ' type ' + type);
					}
				}
			}
			return this._linesToString(result);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getKernelString
   *
   * @desc Get Kernel program string (in *glsl*) for a kernel.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getKernelString',
		value: function _getKernelString() {
			var result = [];
			var names = this.subKernelOutputVariableNames;
			if (names !== null) {
				result.push('float kernelResult = 0.0');
				for (var i = 0; i < names.length; i++) {
					result.push('float ' + names[i] + ' = 0.0');
				}
			} else {
				result.push('float kernelResult = 0.0');
			}

			return this._linesToString(result) + this.functionBuilder.getPrototypeString('kernel');
		}

		/**
   *
   * @memberOf WebGLKernel#
   * @function
   * @name _getMainResultString
   *
   * @desc Get main result string with checks for floatOutput, graphical, subKernelsOutputs, etc.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getMainResultString',
		value: function _getMainResultString() {
			var names = this.subKernelOutputVariableNames;
			var result = [];

			if (this.floatOutput) {
				result.push('  index *= 4');
			}

			if (this.graphical) {
				result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragColor = actualColor');
			} else if (this.floatOutput) {
				var channels = ['r', 'g', 'b', 'a'];

				for (var i = 0; i < channels.length; ++i) {
					result.push('  threadId = indexTo3D(index, uOutputDim)');
					result.push('  kernel()');

					if (names) {
						result.push('  gl_FragData[0].' + channels[i] + ' = kernelResult');

						for (var j = 0; j < names.length; ++j) {
							result.push('  gl_FragData[' + (j + 1) + '].' + channels[i] + ' = ' + names[j]);
						}
					} else {
						result.push('  gl_FragColor.' + channels[i] + ' = kernelResult');
					}

					if (i < channels.length - 1) {
						result.push('  index += 1');
					}
				}
			} else if (names !== null) {
				result.push('  threadId = indexTo3D(index, uOutputDim)');
				result.push('  kernel()');
				result.push('  gl_FragData[0] = encode32(kernelResult)');
				for (var _i2 = 0; _i2 < names.length; _i2++) {
					result.push('  gl_FragData[' + (_i2 + 1) + '] = encode32(' + names[_i2] + ')');
				}
			} else {
				result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  gl_FragColor = encode32(kernelResult)');
			}

			return this._linesToString(result);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _linesToString
   *
   * @param {Array} lines - An Array of strings
   *
   * @returns {String} Single combined String, seperated by *\n*
   *
   */

	}, {
		key: '_linesToString',
		value: function _linesToString(lines) {
			if (lines.length > 0) {
				return lines.join(';\n') + ';\n';
			} else {
				return '\n';
			}
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _replaceArtifacts
   *
   * @param {String} src - Shader string
   * @param {Array} map - Variables/Constants associated with shader
   *
   */

	}, {
		key: '_replaceArtifacts',
		value: function _replaceArtifacts(src, map) {
			return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z])*)__;\n/g, function (match, artifact) {
				if (map.hasOwnProperty(artifact)) {
					return map[artifact];
				}
				throw 'unhandled artifact ' + artifact;
			});
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _addKernels
   *
   * @desc Adds all the sub-kernels supplied with this Kernel instance.
   *
   */

	}, {
		key: '_addKernels',
		value: function _addKernels() {
			var _this2 = this;

			var builder = this.functionBuilder;
			var gl = this._webGl;

			builder.addFunctions(this.functions, {
				constants: this.constants,
				output: this.output
			});
			builder.addNativeFunctions(this.nativeFunctions);

			builder.addKernel(this.fnString, {
				prototypeOnly: false,
				constants: this.constants,
				output: this.output,
				debug: this.debug,
				loopMaxIterations: this.loopMaxIterations,
				paramNames: this.paramNames,
				paramTypes: this.paramTypes,
				constantTypes: this.constantTypes,
				fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
			});

			if (this.subKernels !== null) {
				var drawBuffers = this.drawBuffers = gl.getExtension('WEBGL_draw_buffers');
				if (!drawBuffers) throw new Error('could not instantiate draw buffers extension');
				this.subKernelOutputVariableNames = [];
				this.subKernels.forEach(function (subKernel) {
					return _this2._addSubKernel(subKernel);
				});
			} else if (this.subKernelProperties !== null) {
				var _drawBuffers = this.drawBuffers = gl.getExtension('WEBGL_draw_buffers');
				if (!_drawBuffers) throw new Error('could not instantiate draw buffers extension');
				this.subKernelOutputVariableNames = [];
				Object.keys(this.subKernelProperties).forEach(function (property) {
					return _this2._addSubKernel(_this2.subKernelProperties[property]);
				});
			}
		}
	}, {
		key: '_addSubKernel',
		value: function _addSubKernel(subKernel) {
			this.functionBuilder.addSubKernel(subKernel, {
				prototypeOnly: false,
				constants: this.constants,
				output: this.output,
				debug: this.debug,
				loopMaxIterations: this.loopMaxIterations,
				fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
			});
			this.subKernelOutputVariableNames.push(subKernel.name + 'Result');
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getFragShaderString
   *
   * @desc Get the fragment shader String.
   * If the String hasn't been compiled yet,
   * then this method compiles it as well
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {string} Fragment Shader string
   *
   */

	}, {
		key: '_getFragShaderString',
		value: function _getFragShaderString(args) {
			if (this.compiledFragShaderString !== null) {
				return this.compiledFragShaderString;
			}
			return this.compiledFragShaderString = this._replaceArtifacts(this.constructor.fragShaderString, this._getFragShaderArtifactMap(args));
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getVertShaderString
   *
   * @desc Get the vertical shader String
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {string} Vertical Shader string
   *
   */

	}, {
		key: '_getVertShaderString',
		value: function _getVertShaderString(args) {
			if (this.compiledVertShaderString !== null) {
				return this.compiledVertShaderString;
			}
			return this.compiledVertShaderString = this.constructor.vertShaderString;
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name toString
   *
   * @desc Returns the *pre-compiled* Kernel as a JS Object String, that can be reused.
   *
   */

	}, {
		key: 'toString',
		value: function toString() {
			return kernelString(this);
		}
	}, {
		key: 'addFunction',
		value: function addFunction(fn) {
			this.functionBuilder.addFunction(null, fn);
		}
	}, {
		key: 'destroy',
		value: function destroy(removeCanvasReferences) {
			_get(WebGLKernel.prototype.__proto__ || Object.getPrototypeOf(WebGLKernel.prototype), 'destroy', this).call(this);
			if (this.outputTexture) {
				this._webGl.deleteTexture(this.outputTexture);
			}
			if (this.buffer) {
				this._webGl.deleteBuffer(this.buffer);
			}
			if (this.framebuffer) {
				this._webGl.deleteFramebuffer(this.framebuffer);
			}

			if (this.vertShader) {
				this._webGl.deleteShader(this.vertShader);
			}

			if (this.fragShader) {
				this._webGl.deleteShader(this.fragShader);
			}

			if (this.program) {
				this._webGl.deleteProgram(this.program);
			}

			var keys = Object.keys(this.textureCache);

			for (var i = 0; i < keys.length; i++) {
				var name = keys[i];
				this._webGl.deleteTexture(this.textureCache[name]);
			}

			if (this.subKernelOutputTextures) {
				for (var _i3 = 0; _i3 < this.subKernelOutputTextures.length; _i3++) {
					this._webGl.deleteTexture(this.subKernelOutputTextures[_i3]);
				}
			}
			if (removeCanvasReferences) {
				var idx = canvases.indexOf(this._canvas);
				if (idx >= 0) {
					canvases[idx] = null;
					maxTexSizes[idx] = null;
				}
			}
			delete this._webGl;
		}
	}]);

	return WebGLKernel;
}(KernelBase);
},{"../../core/texture":98,"../../core/utils":100,"../kernel-base":76,"./kernel-string":81,"./shader-frag":84,"./shader-vert":85}],83:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RunnerBase = require('../runner-base');
var WebGLKernel = require('./kernel');
var WebGLFunctionBuilder = require('./function-builder');

module.exports = function (_RunnerBase) {
	_inherits(WebGLRunner, _RunnerBase);

	/**
  * @constructor WebGLRunner
  *
 	 * @extends RunnerBase
  	 * @desc Instantiates a Runner instance for the kernel.
  * 
  * @param {Object} settings - Settings to instantiate properties in RunnerBase, with given values
  *
  */
	function WebGLRunner(settings) {
		_classCallCheck(this, WebGLRunner);

		var _this = _possibleConstructorReturn(this, (WebGLRunner.__proto__ || Object.getPrototypeOf(WebGLRunner)).call(this, new WebGLFunctionBuilder(), settings));

		_this.Kernel = WebGLKernel;
		_this.kernel = null;
		return _this;
	}

	/**
  * @memberOf WebGLRunner#
  * @function
  * @name getMode
  *
  * @desc Return the current mode in which gpu.js is executing.
  * 
  * @returns {String} The current mode; "cpu".
  *
  */


	_createClass(WebGLRunner, [{
		key: 'getMode',
		value: function getMode() {
			return 'gpu';
		}
	}]);

	return WebGLRunner;
}(RunnerBase);
},{"../runner-base":78,"./function-builder":79,"./kernel":82}],84:[function(require,module,exports){
"use strict";

module.exports = "__HEADER__;\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nconst float LOOP_MAX = __LOOP_MAX__;\n\n__CONSTANTS__;\n\nvarying vec2 vTexCoord;\n\nvec4 round(vec4 x) {\n  return floor(x + 0.5);\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x - (y * int(x / y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 rgba) {\n  __DECODE32_ENDIANNESS__;\n  rgba *= 255.0;\n  vec2 gte128;\n  gte128.x = rgba.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = rgba.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * rgba.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(round(exponent));\n  rgba.b = rgba.b - 128.0 * gte128.x;\n  res = dot(rgba, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nvec4 encode32(float f) {\n  float F = abs(f);\n  float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 rgba = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  rgba.rg = integerMod(rgba.rg, 256.0);\n  rgba.b = integerMod(rgba.b, 128.0);\n  rgba.a = exponent*0.5 + 63.5;\n  rgba.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  rgba = floor(rgba);\n  rgba *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return rgba;\n}\n// Dragons end here\n\nfloat decode(vec4 rgba, int x, int bitRatio) {\n  if (bitRatio == 1) {\n    return decode32(rgba);\n  }\n  __DECODE32_ENDIANNESS__;\n  int channel = integerMod(x, bitRatio);\n  if (bitRatio == 4) {\n    if (channel == 0) return rgba.r * 255.0;\n    if (channel == 1) return rgba.g * 255.0;\n    if (channel == 2) return rgba.b * 255.0;\n    if (channel == 3) return rgba.a * 255.0;\n  }\n  else {\n    if (channel == 0) return rgba.r * 255.0 + rgba.g * 65280.0;\n    if (channel == 1) return rgba.b * 255.0 + rgba.a * 65280.0;\n  }\n}\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat get(sampler2D tex, ivec2 texSize, ivec3 texDim, int bitRatio,  int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  __GET_WRAPAROUND__;\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  __GET_TEXTURE_CHANNEL__;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  __GET_TEXTURE_INDEX__;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  __GET_RESULT__;\n  \n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  __GET_WRAPAROUND__;\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  __GET_TEXTURE_CHANNEL__;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  __GET_TEXTURE_INDEX__;\n  return texture2D(tex, st / vec2(texSize));\n}\n\nfloat get(sampler2D tex, ivec2 texSize, ivec3 texDim, int bitRatio, int y, int x) {\n  return get(tex, texSize, texDim, bitRatio, int(0), y, x);\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int y, int x) {\n  return getImage2D(tex, texSize, texDim, int(0), y, x);\n}\n\nfloat get(sampler2D tex, ivec2 texSize, ivec3 texDim, int bitRatio, int x) {\n  return get(tex, texSize, texDim, bitRatio, int(0), int(0), x);\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int x) {\n  return getImage2D(tex, texSize, texDim, int(0), int(0), x);\n}\n\n\nvec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\nvoid color(sampler2D image) {\n  actualColor = texture2D(image, vTexCoord);\n}\n\n__MAIN_PARAMS__;\n__MAIN_CONSTANTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}";
},{}],85:[function(require,module,exports){
"use strict";

module.exports = "precision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nattribute vec2 aPos;\nattribute vec2 aTexCoord;\n\nvarying vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}";
},{}],86:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebGLKernel = require('./kernel');
var utils = require('../../core/utils');

/**
 * @class WebGLValidatorKernel
 *
 * @desc Helper class for WebGLKernel to validate texture size and dimensions.
 *
 */
module.exports = function (_WebGLKernel) {
	_inherits(WebGLValidatorKernel, _WebGLKernel);

	function WebGLValidatorKernel() {
		_classCallCheck(this, WebGLValidatorKernel);

		return _possibleConstructorReturn(this, (WebGLValidatorKernel.__proto__ || Object.getPrototypeOf(WebGLValidatorKernel)).apply(this, arguments));
	}

	_createClass(WebGLValidatorKernel, [{
		key: 'validateOptions',


		/** 
   * @memberOf WebGLValidatorKernel#
   * @function
   * @name validateOptions
   *
   */
		value: function validateOptions() {
			this.texSize = utils.dimToTexSize({
				floatTextures: this.floatTextures,
				floatOutput: this.floatOutput
			}, this.output, true);
		}
	}]);

	return WebGLValidatorKernel;
}(WebGLKernel);
},{"../../core/utils":100,"./kernel":82}],87:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FunctionBuilderBase = require('../function-builder-base');
var WebGL2FunctionNode = require('./function-node');

/**
 * @class WebGLFunctionBuilder
 *
 * @extends FunctionBuilderBase
 *
 * @desc Builds webGl functions (shaders) from JavaScript function Strings
 *
 */
module.exports = function (_FunctionBuilderBase) {
  _inherits(WebGL2FunctionBuilder, _FunctionBuilderBase);

  function WebGL2FunctionBuilder() {
    _classCallCheck(this, WebGL2FunctionBuilder);

    var _this = _possibleConstructorReturn(this, (WebGL2FunctionBuilder.__proto__ || Object.getPrototypeOf(WebGL2FunctionBuilder)).call(this));

    _this.Node = WebGL2FunctionNode;
    return _this;
  }

  return WebGL2FunctionBuilder;
}(FunctionBuilderBase);
},{"../function-builder-base":74,"./function-node":88}],88:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebGLFunctionNode = require('../web-gl/function-node');
var DECODE32_ENCODE32 = /decode32\(\s+encode32\(/g;
var ENCODE32_DECODE32 = /encode32\(\s+decode32\(/g;

/** 
 * @class WebGL2FunctionNode
 *
 * @desc [INTERNAL] Takes in a function node, and does all the AST voodoo required to generate its respective webGL code.
 *
 * @extends WebGLFunctionNode
 *
 * @returns the converted webGL function string
 *
 */
module.exports = function (_WebGLFunctionNode) {
	_inherits(WebGL2FunctionNode, _WebGLFunctionNode);

	function WebGL2FunctionNode() {
		_classCallCheck(this, WebGL2FunctionNode);

		return _possibleConstructorReturn(this, (WebGL2FunctionNode.__proto__ || Object.getPrototypeOf(WebGL2FunctionNode)).apply(this, arguments));
	}

	_createClass(WebGL2FunctionNode, [{
		key: 'generate',
		value: function generate() {
			if (this.debug) {
				console.log(this);
			}
			if (this.prototypeOnly) {
				return this.astFunctionPrototype(this.getJsAST(), []).join('').trim();
			} else {
				this.functionStringArray = this.astGeneric(this.getJsAST(), []);
			}
			this.functionString = webGlRegexOptimize(this.functionStringArray.join('').trim());
			return this.functionString;
		}

		/**
   * @memberOf WebGL2FunctionNode#
   * @function
   * @name astIdentifierExpression
   *
   * @desc Parses the abstract syntax tree for *identifier* expression
   *
   * @param {Object} idtNode - An ast Node
   * @param {Array} retArr - return array string
   *
   * @returns {Array} the append retArr
   */

	}, {
		key: 'astIdentifierExpression',
		value: function astIdentifierExpression(idtNode, retArr) {
			if (idtNode.type !== 'Identifier') {
				throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
			}

			// do we need to cast addressing vales to float?
			var castFloat = !this.isState('in-get-call-parameters');

			switch (idtNode.name) {
				case 'gpu_threadX':
					castFloat && retArr.push('float(');
					retArr.push('threadId.x');
					castFloat && retArr.push(')');
					break;
				case 'gpu_threadY':
					castFloat && retArr.push('float(');
					retArr.push('threadId.y');
					castFloat && retArr.push(')');
					break;
				case 'gpu_threadZ':
					castFloat && retArr.push('float(');
					retArr.push('threadId.z');
					castFloat && retArr.push(')');
					break;
				case 'gpu_outputX':
					retArr.push('uOutputDim.x');
					break;
				case 'gpu_outputY':
					retArr.push('uOutputDim.y');
					break;
				case 'gpu_outputZ':
					retArr.push('uOutputDim.z');
					break;
				case 'Infinity':
					retArr.push('intBitsToFloat(2139095039)');
					break;
				default:
					var userParamName = this.getUserParamName(idtNode.name);
					if (userParamName !== null) {
						this.pushParameter(retArr, 'user_' + userParamName);
					} else {
						this.pushParameter(retArr, 'user_' + idtNode.name);
					}
			}

			return retArr;
		}
	}]);

	return WebGL2FunctionNode;
}(WebGLFunctionNode);

/**
 * @ignore
 * @function
 * @name webgl_regex_optimize
 *
 * @desc [INTERNAL] Takes the near final webgl function string, and do regex search and replacments.
 * For voodoo optimize out the following: 
 *
 * - decode32(encode32( <br>
 * - encode32(decode32( <br>
 *
 * @param {String} inStr - The webGl function String
 *
 */
function webGlRegexOptimize(inStr) {
	return inStr.replace(DECODE32_ENCODE32, '((').replace(ENCODE32_DECODE32, '((');
}
},{"../web-gl/function-node":80}],89:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebGLKernel = require('../web-gl/kernel');
var utils = require('../../core/utils');
var Texture = require('../../core/texture');
var fragShaderString = require('./shader-frag');
var vertShaderString = require('./shader-vert');

module.exports = function (_WebGLKernel) {
	_inherits(WebGL2Kernel, _WebGLKernel);

	function WebGL2Kernel() {
		_classCallCheck(this, WebGL2Kernel);

		return _possibleConstructorReturn(this, (WebGL2Kernel.__proto__ || Object.getPrototypeOf(WebGL2Kernel)).apply(this, arguments));
	}

	_createClass(WebGL2Kernel, [{
		key: 'initWebGl',
		value: function initWebGl() {
			return utils.initWebGl2(this.getCanvas());
		}
		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name validateOptions
   *
   * @desc Validate options related to Kernel, such as
   * floatOutputs and Textures, texSize, output,
   * graphical output.
   *
   */

	}, {
		key: 'validateOptions',
		value: function validateOptions() {
			var isFloatReadPixel = utils.isFloatReadPixelsSupportedWebGL2();
			if (this.floatOutput === true && this.floatOutputForce !== true && !isFloatReadPixel) {
				throw new Error('Float texture outputs are not supported on this browser');
			} else if (this.floatTextures === undefined) {
				this.floatTextures = true;
				this.floatOutput = isFloatReadPixel;
			}

			var hasIntegerDivisionBug = utils.hasIntegerDivisionAccuracyBug();
			if (this.fixIntegerDivisionAccuracy === null) {
				this.fixIntegerDivisionAccuracy = hasIntegerDivisionBug;
			} else if (this.fixIntegerDivisionAccuracy && !hasIntegerDivisionBug) {
				this.fixIntegerDivisionAccuracy = false;
			}

			utils.checkOutput(this.output);

			if (!this.output || this.output.length === 0) {
				if (arguments.length !== 1) {
					throw new Error('Auto output only supported for kernels with only one input');
				}

				var argType = utils.getArgumentType(arguments[0]);
				if (argType === 'Array') {
					this.output = utils.getDimensions(argType);
				} else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
					this.output = arguments[0].output;
				} else {
					throw new Error('Auto output not supported for input type: ' + argType);
				}
			}

			this.texSize = utils.dimToTexSize({
				floatTextures: this.floatTextures,
				floatOutput: this.floatOutput
			}, this.output, true);

			if (this.graphical) {
				if (this.output.length !== 2) {
					throw new Error('Output must have 2 dimensions on graphical mode');
				}

				if (this.floatOutput) {
					this.floatOutput = false;
					console.warn('Cannot use graphical mode and float output at the same time');
				}

				this.texSize = utils.clone(this.output);
			} else if (this.floatOutput === undefined) {
				this.floatOutput = true;
			}

			if (this.floatOutput || this.floatOutputForce) {
				this._webGl.getExtension('EXT_color_buffer_float');
			}
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name run
   *
   * @desc Run the kernel program, and send the output to renderOutput
   *
   * <p> This method calls a helper method *renderOutput* to return the result. </p>
   *
   * @returns {Object|Undefined} Result The final output of the program, as float, and as Textures for reuse.
   *
   *
   */

	}, {
		key: 'run',
		value: function run() {
			if (this.program === null) {
				this.build.apply(this, arguments);
			}
			var paramNames = this.paramNames;
			var paramTypes = this.paramTypes;
			var texSize = this.texSize;
			var gl = this._webGl;

			gl.useProgram(this.program);
			gl.scissor(0, 0, texSize[0], texSize[1]);

			if (!this.hardcodeConstants) {
				this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
				this.setUniform2iv('uTexSize', texSize);
			}

			this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

			this.argumentsLength = 0;
			for (var texIndex = 0; texIndex < paramNames.length; texIndex++) {
				this._addArgument(arguments[texIndex], paramTypes[texIndex], paramNames[texIndex]);
			}

			if (this.graphical) {
				if (this.outputToTexture) {
					gl.bindRenderbuffer(gl.RENDERBUFFER, null);
					gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
					if (!this.outputTexture || this.outputImmutable) {
						this._setupOutputTexture();
					}
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
					return new Texture(this.outputTexture, texSize, this.threadDim, this.output, this._webGl, 'ArrayTexture(4)');
				}
				gl.bindRenderbuffer(gl.RENDERBUFFER, null);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
				return;
			}

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
			if (this.outputImmutable) {
				this._setupOutputTexture();
			}
			var outputTexture = this.outputTexture;

			if (this.subKernelOutputVariableNames !== null) {
				if (this.outputImmutable) {
					this.subKernelOutputTextures = [];
					this._setupSubOutputTextures(this.subKernelOutputVariableNames.length);
				}
				gl.drawBuffers(this.drawBuffersMap);
			}

			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

			if (this.subKernelOutputTextures !== null) {
				if (this.subKernels !== null) {
					var output = [];
					output.result = this.renderOutput(outputTexture);
					for (var i = 0; i < this.subKernels.length; i++) {
						output.push(new Texture(this.subKernelOutputTextures[i], texSize, this.threadDim, this.output, this._webGl));
					}
					return output;
				} else if (this.subKernelProperties !== null) {
					var _output = {
						result: this.renderOutput(outputTexture)
					};
					var _i = 0;
					for (var p in this.subKernelProperties) {
						if (!this.subKernelProperties.hasOwnProperty(p)) continue;
						_output[p] = new Texture(this.subKernelOutputTextures[_i], texSize, this.threadDim, this.output, this._webGl);
						_i++;
					}
					return _output;
				}
			}

			return this.renderOutput(outputTexture);
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name getOutputTexture
   *
   * @desc This return defined outputTexture, which is setup in .build(), or if immutable, is defined in .run()
   *
   * @returns {Object} Output Texture Cache
   *
   */

	}, {
		key: 'getOutputTexture',
		value: function getOutputTexture() {
			return this.outputTexture;
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _setupOutputTexture
   * @private
   *
   * @desc Setup and replace output texture
   */

	}, {
		key: '_setupOutputTexture',
		value: function _setupOutputTexture() {
			var gl = this._webGl;
			var texSize = this.texSize;
			var texture = this.outputTexture = this._webGl.createTexture();
			gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			if (this.floatOutput) {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			}
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
		}

		/**
   * @memberOf WebGL2Kernel#
   * @param length
   * @private
   *
   * @desc Setup and replace sub-output textures
   */

	}, {
		key: '_setupSubOutputTextures',
		value: function _setupSubOutputTextures(length) {
			var gl = this._webGl;
			var texSize = this.texSize;
			var drawBuffersMap = this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
			var textures = this.subKernelOutputTextures = [];
			for (var i = 0; i < length; i++) {
				var texture = this._webGl.createTexture();
				textures.push(texture);
				drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
				gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.paramNames.length + i);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				if (this.floatOutput) {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
				} else {
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				}
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
			}
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _addArgument
   *
   * @desc Adds kernel parameters to the Argument Texture,
   * binding it to the webGl instance, etc.
   *
   * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
   * @param {String} type - Type of the argument
   * @param {String} name - Name of the argument
   *
   */

	}, {
		key: '_addArgument',
		value: function _addArgument(value, type, name) {
			var gl = this._webGl;
			var argumentTexture = this.getArgumentTexture(name);
			if (value instanceof Texture) {
				type = value.type;
			}
			switch (type) {
				case 'Array':
					{
						var dim = utils.getDimensions(value, true);
						var size = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, dim);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var length = size[0] * size[1];

						var _formatArrayTransfer = this._formatArrayTransfer(value, length),
						    valuesFlat = _formatArrayTransfer.valuesFlat,
						    bitRatio = _formatArrayTransfer.bitRatio;

						var buffer = void 0;
						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);
						} else {
							buffer = new Uint8Array(valuesFlat.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('user_' + name + 'Dim', dim);
							this.setUniform2iv('user_' + name + 'Size', size);
						}
						this.setUniform1i('user_' + name + 'BitRatio', bitRatio);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'Integer':
				case 'Float':
				case 'Number':
					{
						this.setUniform1f('user_' + name, value);
						break;
					}
				case 'Input':
					{
						var input = value;
						var _dim = input.size;
						var _size = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, _dim);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var _length = _size[0] * _size[1];

						var _formatArrayTransfer2 = this._formatArrayTransfer(value.value, _length),
						    _valuesFlat = _formatArrayTransfer2.valuesFlat,
						    _bitRatio = _formatArrayTransfer2.bitRatio;

						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, _size[0], _size[1], 0, gl.RGBA, gl.FLOAT, inputArray);
						} else {
							var _buffer = new Uint8Array(_valuesFlat.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size[0] / _bitRatio, _size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('user_' + name + 'Dim', _dim);
							this.setUniform2iv('user_' + name + 'Size', _size);
						}
						this.setUniform1i('user_' + name + 'BitRatio', _bitRatio);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'HTMLImage':
					{
						var inputImage = value;
						var _dim2 = [inputImage.width, inputImage.height, 1];
						var _size2 = [inputImage.width, inputImage.height];

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						// Upload the image into the texture.
						var mipLevel = 0; // the largest mip
						var internalFormat = gl.RGBA; // format we want in the texture
						var srcFormat = gl.RGBA; // format of data we are supplying
						var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);
						this.setUniform3iv('user_' + name + 'Dim', _dim2);
						this.setUniform2iv('user_' + name + 'Size', _size2);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'HTMLImageArray':
					{
						var inputImages = value;
						var _dim3 = [inputImages[0].width, inputImages[0].height, inputImages.length];
						var _size3 = [inputImages[0].width, inputImages[0].height];

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D_ARRAY, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						// Upload the images into the texture.
						var _mipLevel = 0; // the largest mip
						var _internalFormat = gl.RGBA; // format we want in the texture
						var width = inputImages[0].width;
						var height = inputImages[0].height;
						var textureDepth = inputImages.length;
						var border = 0;
						var _srcFormat = gl.RGBA; // format of data we are supplying
						var _srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
						gl.texImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, _internalFormat, width, height, textureDepth, border, _srcFormat, _srcType, null);
						for (var i = 0; i < inputImages.length; i++) {
							var xOffset = 0;
							var yOffset = 0;
							var imageDepth = 1;
							gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel, xOffset, yOffset, i, inputImages[i].width, inputImages[i].height, imageDepth, _srcFormat, _srcType, inputImages[i]);
						}
						this.setUniform3iv('user_' + name + 'Dim', _dim3);
						this.setUniform2iv('user_' + name + 'Size', _size3);
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				case 'ArrayTexture(4)':
				case 'NumberTexture':
					{
						var inputTexture = value;
						var _dim4 = inputTexture.dimensions;
						var _size4 = inputTexture.size;

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength + this.argumentsLength);
						gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

						this.setUniform3iv('user_' + name + 'Dim', _dim4);
						this.setUniform2iv('user_' + name + 'Size', _size4);
						this.setUniform1i('user_' + name + 'BitRatio', 1); // always float32
						this.setUniform1i('user_' + name, this.argumentsLength);
						break;
					}
				default:
					throw new Error('Input type not supported (WebGL): ' + value);
			}
			this.argumentsLength++;
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _getMainConstantsString
   *
   */

	}, {
		key: '_getMainConstantsString',
		value: function _getMainConstantsString() {
			var result = [];
			if (this.constants) {
				for (var name in this.constants) {
					if (!this.constants.hasOwnProperty(name)) continue;
					var value = this.constants[name];
					var type = utils.getArgumentType(value);
					switch (type) {
						case 'Integer':
							result.push('const float constants_' + name + ' = ' + parseInt(value) + '.0');
							break;
						case 'Float':
							result.push('const float constants_' + name + ' = ' + parseFloat(value));
							break;
						case 'Array':
						case 'Input':
						case 'HTMLImage':
						case 'ArrayTexture(4)':
						case 'NumberTexture':
							result.push('uniform highp sampler2D constants_' + name, 'uniform highp ivec2 constants_' + name + 'Size', 'uniform highp ivec3 constants_' + name + 'Dim', 'uniform highp int constants_' + name + 'BitRatio');
							break;
						case 'HTMLImageArray':
							result.push('uniform highp sampler2DArray constants_' + name, 'uniform highp ivec2 constants_' + name + 'Size', 'uniform highp ivec3 constants_' + name + 'Dim', 'uniform highp int constants_' + name + 'BitRatio');
							break;

						default:
							throw new Error('Unsupported constant ' + name + ' type ' + type);
					}
				}
			}
			return this._linesToString(result);
		}

		/**
   * @memberOf WebGLKernel#
   * @function
   * @name _addConstant
   *
   * @desc Adds kernel parameters to the Argument Texture,
   * binding it to the webGl instance, etc.
   *
   * @param {Array|Texture|Number} value - The actual argument supplied to the kernel
   * @param {String} type - Type of the argument
   * @param {String} name - Name of the argument
   *
   */

	}, {
		key: '_addConstant',
		value: function _addConstant(value, type, name) {
			var gl = this._webGl;
			var argumentTexture = this.getArgumentTexture(name);
			if (value instanceof Texture) {
				type = value.type;
			}
			switch (type) {
				case 'Array':
					{
						var dim = utils.getDimensions(value, true);
						var size = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, dim);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var length = size[0] * size[1];

						var _formatArrayTransfer3 = this._formatArrayTransfer(value, length),
						    valuesFlat = _formatArrayTransfer3.valuesFlat,
						    bitRatio = _formatArrayTransfer3.bitRatio;

						var buffer = void 0;
						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0], size[1], 0, gl.RGBA, gl.FLOAT, valuesFlat);
						} else {
							buffer = new Uint8Array(valuesFlat.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size[0] / bitRatio, size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('constants_' + name + 'Dim', dim);
							this.setUniform2iv('constants_' + name + 'Size', size);
						}
						this.setUniform1i('constants_' + name + 'BitRatio', bitRatio);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'Input':
					{
						var input = value;
						var _dim5 = input.size;
						var _size5 = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, _dim5);
						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						var _length2 = _size5[0] * _size5[1];

						var _formatArrayTransfer4 = this._formatArrayTransfer(value.value, _length2),
						    _valuesFlat2 = _formatArrayTransfer4.valuesFlat,
						    _bitRatio2 = _formatArrayTransfer4.bitRatio;

						if (this.floatTextures) {
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, _size5[0], _size5[1], 0, gl.RGBA, gl.FLOAT, inputArray);
						} else {
							var _buffer2 = new Uint8Array(_valuesFlat2.buffer);
							gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _size5[0] / _bitRatio2, _size5[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, _buffer2);
						}

						if (!this.hardcodeConstants) {
							this.setUniform3iv('constants_' + name + 'Dim', _dim5);
							this.setUniform2iv('constants_' + name + 'Size', _size5);
						}
						this.setUniform1i('constants_' + name + 'BitRatio', _bitRatio2);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'HTMLImage':
					{
						var inputImage = value;
						var _dim6 = [inputImage.width, inputImage.height, 1];
						var _size6 = [inputImage.width, inputImage.height];

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						// Upload the image into the texture.
						var mipLevel = 0; // the largest mip
						var internalFormat = gl.RGBA; // format we want in the texture
						var srcFormat = gl.RGBA; // format of data we are supplying
						var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
						gl.texImage2D(gl.TEXTURE_2D, mipLevel, internalFormat, srcFormat, srcType, inputImage);
						this.setUniform3iv('constants_' + name + 'Dim', _dim6);
						this.setUniform2iv('constants_' + name + 'Size', _size6);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'HTMLImageArray':
					{
						var inputImages = value;
						var _dim7 = [inputImages[0].width, inputImages[0].height, inputImages.length];
						var _size7 = [inputImages[0].width, inputImages[0].height];

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D_ARRAY, argumentTexture);
						gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						// Upload the images into the texture.
						var _mipLevel2 = 0; // the largest mip
						var _internalFormat2 = gl.RGBA; // format we want in the texture
						var width = inputImages[0].width;
						var height = inputImages[0].height;
						var textureDepth = inputImages.length;
						var border = 0;
						var _srcFormat2 = gl.RGBA; // format of data we are supplying
						var _srcType2 = gl.UNSIGNED_BYTE; // type of data we are supplying
						gl.texImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, _internalFormat2, width, height, textureDepth, border, _srcFormat2, _srcType2, null);
						for (var i = 0; i < inputImages.length; i++) {
							var xOffset = 0;
							var yOffset = 0;
							var imageDepth = 1;
							gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, _mipLevel2, xOffset, yOffset, i, inputImages[i].width, inputImages[i].height, imageDepth, _srcFormat2, _srcType2, inputImages[i]);
						}
						this.setUniform3iv('constants_' + name + 'Dim', _dim7);
						this.setUniform2iv('constants_' + name + 'Size', _size7);
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'ArrayTexture(4)':
				case 'NumberTexture':
					{
						var inputTexture = value;
						var _dim8 = inputTexture.dimensions;
						var _size8 = inputTexture.size;

						gl.activeTexture(gl.TEXTURE0 + this.constantsLength);
						gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);

						this.setUniform3iv('constants_' + name + 'Dim', _dim8);
						this.setUniform2iv('constants_' + name + 'Size', _size8);
						this.setUniform1i('constants_' + name + 'BitRatio', 1); // aways float32
						this.setUniform1i('constants_' + name, this.constantsLength);
						break;
					}
				case 'Integer':
				case 'Float':
				default:
					throw new Error('Input type not supported (WebGL): ' + value);
			}
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getGetResultString
   *
   */

	}, {
		key: '_getGetResultString',
		value: function _getGetResultString() {
			if (!this.floatTextures) {
				return '  return decode(texel, x, bitRatio);';
			}
			return '  return texel[channel];';
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getHeaderString
   *
   * @desc Get the header string for the program.
   * This returns an empty string if no sub-kernels are defined.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getHeaderString',
		value: function _getHeaderString() {
			return '';
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getTextureCoordinate
   *
   * @desc Get texture coordinate string for the program
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getTextureCoordinate',
		value: function _getTextureCoordinate() {
			var names = this.subKernelOutputVariableNames;
			if (names === null || names.length < 1) {
				return 'in highp vec2 vTexCoord;\n';
			} else {
				return 'out highp vec2 vTexCoord;\n';
			}
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getMainParamsString
   *
   * @desc Generate transpiled glsl Strings for user-defined parameters sent to a kernel
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getMainParamsString',
		value: function _getMainParamsString(args) {
			var result = [];
			var paramTypes = this.paramTypes;
			var paramNames = this.paramNames;
			for (var i = 0; i < paramNames.length; i++) {
				var param = args[i];
				var paramName = paramNames[i];
				var paramType = paramTypes[i];
				if (this.hardcodeConstants) {
					if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)') {
						var paramDim = utils.getDimensions(param, true);
						var paramSize = utils.dimToTexSize({
							floatTextures: this.floatTextures,
							floatOutput: this.floatOutput
						}, paramDim);

						result.push('uniform highp sampler2D user_' + paramName, 'highp ivec2 user_' + paramName + 'Size = ivec2(' + paramSize[0] + ', ' + paramSize[1] + ')', 'highp ivec3 user_' + paramName + 'Dim = ivec3(' + paramDim[0] + ', ' + paramDim[1] + ', ' + paramDim[2] + ')', 'uniform highp int user_' + paramName + 'BitRatio');
					} else if (paramType === 'Integer') {
						result.push('highp float user_' + paramName + ' = ' + param + '.0');
					} else if (paramType === 'Float') {
						result.push('highp float user_' + paramName + ' = ' + param);
					}
				} else {
					if (paramType === 'Array' || paramType === 'NumberTexture' || paramType === 'ArrayTexture(4)' || paramType === 'Input' || paramType === 'HTMLImage') {
						result.push('uniform highp sampler2D user_' + paramName, 'uniform highp ivec2 user_' + paramName + 'Size', 'uniform highp ivec3 user_' + paramName + 'Dim');
						if (paramType !== 'HTMLImage') {
							result.push('uniform highp int user_' + paramName + 'BitRatio');
						}
					} else if (paramType === 'HTMLImageArray') {
						result.push('uniform highp sampler2DArray user_' + paramName, 'uniform highp ivec2 user_' + paramName + 'Size', 'uniform highp ivec3 user_' + paramName + 'Dim');
					} else if (paramType === 'Integer' || paramType === 'Float') {
						result.push('uniform float user_' + paramName);
					}
				}
			}
			return this._linesToString(result);
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getKernelString
   *
   * @desc Get Kernel program string (in *glsl*) for a kernel.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getKernelString',
		value: function _getKernelString() {
			var result = [];
			var names = this.subKernelOutputVariableNames;
			if (names !== null) {
				result.push('float kernelResult = 0.0');
				result.push('layout(location = 0) out vec4 data0');
				for (var i = 0; i < names.length; i++) {
					result.push('float ' + names[i] + ' = 0.0', 'layout(location = ' + (i + 1) + ') out vec4 data' + (i + 1));
				}
			} else {
				result.push('out vec4 data0');
				result.push('float kernelResult = 0.0');
			}

			return this._linesToString(result) + this.functionBuilder.getPrototypeString('kernel');
		}

		/**
   *
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getMainResultString
   *
   * @desc Get main result string with checks for floatOutput, graphical, subKernelsOutputs, etc.
   *
   * @returns {String} result
   *
   */

	}, {
		key: '_getMainResultString',
		value: function _getMainResultString() {
			var names = this.subKernelOutputVariableNames;
			var result = [];

			if (this.floatOutput) {
				result.push('  index *= 4');
			}

			if (this.graphical) {
				result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0 = actualColor');
			} else if (this.floatOutput) {
				var channels = ['r', 'g', 'b', 'a'];

				for (var i = 0; i < channels.length; ++i) {
					result.push('  threadId = indexTo3D(index, uOutputDim)');
					result.push('  kernel()');

					if (names) {
						result.push('  data0.' + channels[i] + ' = kernelResult');

						for (var j = 0; j < names.length; ++j) {
							result.push('  data' + (j + 1) + '.' + channels[i] + ' = ' + names[j]);
						}
					} else {
						result.push('  data0.' + channels[i] + ' = kernelResult');
					}

					if (i < channels.length - 1) {
						result.push('  index += 1');
					}
				}
			} else if (names !== null) {
				result.push('  threadId = indexTo3D(index, uOutputDim)');
				result.push('  kernel()');
				result.push('  data0 = encode32(kernelResult)');
				for (var _i2 = 0; _i2 < names.length; _i2++) {
					result.push('  data' + (_i2 + 1) + ' = encode32(' + names[_i2] + ')');
				}
			} else {
				result.push('  threadId = indexTo3D(index, uOutputDim)', '  kernel()', '  data0 = encode32(kernelResult)');
			}

			return this._linesToString(result);
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _addKernels
   *
   * @desc Adds all the sub-kernels supplied with this Kernel instance.
   *
   */

	}, {
		key: '_addKernels',
		value: function _addKernels() {
			var _this2 = this;

			var builder = this.functionBuilder;
			var gl = this._webGl;

			builder.addFunctions(this.functions, {
				constants: this.constants,
				output: this.output
			});
			builder.addNativeFunctions(this.nativeFunctions);

			builder.addKernel(this.fnString, {
				prototypeOnly: false,
				constants: this.constants,
				output: this.output,
				debug: this.debug,
				loopMaxIterations: this.loopMaxIterations,
				paramNames: this.paramNames,
				paramTypes: this.paramTypes,
				constantTypes: this.constantTypes,
				fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
			});

			if (this.subKernels !== null) {
				this.subKernelOutputTextures = [];
				this.subKernelOutputVariableNames = [];
				this.subKernels.forEach(function (subKernel) {
					return _this2._addSubKernel(subKernel);
				});
			} else if (this.subKernelProperties !== null) {
				this.subKernelOutputTextures = [];
				this.subKernelOutputVariableNames = [];
				Object.keys(this.subKernelProperties).forEach(function (property) {
					return _this2._addSubKernel(_this2.subKernelProperties[property]);
				});
			}
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getFragShaderString
   *
   * @desc Get the fragment shader String.
   * If the String hasn't been compiled yet,
   * then this method compiles it as well
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {string} Fragment Shader string
   *
   */

	}, {
		key: '_getFragShaderString',
		value: function _getFragShaderString(args) {
			if (this.compiledFragShaderString !== null) {
				return this.compiledFragShaderString;
			}
			return this.compiledFragShaderString = this._replaceArtifacts(this.constructor.fragShaderString, this._getFragShaderArtifactMap(args));
		}

		/**
   * @memberOf WebGL2Kernel#
   * @function
   * @name _getVertShaderString
   *
   * @desc Get the vertical shader String
   *
   * @param {Array} args - The actual parameters sent to the Kernel
   *
   * @returns {string} Vertical Shader string
   *
   */

	}, {
		key: '_getVertShaderString',
		value: function _getVertShaderString(args) {
			if (this.compiledVertShaderString !== null) {
				return this.compiledVertShaderString;
			}
			return this.compiledVertShaderString = this.constructor.vertShaderString;
		}
	}], [{
		key: 'fragShaderString',
		get: function get() {
			return fragShaderString;
		}
	}, {
		key: 'vertShaderString',
		get: function get() {
			return vertShaderString;
		}
	}]);

	return WebGL2Kernel;
}(WebGLKernel);
},{"../../core/texture":98,"../../core/utils":100,"../web-gl/kernel":82,"./shader-frag":91,"./shader-vert":92}],90:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RunnerBase = require('../runner-base');
var WebGL2FunctionBuilder = require('./function-builder');
var WebGL2Kernel = require('./kernel');

module.exports = function (_RunnerBase) {
	_inherits(WebGL2Runner, _RunnerBase);

	/**
  * @constructor WebGL2Runner
  *
  * @extends RunnerBase
 	 * @desc Instantiates a Runner instance for the kernel.
  *
  * @param {Object} settings - Settings to instantiate properties in RunnerBase, with given values
  *
  */
	function WebGL2Runner(settings) {
		_classCallCheck(this, WebGL2Runner);

		var _this = _possibleConstructorReturn(this, (WebGL2Runner.__proto__ || Object.getPrototypeOf(WebGL2Runner)).call(this, new WebGL2FunctionBuilder(), settings));

		_this.Kernel = WebGL2Kernel;
		_this.kernel = null;
		return _this;
	}

	/**
  * @memberOf WebGL2Runner#
  * @function
  * @name getMode
  *
  * @desc Return the current mode in which gpu.js is executing.
  *
  * @returns {String} The current mode; "gpu".
  *
  */


	_createClass(WebGL2Runner, [{
		key: 'getMode',
		value: function getMode() {
			return 'gpu';
		}
	}]);

	return WebGL2Runner;
}(RunnerBase);
},{"../runner-base":78,"./function-builder":87,"./kernel":89}],91:[function(require,module,exports){
"use strict";

module.exports = "#version 300 es\n__HEADER__;\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nconst float LOOP_MAX = __LOOP_MAX__;\n\n__CONSTANTS__;\n\nin vec2 vTexCoord;\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x - (y * int(x/y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 rgba) {\n  __DECODE32_ENDIANNESS__;\n  rgba *= 255.0;\n  vec2 gte128;\n  gte128.x = rgba.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = rgba.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * rgba.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(round(exponent));\n  rgba.b = rgba.b - 128.0 * gte128.x;\n  res = dot(rgba, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nvec4 encode32(float f) {\n  float F = abs(f);\n  float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 rgba = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  rgba.rg = integerMod(rgba.rg, 256.0);\n  rgba.b = integerMod(rgba.b, 128.0);\n  rgba.a = exponent*0.5 + 63.5;\n  rgba.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  rgba = floor(rgba);\n  rgba *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return rgba;\n}\n// Dragons end here\n\nfloat decode(vec4 rgba, int x, int bitRatio) {\n  if (bitRatio == 1) {\n    return decode32(rgba);\n  }\n  __DECODE32_ENDIANNESS__;\n  int channel = integerMod(x, bitRatio);\n  if (bitRatio == 4) {\n    return rgba[channel] * 255.0;\n  }\n  else {\n    return rgba[channel*2] * 255.0 + rgba[channel*2 + 1] * 65280.0;\n  }\n}\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat get(sampler2D tex, ivec2 texSize, ivec3 texDim, int bitRatio,  int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  __GET_WRAPAROUND__;\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  __GET_TEXTURE_CHANNEL__;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  __GET_TEXTURE_INDEX__;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  __GET_RESULT__;\n  \n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  __GET_WRAPAROUND__;\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  __GET_TEXTURE_CHANNEL__;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  __GET_TEXTURE_INDEX__;\n  return texture(tex, st / vec2(texSize));\n}\n\nvec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  ivec3 xyz = ivec3(x, y, z);\n  __GET_WRAPAROUND__;\n  int index = xyz.x + texDim.x * (xyz.y + texDim.y * xyz.z);\n  __GET_TEXTURE_CHANNEL__;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  __GET_TEXTURE_INDEX__;\n  return texture(tex, vec3(st / vec2(texSize), z));\n}\n\nfloat get(sampler2D tex, ivec2 texSize, ivec3 texDim, int bitRatio, int y, int x) {\n  return get(tex, texSize, texDim, bitRatio, 0, y, x);\n}\n\nfloat get(sampler2D tex, ivec2 texSize, ivec3 texDim, int bitRatio, int x) {\n  return get(tex, texSize, texDim, bitRatio, 0, 0, x);\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int y, int x) {\n  return getImage2D(tex, texSize, texDim, 0, y, x);\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int x) {\n  return getImage2D(tex, texSize, texDim, 0, 0, x);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\n__MAIN_PARAMS__;\n__MAIN_CONSTANTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}";
},{}],92:[function(require,module,exports){
"use strict";

module.exports = "#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n\nin vec2 aPos;\nin vec2 aTexCoord;\n\nout vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}";
},{}],93:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebGLKernel = require('./kernel');
var utils = require('../../core/utils');

/**
 * @class WebGLValidatorKernel
 *
 * @desc Helper class for WebGLKernel to validate texture size and dimensions.
 *
 */
module.exports = function (_WebGLKernel) {
	_inherits(WebGL2ValidatorKernel, _WebGLKernel);

	function WebGL2ValidatorKernel() {
		_classCallCheck(this, WebGL2ValidatorKernel);

		return _possibleConstructorReturn(this, (WebGL2ValidatorKernel.__proto__ || Object.getPrototypeOf(WebGL2ValidatorKernel)).apply(this, arguments));
	}

	_createClass(WebGL2ValidatorKernel, [{
		key: 'validateOptions',


		/** 
   * @memberOf WebGLValidatorKernel#
   * @function
   * @name validateOptions
   *
   */
		value: function validateOptions() {
			this._webGl.getExtension('EXT_color_buffer_float');
			this.texSize = utils.dimToTexSize({
				floatTextures: this.floatTextures,
				floatOutput: this.floatOutput
			}, this.output, true);
		}
	}]);

	return WebGL2ValidatorKernel;
}(WebGLKernel);
},{"../../core/utils":100,"./kernel":89}],94:[function(require,module,exports){
'use strict';

var utils = require('./utils');
module.exports = function alias(name, fn) {
	var fnString = fn.toString();
	return new Function('return function ' + name + ' (' + utils.getParamNamesFromString(fnString).join(', ') + ') {' + utils.getFunctionBodyFromString(fnString) + '}')();
};
},{"./utils":100}],95:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UtilsCore = require("./utils-core");

/**
 * This is a minimalistic version of GPU.js used 
 * to run precompiled GPU.JS code.
 *
 * This intentionally excludes the JS AST compiller : which is 400kb alone/
 *
 * @class GPUCore
 */
module.exports = function () {
	function GPUCore() {
		_classCallCheck(this, GPUCore);
	}

	_createClass(GPUCore, null, [{
		key: "validateKernelObj",


		/**
   * @name validateKernelObj
   * @function
   * @static
   * @memberOf GPUCore
   *
   * @description Validates the KernelObj to comply with the defined format
   * Note that this does only a limited sanity check, and does not  
   * guarantee a full working validation.
   *
   * For the kernel object format see : <kernelObj-format>
   *
   * @param {Object|String} kernelObj - KernelObj used to validate
   *
   * @returns {Object} The validated kernel object, converted from JSON if needed
   *
   */
		value: function validateKernelObj(kernelObj) {

			// NULL validation
			if (kernelObj === null) {
				throw "KernelObj being validated is NULL";
			}

			// String JSON conversion
			if (typeof kernelObj === "string") {
				try {
					kernelObj = JSON.parse(kernelObj);
				} catch (e) {
					console.error(e);
					throw "Failed to convert KernelObj from JSON string";
				}

				// NULL validation
				if (kernelObj === null) {
					throw "Invalid (NULL) KernelObj JSON string representation";
				}
			}

			// Check for kernel obj flag
			if (kernelObj.isKernelObj !== true) {
				throw "Failed missing isKernelObj flag check";
			}

			// Return the validated kernelObj
			return kernelObj;
		}

		/**
   * @name loadKernelObj
   * @function
   * @static
   * @memberOf GPUCore
   *
   * @description Loads the precompiled kernel object. For GPUCore this is the ONLY way to create the kernel.
   * To generate the kernelObj use <Kernel.exportKernelObj>
   *
   * Note that this function calls <validateKernelObj> internally, and throws an exception if it fails.
   *
   * @see GPUCore.validateKernelObj
   * @see	Kernel.exportKernelObj
   *
   * @param {Object} kernelObj - The precompiled kernel object
   * @param {Object} inOpt - [Optional] the option overrides to use
   *
   * @returns {Function} The kernel function
   * 
   */

	}, {
		key: "loadKernelObj",
		value: function loadKernelObj(kernelObj, inOpt) {

			// Validates the kernelObj, throws an exception if it fails
			kernelObj = validateKernelObj(kernelObj);
		}
	}]);

	return GPUCore;
}();
},{"./utils-core":99}],96:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var utils = require('./utils');
var WebGLRunner = require('../backend/web-gl/runner');
var WebGL2Runner = require('../backend/web-gl2/runner');
var CPURunner = require('../backend/cpu/runner');
var WebGLValidatorKernel = require('../backend/web-gl/validator-kernel');
var WebGL2ValidatorKernel = require('../backend/web-gl2/validator-kernel');
var GPUCore = require("./gpu-core");

/**
 * Initialises the GPU.js library class which manages the webGlContext for the created functions.
 * @class
 * @extends GPUCore
 */

var GPU = function (_GPUCore) {
	_inherits(GPU, _GPUCore);

	/**
  * Creates an instance of GPU.
  * @param {any} settings - Settings to set mode, andother properties. See #GPUCore
  * @memberOf GPU#
  */
	function GPU(settings) {
		_classCallCheck(this, GPU);

		var _this = _possibleConstructorReturn(this, (GPU.__proto__ || Object.getPrototypeOf(GPU)).call(this, settings));

		settings = settings || {};
		_this._canvas = settings.canvas || null;
		_this._webGl = settings.webGl || null;
		var mode = settings.mode;
		var detectedMode = void 0;
		if (!utils.isWebGlSupported()) {
			if (mode && mode !== 'cpu') {
				throw new Error('A requested mode of "' + mode + '" and is not supported');
			} else {
				console.warn('Warning: gpu not supported, falling back to cpu support');
				detectedMode = 'cpu';
			}
		} else {
			if (_this._webGl) {
				if (typeof WebGL2RenderingContext !== 'undefined' && _this._webGl.constructor === WebGL2RenderingContext) {
					detectedMode = 'webgl2';
				} else if (typeof WebGLRenderingContext !== 'undefined' && _this._webGl.constructor === WebGLRenderingContext) {
					detectedMode = 'webgl';
				} else {
					throw new Error('unknown WebGL Context');
				}
			} else {
				detectedMode = mode || 'gpu';
			}
		}
		_this.kernels = [];

		var runnerSettings = {
			canvas: _this._canvas,
			webGl: _this._webGl
		};

		switch (detectedMode) {
			// public options
			case 'cpu':
				_this._runner = new CPURunner(runnerSettings);
				break;
			case 'gpu':
				var Runner = _this.getGPURunner();
				_this._runner = new Runner(runnerSettings);
				break;

			// private explicit options for testing
			case 'webgl2':
				_this._runner = new WebGL2Runner(runnerSettings);
				break;
			case 'webgl':
				_this._runner = new WebGLRunner(runnerSettings);
				break;

			// private explicit options for internal
			case 'webgl2-validator':
				_this._runner = new WebGL2Runner(runnerSettings);
				_this._runner.Kernel = WebGL2ValidatorKernel;
				break;
			case 'webgl-validator':
				_this._runner = new WebGLRunner(runnerSettings);
				_this._runner.Kernel = WebGLValidatorKernel;
				break;
			default:
				throw new Error('"' + mode + '" mode is not defined');
		}
		return _this;
	}
	/**
  *
  * This creates a callable function object to call the kernel function with the argument parameter set
  *
  * @name createKernel
  * @function
  * @memberOf GPU##
  *
  * @param {Function} fn - The calling to perform the conversion
  * @param {Object} [settings] - The parameter configuration object
  * @property {String} settings.dimensions - Thread dimension array (Defaults to [1024])
  * @property {String} settings.mode - CPU / GPU configuration mode (Defaults to null)
  *
  * The following modes are supported
  * *'falsey'* : Attempts to build GPU mode, else fallbacks
  * *'gpu'* : Attempts to build GPU mode, else fallbacks
  * *'cpu'* : Forces JS fallback mode only
  *
  *
  * @returns {Function} callable function to run
  *
  */


	_createClass(GPU, [{
		key: 'createKernel',
		value: function createKernel(fn, settings) {
			//
			// basic parameters safety checks
			//
			if (typeof fn === 'undefined') {
				throw 'Missing fn parameter';
			}
			if (!utils.isFunction(fn) && typeof fn !== 'string') {
				throw 'fn parameter not a function';
			}

			var mergedSettings = Object.assign({
				webGl: this._webGl,
				canvas: this._canvas
			}, settings || {});

			var kernel = this._runner.buildKernel(fn, mergedSettings);

			//if canvas didn't come from this, propagate from kernel
			if (!this._canvas) {
				this._canvas = kernel.getCanvas();
			}
			if (!this._runner.canvas) {
				this._runner.canvas = kernel.getCanvas();
			}

			this.kernels.push(kernel);

			return kernel;
		}

		/**
   *
   * Create a super kernel which executes sub kernels
   * and saves their output to be used with the next sub kernel.
   * This can be useful if we want to save the output on one kernel,
   * and then use it as an input to another kernel. *Machine Learning*
   *
   * @name createKernelMap
   * @function
   * @memberOf GPU#
   *
   * @param {Object|Array} subKernels - Sub kernels for this kernel
   * @param {Function} rootKernel - Root kernel
   *
   * @returns {Function} callable kernel function
   *
   * @example
   * const megaKernel = gpu.createKernelMap({
   *   addResult: function add(a, b) {
   *     return a[this.thread.x] + b[this.thread.x];
   *   },
   *   multiplyResult: function multiply(a, b) {
   *     return a[this.thread.x] * b[this.thread.x];
   *   },
   *  }, function(a, b, c) {
   *       return multiply(add(a, b), c);
   * });
   *
   * megaKernel(a, b, c);
   *
   * Note: You can also define subKernels as an array of functions.
   * > [add, multiply]
   *
   */

	}, {
		key: 'createKernelMap',
		value: function createKernelMap() {
			var fn = void 0;
			var settings = void 0;
			if (typeof arguments[arguments.length - 2] === 'function') {
				fn = arguments[arguments.length - 2];
				settings = arguments[arguments.length - 1];
			} else {
				fn = arguments[arguments.length - 1];
			}

			if (!utils.isWebGlDrawBuffersSupported()) {
				this._runner = new CPURunner(settings);
			}

			var kernel = this.createKernel(fn, settings);
			if (Array.isArray(arguments[0])) {
				var functions = arguments[0];
				for (var i = 0; i < functions.length; i++) {
					kernel.addSubKernel(functions[i]);
				}
			} else {
				var _functions = arguments[0];
				for (var p in _functions) {
					if (!_functions.hasOwnProperty(p)) continue;
					kernel.addSubKernelProperty(p, _functions[p]);
				}
			}

			return kernel;
		}

		/**
   *
   * Combine different kernels into one super Kernel,
   * useful to perform multiple operations inside one
   * kernel without the penalty of data transfer between
   * cpu and gpu.
   *
   * The number of kernel functions sent to this method can be variable.
   * You can send in one, two, etc.
   *
   * @name combineKernels
   * @function
   * @memberOf GPU#
   *
   * @param {Function} subKernels - Kernel function(s) to combine.
   * @param {Function} rootKernel - Root kernel to combine kernels into
   *
   * @example
   * 	combineKernels(add, multiply, function(a,b,c){
   *	 	return add(multiply(a,b), c)
   *	})
   *
   * @returns {Function} Callable kernel function
   *
   */

	}, {
		key: 'combineKernels',
		value: function combineKernels() {
			var lastKernel = arguments[arguments.length - 2];
			var combinedKernel = arguments[arguments.length - 1];
			if (this.getMode() === 'cpu') return combinedKernel;

			var canvas = arguments[0].getCanvas();
			var webGl = arguments[0].getWebGl();

			for (var i = 0; i < arguments.length - 1; i++) {
				arguments[i].setCanvas(canvas).setWebGl(webGl).setOutputToTexture(true);
			}

			return function () {
				combinedKernel.apply(null, arguments);
				var texSize = lastKernel.texSize;
				var gl = lastKernel.getWebGl();
				var threadDim = lastKernel.threadDim;
				var result = void 0;
				if (lastKernel.floatOutput) {
					var w = texSize[0];
					var h = Math.ceil(texSize[1] / 4);
					result = new Float32Array(w * h * 4);
					gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
				} else {
					var bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
					gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, bytes);
					result = new Float32Array(bytes.buffer);
				}

				result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

				if (lastKernel.output.length === 1) {
					return result;
				} else if (lastKernel.output.length === 2) {
					return utils.splitArray(result, lastKernel.output[0]);
				} else if (lastKernel.output.length === 3) {
					var cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
					return cube.map(function (x) {
						return utils.splitArray(x, lastKernel.output[0]);
					});
				}
			};
		}
	}, {
		key: 'getGPURunner',
		value: function getGPURunner() {
			if (typeof WebGL2RenderingContext !== 'undefined' && utils.isWebGl2Supported()) return WebGL2Runner;
			if (typeof WebGLRenderingContext !== 'undefined') return WebGLRunner;
		}

		/**
   *
   * Adds additional functions, that the kernel may call.
   *
   * @name addFunction
   * @function
   * @memberOf GPU#
   *
   * @param {Function|String} fn - JS Function to do conversion
   * @param {Object} options
   *
   * @returns {GPU} returns itself
   *
   */

	}, {
		key: 'addFunction',
		value: function addFunction(fn, options) {
			this._runner.functionBuilder.addFunction(null, fn, options);
			return this;
		}

		/**
   *
   * Adds additional native functions, that the kernel may call.
   *
   * @name addNativeFunction
   * @function
   * @memberOf GPU#
   *
   * @param {String} name - native function name, used for reverse lookup
   * @param {String} nativeFunction - the native function implementation, as it would be defined in it's entirety
   *
   * @returns {GPU} returns itself
   *
   */

	}, {
		key: 'addNativeFunction',
		value: function addNativeFunction(name, nativeFunction) {
			this._runner.functionBuilder.addNativeFunction(name, nativeFunction);
			return this;
		}

		/**
   *
   * Return the current mode in which gpu.js is executing.
   * @name getMode
   * @function
   * @memberOf GPU#
   *
   * @returns {String} The current mode, "cpu", "webgl", etc.
   *
   */

	}, {
		key: 'getMode',
		value: function getMode() {
			return this._runner.getMode();
		}

		/**
   *
   * Return TRUE, if browser supports WebGl AND Canvas
   *
   * @name get isWebGlSupported
   * @function
   * @memberOf GPU#
   *
   * Note: This function can also be called directly `GPU.isWebGlSupported()`
   *
   * @returns {Boolean} TRUE if browser supports webGl
   *
   */

	}, {
		key: 'isWebGlSupported',
		value: function isWebGlSupported() {
			return utils.isWebGlSupported();
		}

		/**
   *
   * Return TRUE, if system has integer division accuracy issue
   *
   * @name get hasIntegerDivisionAccuracyBug
   * @function
   * @memberOf GPU#
   *
   * Note: This function can also be called directly `GPU.hasIntegerDivisionAccuracyBug()`
   *
   * @returns {Boolean} TRUE if system has integer division accuracy issue
   *
   *
   */

	}, {
		key: 'hasIntegerDivisionAccuracyBug',
		value: function hasIntegerDivisionAccuracyBug() {
			return utils.hasIntegerDivisionAccuracyBug();
		}

		/**
   *
   * Return the canvas object bound to this gpu instance.
   *
   * @name getCanvas
   * @function
   * @memberOf GPU#
   *
   * @returns {Object} Canvas object if present
   *
   */

	}, {
		key: 'getCanvas',
		value: function getCanvas() {
			return this._canvas;
		}

		/**
   *
   * Return the webGl object bound to this gpu instance.
   *
   * @name getWebGl
   * @function
   * @memberOf GPU#
   *
   * @returns {Object} WebGl object if present
   *
   */

	}, {
		key: 'getWebGl',
		value: function getWebGl() {
			return this._webGl;
		}

		/**
   *
   * Destroys all memory associated with gpu.js & the webGl if we created it
   *
   * @name destroy
   * @function
   * @memberOf GPU#
   *
   *
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			var _this2 = this;

			// perform on next runloop - for some reason we dont get lose context events 
			// if webGl is created and destroyed in the same run loop.
			setTimeout(function () {
				var kernels = _this2.kernels;

				var destroyWebGl = !_this2._webGl && kernels.length && kernels[0]._webGl;
				for (var i = 0; i < _this2.kernels.length; i++) {
					_this2.kernels[i].destroy(true); // remove canvas if exists
				}

				if (destroyWebGl) {
					destroyWebGl.OES_texture_float = null;
					destroyWebGl.OES_texture_float_linear = null;
					destroyWebGl.OES_element_index_uint = null;
					var loseContextExt = destroyWebGl.getExtension('WEBGL_lose_context');
					if (loseContextExt) {
						loseContextExt.loseContext();
					}
				}
			}, 0);
		}
	}]);

	return GPU;
}(GPUCore);

;

// This ensure static methods are "inherited"
// See: https://stackoverflow.com/questions/5441508/how-to-inherit-static-methods-from-base-class-in-javascript
Object.assign(GPU, GPUCore);

module.exports = GPU;
},{"../backend/cpu/runner":73,"../backend/web-gl/runner":83,"../backend/web-gl/validator-kernel":86,"../backend/web-gl2/runner":90,"../backend/web-gl2/validator-kernel":93,"./gpu-core":95,"./utils":100}],97:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function Input(value, size) {
	_classCallCheck(this, Input);

	this.value = value;
	if (Array.isArray(size)) {
		this.size = [];
		for (var i = 0; i < size.length; i++) {
			this.size[i] = size[i];
		}
		while (this.size.length < 3) {
			this.size.push(1);
		}
	} else {
		if (size.z) {
			this.size = [size.x, size.y, size.z];
		} else if (size.y) {
			this.size = [size.x, size.y, 1];
		} else {
			this.size = [size.x, 1, 1];
		}
	}
};
},{}],98:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {

	/**
  * @desc WebGl Texture implementation in JS
  * @constructor Texture
  * @param {Object} texture
  * @param {Array} size
  * @param dimensions
  * @param {Array} output
  * @param {Object} webGl
  * @param {String} [type]
  */
	function Texture(texture, size, dimensions, output, webGl) {
		var type = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'NumberTexture';

		_classCallCheck(this, Texture);

		this.texture = texture;
		this.size = size;
		this.dimensions = dimensions;
		this.output = output;
		this.webGl = webGl;
		this.kernel = null;
		this.type = type;
	}

	/**
  * @name toArray
  * @function
  * @memberOf Texture#
  *
  * @desc Converts the Texture into a JavaScript Array.
  * 
  * @param {Object} The `gpu` Object
  *
  */


	_createClass(Texture, [{
		key: 'toArray',
		value: function toArray(gpu) {
			if (!gpu) throw new Error('You need to pass the GPU object for toArray to work.');
			if (this.kernel) return this.kernel(this);

			this.kernel = gpu.createKernel(function (x) {
				return x[this.thread.z][this.thread.y][this.thread.x];
			}).setOutput(this.output);

			return this.kernel(this);
		}

		/**
   * @name delete
   * @desc Deletes the Texture.
   * @function
   * @memberOf Texture#
   *
   *
   */

	}, {
		key: 'delete',
		value: function _delete() {
			return this.webGl.deleteTexture(this.texture);
		}
	}]);

	return Texture;
}();
},{}],99:[function(require,module,exports){
'use strict';

/**
 *
 * @desc Reduced subset of Utils, used exclusively in gpu-core.js
 * Various utility functions / snippets of code that GPU.JS uses internally.\
 * This covers various snippets of code that is not entirely gpu.js specific (ie. may find uses elsewhere)
 *
 * Note that all methods in this class is 'static' by nature `UtilsCore.functionName()`
 *
 * @class UtilsCore
 *
 */

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UtilsCore = function () {
	function UtilsCore() {
		_classCallCheck(this, UtilsCore);
	}

	_createClass(UtilsCore, null, [{
		key: 'isCanvas',


		/**
   * @typedef {Object} webGlContext
   */

		/**
   * @typedef {Object} CanvasDOMObject
   */

		//-----------------------------------------------------------------------------
		//
		//  Canvas validation and support
		//
		//-----------------------------------------------------------------------------

		/**
   * @name isCanvas
   * @static
   * @function
   * @memberOf UtilsCore
   *
   *
   * @desc Return TRUE, on a valid DOM canvas or OffscreenCanvas object
   *
   * Note: This does just a VERY simply sanity check. And may give false positives.
   *
   * @param {CanvasDOMObject} canvasObj - Object to validate
   *
   * @returns {Boolean} TRUE if the object is a DOM canvas or OffscreenCanvas
   *
   */
		value: function isCanvas(canvasObj) {
			return canvasObj !== null && (canvasObj.nodeName && canvasObj.getContext && canvasObj.nodeName.toUpperCase() === 'CANVAS' || typeof OffscreenCanvas !== 'undefined' && canvasObj instanceof OffscreenCanvas);
		}

		/**
   * @name isCanvasSupported
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Return TRUE, if browser supports canvas
   *
   * @returns {Boolean} TRUE if browser supports canvas
   *
   */

	}, {
		key: 'isCanvasSupported',
		value: function isCanvasSupported() {
			return _isCanvasSupported;
		}

		/**
   * @name initCanvas
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Initiate and returns a canvas, for usage in init_webgl.
   * Returns only if canvas is supported by browser.
   *
   * @returns {CanvasDOMObject} CanvasDOMObject if supported by browser, else null
   *
   */

	}, {
		key: 'initCanvas',
		value: function initCanvas() {
			// Fail fast if browser previously detected no support
			if (!_isCanvasSupported) {
				return null;
			}

			// Create a new canvas DOM
			var canvas = typeof document !== 'undefined' ? document.createElement('canvas') : new OffscreenCanvas(0, 0);

			// Default width and height, to fix webgl issue in safari
			canvas.width = 2;
			canvas.height = 2;

			// Returns the canvas
			return canvas;
		}

		//-----------------------------------------------------------------------------
		//
		//  Webgl validation and support
		//
		//-----------------------------------------------------------------------------


		/**
   *
   * @name isWebGl
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Return TRUE, on a valid webGlContext object
   *
   * Note: This does just a VERY simply sanity check. And may give false positives.
   *
   * @param {webGlContext} webGlObj - Object to validate
   *
   * @returns {Boolean} TRUE if the object is a webGlContext object
   *
   */

	}, {
		key: 'isWebGl',
		value: function isWebGl(webGlObj) {
			return webGlObj && typeof webGlObj.getExtension === 'function';
		}

		/**
   *
   * @name isWebGl2
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Return TRUE, on a valid webGl2Context object
   *
   * Note: This does just a VERY simply sanity check. And may give false positives.
   *
   * @param {webGlContext} webGl2Obj - Object to validate
   *
   * @returns {Boolean} TRUE if the object is a webGl2Context object
   *
   */

	}, {
		key: 'isWebGl2',
		value: function isWebGl2(webGl2Obj) {
			return webGl2Obj && typeof WebGL2RenderingContext !== 'undefined' && webGl2Obj instanceof WebGL2RenderingContext;
		}

		/**
   * @name isWebGlSupported
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Return TRUE, if browser supports webgl
   *
   * @returns {Boolean} TRUE if browser supports webgl
   *
   */

	}, {
		key: 'isWebGlSupported',
		value: function isWebGlSupported() {
			return _isWebGlSupported;
		}

		/**
   * @name isWebGlSupported2
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Return TRUE, if browser supports webgl2
   *
   * @returns {Boolean} TRUE if browser supports webgl2
   *
   */

	}, {
		key: 'isWebGl2Supported',
		value: function isWebGl2Supported() {
			return _isWebGl2Supported;
		}
	}, {
		key: 'isWebGlDrawBuffersSupported',
		value: function isWebGlDrawBuffersSupported() {
			return _isWebGlDrawBuffersSupported;
		}

		// Default webgl options to use

	}, {
		key: 'initWebGlDefaultOptions',
		value: function initWebGlDefaultOptions() {
			return {
				alpha: false,
				depth: false,
				antialias: false
			};
		}

		/**
   * @name initWebGl
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Initiate and returns a webGl, from a canvas object
   * Returns only if webGl is supported by browser.
   *
   * @param {CanvasDOMObject} canvasObj - Object to validate
   *
   * @returns {CanvasDOMObject} CanvasDOMObject if supported by browser, else null
   *
   */

	}, {
		key: 'initWebGl',
		value: function initWebGl(canvasObj) {

			// First time setup, does the browser support check memorizer
			if (typeof _isCanvasSupported !== 'undefined' || canvasObj === null) {
				if (!_isCanvasSupported) {
					return null;
				}
			}

			// Fail fast for invalid canvas object
			if (!UtilsCore.isCanvas(canvasObj)) {
				throw new Error('Invalid canvas object - ' + canvasObj);
			}

			// Create a new canvas DOM
			var webGl = null;
			var defaultOptions = UtilsCore.initWebGlDefaultOptions();
			try {
				webGl = canvasObj.getContext('experimental-webgl', defaultOptions);
			} catch (e) {
				// 'experimental-webgl' is not a supported context type
				// fallback to 'webgl2' or 'webgl' below
			}

			if (webGl === null) {
				webGl = canvasObj.getContext('webgl2', defaultOptions) || canvasObj.getContext('webgl', defaultOptions);
			}

			if (webGl) {
				// Get the extension that is needed
				webGl.OES_texture_float = webGl.getExtension('OES_texture_float');
				webGl.OES_texture_float_linear = webGl.getExtension('OES_texture_float_linear');
				webGl.OES_element_index_uint = webGl.getExtension('OES_element_index_uint');
			}

			// Returns the canvas
			return webGl;
		}

		/**
   * @name initWebGl2
   * @function
   * @static
   * @memberOf UtilsCore
   *
   * @desc Initiate and returns a webGl, from a canvas object
   * Returns only if webGl is supported by browser.
   *
   * @param {CanvasDOMObject} canvasObj - Object to validate
   *
   * @returns {CanvasDOMObject} CanvasDOMObject if supported by browser, else null
   *
   */

	}, {
		key: 'initWebGl2',
		value: function initWebGl2(canvasObj) {

			// First time setup, does the browser support check memorizer
			if (typeof _isCanvasSupported !== 'undefined' || canvasObj === null) {
				if (!_isCanvasSupported) {
					return null;
				}
			}

			// Fail fast for invalid canvas object
			if (!UtilsCore.isCanvas(canvasObj)) {
				throw new Error('Invalid canvas object - ' + canvasObj);
			}

			// Create a new canvas DOM
			return canvasObj.getContext('webgl2', UtilsCore.initWebGlDefaultOptions());
		}

		/**
   * @function
   * @static
   * @memberOf UtilsCore
   * @param {number[]} output
   * @throws if not correctly defined
   */

	}, {
		key: 'checkOutput',
		value: function checkOutput(output) {
			if (!output || !Array.isArray(output)) throw new Error('kernel.output not an array');
			for (var i = 0; i < output.length; i++) {
				if (isNaN(output[i]) || output[i] < 1) {
					throw new Error('kernel.output[' + i + '] incorrectly defined as `' + output[i] + '`, needs to be numeric, and greater than 0');
				}
			}
		}
	}]);

	return UtilsCore;
}();

//-----------------------------------------------------------------------------
//
//  Canvas & Webgl validation and support constants
//
//-----------------------------------------------------------------------------

var _isCanvasSupported = typeof document !== 'undefined' ? UtilsCore.isCanvas(document.createElement('canvas')) : typeof OffscreenCanvas !== 'undefined';
var _testingWebGl = UtilsCore.initWebGl(UtilsCore.initCanvas());
var _testingWebGl2 = UtilsCore.initWebGl2(UtilsCore.initCanvas());
var _isWebGlSupported = UtilsCore.isWebGl(_testingWebGl);
var _isWebGl2Supported = UtilsCore.isWebGl2(_testingWebGl2);
var _isWebGlDrawBuffersSupported = _isWebGlSupported && Boolean(_testingWebGl.getExtension('WEBGL_draw_buffers'));

if (_isWebGlSupported) {
	UtilsCore.OES_texture_float = _testingWebGl.OES_texture_float;
	UtilsCore.OES_texture_float_linear = _testingWebGl.OES_texture_float_linear;
	UtilsCore.OES_element_index_uint = _testingWebGl.OES_element_index_uint;
} else {
	UtilsCore.OES_texture_float = false;
	UtilsCore.OES_texture_float_linear = false;
	UtilsCore.OES_element_index_uint = false;
}

module.exports = UtilsCore;
},{}],100:[function(require,module,exports){
'use strict';

/**
 * 
 * @classdesc Various utility functions / snippets of code that GPU.JS uses internally.\
 * This covers various snippets of code that is not entirely gpu.js specific (ie. may find uses elsewhere)
 *
 * Note that all methods in this class are *static* by nature `Utils.functionName()`
 * 
 * @class Utils
 * @extends UtilsCore
 *
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UtilsCore = require("./utils-core");
var Input = require('./input');
var Texture = require('./texture');
// FUNCTION_NAME regex
var FUNCTION_NAME = /function ([^(]*)/;

// STRIP COMMENTS regex
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

// ARGUMENT NAMES regex
var ARGUMENT_NAMES = /([^\s,]+)/g;

var _systemEndianness = function () {
	var b = new ArrayBuffer(4);
	var a = new Uint32Array(b);
	var c = new Uint8Array(b);
	a[0] = 0xdeadbeef;
	if (c[0] === 0xef) return 'LE';
	if (c[0] === 0xde) return 'BE';
	throw new Error('unknown endianness');
}();

var _isFloatReadPixelsSupported = null;
var _isFloatReadPixelsSupportedWebGL2 = null;

var _isMixedIdentifiersSupported = function () {
	try {
		new Function('let i = 1; const j = 1;')();
		return true;
	} catch (e) {
		return false;
	}
}();

var _hasIntegerDivisionAccuracyBug = null;

/**
 * @class
 * @extends UtilsCore
 */

var Utils = function (_UtilsCore) {
	_inherits(Utils, _UtilsCore);

	function Utils() {
		_classCallCheck(this, Utils);

		return _possibleConstructorReturn(this, (Utils.__proto__ || Object.getPrototypeOf(Utils)).apply(this, arguments));
	}

	_createClass(Utils, null, [{
		key: 'systemEndianness',


		//-----------------------------------------------------------------------------
		//
		//  System values support (currently only endianness)
		//
		//-----------------------------------------------------------------------------

		/**
   * @memberOf Utils
   * @name systemEndianness
   * @function
   * @static
   *
   * Gets the system endianness, and cache it
   *
   * @returns {String} 'LE' or 'BE' depending on system architecture
   *
   * Credit: https://gist.github.com/TooTallNate/4750953
   */
		value: function systemEndianness() {
			return _systemEndianness;
		}

		//-----------------------------------------------------------------------------
		//
		//  Function and function string validations
		//
		//-----------------------------------------------------------------------------

		/**
   * @memberOf Utils
   * @name isFunction
   * @function
   * @static
   *
   * Return TRUE, on a JS function
   *
   * @param {Function} funcObj - Object to validate if its a function
   *
   * @returns	{Boolean} TRUE if the object is a JS function
   *
   */

	}, {
		key: 'isFunction',
		value: function isFunction(funcObj) {
			return typeof funcObj === 'function';
		}

		/**
   * @memberOf Utils
   * @name isFunctionString
   * @function
   * @static
   *
   * Return TRUE, on a valid JS function string
   *
   * Note: This does just a VERY simply sanity check. And may give false positives.
   *
   * @param {String} funcStr - String of JS function to validate
   *
   * @returns {Boolean} TRUE if the string passes basic validation
   *
   */

	}, {
		key: 'isFunctionString',
		value: function isFunctionString(funcStr) {
			if (funcStr !== null) {
				return funcStr.toString().slice(0, 'function'.length).toLowerCase() === 'function';
			}
			return false;
		}

		/**
   * @memberOf Utils
   * @name getFunctionName_fromString
   * @function
   * @static
   *
   * Return the function name from a JS function string
   *
   * @param {String} funcStr - String of JS function to validate
   *
   * @returns {String} Function name string (if found)
   *
   */

	}, {
		key: 'getFunctionNameFromString',
		value: function getFunctionNameFromString(funcStr) {
			return FUNCTION_NAME.exec(funcStr)[1];
		}
	}, {
		key: 'getFunctionBodyFromString',
		value: function getFunctionBodyFromString(funcStr) {
			return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
		}

		/**
   * @memberOf Utils
   * @name getParamNames_fromString
   * @function
   * @static
   *
   * Return list of parameter names extracted from the JS function string
   *
   * @param {String} funcStr - String of JS function to validate
   *
   * @returns {String[]}  Array representing all the parameter names
   *
   */

	}, {
		key: 'getParamNamesFromString',
		value: function getParamNamesFromString(func) {
			var fnStr = func.toString().replace(STRIP_COMMENTS, '');
			var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
			if (result === null) result = [];
			return result;
		}

		//-----------------------------------------------------------------------------
		//
		//  Object / function cloning and manipulation
		//
		//-----------------------------------------------------------------------------

		/**
   * @memberOf Utils
   * @name clone
   * @function
   * @static
   *
   * Returns a clone
   *
   * @param {Object} obj - Object to clone
   *
   * @returns {Object}  Cloned object
   *
   */

	}, {
		key: 'clone',
		value: function clone(obj) {
			if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

			var temp = obj.constructor(); // changed

			for (var key in obj) {
				if (Object.prototype.hasOwnProperty.call(obj, key)) {
					obj.isActiveClone = null;
					temp[key] = Utils.clone(obj[key]);
					delete obj.isActiveClone;
				}
			}

			return temp;
		}

		/**
   * @memberOf Utils
   * @name newPromise
   * @function
   * @static
   *
   * Returns a `new Promise` object based on the underlying implmentation
   *
   * @param {Function} executor - Promise builder function
   *
   * @returns {Promise}  Promise object
   *
   */

	}, {
		key: 'newPromise',
		value: function newPromise(executor) {
			var simple = Promise || small_promise;
			if (simple === null) {
				throw TypeError('Browser is missing Promise implementation. Consider adding small_promise.js polyfill');
			}
			return new simple(executor);
		}

		/**
   * @memberOf Utils
   * @name functionBinder
   * @function
   * @static
   *
   * Limited implementation of Function.bind, with fallback
   *
   * @param {Function} inFunc - to setup bind on
   * @param {Object} thisObj - The this parameter to assume inside the binded function
   *
   * @returns {Function}  The binded function
   *
   */

	}, {
		key: 'functionBinder',
		value: function functionBinder(inFunc, thisObj) {
			if (inFunc.bind) {
				return inFunc.bind(thisObj);
			}

			return function () {
				var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
				return inFunc.apply(thisObj, args);
			};
		}

		/**
   * @memberOf Utils
   * @name isArray
   * @function
   * @static
   *
   * * Checks if is an array or Array-like object
   *
   * @param {Object} arg - The argument object to check if is array
   *
   * @returns {Boolean}  true if is array or Array-like object
   *
   */

	}, {
		key: 'isArray',
		value: function isArray(array) {
			if (isNaN(array.length)) {
				return false;
			}

			return true;
		}

		/**
   * @memberOf Utils
   * @name getArgumentType
   * @function
   * @static
   *
   * Evaluate the argument type, to apply respective logic for it
   *
   * @param {Object} arg - The argument object to evaluate type
   *
   * @returns {String}  Argument type Array/Number/Float/Texture/Unknown
   *
   */

	}, {
		key: 'getArgumentType',
		value: function getArgumentType(arg) {
			if (Utils.isArray(arg)) {
				if (arg[0].nodeName === 'IMG') {
					return 'HTMLImageArray';
				}
				return 'Array';
			} else if (typeof arg === 'number') {
				if (Number.isInteger(arg)) {
					return 'Integer';
				}
				return 'Float';
			} else if (arg instanceof Texture) {
				return arg.type;
			} else if (arg instanceof Input) {
				return 'Input';
			} else if (arg.nodeName === 'IMG') {
				return 'HTMLImage';
			} else {
				return 'Unknown';
			}
		}
		/**
   * @typedef {Object} gpuJSObject
   */

		/**
   * @memberOf Utils
   * @name isFloatReadPixelsSupported
   * @function
   * @static
   *
   * Checks if the browser supports readPixels with float type
   *
   * @returns {Boolean} true if browser supports
   *
   */

	}, {
		key: 'isFloatReadPixelsSupported',
		value: function isFloatReadPixelsSupported() {
			if (_isFloatReadPixelsSupported !== null) {
				return _isFloatReadPixelsSupported;
			}

			var GPU = require('../index');
			var gpu = new GPU({
				mode: 'webgl-validator'
			});
			var x = gpu.createKernel(function () {
				return 1;
			}, {
				output: [2],
				floatTextures: true,
				floatOutput: true,
				floatOutputForce: true
			})();

			_isFloatReadPixelsSupported = x[0] === 1;
			gpu.destroy();
			return _isFloatReadPixelsSupported;
		}

		/**
   * @memberOf Utils
   * @name isFloatReadPixelsSupportedWebGL2
   * @function
   * @static
   *
   * Checks if the browser supports readPixels with float type
   *
   * @returns {Boolean} true if browser supports
   *
   */

	}, {
		key: 'isFloatReadPixelsSupportedWebGL2',
		value: function isFloatReadPixelsSupportedWebGL2() {
			if (_isFloatReadPixelsSupportedWebGL2 !== null) {
				return _isFloatReadPixelsSupportedWebGL2;
			}

			var GPU = require('../index');
			var gpu = new GPU({
				mode: 'webgl2-validator'
			});
			var x = gpu.createKernel(function () {
				return 1;
			}, {
				output: [2],
				floatTextures: true,
				floatOutput: true,
				floatOutputForce: true
			})();

			_isFloatReadPixelsSupportedWebGL2 = x[0] === 1;
			gpu.destroy();
			return _isFloatReadPixelsSupportedWebGL2;
		}

		/**
   * @memberOf Utils
   * @name hasIntegerDivisionAccuracyBug
   * @function
   * @static
   *
   * Checks if the system has inaccuracies when dividing integers
   *
   * @returns {Boolean} true if bug is exhibited on this system
   *
   */

	}, {
		key: 'hasIntegerDivisionAccuracyBug',
		value: function hasIntegerDivisionAccuracyBug() {
			if (_hasIntegerDivisionAccuracyBug !== null) {
				return _hasIntegerDivisionAccuracyBug;
			}

			var GPU = require('../index');
			var gpu = new GPU({
				mode: 'webgl-validator'
			});
			var x = gpu.createKernel(function (v1, v2) {
				return v1[this.thread.x] / v2[this.thread.x];
			}, {
				output: [1]
			})([6, 6030401], [3, 3991]);

			// have we not got whole numbers for 6/3 or 6030401/3991
			// add more here if others see this problem
			_hasIntegerDivisionAccuracyBug = x[0] !== 2 || x[1] !== 1511;
			gpu.destroy();
			return _hasIntegerDivisionAccuracyBug;
		}
	}, {
		key: 'isMixedIdentifiersSupported',
		value: function isMixedIdentifiersSupported() {
			return _isMixedIdentifiersSupported;
		}
	}, {
		key: 'dimToTexSize',
		value: function dimToTexSize(opt, dimensions, output) {
			var numTexels = dimensions[0];
			var w = dimensions[0];
			var h = dimensions[1];
			for (var i = 1; i < dimensions.length; i++) {
				numTexels *= dimensions[i];
			}

			if (opt.floatTextures && (!output || opt.floatOutput)) {
				w = numTexels = Math.ceil(numTexels / 4);
			}
			// if given dimensions == a 2d image
			if (h > 1 && w * h === numTexels) {
				return [w, h];
			}
			// find as close to square width, height sizes as possible
			var sqrt = Math.sqrt(numTexels);
			var high = Math.ceil(sqrt);
			var low = Math.floor(sqrt);
			while (high * low > numTexels) {
				high--;
				low = Math.ceil(numTexels / high);
			}
			w = low;
			h = Math.ceil(numTexels / w);
			return [w, h];
		}

		/**
   * @memberOf Utils
   * @name getDimensions
   * @function
   * @static
   *
   * Return the dimension of an array.
   * 
   * @param {Array|String} x - The array
   * @param {number} [pad] - To include padding in the dimension calculation [Optional]
   *
   *
   *
   */

	}, {
		key: 'getDimensions',
		value: function getDimensions(x, pad) {
			var ret = void 0;
			if (Utils.isArray(x)) {
				var dim = [];
				var temp = x;
				while (Utils.isArray(temp)) {
					dim.push(temp.length);
					temp = temp[0];
				}
				ret = dim.reverse();
			} else if (x instanceof Texture) {
				ret = x.output;
			} else if (x instanceof Input) {
				ret = x.size;
			} else {
				throw 'Unknown dimensions of ' + x;
			}

			if (pad) {
				ret = Utils.clone(ret);
				while (ret.length < 3) {
					ret.push(1);
				}
			}
			// return ret;
			return new Int32Array(ret);
		}

		/**
   * @memberOf Utils
   * @name pad
   * @function
   * @static
   *
   * Pad an array AND its elements with leading and ending zeros
   *
   * @param {Array} arr - the array to pad zeros to
   * @param {number} padding - amount of padding
   *
   * @returns {Array} Array with leading and ending zeros, and all the elements padded by zeros.
   *
   */

	}, {
		key: 'pad',
		value: function pad(arr, padding) {
			function zeros(n) {
				return Array.apply(null, new Array(n)).map(Number.prototype.valueOf, 0);
			}

			var len = arr.length + padding * 2;

			var ret = arr.map(function (x) {
				return [].concat(zeros(padding), x, zeros(padding));
			});

			for (var i = 0; i < padding; i++) {
				ret = [].concat([zeros(len)], ret, [zeros(len)]);
			}

			return ret;
		}

		/**
   * @memberOf Utils
   * @name flatten2dArrayTo
   * @function
   * @static
   *
   * Puts a nested 2d array into a one-dimensional target array
   * @param {Array|*} array
   * @param {Float32Array|Float64Array} target
   */

	}, {
		key: 'flatten2dArrayTo',
		value: function flatten2dArrayTo(array, target) {
			var offset = 0;
			for (var y = 0; y < array.length; y++) {
				target.set(array[y], offset);
				offset += array[y].length;
			}
		}

		/**
   * @memberOf Utils
   * @name flatten3dArrayTo
   * @function
   * @static
   *
   * Puts a nested 3d array into a one-dimensional target array
   * @param {Array|*} array
   * @param {Float32Array|Float64Array} target
   */

	}, {
		key: 'flatten3dArrayTo',
		value: function flatten3dArrayTo(array, target) {
			var offset = 0;
			for (var z = 0; z < array.length; z++) {
				for (var y = 0; y < array[z].length; y++) {
					target.set(array[z][y], offset);
					offset += array[z][y].length;
				}
			}
		}

		/**
   * @memberOf Utils
   * @name flatten3dArrayTo
   * @function
   * @static
   *
   * Puts a nested 1d, 2d, or 3d array into a one-dimensional target array
   * @param {Array|*} array
   * @param {Float32Array|Float64Array} target
   */

	}, {
		key: 'flattenTo',
		value: function flattenTo(array, target) {
			if (Utils.isArray(array[0])) {
				if (Utils.isArray(array[0][0])) {
					Utils.flatten3dArrayTo(array, target);
				} else {
					Utils.flatten2dArrayTo(array, target);
				}
			} else {
				target.set(array);
			}
		}

		/**
   * @memberOf Utils
   * @name splitArray
   * @function
   * @static
   *
   * Splits an array into smaller arrays.
   * Number of elements in one small chunk is given by `part`
   *
   * @param {Array} array - The array to split into chunks
   * @param {Array} part - elements in one chunk
   *
  	 * @returns {Array} An array of smaller chunks
   *
   */

	}, {
		key: 'splitArray',
		value: function splitArray(array, part) {
			var result = [];
			for (var i = 0; i < array.length; i += part) {
				result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
			}
			return result;
		}
	}, {
		key: 'getAstString',
		value: function getAstString(source, ast) {
			var lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
			var start = ast.loc.start;
			var end = ast.loc.end;
			var result = [];
			result.push(lines[start.line - 1].slice(start.column));
			for (var i = start.line; i < end.line - 1; i++) {
				result.push(lines[i]);
			}
			result.push(lines[end.line - 1].slice(0, end.column));
			return result.join('\n');
		}
	}, {
		key: 'allPropertiesOf',
		value: function allPropertiesOf(obj) {
			var props = [];

			do {
				props.push.apply(props, Object.getOwnPropertyNames(obj));
			} while (obj = Object.getPrototypeOf(obj));

			return props;
		}
	}]);

	return Utils;
}(UtilsCore);

// This ensure static methods are "inherited"
// See: https://stackoverflow.com/questions/5441508/how-to-inherit-static-methods-from-base-class-in-javascript


Object.assign(Utils, UtilsCore);

module.exports = Utils;
},{"../index":101,"./input":97,"./texture":98,"./utils-core":99}],101:[function(require,module,exports){
'use strict';

var GPU = require('./core/gpu');
var alias = require('./core/alias');
var utils = require('./core/utils');
var Input = require('./core/input');
var Texture = require('./core/texture');

var CPUFunctionBuilder = require('./backend/cpu/function-builder');
var CPUFunctionNode = require('./backend/cpu/function-node');
var CPUKernel = require('./backend/cpu/kernel');
var CPURunner = require('./backend/cpu/runner');

var WebGLFunctionBuilder = require('./backend/web-gl/function-builder');
var WebGLFunctionNode = require('./backend/web-gl/function-node');
var WebGLKernel = require('./backend/web-gl/kernel');
var WebGLRunner = require('./backend/web-gl/runner');

var WebGL2FunctionBuilder = require('./backend/web-gl2/function-builder');
var WebGL2FunctionNode = require('./backend/web-gl2/function-node');
var WebGL2Kernel = require('./backend/web-gl2/kernel');
var WebGL2Runner = require('./backend/web-gl2/runner');

GPU.alias = alias;
GPU.utils = utils;
GPU.Texture = Texture;
GPU.Input = Input;
GPU.input = function (value, size) {
	return new Input(value, size);
};

GPU.CPUFunctionBuilder = CPUFunctionBuilder;
GPU.CPUFunctionNode = CPUFunctionNode;
GPU.CPUKernel = CPUKernel;
GPU.CPURunner = CPURunner;

GPU.WebGLFunctionBuilder = WebGLFunctionBuilder;
GPU.WebGLFunctionNode = WebGLFunctionNode;
GPU.WebGLKernel = WebGLKernel;
GPU.WebGLRunner = WebGLRunner;

GPU.WebGL2FunctionBuilder = WebGL2FunctionBuilder;
GPU.WebGL2FunctionNode = WebGL2FunctionNode;
GPU.WebGL2Kernel = WebGL2Kernel;
GPU.WebGL2Runner = WebGL2Runner;

if (typeof module !== 'undefined') {
	module.exports = GPU;
}
if (typeof window !== 'undefined') {
	window.GPU = GPU;
}
if (typeof self !== 'undefined') {
	self.GPU = GPU;
}
},{"./backend/cpu/function-builder":69,"./backend/cpu/function-node":70,"./backend/cpu/kernel":72,"./backend/cpu/runner":73,"./backend/web-gl/function-builder":79,"./backend/web-gl/function-node":80,"./backend/web-gl/kernel":82,"./backend/web-gl/runner":83,"./backend/web-gl2/function-builder":87,"./backend/web-gl2/function-node":88,"./backend/web-gl2/kernel":89,"./backend/web-gl2/runner":90,"./core/alias":94,"./core/gpu":96,"./core/input":97,"./core/texture":98,"./core/utils":100}],102:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.acorn = {})));
}(this, (function (exports) { 'use strict';

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Registered plugins
var plugins = {};

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Load plugins
  this.loadPlugins(options.plugins);

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false;
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterFunctionScope();

  // For RegExp validation
  this.regexpState = null;
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };

Parser.prototype.extend = function extend (name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];
    if (!plugin) { throw new Error("Plugin '" + name + "' not found") }
    plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
pp.strictDirective = function(start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"};
var switchLabel = {kind: "switch"};

pp$1.isLet = function() {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet()) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false)
  case types._class:
    if (!declaration) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (!declaration && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock()
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (!declaration) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var this$1 = this;

  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
        !(kind !== "var" && init$1.declarations[0].init)) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict && this.type === types._function);
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope();

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;
      if (cur) { this$1.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();
      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this$1.expect(types.colon);
    } else {
      if (!cur) { this$1.unexpected(); }
      cur.consequent.push(this$1.parseStatement(true));
    }
  }
  this.exitLexicalScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      this.enterLexicalScope();
      this.checkLVal(clause.param, "let");
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterLexicalScope();
    }
    clause.body = this.parseBlock(false);
    this.exitLexicalScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this$1.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(true);
  if (node.body.type === "ClassDeclaration" ||
      node.body.type === "VariableDeclaration" && node.body.kind !== "var" ||
      node.body.type === "FunctionDeclaration" && (this.strict || node.body.generator || node.body.async))
    { this.raiseRecoverable(node.body.start, "Invalid labeled declaration"); }
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;

  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) {
    this.enterLexicalScope();
  }
  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) {
    this.exitLexicalScope();
  }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  if (type === "ForInStatement") {
    if (init.type === "AssignmentPattern" ||
      (init.type === "VariableDeclaration" && init.declarations[0].init != null &&
       (this.strict || init.declarations[0].id.type !== "Identifier")))
      { this.raise(init.start, "Invalid assignment in for-in loop head"); }
  }
  node.left = init;
  node.right = type === "ForInStatement" ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type)
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);
    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
      this$1.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
    if (!this$1.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)
    { node.generator = this.eat(types.star); }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (isStatement) {
    node.id = isStatement === "nullableID" && this.type !== types.name ? null : this.parseIdent();
    if (node.id) {
      this.checkLVal(node.id, this.inModule && !this.inFunction ? "let" : "var");
    }
  }

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement)
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  var this$1 = this;

  this.next();

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var member = this$1.parseClassMember(classBody);
    if (member && member.type === "MethodDefinition" && member.kind === "constructor") {
      if (hadConstructor) { this$1.raise(member.start, "Duplicate constructor in the same class"); }
      hadConstructor = true;
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassMember = function(classBody) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(classBody, method, isGenerator, isAsync);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function(node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  var this$1 = this;

  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];

        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this$1.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this$1.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  var this$1 = this;

  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var this$1 = this;

  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var this$1 = this;

  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, "let");
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, "let");
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);
    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this$1.checkLVal(node$2.local, "let");
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Can not use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this$1.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this$1.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this$1.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this$1.expect(types.comma); }
    if (allowEmpty && this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);
      if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
      this$1.expect(close);
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval  something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType && bindingType !== "none") {
      if (
        bindingType === "var" && !this.canDeclareVarName(expr.name) ||
        bindingType !== "var" && !this.canDeclareLexicalName(expr.name)
      ) {
        this.raiseRecoverable(expr.start, ("Identifier '" + (expr.name) + "' has already been declared"));
      }
      if (bindingType === "var") {
        this.declareVarName(expr.name);
      } else {
        this.declareLexicalName(expr.name);
      }
    }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this$1.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) { return this.parseYield() }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  for (var computed = (void 0);;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;
      if (computed) { this$1.expect(types.bracketR); }
      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({isTagged: true});
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base
    }
  }
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.inFunction)
      { this.raise(this.start, "'super' outside of function or class"); }
    node = this.startNode();
    this.next();
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(this.type !== types.name);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent();
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, false)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected();
  }
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
        if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inFunction)
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  var this$1 = this;
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this$1.type === types.eof) { this$1.raise(this$1.pos, "Unterminated template literal"); }
    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    this.checkUnreserved(prop.key);
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.enterFunctionScope();
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitFunctionScope();

  if (this.strict && node.id) {
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    this.checkLVal(node.id, "none");
  }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this$1.type === types.comma)
      { elt = null; }
    else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this$1.start; }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function"); }
  if (this.isKeyword(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Can not use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved === "never") { liberal = false; }
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) { this.checkUnreserved(node); }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function() {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

// Object.assign polyfill
var assign = Object.assign || function(target) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  for (var i = 0, list = sources; i < list.length; i += 1) {
    var source = list[i];

    for (var key in source) {
      if (has(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterFunctionScope = function() {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});
};

pp$5.exitFunctionScope = function() {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function() {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function() {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};

/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */
pp$5.canDeclareVarName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)
};

/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */
pp$5.canDeclareLexicalName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)
};

pp$5.declareVarName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this$1.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

var data = {
  "$LONE": [
    "ASCII",
    "ASCII_Hex_Digit",
    "AHex",
    "Alphabetic",
    "Alpha",
    "Any",
    "Assigned",
    "Bidi_Control",
    "Bidi_C",
    "Bidi_Mirrored",
    "Bidi_M",
    "Case_Ignorable",
    "CI",
    "Cased",
    "Changes_When_Casefolded",
    "CWCF",
    "Changes_When_Casemapped",
    "CWCM",
    "Changes_When_Lowercased",
    "CWL",
    "Changes_When_NFKC_Casefolded",
    "CWKCF",
    "Changes_When_Titlecased",
    "CWT",
    "Changes_When_Uppercased",
    "CWU",
    "Dash",
    "Default_Ignorable_Code_Point",
    "DI",
    "Deprecated",
    "Dep",
    "Diacritic",
    "Dia",
    "Emoji",
    "Emoji_Component",
    "Emoji_Modifier",
    "Emoji_Modifier_Base",
    "Emoji_Presentation",
    "Extender",
    "Ext",
    "Grapheme_Base",
    "Gr_Base",
    "Grapheme_Extend",
    "Gr_Ext",
    "Hex_Digit",
    "Hex",
    "IDS_Binary_Operator",
    "IDSB",
    "IDS_Trinary_Operator",
    "IDST",
    "ID_Continue",
    "IDC",
    "ID_Start",
    "IDS",
    "Ideographic",
    "Ideo",
    "Join_Control",
    "Join_C",
    "Logical_Order_Exception",
    "LOE",
    "Lowercase",
    "Lower",
    "Math",
    "Noncharacter_Code_Point",
    "NChar",
    "Pattern_Syntax",
    "Pat_Syn",
    "Pattern_White_Space",
    "Pat_WS",
    "Quotation_Mark",
    "QMark",
    "Radical",
    "Regional_Indicator",
    "RI",
    "Sentence_Terminal",
    "STerm",
    "Soft_Dotted",
    "SD",
    "Terminal_Punctuation",
    "Term",
    "Unified_Ideograph",
    "UIdeo",
    "Uppercase",
    "Upper",
    "Variation_Selector",
    "VS",
    "White_Space",
    "space",
    "XID_Continue",
    "XIDC",
    "XID_Start",
    "XIDS"
  ],
  "General_Category": [
    "Cased_Letter",
    "LC",
    "Close_Punctuation",
    "Pe",
    "Connector_Punctuation",
    "Pc",
    "Control",
    "Cc",
    "cntrl",
    "Currency_Symbol",
    "Sc",
    "Dash_Punctuation",
    "Pd",
    "Decimal_Number",
    "Nd",
    "digit",
    "Enclosing_Mark",
    "Me",
    "Final_Punctuation",
    "Pf",
    "Format",
    "Cf",
    "Initial_Punctuation",
    "Pi",
    "Letter",
    "L",
    "Letter_Number",
    "Nl",
    "Line_Separator",
    "Zl",
    "Lowercase_Letter",
    "Ll",
    "Mark",
    "M",
    "Combining_Mark",
    "Math_Symbol",
    "Sm",
    "Modifier_Letter",
    "Lm",
    "Modifier_Symbol",
    "Sk",
    "Nonspacing_Mark",
    "Mn",
    "Number",
    "N",
    "Open_Punctuation",
    "Ps",
    "Other",
    "C",
    "Other_Letter",
    "Lo",
    "Other_Number",
    "No",
    "Other_Punctuation",
    "Po",
    "Other_Symbol",
    "So",
    "Paragraph_Separator",
    "Zp",
    "Private_Use",
    "Co",
    "Punctuation",
    "P",
    "punct",
    "Separator",
    "Z",
    "Space_Separator",
    "Zs",
    "Spacing_Mark",
    "Mc",
    "Surrogate",
    "Cs",
    "Symbol",
    "S",
    "Titlecase_Letter",
    "Lt",
    "Unassigned",
    "Cn",
    "Uppercase_Letter",
    "Lu"
  ],
  "Script": [
    "Adlam",
    "Adlm",
    "Ahom",
    "Anatolian_Hieroglyphs",
    "Hluw",
    "Arabic",
    "Arab",
    "Armenian",
    "Armn",
    "Avestan",
    "Avst",
    "Balinese",
    "Bali",
    "Bamum",
    "Bamu",
    "Bassa_Vah",
    "Bass",
    "Batak",
    "Batk",
    "Bengali",
    "Beng",
    "Bhaiksuki",
    "Bhks",
    "Bopomofo",
    "Bopo",
    "Brahmi",
    "Brah",
    "Braille",
    "Brai",
    "Buginese",
    "Bugi",
    "Buhid",
    "Buhd",
    "Canadian_Aboriginal",
    "Cans",
    "Carian",
    "Cari",
    "Caucasian_Albanian",
    "Aghb",
    "Chakma",
    "Cakm",
    "Cham",
    "Cherokee",
    "Cher",
    "Common",
    "Zyyy",
    "Coptic",
    "Copt",
    "Qaac",
    "Cuneiform",
    "Xsux",
    "Cypriot",
    "Cprt",
    "Cyrillic",
    "Cyrl",
    "Deseret",
    "Dsrt",
    "Devanagari",
    "Deva",
    "Duployan",
    "Dupl",
    "Egyptian_Hieroglyphs",
    "Egyp",
    "Elbasan",
    "Elba",
    "Ethiopic",
    "Ethi",
    "Georgian",
    "Geor",
    "Glagolitic",
    "Glag",
    "Gothic",
    "Goth",
    "Grantha",
    "Gran",
    "Greek",
    "Grek",
    "Gujarati",
    "Gujr",
    "Gurmukhi",
    "Guru",
    "Han",
    "Hani",
    "Hangul",
    "Hang",
    "Hanunoo",
    "Hano",
    "Hatran",
    "Hatr",
    "Hebrew",
    "Hebr",
    "Hiragana",
    "Hira",
    "Imperial_Aramaic",
    "Armi",
    "Inherited",
    "Zinh",
    "Qaai",
    "Inscriptional_Pahlavi",
    "Phli",
    "Inscriptional_Parthian",
    "Prti",
    "Javanese",
    "Java",
    "Kaithi",
    "Kthi",
    "Kannada",
    "Knda",
    "Katakana",
    "Kana",
    "Kayah_Li",
    "Kali",
    "Kharoshthi",
    "Khar",
    "Khmer",
    "Khmr",
    "Khojki",
    "Khoj",
    "Khudawadi",
    "Sind",
    "Lao",
    "Laoo",
    "Latin",
    "Latn",
    "Lepcha",
    "Lepc",
    "Limbu",
    "Limb",
    "Linear_A",
    "Lina",
    "Linear_B",
    "Linb",
    "Lisu",
    "Lycian",
    "Lyci",
    "Lydian",
    "Lydi",
    "Mahajani",
    "Mahj",
    "Malayalam",
    "Mlym",
    "Mandaic",
    "Mand",
    "Manichaean",
    "Mani",
    "Marchen",
    "Marc",
    "Masaram_Gondi",
    "Gonm",
    "Meetei_Mayek",
    "Mtei",
    "Mende_Kikakui",
    "Mend",
    "Meroitic_Cursive",
    "Merc",
    "Meroitic_Hieroglyphs",
    "Mero",
    "Miao",
    "Plrd",
    "Modi",
    "Mongolian",
    "Mong",
    "Mro",
    "Mroo",
    "Multani",
    "Mult",
    "Myanmar",
    "Mymr",
    "Nabataean",
    "Nbat",
    "New_Tai_Lue",
    "Talu",
    "Newa",
    "Nko",
    "Nkoo",
    "Nushu",
    "Nshu",
    "Ogham",
    "Ogam",
    "Ol_Chiki",
    "Olck",
    "Old_Hungarian",
    "Hung",
    "Old_Italic",
    "Ital",
    "Old_North_Arabian",
    "Narb",
    "Old_Permic",
    "Perm",
    "Old_Persian",
    "Xpeo",
    "Old_South_Arabian",
    "Sarb",
    "Old_Turkic",
    "Orkh",
    "Oriya",
    "Orya",
    "Osage",
    "Osge",
    "Osmanya",
    "Osma",
    "Pahawh_Hmong",
    "Hmng",
    "Palmyrene",
    "Palm",
    "Pau_Cin_Hau",
    "Pauc",
    "Phags_Pa",
    "Phag",
    "Phoenician",
    "Phnx",
    "Psalter_Pahlavi",
    "Phlp",
    "Rejang",
    "Rjng",
    "Runic",
    "Runr",
    "Samaritan",
    "Samr",
    "Saurashtra",
    "Saur",
    "Sharada",
    "Shrd",
    "Shavian",
    "Shaw",
    "Siddham",
    "Sidd",
    "SignWriting",
    "Sgnw",
    "Sinhala",
    "Sinh",
    "Sora_Sompeng",
    "Sora",
    "Soyombo",
    "Soyo",
    "Sundanese",
    "Sund",
    "Syloti_Nagri",
    "Sylo",
    "Syriac",
    "Syrc",
    "Tagalog",
    "Tglg",
    "Tagbanwa",
    "Tagb",
    "Tai_Le",
    "Tale",
    "Tai_Tham",
    "Lana",
    "Tai_Viet",
    "Tavt",
    "Takri",
    "Takr",
    "Tamil",
    "Taml",
    "Tangut",
    "Tang",
    "Telugu",
    "Telu",
    "Thaana",
    "Thaa",
    "Thai",
    "Tibetan",
    "Tibt",
    "Tifinagh",
    "Tfng",
    "Tirhuta",
    "Tirh",
    "Ugaritic",
    "Ugar",
    "Vai",
    "Vaii",
    "Warang_Citi",
    "Wara",
    "Yi",
    "Yiii",
    "Zanabazar_Square",
    "Zanb"
  ]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;

var pp$9 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString$1(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpFlags = function(state) {
  var this$1 = this;

  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this$1.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this$1.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$9.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$9.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$9.regexp_disjunction = function(state) {
  var this$1 = this;

  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this$1.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$9.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    {  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$9.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$9.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$9.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$9.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$9.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$9.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$9.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$9.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$9.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$9.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$9.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$9.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$9.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString$1(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString$1(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$9.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$9.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$9.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$9.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$9.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$9.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$9.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$9.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$9.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$9.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$9.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$9.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {
    state.raise("Invalid property name");
  }
};
pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (data.$LONE.indexOf(nameOrValue) === -1) {
    state.raise("Invalid property name");
  }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$9.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString$1(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$9.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$9.regexp_classRanges = function(state) {
  var this$1 = this;

  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$9.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$9.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$9.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$9.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$9.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$9.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$9.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$8 = Parser.prototype;

// Move to the next token

pp$8.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$8[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$8.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$8.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$8.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$8.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$8.skipBlockComment = function() {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$8.skipLineComment = function(startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$8.skipSpace = function() {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this$1.pos;
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos;
      }
    case 10: case 8232: case 8233:
      ++this$1.pos;
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      break
    case 47: // '/'
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // '*'
        this$1.skipBlockComment();
        break
      case 47:
        this$1.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$8.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$8.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$8.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$8.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$8.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$8.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$8.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$8.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$8.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$8.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$8.readRegexp = function() {
  var this$1 = this;

  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(start, "Unterminated regular expression"); }
    var ch = this$1.input.charAt(this$1.pos);
    if (lineBreak.test(ch)) { this$1.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this$1.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$8.readInt = function(radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this$1.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$8.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$8.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$8.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$8.readString = function(quote) {
  var this$1 = this;

  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated string constant"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, "Unterminated string constant"); }
      ++this$1.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function() {
  var this$1 = this;

  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated template"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL)
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$8.readInvalidTemplateToken = function() {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
    case "\\":
      ++this$1.pos;
      break

    case "$":
      if (this$1.input[this$1.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$8.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$8.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$8.readWord1 = function() {
  var this$1 = this;

  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;
      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // "u"
        { this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this$1.pos;
      var esc = this$1.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this$1.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$8.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

var version = "5.7.3";

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return new Parser(options, input).parse()
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression()
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return new Parser(options, input)
}

// This is a terrible kludge to support the existing, pre-ES6
// interface where the loose parser module retroactively adds exports
// to this module.
 // eslint-disable-line camelcase
function addLooseExports(parse, Parser$$1, plugins$$1) {
  exports.parse_dammit = parse; // eslint-disable-line camelcase
  exports.LooseParser = Parser$$1;
  exports.pluginsLoose = plugins$$1;
}

exports.version = version;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;
exports.addLooseExports = addLooseExports;
exports.Parser = Parser;
exports.plugins = plugins;
exports.defaultOptions = defaultOptions;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.getLineInfo = getLineInfo;
exports.Node = Node;
exports.TokenType = TokenType;
exports.tokTypes = types;
exports.keywordTypes = keywords$1;
exports.TokContext = TokContext;
exports.tokContexts = types$1;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierStart = isIdentifierStart;
exports.Token = Token;
exports.isNewLine = isNewLine;
exports.lineBreak = lineBreak;
exports.lineBreakG = lineBreakG;
exports.nonASCIIwhitespace = nonASCIIwhitespace;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],103:[function(require,module,exports){
/*! Hammer.JS - v2.0.8 - 2016-09-30
 * http://hammerjs.github.io/
 *
 * Copyright (c)  Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) { 
'use strict';
/**
 * @private
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
  return val1 === undefined ? val2 : val1;
}

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * @private
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
  var prefix = void 0;
  var prop = void 0;
  var camelProp = property[0].toUpperCase() + property.slice(1);

  var i = 0;
  while (i < VENDOR_PREFIXES.length) {
    prefix = VENDOR_PREFIXES[i];
    prop = prefix ? prefix + camelProp : property;

    if (prop in obj) {
      return prop;
    }
    i++;
  }
  return undefined;
}

function getTouchActionProps() {
  if (!NATIVE_TOUCH_ACTION) {
    return false;
  }
  var touchMap = {};
  var cssSupports = window.CSS && window.CSS.supports;
  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {

    // If css.supports is not supported but there is native touch-action assume it supports
    // all values. This is the case for IE 10 and 11.
    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
  });
  return touchMap;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = 'ontouchstart' in window;
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign = void 0;
if (typeof Object.assign !== 'function') {
  assign = function assign(target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);
    for (var index = 1; index < arguments.length; index++) {
      var source = arguments[index];
      if (source !== undefined && source !== null) {
        for (var nextKey in source) {
          if (source.hasOwnProperty(nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }
    return output;
  };
} else {
  assign = Object.assign;
}

var assign$1 = assign;

/**
 * @private
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
  return _uniqueId++;
}

/**
 * @private
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
  var i = void 0;

  if (!obj) {
    return;
  }

  if (obj.forEach) {
    obj.forEach(iterator, context);
  } else if (obj.length !== undefined) {
    i = 0;
    while (i < obj.length) {
      iterator.call(context, obj[i], i, obj);
      i++;
    }
  } else {
    for (i in obj) {
      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
    }
  }
}

/**
 * @private
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
  if (Array.isArray(arg)) {
    each(arg, context[fn], context);
    return true;
  }
  return false;
}

/**
 * @private
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
  if (src.indexOf && !findByKey) {
    return src.indexOf(find);
  } else {
    var i = 0;
    while (i < src.length) {
      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
        // do not use === here, test fails
        return i;
      }
      i++;
    }
    return -1;
  }
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/**
 * @private
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
  if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === TYPE_FUNCTION) {
    return val.apply(args ? args[0] || undefined : undefined, args);
  }
  return val;
}

/**
 * @private
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
  var manager = recognizer.manager;

  if (manager) {
    return manager.get(otherRecognizer);
  }
  return otherRecognizer;
}

/**
 * @private
 * get a usable string, used as event postfix
 * @param {constant} state
 * @returns {String} state
 */
function stateStr(state) {
  if (state & STATE_CANCELLED) {
    return 'cancel';
  } else if (state & STATE_ENDED) {
    return 'end';
  } else if (state & STATE_CHANGED) {
    return 'move';
  } else if (state & STATE_BEGAN) {
    return 'start';
  }
  return '';
}

/**
 * @private
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */

/**
 * @private
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */

var Recognizer = function () {
  function Recognizer(options) {
    classCallCheck(this, Recognizer);

    this.options = assign$1({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }

  /**
   * @private
   * set options
   * @param {Object} options
   * @return {Recognizer}
   */


  createClass(Recognizer, [{
    key: 'set',
    value: function set(options) {
      assign$1(this.options, options);

      // also update the touchAction, in case something changed about the directions/enabled state
      this.manager && this.manager.touchAction.update();
      return this;
    }

    /**
     * @private
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */

  }, {
    key: 'recognizeWith',
    value: function recognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }
      return this;
    }

    /**
     * @private
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */

  }, {
    key: 'dropRecognizeWith',
    value: function dropRecognizeWith(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    }

    /**
     * @private
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */

  }, {
    key: 'requireFailure',
    value: function requireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }
      return this;
    }

    /**
     * @private
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */

  }, {
    key: 'dropRequireFailure',
    value: function dropRequireFailure(otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);
      if (index > -1) {
        this.requireFail.splice(index, 1);
      }
      return this;
    }

    /**
     * @private
     * has require failures boolean
     * @returns {boolean}
     */

  }, {
    key: 'hasRequireFailures',
    value: function hasRequireFailures() {
      return this.requireFail.length > 0;
    }

    /**
     * @private
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */

  }, {
    key: 'canRecognizeWith',
    value: function canRecognizeWith(otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    }

    /**
     * @private
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */

  }, {
    key: 'emit',
    value: function emit(input) {
      var self = this;
      var state = this.state;


      function emit(event) {
        self.manager.emit(event, input);
      }

      // 'panstart' and 'panmove'
      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }

      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      }

      // panend and pancancel
      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    }

    /**
     * @private
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */

  }, {
    key: 'tryEmit',
    value: function tryEmit(input) {
      if (this.canEmit()) {
        return this.emit(input);
      }
      // it's failing anyway
      this.state = STATE_FAILED;
    }

    /**
     * @private
     * can we emit?
     * @returns {boolean}
     */

  }, {
    key: 'canEmit',
    value: function canEmit() {
      var i = 0;
      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }
        i++;
      }
      return true;
    }

    /**
     * @private
     * update the recognizer
     * @param {Object} inputData
     */

  }, {
    key: 'recognize',
    value: function recognize(inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign$1({}, inputData);

      // is is enabled and allow recognizing?
      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      }

      // reset when we've reached the end
      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone);

      // the recognizer has recognized a gesture
      // so trigger an event
      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    }

    /**
     * @private
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {constant} STATE
     */

    /* jshint ignore:start */

  }, {
    key: 'process',
    value: function process(inputData) {}
    /* jshint ignore:end */

    /**
     * @private
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */

  }, {
    key: 'getTouchAction',
    value: function getTouchAction() {}

    /**
     * @private
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */

  }, {
    key: 'reset',
    value: function reset() {}
  }]);
  return Recognizer;
}();

Recognizer.prototype.defaults = {};

/**
 * @private
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */

var AttrRecognizer = function (_Recognizer) {
  inherits(AttrRecognizer, _Recognizer);

  function AttrRecognizer() {
    classCallCheck(this, AttrRecognizer);
    return possibleConstructorReturn(this, (AttrRecognizer.__proto__ || Object.getPrototypeOf(AttrRecognizer)).apply(this, arguments));
  }

  /**
   * @private
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {Boolean} recognized
   */


  createClass(AttrRecognizer, [{
    key: 'attrTest',
    value: function attrTest(input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    }

    /**
     * @private
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */

  }, {
    key: 'process',
    value: function process(input) {
      var state = this.state;
      var eventType = input.eventType;


      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input);

      // on cancel input and we've recognized before, return STATE_CANCELLED
      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }
        return state | STATE_CHANGED;
      }
      return STATE_FAILED;
    }
  }]);
  return AttrRecognizer;
}(Recognizer);

AttrRecognizer.prototype.defaults = {
  /**
   * @private
   * @type {Number}
   * @default 1
   */
  pointers: 1
};

/**
 * @private
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */

var RotateRecognizer = function (_AttrRecognizer) {
  inherits(RotateRecognizer, _AttrRecognizer);

  function RotateRecognizer() {
    classCallCheck(this, RotateRecognizer);
    return possibleConstructorReturn(this, (RotateRecognizer.__proto__ || Object.getPrototypeOf(RotateRecognizer)).apply(this, arguments));
  }

  createClass(RotateRecognizer, [{
    key: 'getTouchAction',
    value: function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    }
  }, {
    key: 'attrTest',
    value: function attrTest(input) {
      return get(RotateRecognizer.prototype.__proto__ || Object.getPrototypeOf(RotateRecognizer.prototype), 'attrTest', this).call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  }]);
  return RotateRecognizer;
}(AttrRecognizer);

RotateRecognizer.prototype.defaults = {
  event: 'rotate',
  threshold: 0,
  pointers: 2
};

/**
 * @private
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */

var PinchRecognizer = function (_AttrRecognizer) {
  inherits(PinchRecognizer, _AttrRecognizer);

  function PinchRecognizer() {
    classCallCheck(this, PinchRecognizer);
    return possibleConstructorReturn(this, (PinchRecognizer.__proto__ || Object.getPrototypeOf(PinchRecognizer)).apply(this, arguments));
  }

  createClass(PinchRecognizer, [{
    key: 'getTouchAction',
    value: function getTouchAction() {
      return [TOUCH_ACTION_NONE];
    }
  }, {
    key: 'attrTest',
    value: function attrTest(input) {
      return get(PinchRecognizer.prototype.__proto__ || Object.getPrototypeOf(PinchRecognizer.prototype), 'attrTest', this).call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    }
  }, {
    key: 'emit',
    value: function emit(input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }
      get(PinchRecognizer.prototype.__proto__ || Object.getPrototypeOf(PinchRecognizer.prototype), 'emit', this).call(this, input);
    }
  }]);
  return PinchRecognizer;
}(AttrRecognizer);

PinchRecognizer.prototype.defaults = {
  event: 'pinch',
  threshold: 0,
  pointers: 2
};

/**
 * @private
 * direction cons to string
 * @param {constant} direction
 * @returns {String}
 */
function directionStr(direction) {
  if (direction === DIRECTION_DOWN) {
    return 'down';
  } else if (direction === DIRECTION_UP) {
    return 'up';
  } else if (direction === DIRECTION_LEFT) {
    return 'left';
  } else if (direction === DIRECTION_RIGHT) {
    return 'right';
  }
  return '';
}

/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */

var PanRecognizer = function (_AttrRecognizer) {
  inherits(PanRecognizer, _AttrRecognizer);

  function PanRecognizer() {
    classCallCheck(this, PanRecognizer);

    var _this = possibleConstructorReturn(this, (PanRecognizer.__proto__ || Object.getPrototypeOf(PanRecognizer)).apply(this, arguments));

    _this.pX = null;
    _this.pY = null;
    return _this;
  }

  createClass(PanRecognizer, [{
    key: 'getTouchAction',
    value: function getTouchAction() {
      var direction = this.options.direction;

      var actions = [];
      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }
      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }
      return actions;
    }
  }, {
    key: 'directionTest',
    value: function directionTest(input) {
      var options = this.options;

      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;

      var x = input.deltaX;
      var y = input.deltaY;

      // lock to axis?
      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x !== this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y !== this.pY;
          distance = Math.abs(input.deltaY);
        }
      }
      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    }
  }, {
    key: 'attrTest',
    value: function attrTest(input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call
      this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    }
  }, {
    key: 'emit',
    value: function emit(input) {

      this.pX = input.deltaX;
      this.pY = input.deltaY;

      var direction = directionStr(input.direction);

      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }
      get(PanRecognizer.prototype.__proto__ || Object.getPrototypeOf(PanRecognizer.prototype), 'emit', this).call(this, input);
    }
  }]);
  return PanRecognizer;
}(AttrRecognizer);

PanRecognizer.prototype.defaults = {
  event: 'pan',
  threshold: 10,
  pointers: 1,
  direction: DIRECTION_ALL
};

/**
 * @private
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */

var SwipeRecognizer = function (_AttrRecognizer) {
  inherits(SwipeRecognizer, _AttrRecognizer);

  function SwipeRecognizer() {
    classCallCheck(this, SwipeRecognizer);
    return possibleConstructorReturn(this, (SwipeRecognizer.__proto__ || Object.getPrototypeOf(SwipeRecognizer)).apply(this, arguments));
  }

  createClass(SwipeRecognizer, [{
    key: 'getTouchAction',
    value: function getTouchAction() {
      return PanRecognizer.prototype.getTouchAction.call(this);
    }
  }, {
    key: 'attrTest',
    value: function attrTest(input) {
      var direction = this.options.direction;

      var velocity = void 0;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }

      return get(SwipeRecognizer.prototype.__proto__ || Object.getPrototypeOf(SwipeRecognizer.prototype), 'attrTest', this).call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    }
  }, {
    key: 'emit',
    value: function emit(input) {
      var direction = directionStr(input.offsetDirection);
      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    }
  }]);
  return SwipeRecognizer;
}(AttrRecognizer);

SwipeRecognizer.prototype.defaults = {
  event: 'swipe',
  threshold: 10,
  velocity: 0.3,
  direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
  pointers: 1
};

/**
 * @private
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
  return function boundFn() {
    return fn.apply(context, arguments);
  };
}

/**
 * @private
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
  return setTimeout(bindFn(fn, context), timeout);
}

/**
 * @private
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];

  return Math.sqrt(x * x + y * y);
}

/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */

var TapRecognizer = function (_Recognizer) {
  inherits(TapRecognizer, _Recognizer);

  function TapRecognizer() {
    classCallCheck(this, TapRecognizer);

    // previous time and center,
    // used for tap counting
    var _this = possibleConstructorReturn(this, (TapRecognizer.__proto__ || Object.getPrototypeOf(TapRecognizer)).apply(this, arguments));

    _this.pTime = false;
    _this.pCenter = false;

    _this._timer = null;
    _this._input = null;
    _this.count = 0;
    return _this;
  }

  createClass(TapRecognizer, [{
    key: 'getTouchAction',
    value: function getTouchAction() {
      return [TOUCH_ACTION_MANIPULATION];
    }
  }, {
    key: 'process',
    value: function process(input) {
      var _this2 = this;

      var options = this.options;


      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;

      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      }

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType !== INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input;

        // if tap count matches we have recognized it,
        // else it has began recognizing...
        var tapCount = this.count % options.taps;
        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              _this2.state = STATE_RECOGNIZED;
              _this2.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }
      return STATE_FAILED;
    }
  }, {
    key: 'failTimeout',
    value: function failTimeout() {
      var _this3 = this;

      this._timer = setTimeoutContext(function () {
        _this3.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    }
  }, {
    key: 'reset',
    value: function reset() {
      clearTimeout(this._timer);
    }
  }, {
    key: 'emit',
    value: function emit() {
      if (this.state === STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  }]);
  return TapRecognizer;
}(Recognizer);

TapRecognizer.prototype.defaults = {
  event: 'tap',
  pointers: 1,
  taps: 1,
  interval: 300, // max time between the multi-tap taps
  time: 250, // max time of the pointer to be down (like finger on the screen)
  threshold: 9, // a minimal movement is ok, but keep it low
  posThreshold: 10 // a multi-tap can be a bit off the initial position
};

/**
 * @private
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */

var PressRecognizer = function (_Recognizer) {
  inherits(PressRecognizer, _Recognizer);

  function PressRecognizer() {
    classCallCheck(this, PressRecognizer);

    var _this = possibleConstructorReturn(this, (PressRecognizer.__proto__ || Object.getPrototypeOf(PressRecognizer)).apply(this, arguments));

    _this._timer = null;
    _this._input = null;
    return _this;
  }

  createClass(PressRecognizer, [{
    key: 'getTouchAction',
    value: function getTouchAction() {
      return [TOUCH_ACTION_AUTO];
    }
  }, {
    key: 'process',
    value: function process(input) {
      var _this2 = this;

      var options = this.options;

      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;

      this._input = input;

      // we only allow little movement
      // and we've reached an end event, so a tap is possible
      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          _this2.state = STATE_RECOGNIZED;
          _this2.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }
      return STATE_FAILED;
    }
  }, {
    key: 'reset',
    value: function reset() {
      clearTimeout(this._timer);
    }
  }, {
    key: 'emit',
    value: function emit(input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  }]);
  return PressRecognizer;
}(Recognizer);

PressRecognizer.prototype.defaults = {
  event: 'press',
  pointers: 1,
  time: 251, // minimal time of the pointer to be pressed
  threshold: 9 // a minimal movement is ok, but keep it low
};

/**
 * @private
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
  return str.indexOf(find) > -1;
}

/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
  // none
  if (inStr(actions, TOUCH_ACTION_NONE)) {
    return TOUCH_ACTION_NONE;
  }

  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

  // if both pan-x and pan-y are set (different recognizers
  // for different directions, e.g. horizontal pan but vertical swipe?)
  // we need none (as otherwise with pan-x pan-y combined none of these
  // recognizers will work, since the browser would handle all panning
  if (hasPanX && hasPanY) {
    return TOUCH_ACTION_NONE;
  }

  // pan-x OR pan-y
  if (hasPanX || hasPanY) {
    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
  }

  // manipulation
  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
    return TOUCH_ACTION_MANIPULATION;
  }

  return TOUCH_ACTION_AUTO;
}

/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */

var TouchAction = function () {
  function TouchAction(manager, value) {
    classCallCheck(this, TouchAction);

    this.manager = manager;
    this.set(value);
  }

  /**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */


  createClass(TouchAction, [{
    key: 'set',
    value: function set(value) {
      // find out the touch-action by the event handlers
      if (value === TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }
      this.actions = value.toLowerCase().trim();
    }

    /**
     * @private
     * just re-set the touchAction value
     */

  }, {
    key: 'update',
    value: function update() {
      this.set(this.manager.options.touchAction);
    }

    /**
     * @private
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */

  }, {
    key: 'compute',
    value: function compute() {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    }

    /**
     * @private
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */

  }, {
    key: 'preventDefaults',
    value: function preventDefaults(input) {
      var srcEvent = input.srcEvent;

      var direction = input.offsetDirection;

      // if the touch action did prevented once this session
      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;

      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

      if (hasNone) {
        // do not prevent defaults if this is a tap gesture
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;

        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }

      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    }

    /**
     * @private
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */

  }, {
    key: 'preventSrc',
    value: function preventSrc(srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  }]);
  return TouchAction;
}();

/**
 * @private
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
  while (node) {
    if (node === parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

/**
 * @private
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
  var pointersLength = pointers.length;

  // no need to loop when only one touch
  if (pointersLength === 1) {
    return {
      x: round(pointers[0].clientX),
      y: round(pointers[0].clientY)
    };
  }

  var x = 0;
  var y = 0;
  var i = 0;
  while (i < pointersLength) {
    x += pointers[i].clientX;
    y += pointers[i].clientY;
    i++;
  }

  return {
    x: round(x / pointersLength),
    y: round(y / pointersLength)
  };
}

/**
 * @private
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
  // make a simple copy of the pointers because we will get a reference if we don't
  // we only need clientXY for the calculations
  var pointers = [];
  var i = 0;
  while (i < input.pointers.length) {
    pointers[i] = {
      clientX: round(input.pointers[i].clientX),
      clientY: round(input.pointers[i].clientY)
    };
    i++;
  }

  return {
    timeStamp: now(),
    pointers: pointers,
    center: getCenter(pointers),
    deltaX: input.deltaX,
    deltaY: input.deltaY
  };
}

/**
 * @private
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
  if (!props) {
    props = PROPS_XY;
  }
  var x = p2[props[0]] - p1[props[0]];
  var y = p2[props[1]] - p1[props[1]];
  return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * @private
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
  if (x === y) {
    return DIRECTION_NONE;
  }

  if (abs(x) >= abs(y)) {
    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
  }
  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

function computeDeltaXY(session, input) {
  var center = input.center;
  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
  // jscs throwing error on defalut destructured values and without defaults tests fail

  var offset = session.offsetDelta || {};
  var prevDelta = session.prevDelta || {};
  var prevInput = session.prevInput || {};

  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
    prevDelta = session.prevDelta = {
      x: prevInput.deltaX || 0,
      y: prevInput.deltaY || 0
    };

    offset = session.offsetDelta = {
      x: center.x,
      y: center.y
    };
  }

  input.deltaX = prevDelta.x + (center.x - offset.x);
  input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * @private
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
  return {
    x: x / deltaTime || 0,
    y: y / deltaTime || 0
  };
}

/**
 * @private
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

/**
 * @private
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * @private
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
  var last = session.lastInterval || input;
  var deltaTime = input.timeStamp - last.timeStamp;
  var velocity = void 0;
  var velocityX = void 0;
  var velocityY = void 0;
  var direction = void 0;

  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
    var deltaX = input.deltaX - last.deltaX;
    var deltaY = input.deltaY - last.deltaY;

    var v = getVelocity(deltaTime, deltaX, deltaY);
    velocityX = v.x;
    velocityY = v.y;
    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
    direction = getDirection(deltaX, deltaY);

    session.lastInterval = input;
  } else {
    // use latest velocity info if it doesn't overtake a minimum period
    velocity = last.velocity;
    velocityX = last.velocityX;
    velocityY = last.velocityY;
    direction = last.direction;
  }

  input.velocity = velocity;
  input.velocityX = velocityX;
  input.velocityY = velocityY;
  input.direction = direction;
}

/**
* @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
  var session = manager.session;
  var pointers = input.pointers;
  var pointersLength = pointers.length;

  // store the first input to calculate the distance and direction

  if (!session.firstInput) {
    session.firstInput = simpleCloneInputData(input);
  }

  // to compute scale and rotation we need to store the multiple touches
  if (pointersLength > 1 && !session.firstMultiple) {
    session.firstMultiple = simpleCloneInputData(input);
  } else if (pointersLength === 1) {
    session.firstMultiple = false;
  }

  var firstInput = session.firstInput;
  var firstMultiple = session.firstMultiple;

  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

  var center = input.center = getCenter(pointers);
  input.timeStamp = now();
  input.deltaTime = input.timeStamp - firstInput.timeStamp;

  input.angle = getAngle(offsetCenter, center);
  input.distance = getDistance(offsetCenter, center);

  computeDeltaXY(session, input);
  input.offsetDirection = getDirection(input.deltaX, input.deltaY);

  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
  input.overallVelocityX = overallVelocity.x;
  input.overallVelocityY = overallVelocity.y;
  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;

  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;

  computeIntervalInputData(session, input);

  // find the correct target
  var target = manager.element;
  if (hasParent(input.srcEvent.target, target)) {
    target = input.srcEvent.target;
  }
  input.target = target;
}

/**
 * @private
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
  var pointersLen = input.pointers.length;
  var changedPointersLen = input.changedPointers.length;
  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;

  input.isFirst = !!isFirst;
  input.isFinal = !!isFinal;

  if (isFirst) {
    manager.session = {};
  }

  // source event is the normalized value of the domEvents
  // like 'touchstart, mouseup, pointerdown'
  input.eventType = eventType;

  // compute scale, rotation etc
  computeInputData(manager, input);

  // emit secret event
  manager.emit('hammer.input', input);

  manager.recognize(input);
  manager.session.prevInput = input;
}

/**
 * @private
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */

function splitStr(str) {
  return str.trim().split(/\s+/g);
}

/**
 * @private
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.addEventListener(type, handler, false);
  });
}

/**
 * @private
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
  each(splitStr(types), function (type) {
    target.removeEventListener(type, handler, false);
  });
}

/**
 * @private
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
  var doc = element.ownerDocument || element;
  return doc.defaultView || doc.parentWindow || window;
}

/**
 * @private
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */

var Input = function () {
  function Input(manager, callback) {
    classCallCheck(this, Input);

    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }
  /**
   * @private
   * should handle the inputEvent data and trigger the callback
   * @virtual
   */


  createClass(Input, [{
    key: 'handler',
    value: function handler() {}

    /**
     * @private
     * bind the events
     */

  }, {
    key: 'init',
    value: function init() {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }

    /**
     * @private
     * unbind the events
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  }]);
  return Input;
}();

var POINTER_INPUT_MAP = {
  pointerdown: INPUT_START,
  pointermove: INPUT_MOVE,
  pointerup: INPUT_END,
  pointercancel: INPUT_CANCEL,
  pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
  2: INPUT_TYPE_TOUCH,
  3: INPUT_TYPE_PEN,
  4: INPUT_TYPE_MOUSE,
  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
  POINTER_ELEMENT_EVENTS = 'MSPointerDown';
  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * @private
 * Pointer events input
 * @constructor
 * @extends Input
 */

var PointerEventInput = function (_Input) {
  inherits(PointerEventInput, _Input);

  function PointerEventInput() {
    classCallCheck(this, PointerEventInput);

    var _this = possibleConstructorReturn(this, (PointerEventInput.__proto__ || Object.getPrototypeOf(PointerEventInput)).apply(this, arguments));

    _this.evEl = POINTER_ELEMENT_EVENTS;
    _this.evWin = POINTER_WINDOW_EVENTS;

    _this.store = _this.manager.session.pointerEvents = [];
    return _this;
  }

  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  createClass(PointerEventInput, [{
    key: 'handler',
    value: function handler(ev) {
      var store = this.store;

      var removePointer = false;

      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

      var isTouch = pointerType === INPUT_TYPE_TOUCH;

      // get index of the event in the store
      var storeIndex = inArray(store, ev.pointerId, 'pointerId');

      // start and mouse must be down
      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      }

      // it not found, so the pointer hasn't been down (so it's probably a hover)
      if (storeIndex < 0) {
        return;
      }

      // update the event in the store
      store[storeIndex] = ev;

      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  }]);
  return PointerEventInput;
}(Input);

/**
 * @private
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray$1(obj) {
  return Array.prototype.slice.call(obj, 0);
}

/**
 * @private
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
  var results = [];
  var values = [];
  var i = 0;

  while (i < src.length) {
    var val = key ? src[i][key] : src[i];
    if (inArray(values, val) < 0) {
      results.push(src[i]);
    }
    values[i] = val;
    i++;
  }

  if (sort) {
    if (!key) {
      results = results.sort();
    } else {
      results = results.sort(function (a, b) {
        return a[key] > b[key];
      });
    }
  }

  return results;
}

var TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */

var TouchInput = function (_Input) {
  inherits(TouchInput, _Input);

  function TouchInput() {
    classCallCheck(this, TouchInput);

    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;
    TouchInput.prototype.targetIds = {};

    var _this = possibleConstructorReturn(this, (TouchInput.__proto__ || Object.getPrototypeOf(TouchInput)).apply(this, arguments));

    _this.evTarget = TOUCH_TARGET_EVENTS;
    _this.targetIds = {};
    return _this;
  }

  createClass(TouchInput, [{
    key: 'handler',
    value: function handler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);
      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  }]);
  return TouchInput;
}(Input);

function getTouches(ev, type) {
  var allTouches = toArray$1(ev.touches);
  var targetIds = this.targetIds;

  // when there is only one touch, the process can be simplified

  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
    targetIds[allTouches[0].identifier] = true;
    return [allTouches, allTouches];
  }

  var i = void 0;
  var targetTouches = void 0;
  var changedTouches = toArray$1(ev.changedTouches);
  var changedTargetTouches = [];
  var target = this.target;

  // get target touches from touches

  targetTouches = allTouches.filter(function (touch) {
    return hasParent(touch.target, target);
  });

  // collect touches
  if (type === INPUT_START) {
    i = 0;
    while (i < targetTouches.length) {
      targetIds[targetTouches[i].identifier] = true;
      i++;
    }
  }

  // filter changed touches to only contain touches that exist in the collected target ids
  i = 0;
  while (i < changedTouches.length) {
    if (targetIds[changedTouches[i].identifier]) {
      changedTargetTouches.push(changedTouches[i]);
    }

    // cleanup removed touches
    if (type & (INPUT_END | INPUT_CANCEL)) {
      delete targetIds[changedTouches[i].identifier];
    }
    i++;
  }

  if (!changedTargetTouches.length) {
    return;
  }

  return [
  // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
}

var MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * @private
 * Mouse events input
 * @constructor
 * @extends Input
 */

var MouseInput = function (_Input) {
  inherits(MouseInput, _Input);

  function MouseInput() {
    classCallCheck(this, MouseInput);

    var _this = possibleConstructorReturn(this, (MouseInput.__proto__ || Object.getPrototypeOf(MouseInput)).apply(this, arguments));

    _this.evEl = MOUSE_ELEMENT_EVENTS;
    _this.evWin = MOUSE_WINDOW_EVENTS;

    _this.pressed = false; // mousedown state
    return _this;
  }

  /**
   * @private
   * handle mouse events
   * @param {Object} ev
   */


  createClass(MouseInput, [{
    key: 'handler',
    value: function handler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type];

      // on start we want to have the left mouse button down
      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      }

      // mouse must be down
      if (!this.pressed) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  }]);
  return MouseInput;
}(Input);

/**
 * @private
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

var TouchMouseInput = function (_Input) {
  inherits(TouchMouseInput, _Input);

  function TouchMouseInput() {
    classCallCheck(this, TouchMouseInput);

    var _this = possibleConstructorReturn(this, (TouchMouseInput.__proto__ || Object.getPrototypeOf(TouchMouseInput)).apply(this, arguments));

    var handler = bindFn(_this.handler, _this);
    _this.touch = new TouchInput(_this.manager, handler);
    _this.mouse = new MouseInput(_this.manager, handler);

    _this.primaryTouch = null;
    _this.lastTouches = [];
    return _this;
  }

  /**
   * @private
   * handle mouse and touch events
   * @param {Hammer} manager
   * @param {String} inputEvent
   * @param {Object} inputData
   */


  createClass(TouchMouseInput, [{
    key: 'handler',
    value: function handler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;
      var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;

      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
        return;
      }

      // when we're in a touch event, record touches to  de-dupe synthetic mouse event
      if (isTouch) {
        recordTouches.call(this, inputEvent, inputData);
      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
        return;
      }

      this.callback(manager, inputEvent, inputData);
    }

    /**
     * @private
     * remove the event listeners
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  }]);
  return TouchMouseInput;
}(Input);

function recordTouches(eventType, eventData) {
  if (eventType & INPUT_START) {
    this.primaryTouch = eventData.changedPointers[0].identifier;
    setLastTouch.call(this, eventData);
  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
    setLastTouch.call(this, eventData);
  }
}

function setLastTouch(eventData) {
  var _this2 = this;

  var _eventData$changedPoi = slicedToArray(eventData.changedPointers, 1);

  var touch = _eventData$changedPoi[0];

  if (touch.identifier === this.primaryTouch) {
    (function () {
      var lastTouch = { x: touch.clientX, y: touch.clientY };
      _this2.lastTouches.push(lastTouch);
      var lts = _this2.lastTouches;
      var removeLastTouch = function removeLastTouch() {
        var i = lts.indexOf(lastTouch);
        if (i > -1) {
          lts.splice(i, 1);
        }
      };
      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    })();
  }
}

function isSyntheticEvent(eventData) {
  var x = eventData.srcEvent.clientX;
  var y = eventData.srcEvent.clientY;
  for (var i = 0; i < this.lastTouches.length; i++) {
    var t = this.lastTouches[i];
    var dx = Math.abs(x - t.x);
    var dy = Math.abs(y - t.y);
    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
      return true;
    }
  }
  return false;
}

/**
 * @private
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
  var Type = void 0;
  // let inputClass = manager.options.inputClass;
  var inputClass = manager.options.inputClass;

  if (inputClass) {
    Type = inputClass;
  } else if (SUPPORT_POINTER_EVENTS) {
    Type = PointerEventInput;
  } else if (SUPPORT_ONLY_TOUCH) {
    Type = TouchInput;
  } else if (!SUPPORT_TOUCH) {
    Type = MouseInput;
  } else {
    Type = TouchMouseInput;
  }
  return new Type(manager, inputHandler);
}

var STOP = 1;
var FORCED_STOP = 2;

/**
* @private
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */

var Manager = function () {
  function Manager(element, options) {
    var _this = this;

    classCallCheck(this, Manager);

    this.options = assign$1({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function (item) {
      var recognizer = _this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }

  /**
   * @private
   * set options
   * @param {Object} options
   * @returns {Manager}
   */


  createClass(Manager, [{
    key: 'set',
    value: function set(options) {
      assign$1(this.options, options);

      // Options that need a little more setup
      if (options.touchAction) {
        this.touchAction.update();
      }
      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }
      return this;
    }

    /**
     * @private
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */

  }, {
    key: 'stop',
    value: function stop(force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    }

    /**
     * @private
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */

  }, {
    key: 'recognize',
    value: function recognize(inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      }

      // run the touch-action polyfill
      this.touchAction.preventDefaults(inputData);

      var recognizer = void 0;
      var recognizers = this.recognizers;

      // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer;

      // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }

      var i = 0;
      while (i < recognizers.length) {
        recognizer = recognizers[i];

        // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.
        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer === curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        }

        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer
        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }
        i++;
      }
    }

    /**
     * @private
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */

  }, {
    key: 'get',
    value: function get(recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event === recognizer) {
          return recognizers[i];
        }
      }
      return null;
    }

    /**
     * @private add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */

  }, {
    key: 'add',
    value: function add(recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      }

      // remove existing
      var existing = this.get(recognizer.options.event);
      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;

      this.touchAction.update();
      return recognizer;
    }

    /**
     * @private
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */

  }, {
    key: 'remove',
    value: function remove(recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }

      recognizer = this.get(recognizer);

      // let's make sure this recognizer exists
      if (recognizer) {
        var recognizers = this.recognizers;

        var index = inArray(recognizers, recognizer);

        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }

      return this;
    }

    /**
     * @private
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */

  }, {
    key: 'on',
    value: function on(events, handler) {
      if (events === undefined) {
        return;
      }
      if (handler === undefined) {
        return;
      }

      var handlers = this.handlers;

      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    }

    /**
     * @private unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */

  }, {
    key: 'off',
    value: function off(events, handler) {
      if (events === undefined) {
        return;
      }

      var handlers = this.handlers;

      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    }

    /**
     * @private emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */

  }, {
    key: 'emit',
    value: function emit(event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      }

      // no handlers, so skip it all
      var handlers = this.handlers[event] && this.handlers[event].slice();
      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;
      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;
      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    }

    /**
     * @private
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.element && toggleCssProps(this, false);

      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  }]);
  return Manager;
}();

function toggleCssProps(manager, add) {
  var element = manager.element;

  if (!element.style) {
    return;
  }
  var prop = void 0;
  each(manager.options.cssProps, function (value, name) {
    prop = prefixed(element.style, name);
    if (add) {
      manager.oldCssProps[prop] = element.style[prop];
      element.style[prop] = value;
    } else {
      element.style[prop] = manager.oldCssProps[prop] || '';
    }
  });
  if (!add) {
    manager.oldCssProps = {};
  }
}

/**
 * @private
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
  var gestureEvent = document.createEvent('Event');
  gestureEvent.initEvent(event, true, true);
  gestureEvent.gesture = data;
  data.target.dispatchEvent(gestureEvent);
}

/**
 * @private
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */

var Hammer = function Hammer(element, options) {
  classCallCheck(this, Hammer);

  options = options || {};
  options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
  return new Manager(element, options);
};

Hammer.VERSION = '2.0.8';

/**
 * @private
 * default settings
 * @namespace
 */
Hammer.defaults = {
  /**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */
  domEvents: false,

  /**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */
  touchAction: TOUCH_ACTION_COMPUTE,

  /**
   * @private
   * @type {Boolean}
   * @default true
   */
  enable: true,

  /**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */
  inputTarget: null,

  /**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */
  inputClass: null,

  /**
   * @private
   * Default recognizer setup when calling `Hammer()`
   * When creating a new Manager these will be skipped.
   * @type {Array}
   */
  preset: [
  // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
  [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],

  /**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */
  cssProps: {
    /**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userSelect: 'none',

    /**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */
    touchSelect: 'none',

    /**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */
    touchCallout: 'none',

    /**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */
    contentZooming: 'none',

    /**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */
    userDrag: 'none',

    /**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

var SINGLE_TOUCH_INPUT_MAP = {
  touchstart: INPUT_START,
  touchmove: INPUT_MOVE,
  touchend: INPUT_END,
  touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * @private
 * Touch events input
 * @constructor
 * @extends Input
 */

var SingleTouchInput = function (_Input) {
  inherits(SingleTouchInput, _Input);

  function SingleTouchInput() {
    classCallCheck(this, SingleTouchInput);

    var _this = possibleConstructorReturn(this, (SingleTouchInput.__proto__ || Object.getPrototypeOf(SingleTouchInput)).apply(this, arguments));

    _this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    _this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    _this.started = false;

    Input.apply(_this, arguments);
    return _this;
  }

  createClass(SingleTouchInput, [{
    key: 'handler',
    value: function handler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

      // should we handle the touch events?
      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type);

      // when done, reset the started state
      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  }]);
  return SingleTouchInput;
}(Input);

function normalizeSingleTouches(ev, type) {
  var all = toArray$1(ev.touches);
  var changed = toArray$1(ev.changedTouches);

  if (type & (INPUT_END | INPUT_CANCEL)) {
    all = uniqueArray(all.concat(changed), 'identifier', true);
  }

  return [all, changed];
}

/**
 * @private
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
  var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
  return function () {
    var e = new Error('get-stack-trace');
    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

    var log = window.console && (window.console.warn || window.console.log);
    if (log) {
      log.call(window.console, deprecationMessage, stack);
    }
    return method.apply(this, arguments);
  };
}

/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function (dest, src, merge) {
  var keys = Object.keys(src);
  var i = 0;
  while (i < keys.length) {
    if (!merge || merge && dest[keys[i]] === undefined) {
      dest[keys[i]] = src[keys[i]];
    }
    i++;
  }
  return dest;
}, 'extend', 'Use `assign`.');

/**
 * @private
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function (dest, src) {
  return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * @private
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
  var baseP = base.prototype;
  var childP = void 0;

  childP = child.prototype = Object.create(baseP);
  childP.constructor = child;
  childP._super = baseP;

  if (properties) {
    assign$1(childP, properties);
  }
}

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.

assign$1(Hammer, {
  INPUT_START: INPUT_START,
  INPUT_MOVE: INPUT_MOVE,
  INPUT_END: INPUT_END,
  INPUT_CANCEL: INPUT_CANCEL,

  STATE_POSSIBLE: STATE_POSSIBLE,
  STATE_BEGAN: STATE_BEGAN,
  STATE_CHANGED: STATE_CHANGED,
  STATE_ENDED: STATE_ENDED,
  STATE_RECOGNIZED: STATE_RECOGNIZED,
  STATE_CANCELLED: STATE_CANCELLED,
  STATE_FAILED: STATE_FAILED,

  DIRECTION_NONE: DIRECTION_NONE,
  DIRECTION_LEFT: DIRECTION_LEFT,
  DIRECTION_RIGHT: DIRECTION_RIGHT,
  DIRECTION_UP: DIRECTION_UP,
  DIRECTION_DOWN: DIRECTION_DOWN,
  DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
  DIRECTION_VERTICAL: DIRECTION_VERTICAL,
  DIRECTION_ALL: DIRECTION_ALL,

  Manager: Manager,
  Input: Input,
  TouchAction: TouchAction,

  TouchInput: TouchInput,
  MouseInput: MouseInput,
  PointerEventInput: PointerEventInput,
  TouchMouseInput: TouchMouseInput,
  SingleTouchInput: SingleTouchInput,

  Recognizer: Recognizer,
  AttrRecognizer: AttrRecognizer,
  Tap: TapRecognizer,
  Pan: PanRecognizer,
  Swipe: SwipeRecognizer,
  Pinch: PinchRecognizer,
  Rotate: RotateRecognizer,
  Press: PressRecognizer,

  on: addEventListeners,
  off: removeEventListeners,
  each: each,
  merge: merge,
  extend: extend,
  assign: assign$1,
  inherit: inherit,
  bindFn: bindFn,
  prefixed: prefixed,
  toArray: toArray$1,
  inArray: inArray,
  uniqueArray: uniqueArray,
  splitStr: splitStr,
  boolOrFn: boolOrFn,
  hasParent: hasParent,
  addEventListeners: addEventListeners,
  removeEventListeners: removeEventListeners
});

/* jshint ignore:start */
if (typeof define === 'function' && define.amd) {
  define(function () {
    return Hammer;
  });
} else if (typeof module !== 'undefined' && module.exports) {
  module.exports = Hammer;
} else {
  window[exportName] = Hammer;
}
/* jshint ignore:end */
})(window, document, 'Hammer');
},{}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _ = require('./');

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * @param {Object} [options]
 * @param {Number} [count]
 * @constructor
 */
var Block = function () {
  function Block(options, count) {
    _classCallCheck(this, Block);

    this.index = 0;
    this.thaws = [];
    this.count = count || 200;
    this.options = options;
  }

  /**
   * add an item to the end of items
   * @param item
   * @returns {Block}
   */


  _createClass(Block, [{
    key: 'add',
    value: function add(item) {
      var next = this._next();
      next.add(item);

      return this;
    }

    /**
     * add an Array to the end of items
     * @param items
     * @returns {Block}
     */

  }, {
    key: 'addArray',
    value: function addArray(items) {
      var next = this._next();
      next.addArray(items);

      return this;
    }

    /**
     * insert an item into items @ current position
     * @param item
     * @returns {Block}
     */

  }, {
    key: 'insert',
    value: function insert(item) {
      var next = this._next();
      next.insert(item);

      return this;
    }

    /**
     * insert and array into items @ current position
     * @param items
     * @returns {Block}
     */

  }, {
    key: 'insertArray',
    value: function insertArray(items) {
      var next = this._next();
      next.insertArray(items);

      return this;
    }

    /**
     * Stops all thaws in this block
     * @returns {Block}
     */

  }, {
    key: 'stop',
    value: function stop() {
      for (var i = 0; i < this.thaws.length; i++) {
        this.thaws[i].stop();
      }
      return this;
    }

    /**
     * Get next available in block
     * @returns {*}
     * @private
     */

  }, {
    key: '_next',
    value: function _next() {
      var thaw = null;
      var thaws = this.thaws;

      if (thaws.length < this.count) {
        thaws.push(thaw = new _2.default([], this.options));
      } else {
        thaw = thaws[this.index];
      }
      this.index++;
      if (this.index >= this.count) {
        this.index = 0;
      }

      return thaw;
    }
  }]);

  return Block;
}();

exports.default = Block;
;

},{"./":105}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = undefined;

var _thaw = require('./thaw');

var _thaw2 = _interopRequireDefault(_thaw);

var _block = require('./block');

var _block2 = _interopRequireDefault(_block);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _thaw2.default;
exports.Block = _block2.default;


if (typeof window !== 'undefined') {
  window.Thaw = _thaw2.default;
  window.Thaw.Block = _block2.default;
}

},{"./block":104,"./thaw":106}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.thaw = thaw;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//private variables
var thawing = false;
var thaws = [];

/**
 * thaw an array of items
 * @param {Array} items
 * @param {Object} [options]
 * @constructor
 */

var Thaw = function () {
  _createClass(Thaw, null, [{
    key: "stopAll",


    /**
     * Stops all Thaw instances
     */
    value: function stopAll() {
      for (var i = 0; i < thaws.length; i++) {
        thaws[i].stop();
      }
    }
  }, {
    key: "defaultSettings",

    /**
     *
     * @type {{each: null, done: null}}
     */
    get: function get() {
      return {
        each: null,
        done: null
      };
    }

    /**
     * returns if Thaw.js is thawing
     * @returns {boolean}
     */

  }, {
    key: "isThawing",
    get: function get() {
      return thawing;
    }
  }]);

  function Thaw(items) {
    var _this = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Thaw);

    var _constructor$defaultS = _extends({}, this.constructor.defaultSettings, options),
        each = _constructor$defaultS.each,
        done = _constructor$defaultS.done;

    this.items = items;
    this.i = 0;
    this.options = options;
    var tick = this.tick = function () {
      if (_this.i < 0) return;

      _this.timeout = setTimeout(tick, 0);

      if (thawing) return;
      var item = items[_this.i];
      if (_this.i >= items.length) {
        if (done !== null) {
          thawing = true;
          done(item, _this.i);
          thawing = false;
        }

        _this.i = -1;
        clearTimeout(_this.timeout);
        return;
      }
      if (each !== null) {
        thawing = true;
        each(item, _this.i);
        thawing = false;
      } else if (item !== undefined) {
        item();
      }
      _this.i++;
    };

    thaws.push(this);
    if (!options.delay) {
      tick();
    }
  }

  /**
   * readies thaw to continue
   * @returns {boolean} if had to get ready
   */


  _createClass(Thaw, [{
    key: "makeReady",
    value: function makeReady() {
      if (this.i < 0) {
        this.i = this.items.length;
        return true;
      }
      return false;
    }

    /**
     * Adds an item to the end of this instance of Thaw and readies Thaw to process it
     * @param item
     * @returns {Thaw}
     */

  }, {
    key: "add",
    value: function add(item) {
      var doTick = this.makeReady();

      this.items.push(item);

      if (doTick) {
        this.tick();
      }
      return this;
    }

    /**
     * Inserts an item just after the current item being processed in Thaw and readies Thaw to process it
     * @param item
     * @returns {Thaw}
     */

  }, {
    key: "insert",
    value: function insert(item) {
      var doTick = this.makeReady();

      this.items.splice(this.i, 0, item);

      if (doTick) {
        this.tick();
      }

      return this;
    }

    /**
     * Adds an Array to the end of this instance of Thaw and readies Thaw to process it
     * @param {Array} items
     * @returns {Thaw}
     */

  }, {
    key: "addArray",
    value: function addArray(items) {
      var doTick = this.makeReady();

      this.items = this.items.concat(items);

      if (doTick) {
        this.tick();
      }

      return this;
    }

    /**
     * Inserts an Array just after the current item being processed in Thaw and readies Thaw to process them
     * @param {Array} items
     * @returns {Thaw}
     */

  }, {
    key: "insertArray",
    value: function insertArray(items) {
      var doTick = this.makeReady();
      var left = this.items;
      var middle = items;
      var right = this.items.splice(this.i, this.items.length - this.i + 1);

      this.items = left.concat(middle, right);

      if (doTick) {
        this.tick();
      }
      return this;
    }

    /**
     * Stops this instance of Thaw
     * @returns {Thaw}
     */

  }, {
    key: "stop",
    value: function stop() {
      this.i = -1;
      clearTimeout(this.timeout);
      if (this.options.done) {
        this.options.done();
      }
      return this;
    }
  }]);

  return Thaw;
}();

/**
 * simple thaw
 * @param {Array} items
 * @param {Object} [options]
 * @returns Thaw
 */


exports.default = Thaw;
function thaw(items) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  return new Thaw(items, options);
}

},{}],107:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],108:[function(require,module,exports){

},{}],109:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":107,"ieee754":112}],110:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":114}],111:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],112:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],113:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],114:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],115:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],116:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":117}],117:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],118:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":119}],119:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":121,"./_stream_writable":123,"core-util-is":110,"inherits":113,"process-nextick-args":116}],120:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":122,"core-util-is":110,"inherits":113}],121:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":119,"./internal/streams/BufferList":124,"./internal/streams/destroy":125,"./internal/streams/stream":126,"_process":117,"core-util-is":110,"events":111,"inherits":113,"isarray":115,"process-nextick-args":116,"safe-buffer":132,"string_decoder/":127,"util":108}],122:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":119,"core-util-is":110,"inherits":113}],123:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":119,"./internal/streams/destroy":125,"./internal/streams/stream":126,"_process":117,"core-util-is":110,"inherits":113,"process-nextick-args":116,"safe-buffer":132,"timers":134,"util-deprecate":135}],124:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":132,"util":108}],125:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":116}],126:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":111}],127:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":132}],128:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":129}],129:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":119,"./lib/_stream_passthrough.js":120,"./lib/_stream_readable.js":121,"./lib/_stream_transform.js":122,"./lib/_stream_writable.js":123}],130:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":129}],131:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":123}],132:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":109}],133:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":111,"inherits":113,"readable-stream/duplex.js":118,"readable-stream/passthrough.js":128,"readable-stream/readable.js":129,"readable-stream/transform.js":130,"readable-stream/writable.js":131}],134:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":117,"timers":134}],135:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[13])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImpzL2xpYi9haUJyYWluLmpzIiwianMvbGliL2NhbnZhc1JlbmRlcmluZ0NvbnRleHQyREV4dGVuc2lvbnMuanMiLCJqcy9saWIvZ2FtZS5qcyIsImpzL2xpYi9ndWlkLmpzIiwianMvbGliL2luZm9Cb3guanMiLCJqcy9saWIvaXNNb2JpbGVEZXZpY2UuanMiLCJqcy9saWIvbW9uc3Rlci5qcyIsImpzL2xpYi9wbHVnaW5zLmpzIiwianMvbGliL3NraWVyLmpzIiwianMvbGliL3Nub3dib2FyZGVyLmpzIiwianMvbGliL3Nwcml0ZS5qcyIsImpzL2xpYi9zcHJpdGVBcnJheS5qcyIsImpzL21haW4uanMiLCJqcy9zcHJpdGVJbmZvLmpzIiwibm9kZV9tb2R1bGVzL2JyLW1vdXNldHJhcC9tb3VzZXRyYXAuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9jcm9zcy12YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L2xpa2VseS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L2xvb2t1cC5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L25ldXJhbC1uZXR3b3JrLWdwdS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L25ldXJhbC1uZXR3b3JrLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L2dydS10aW1lLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvZ3J1LmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L2xzdG0tdGltZS1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L2xzdG0uanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L2FkZC1iLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L21hdHJpeC9hZGQuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L2FsbC1vbmVzLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L21hdHJpeC9jbG9uZS1uZWdhdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvZXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L21hdHJpeC9tYXgtaS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvbXVsdGlwbHktYi5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvbXVsdGlwbHktZWxlbWVudC1iLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L21hdHJpeC9tdWx0aXBseS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L21hdHJpeC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvb25lcy1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L3JhbmRvbS1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L3JlbHUtYi5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvcmVsdS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvcm93LXBsdWNrLWIuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L3Jvdy1wbHVjay5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvc2FtcGxlLWkuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvbWF0cml4L3NpZ21vaWQtYi5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvc2lnbW9pZC5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvc29mdG1heC5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3JlY3VycmVudC9tYXRyaXgvdGFuaC1iLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L21hdHJpeC90YW5oLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvcmVjdXJyZW50L3Jubi10aW1lLXN0ZXAuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC9yZWN1cnJlbnQvcm5uLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdHJhaW4tc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL2FycmF5LWxvb2t1cC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3V0aWxpdGllcy9jYXN0LmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL2RhdGEtZm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL2xvb2t1cC10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3V0aWxpdGllcy9tYXguanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC91dGlsaXRpZXMvbXNlLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL29uZXMuanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC91dGlsaXRpZXMvcmFuZG9tLXdlaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3V0aWxpdGllcy9yYW5kb20uanMiLCJub2RlX21vZHVsZXMvYnJhaW4uanMvZGlzdC91dGlsaXRpZXMvcmFuZG9zLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL3RvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2JyYWluLmpzL2Rpc3QvdXRpbGl0aWVzL3RvLXN2Zy5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9kaXN0L3V0aWxpdGllcy96ZXJvcy5qcyIsIm5vZGVfbW9kdWxlcy9icmFpbi5qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudGVkbG9vcC9saWIvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudGVkbG9vcC9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvY3B1L2Z1bmN0aW9uLWJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL2NwdS9rZXJuZWwtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvY3B1L2tlcm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL2NwdS9ydW5uZXIuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC9mdW5jdGlvbi1idWlsZGVyLWJhc2UuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC9mdW5jdGlvbi1ub2RlLWJhc2UuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC9rZXJuZWwtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL2tlcm5lbC1ydW4tc2hvcnRjdXQuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC9ydW5uZXItYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvd2ViLWdsL2Z1bmN0aW9uLW5vZGUuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC93ZWItZ2wva2VybmVsLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL3dlYi1nbC9rZXJuZWwuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC93ZWItZ2wvcnVubmVyLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvd2ViLWdsL3NoYWRlci1mcmFnLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvd2ViLWdsL3NoYWRlci12ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvd2ViLWdsL3ZhbGlkYXRvci1rZXJuZWwuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLWJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLW5vZGUuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC93ZWItZ2wyL2tlcm5lbC5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL3dlYi1nbDIvcnVubmVyLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2JhY2tlbmQvd2ViLWdsMi9zaGFkZXItZnJhZy5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9iYWNrZW5kL3dlYi1nbDIvc2hhZGVyLXZlcnQuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvYmFja2VuZC93ZWItZ2wyL3ZhbGlkYXRvci1rZXJuZWwuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvY29yZS9hbGlhcy5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9jb3JlL2dwdS1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2NvcmUvZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2NvcmUvaW5wdXQuanMiLCJub2RlX21vZHVsZXMvZ3B1LmpzL2Rpc3QvY29yZS90ZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2NvcmUvdXRpbHMtY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ncHUuanMvZGlzdC9jb3JlL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dwdS5qcy9ub2RlX21vZHVsZXMvYWNvcm4vZGlzdC9hY29ybi5qcyIsIm5vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanMiLCJub2RlX21vZHVsZXMvdGhhdy5qcy9kaXN0L2Jsb2NrLmpzIiwibm9kZV9tb2R1bGVzL3RoYXcuanMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aGF3LmpzL2Rpc3QvdGhhdy5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9nQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3A5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqdUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2cUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsInZhciBCcmFpbiA9IHJlcXVpcmUoJ2JyYWluLmpzJyk7XG5cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cdGZ1bmN0aW9uIEFpQnJhaW4gKCkge1xuICAgICAgICB0aGlzLmFpQnJhaW5KcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGVwID0gMDtcblxuICAgICAgICB0aGlzLnRyYWluaW5nVmVjdG9ycyA9IFtdOyAvLyBUT0RPIHdlIHNob3VsZCB1c2Ugc3RyZWFtIGlucHV0IGZvciBicmFpbmpzXG5cbiAgICAgICAgdGhpcy5MRUFSTklOR19TVEVQX0NPVU5UID0gMTAwO1xuICAgICAgICB0aGlzLlJFUExBWV9TVEVQX0NPVU5UID0gMzAwO1xuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYWlCcmFpbkpzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zdGVwID0gMDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhaUJyYWluOiByZXNldCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jeWNsZSA9IGZ1bmN0aW9uKG1vdXNlTWFwUG9zaXRpb24sIHN0YXRpY09iamVjdHMsIG1vdmluZ09iamVjdHMsIHBsYXllcikge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRTaXR1YXRpb24gPSB0aGlzLmNhbGNTaXR1YXRpb24oc3RhdGljT2JqZWN0cywgbW92aW5nT2JqZWN0cywgcGxheWVyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuUkVQTEFZX1NURVBfQ09VTlQgPCB0aGlzLnN0ZXApIHtcbiAgICAgICAgICAgICAgICAvLyBwZXJtZXQgZCdhcnJldGVyIGxlcyBsb2dzXG4gICAgICAgICAgICAgICAgdGhpcy5haUJyYWluSnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTaXR1YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXAgPCB0aGlzLkxFQVJOSU5HX1NURVBfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYWlCcmFpbjogcmVjb3JkJyk7XG4gICAgICAgICAgICAgICAgLy8gd2UgbGVhcm4gKHNhbXBsZWQgbGVhcm5pbmcsIG9ubHkgd2hlbiB0aGVyZSBpcyBjaGFuZ2UgaW4gdGhlIGlucHV0cylcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaXR1YXRpb246IFwiLCBjdXJyZW50U2l0dWF0aW9uKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudHJhaW5pbmdWZWN0b3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IGN1cnJlbnRTaXR1YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IHsgYW5nbGU6IHRoaXMuZ2V0QW5nbGUobW91c2VNYXBQb3NpdGlvbiwgcGxheWVyLm1hcFBvc2l0aW9uKSB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RlcCA8IHRoaXMuUkVQTEFZX1NURVBfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWlCcmFpbkpzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhaUJyYWluOiB0cmFpbiBBSScpO1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjcmVhdGUgYW5kIHRyYWluIHRoZSBJQVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPXG5cbiAgICAgICAgICAgICAgICAgICAgXHRcdFx0XHRcdC8vIG9uIGNhbGN1bGUgbGEgZm9uY3Rpb25cblx0XHRcdFx0XHRjb25zdCBjb25maWcgPSB7XG5cdFx0XHRcdFx0XHRiaW5hcnlUaHJlc2g6IDAuNSxcblx0XHRcdFx0XHRcdGhpZGRlbkxheWVyczogWzNdLCAgICAgLy8gYXJyYXkgb2YgaW50cyBmb3IgdGhlIHNpemVzIG9mIHRoZSBoaWRkZW4gbGF5ZXJzIGluIHRoZSBuZXR3b3JrXG5cdFx0XHRcdFx0XHRhY3RpdmF0aW9uOiAnc2lnbW9pZCcsICAvLyBzdXBwb3J0ZWQgYWN0aXZhdGlvbiB0eXBlczogWydzaWdtb2lkJywgJ3JlbHUnLCAnbGVha3ktcmVsdScsICd0YW5oJ10sXG5cdFx0XHRcdFx0XHRsZWFreVJlbHVBbHBoYTogMC4wMSAgIC8vIHN1cHBvcnRlZCBmb3IgYWN0aXZhdGlvbiB0eXBlICdsZWFreS1yZWx1J1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBjcmVhdGUgYSBzaW1wbGUgZmVlZCBmb3J3YXJkIG5ldXJhbCBuZXR3b3JrIHdpdGggYmFja3Byb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWlCcmFpbkpzID0gbmV3IEJyYWluLk5ldXJhbE5ldHdvcmsoY29uZmlnKTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmFpQnJhaW5Kcykge1xuXHRcdFx0XHRcdFx0Ly8gdHJhaW4gdGhlIElBXG5cdFx0XHRcdFx0XHRsZXQgZGF0YUZvclRyYWluaW5nID0gdGhpcy50cmFpbmluZ1ZlY3RvcnMubWFwKHggPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge2lucHV0OiB4LmlucHV0cy5jb252ZXJ0KCksIG91dHB1dDogW3gub3V0cHV0cy5hbmdsZV19O1xuXHRcdFx0XHRcdFx0fSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHV0aWxpc2VyIGwnQVBJIGRlIHN0cmVhbWluZ1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlY2hhbnRpbGxvbm5hZ2U/XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhaXJlIHVuIHByZSBhcHByZW50aXNzYWdlIGJhc2Ugc3VyIGR1IHByZXByb2Nlc3NpbmcgKHRyYW5zZmVydCBkZSBsZWFybmluZylcblx0XHRcdFx0XHRcdFx0XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiaW5wdXRzOiBcIiwgZGF0YUZvclRyYWluaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5haUJyYWluSnMudHJhaW4oZGF0YUZvclRyYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3VyIGxlIHRlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWlCcmFpbkpzLnRyYWluKFt7IGlucHV0OiBbMCwgMF0sIG91dHB1dDogWzBdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7IGlucHV0OiBbMCwgMV0sIG91dHB1dDogWzFdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7IGlucHV0OiBbMSwgMF0sIG91dHB1dDogWzFdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB7IGlucHV0OiBbMSwgMV0sIG91dHB1dDogWzBdIH1dKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFsZXJ0IHRoZSB1c2VyIGFib3V0IHRoZSBzd2l0Y2ggdG8gdGhlIHJlcGxheSBtb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FpQnJhaW46IHJlcGxheScpO1xuICAgICAgICAgICAgICAgIC8vIHdlIHJlcGxheSB2aWEgZ2V0QUlDb21tYW5kXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIHRoZSBzY29yZSBwYXJ0XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2NvcmUocGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RlcCsrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFNpdHVhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0QUlDb21tYW5kID0gZnVuY3Rpb24ocGxheWVyLCBjdXJyZW50U2l0dWF0aW9uKSB7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTaXR1YXRpb24gJiYgdGhpcy5haUJyYWluSnMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSByZXR1cm4gdGhlIGNvbW1hbmQgY2FsY3VsYXRlZCBieSB0aGUgSUFcbiAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2FpQnJhaW46IGdldEFJQ29tbWFuZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5haUJyYWluSnMucnVuKGN1cnJlbnRTaXR1YXRpb24uY29udmVydCgpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm91dHB1dFwiLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gb3V0cHV0ICogTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhbmdsZVwiLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgbGV0IG1vdXNlTWFwUG9zaXRpb24gPSBbMCwwXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsdGEgPSB7eDogMTAwICogTWF0aC5zaW4oYW5nbGUpLCB5OiAxMDAgKiBNYXRoLmNvcyhhbmdsZSl9O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVsdGFcIiwgZGVsdGEpO1xuICAgICAgICAgICAgICAgIG1vdXNlTWFwUG9zaXRpb25bMF0gPSBwbGF5ZXIuY2FudmFzWCArIGRlbHRhLng7XG4gICAgICAgICAgICAgICAgbW91c2VNYXBQb3NpdGlvblsxXSA9IHBsYXllci5jYW52YXNYICsgZGVsdGEueTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1vdXNlTWFwUG9zaXRpb25cIiwgbW91c2VNYXBQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHttb3VzZU1hcFBvc2l0aW9uOiBtb3VzZU1hcFBvc2l0aW9ufTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW5kY3ljbGUgPSBmdW5jdGlvbihwbGF5ZXIpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gd2hlcmUgdG8gY2FsbCBpdCBmcm9tIGdhbWUuanMgPz9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhaUJyYWluOiBlbmRjeWNsZScpO1xuICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBzdGVwXG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwIDwgdGhpcy5MRUFSTklOR19TVEVQX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHNraWVyIHNob3VsZCBub3QgYmUgYWJsZSB0byBkaWUgaW4gdGhlIGxlYXJuaW5nIHBoYXNlXG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0ZXAgPCB0aGlzLlJFUExBWV9TVEVQX0NPVU5UKSB7XG5cblxuXG4gICAgICAgICAgICAgICAgLy8gd2FybiB0aGUgdXNlciB0aGUgSUEganVzdCBkaWVkXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2NvcmUocGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHJvY2Vzc1Njb3JlID0gZnVuY3Rpb24ocGxheWVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYWlCcmFpbjogcHJvY2VzcyBzY29yZScpO1xuICAgICAgICAgICAgYWxlcnQoJ1lPVVIgU0NPUkUgSVM6ICcpO1xuICAgICAgICAgICAgLy8gVE9ET1xuXG4gICAgICAgICAgICAvLyBGUEVUT0RPIGVuIG1vZGUgZGV2LCBvbiB2ZXV0IHBhcyBxdWUgY2EgcmVjb21tZW5jZS4uLiB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFRPRE8gZ2FtZSBtdXN0IGJlIGFsc28gcmVzZXRcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY1NpdHVhdGlvbiA9IGZ1bmN0aW9uKHN0YXRpY09iamVjdHMsIG1vdmluZ09iamVjdHMsIHBsYXllcilcbiAgICAgICAge1xuXHRcdFx0bGV0IGlhSW5wdXRzID0ge1xuXHRcdFx0XHRlbnZJbnB1dHM6IFtdLFxuXHRcdFx0XHRwbGF5ZXJJbnB1dHM6IHt9LFxuXHRcdFx0XHRkdW1teUlucHV0OiB7eDogMCwgeTogMCwgdHlwZTogMCwgZGlzdDogMH0sXG5cdFx0XHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGxldCByZXN1bHQgPSB0aGlzLmVudklucHV0cy5mbGF0TWFwKHggPT4gW3gueCAvIDIwMDAsIHgueSAvIDIwMDAsIHgudHlwZV0pOyAvLyAyMDAwIHBvdXIgbm9ybWFsaXNlciBhIGxhIGhhY2hlXG5cdFx0XHRcdFx0Ly8gRlBFVE9ETyBub3JtYWxpc2VyIGVudHJlIDAgZXQgMVxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHRoaXMucGxheWVySW5wdXRzLmRpcik7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuICAgICAgICAgICAgLy8gVE9ETyBham91dGVyIGxhIHZpdGVzc2UgZHUgc2tpZXIgY29tbWUgZW50cmVlPz9cblxuICAgICAgICAgICAgLy8gRlBFVE9ETyBwbGF5ZXIuZGlyZWN0aW9uIGVzdCBwYXJmb2lzIHVuZGVmaW5lZCAuLi5cblx0XHRcdGlhSW5wdXRzLnBsYXllcklucHV0cyA9IHsgZGlyOiAwIH07IC8vIHBvdXIgdGVzdCB0cmFpbiBwbGF5ZXIuZGlyZWN0aW9uIH07XG5cblx0XHRcdHN0YXRpY09iamVjdHMuZWFjaChvYmogPT4ge1xuXHRcdFx0XHRpZiAoIW9iai5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IHt4OiBvYmouY2FudmFzWCAtIHBsYXllci5tYXBQb3NpdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9iai5jYW52YXNZIC0gcGxheWVyLm1hcFBvc2l0aW9uWzFdfTtcblx0XHRcdFx0XHRpYUlucHV0cy5lbnZJbnB1dHMucHVzaCh7IHg6IGRlbHRhLngsIFxuXHRcdFx0XHRcdFx0eTogZGVsdGEueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDAsICAvLyBjb21tZW50IHR5cGVyIGxlcyBvYmpldHM/XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0OiBNYXRoLmFicyhkZWx0YS54ICogZGVsdGEueCArIGRlbHRhLnkgKiBkZWx0YS55KVxuICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdG1vdmluZ09iamVjdHMuZWFjaChvYmogPT4ge1xuXHRcdFx0XHRpZiAoIW9iai5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YSA9IHt4OiBvYmouY2FudmFzWCAtIHBsYXllci5tYXBQb3NpdGlvblswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG9iai5jYW52YXNZIC0gcGxheWVyLm1hcFBvc2l0aW9uWzFdfTtcblx0XHRcdFx0XHRpYUlucHV0cy5lbnZJbnB1dHMucHVzaCh7IHg6IGRlbHRhLngsIFxuXHRcdFx0XHRcdFx0eTogZGVsdGEueSxcblx0XHRcdFx0XHRcdHR5cGU6IDEsICAvLyBjb21tZW50IHR5cGVyIGxlcyBvYmpldHM/XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0OiBNYXRoLmFicyhkZWx0YS54ICogZGVsdGEueCArIGRlbHRhLnkgKiBkZWx0YS55KVxuICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gd2UgdGFrZSA1IG5lYXJlc3Qgb2JqZWN0c1xuICAgICAgICAgICAgaWFJbnB1dHMuZW52SW5wdXRzLnNvcnQoKGEsIGIpID0+IGEuZGlzdCAtIGIuZGlzdCk7XG4gICAgICAgICAgICBpYUlucHV0cy5lbnZJbnB1dHMuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICBcblx0XHRcdC8vIHdlIGNvbXBsZXRlIHVwIHRvIDVcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNTsgKytpKSB7XG5cdFx0XHRcdGlmICghaWFJbnB1dHMuZW52SW5wdXRzW2ldKSB7XG5cdFx0XHRcdFx0aWFJbnB1dHMuZW52SW5wdXRzW2ldID0gaWFJbnB1dHMuZHVtbXlJbnB1dDtcblx0XHRcdFx0fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gaWFJbnB1dHM7XG4gICAgICAgIH0gXG5cbiAgICAgICAgdGhpcy5nZXRBbmdsZSA9IGZ1bmN0aW9uKG1vdXNlTWFwUG9zaXRpb24sIHBsYXllck1hcFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBsZXQgcmVsYXRpdmVNb3VzZVBvcyA9IFttb3VzZU1hcFBvc2l0aW9uWzBdIC0gcGxheWVyTWFwUG9zaXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZU1hcFBvc2l0aW9uWzFdIC0gcGxheWVyTWFwUG9zaXRpb25bMV1dO1xuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlTW91c2VQb3NbMV0gIT09IDAgXG4gICAgICAgICAgICAgICAgPyBNYXRoLmF0YW4ocmVsYXRpdmVNb3VzZVBvc1swXSAvIHJlbGF0aXZlTW91c2VQb3NbMV0pIC8gKE1hdGguUEkgLyAyKSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnbG9iYWwuQWlCcmFpbiA9IEFpQnJhaW47XG59KSh0aGlzKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdGhpcy5BaUJyYWluO1xufSIsIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3RvcmVMb2FkZWRJbWFnZSA9IGZ1bmN0aW9uIChrZXksIGltYWdlKSB7XG5cdGlmICghdGhpcy5pbWFnZXMpIHtcblx0XHR0aGlzLmltYWdlcyA9IHt9O1xuXHR9XG5cblx0dGhpcy5pbWFnZXNba2V5XSA9IGltYWdlO1xufTtcblxuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5nZXRMb2FkZWRJbWFnZSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0aWYgKHRoaXMuaW1hZ2VzW2tleV0pIHtcblx0XHRyZXR1cm4gdGhpcy5pbWFnZXNba2V5XTtcblx0fVxufTtcblxuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5mb2xsb3dTcHJpdGUgPSBmdW5jdGlvbiAoc3ByaXRlKSB7XG5cdHRoaXMuY2VudHJhbFNwcml0ZSA9IHNwcml0ZTtcbn07XG5cbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZ2V0Q2VudHJhbFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4ge1xuXHRcdG1hcDogdGhpcy5jZW50cmFsU3ByaXRlLm1hcFBvc2l0aW9uLFxuXHRcdGNhbnZhczogWyBNYXRoLnJvdW5kKHRoaXMuY2FudmFzLndpZHRoICogMC41KSwgTWF0aC5yb3VuZCh0aGlzLmNhbnZhcy5oZWlnaHQgKiAwLjUpLCAwXVxuXHR9O1xufTtcblxuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5tYXBQb3NpdGlvblRvQ2FudmFzUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0dmFyIGNlbnRyYWwgPSB0aGlzLmdldENlbnRyYWxQb3NpdGlvbigpO1xuXHR2YXIgY2VudHJhbE1hcFBvc2l0aW9uID0gY2VudHJhbC5tYXA7XG5cdHZhciBjZW50cmFsQ2FudmFzUG9zaXRpb24gPSBjZW50cmFsLmNhbnZhcztcblx0dmFyIG1hcERpZmZlcmVuY2VYID0gY2VudHJhbE1hcFBvc2l0aW9uWzBdIC0gcG9zaXRpb25bMF07XG5cdHZhciBtYXBEaWZmZXJlbmNlWSA9IGNlbnRyYWxNYXBQb3NpdGlvblsxXSAtIHBvc2l0aW9uWzFdO1xuXHRyZXR1cm4gWyBjZW50cmFsQ2FudmFzUG9zaXRpb25bMF0gLSBtYXBEaWZmZXJlbmNlWCwgY2VudHJhbENhbnZhc1Bvc2l0aW9uWzFdIC0gbWFwRGlmZmVyZW5jZVkgXTtcbn07XG5cbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2FudmFzUG9zaXRpb25Ub01hcFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG5cdHZhciBjZW50cmFsID0gdGhpcy5nZXRDZW50cmFsUG9zaXRpb24oKTtcblx0dmFyIGNlbnRyYWxNYXBQb3NpdGlvbiA9IGNlbnRyYWwubWFwO1xuXHR2YXIgY2VudHJhbENhbnZhc1Bvc2l0aW9uID0gY2VudHJhbC5jYW52YXM7XG5cdHZhciBtYXBEaWZmZXJlbmNlWCA9IGNlbnRyYWxDYW52YXNQb3NpdGlvblswXSAtIHBvc2l0aW9uWzBdO1xuXHR2YXIgbWFwRGlmZmVyZW5jZVkgPSBjZW50cmFsQ2FudmFzUG9zaXRpb25bMV0gLSBwb3NpdGlvblsxXTtcblx0cmV0dXJuIFsgY2VudHJhbE1hcFBvc2l0aW9uWzBdIC0gbWFwRGlmZmVyZW5jZVgsIGNlbnRyYWxNYXBQb3NpdGlvblsxXSAtIG1hcERpZmZlcmVuY2VZIF07XG59O1xuXG5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmdldENlbnRyZU9mVmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5jYW52YXMud2lkdGggLyAyKS5mbG9vcigpO1xufTtcblxuLy8gWS1wb3MgY2FudmFzIGZ1bmN0aW9uc1xuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5nZXRNaWRkbGVPZlZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHRoaXMuY2FudmFzLmhlaWdodCAvIDIpLmZsb29yKCk7XG59O1xuXG5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmdldEJlbG93Vmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQuZmxvb3IoKTtcbn07XG5cbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZ2V0TWFwQmVsb3dWaWV3cG9ydCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGJlbG93ID0gdGhpcy5nZXRCZWxvd1ZpZXdwb3J0KCk7XG5cdHJldHVybiB0aGlzLmNhbnZhc1Bvc2l0aW9uVG9NYXBQb3NpdGlvbihbIDAsIGJlbG93IF0pWzFdO1xufTtcblxuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5nZXRSYW5kb21seUluVGhlQ2VudHJlT2ZDYW52YXMgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdHZhciBtaW4gPSAwO1xuXHR2YXIgbWF4ID0gdGhpcy5jYW52YXMud2lkdGg7XG5cblx0aWYgKGJ1ZmZlcikge1xuXHRcdG1pbiAtPSBidWZmZXI7XG5cdFx0bWF4ICs9IGJ1ZmZlcjtcblx0fVxuXG5cdHJldHVybiBOdW1iZXIucmFuZG9tKG1pbiwgbWF4KTtcbn07XG5cbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZ2V0UmFuZG9tbHlJblRoZUNlbnRyZU9mTWFwID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHR2YXIgcmFuZG9tID0gdGhpcy5nZXRSYW5kb21seUluVGhlQ2VudHJlT2ZDYW52YXMoYnVmZmVyKTtcblx0cmV0dXJuIHRoaXMuY2FudmFzUG9zaXRpb25Ub01hcFBvc2l0aW9uKFsgcmFuZG9tLCAwIF0pWzBdO1xufTtcblxuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5nZXRSYW5kb21NYXBQb3NpdGlvbkJlbG93Vmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB4Q2FudmFzID0gdGhpcy5nZXRSYW5kb21seUluVGhlQ2VudHJlT2ZDYW52YXMoKTtcblx0dmFyIHlDYW52YXMgPSB0aGlzLmdldEJlbG93Vmlld3BvcnQoKTtcblx0cmV0dXJuIHRoaXMuY2FudmFzUG9zaXRpb25Ub01hcFBvc2l0aW9uKFsgeENhbnZhcywgeUNhbnZhcyBdKTtcbn07XG5cbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZ2V0UmFuZG9tTWFwUG9zaXRpb25BYm92ZVZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgeENhbnZhcyA9IHRoaXMuZ2V0UmFuZG9tbHlJblRoZUNlbnRyZU9mQ2FudmFzKCk7XG5cdHZhciB5Q2FudmFzID0gdGhpcy5nZXRBYm92ZVZpZXdwb3J0KCk7XG5cdHJldHVybiB0aGlzLmNhbnZhc1Bvc2l0aW9uVG9NYXBQb3NpdGlvbihbIHhDYW52YXMsIHlDYW52YXMgXSk7XG59O1xuXG5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmdldFRvcE9mVmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNhbnZhc1Bvc2l0aW9uVG9NYXBQb3NpdGlvbihbIDAsIDAgXSlbMV07XG59O1xuXG5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmdldEFib3ZlVmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAwIC0gKHRoaXMuY2FudmFzLmhlaWdodCAvIDQpLmZsb29yKCk7XG59OyIsInZhciBTcHJpdGVBcnJheSA9IHJlcXVpcmUoJy4vc3ByaXRlQXJyYXknKTtcbnZhciBFdmVudGVkTG9vcCA9IHJlcXVpcmUoJ2V2ZW50ZWRsb29wJyk7XG52YXIgQWlCcmFpbiA9IHJlcXVpcmUoJy4vYWlCcmFpbicpO1xuXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuXHRmdW5jdGlvbiBHYW1lIChtYWluQ2FudmFzLCBwbGF5ZXIpIHtcblx0XHR2YXIgc3RhdGljT2JqZWN0cyA9IG5ldyBTcHJpdGVBcnJheSgpO1xuXHRcdHZhciBtb3ZpbmdPYmplY3RzID0gbmV3IFNwcml0ZUFycmF5KCk7XG5cdFx0dmFyIHVpRWxlbWVudHMgPSBuZXcgU3ByaXRlQXJyYXkoKTtcblx0XHR2YXIgZENvbnRleHQgPSBtYWluQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0dmFyIG1vdXNlWCA9IGRDb250ZXh0LmdldENlbnRyZU9mVmlld3BvcnQoKTtcblx0XHR2YXIgbW91c2VZID0gMDtcblx0XHR2YXIgcGF1c2VkID0gZmFsc2U7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBiZWZvcmVDeWNsZUNhbGxiYWNrcyA9IFtdO1xuXHRcdHZhciBhZnRlckN5Y2xlQ2FsbGJhY2tzID0gW107XG5cdFx0dmFyIGdhbWVMb29wID0gbmV3IEV2ZW50ZWRMb29wKCk7XG5cdFx0dmFyIGFpQnJhaW4gPSBuZXcgQWlCcmFpbigpO1xuXHRcdGFpQnJhaW4ucmVzZXQoKTtcblxuXHRcdHRoaXMuYWRkU3RhdGljT2JqZWN0ID0gZnVuY3Rpb24gKHNwcml0ZSkge1xuXHRcdFx0c3RhdGljT2JqZWN0cy5wdXNoKHNwcml0ZSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuYWRkU3RhdGljT2JqZWN0cyA9IGZ1bmN0aW9uIChzcHJpdGVzKSB7XG5cdFx0XHRzcHJpdGVzLmZvckVhY2godGhpcy5hZGRTdGF0aWNPYmplY3QuYmluZCh0aGlzKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuYWRkTW92aW5nT2JqZWN0ID0gZnVuY3Rpb24gKG1vdmluZ09iamVjdCwgbW92aW5nT2JqZWN0VHlwZSkge1xuXHRcdFx0aWYgKG1vdmluZ09iamVjdFR5cGUpIHtcblx0XHRcdFx0c3RhdGljT2JqZWN0cy5vblB1c2goZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRcdGlmIChvYmouZGF0YSAmJiBvYmouZGF0YS5oaXRCZWhhdmlvdXJbbW92aW5nT2JqZWN0VHlwZV0pIHtcblx0XHRcdFx0XHRcdG9iai5vbkhpdHRpbmcobW92aW5nT2JqZWN0LCBvYmouZGF0YS5oaXRCZWhhdmlvdXJbbW92aW5nT2JqZWN0VHlwZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdG1vdmluZ09iamVjdHMucHVzaChtb3ZpbmdPYmplY3QpO1xuXHRcdH07XG5cblx0XHR0aGlzLmFkZFVJRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHR1aUVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuYmVmb3JlQ3ljbGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGJlZm9yZUN5Y2xlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdH07XG5cblx0XHR0aGlzLmFmdGVyQ3ljbGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdGFmdGVyQ3ljbGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0TW91c2VYID0gZnVuY3Rpb24gKHgpIHtcblx0XHRcdG1vdXNlWCA9IHg7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0TW91c2VZID0gZnVuY3Rpb24gKHkpIHtcblx0XHRcdG1vdXNlWSA9IHk7XG5cdFx0fTtcblxuXHRcdHBsYXllci5zZXRNYXBQb3NpdGlvbigwLCAwKTtcblx0XHRwbGF5ZXIuc2V0TWFwUG9zaXRpb25UYXJnZXQoMCwgLTEwKTtcblx0XHRkQ29udGV4dC5mb2xsb3dTcHJpdGUocGxheWVyKTtcblxuXHRcdHZhciBpbnRlcnZhbE51bSA9IDA7XG5cblx0XHR0aGlzLmN5Y2xlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0YmVmb3JlQ3ljbGVDYWxsYmFja3MuZWFjaChmdW5jdGlvbihjKSB7XG5cdFx0XHRcdGMoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBDbGVhciBjYW52YXNcblx0XHRcdHZhciBtb3VzZU1hcFBvc2l0aW9uID0gZENvbnRleHQuY2FudmFzUG9zaXRpb25Ub01hcFBvc2l0aW9uKFttb3VzZVgsIG1vdXNlWV0pO1xuXG5cdFx0XHRsZXQgY3VycmVudFNpdHVhdGlvbiA9IGFpQnJhaW4uY3ljbGUobW91c2VNYXBQb3NpdGlvbiwgc3RhdGljT2JqZWN0cywgbW92aW5nT2JqZWN0cywgcGxheWVyKTtcblxuXHRcdFx0aWYgKCFwbGF5ZXIuaXNKdW1waW5nKSB7XG5cdFx0XHRcdGxldCBhaUNvbW1hbmQgPSBhaUJyYWluLmdldEFJQ29tbWFuZChwbGF5ZXIsIGN1cnJlbnRTaXR1YXRpb24pO1xuXHRcdFx0XHRpZiAoYWlDb21tYW5kKSB7XG5cdFx0XHRcdFx0bW91c2VNYXBQb3NpdGlvbiA9IGFpQ29tbWFuZC5tb3VzZU1hcFBvc2l0aW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsYXllci5zZXRNYXBQb3NpdGlvblRhcmdldChtb3VzZU1hcFBvc2l0aW9uWzBdLCBtb3VzZU1hcFBvc2l0aW9uWzFdKTtcblx0XHRcdH1cblxuXHRcdFx0aW50ZXJ2YWxOdW0rKztcblxuXHRcdFx0cGxheWVyLmN5Y2xlKCk7XG5cblx0XHRcdG1vdmluZ09iamVjdHMuZWFjaChmdW5jdGlvbiAobW92aW5nT2JqZWN0LCBpKSB7XG5cdFx0XHRcdG1vdmluZ09iamVjdC5jeWNsZShkQ29udGV4dCk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0c3RhdGljT2JqZWN0cy5jdWxsKCk7XG5cdFx0XHRzdGF0aWNPYmplY3RzLmVhY2goZnVuY3Rpb24gKHN0YXRpY09iamVjdCwgaSkge1xuXHRcdFx0XHRpZiAoc3RhdGljT2JqZWN0LmN5Y2xlKSB7XG5cdFx0XHRcdFx0c3RhdGljT2JqZWN0LmN5Y2xlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR1aUVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKHVpRWxlbWVudCwgaSkge1xuXHRcdFx0XHRpZiAodWlFbGVtZW50LmN5Y2xlKSB7XG5cdFx0XHRcdFx0dWlFbGVtZW50LmN5Y2xlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRhZnRlckN5Y2xlQ2FsbGJhY2tzLmVhY2goZnVuY3Rpb24oYykge1xuXHRcdFx0XHRjKCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0dGhhdC5kcmF3ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gQ2xlYXIgY2FudmFzXG5cdFx0XHRtYWluQ2FudmFzLndpZHRoID0gbWFpbkNhbnZhcy53aWR0aDtcblxuXHRcdFx0cGxheWVyLmRyYXcoZENvbnRleHQpO1xuXG5cdFx0XHRwbGF5ZXIuY3ljbGUoKTtcblxuXHRcdFx0bW92aW5nT2JqZWN0cy5lYWNoKGZ1bmN0aW9uIChtb3ZpbmdPYmplY3QsIGkpIHtcblx0XHRcdFx0bW92aW5nT2JqZWN0LmRyYXcoZENvbnRleHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHN0YXRpY09iamVjdHMuZWFjaChmdW5jdGlvbiAoc3RhdGljT2JqZWN0LCBpKSB7XG5cdFx0XHRcdGlmIChzdGF0aWNPYmplY3QuZHJhdykge1xuXHRcdFx0XHRcdHN0YXRpY09iamVjdC5kcmF3KGRDb250ZXh0LCAnbWFpbicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dWlFbGVtZW50cy5lYWNoKGZ1bmN0aW9uICh1aUVsZW1lbnQsIGkpIHtcblx0XHRcdFx0aWYgKHVpRWxlbWVudC5kcmF3KSB7XG5cdFx0XHRcdFx0dWlFbGVtZW50LmRyYXcoZENvbnRleHQsICdtYWluJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHR0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Z2FtZUxvb3Auc3RhcnQoKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHBhdXNlZCA9IHRydWU7XG5cdFx0XHRnYW1lTG9vcC5zdG9wKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gcGF1c2VkO1xuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cGF1c2VkID0gZmFsc2U7XG5cdFx0XHRzdGF0aWNPYmplY3RzID0gbmV3IFNwcml0ZUFycmF5KCk7XG5cdFx0XHRtb3ZpbmdPYmplY3RzID0gbmV3IFNwcml0ZUFycmF5KCk7XG5cdFx0XHRtb3VzZVggPSBkQ29udGV4dC5nZXRDZW50cmVPZlZpZXdwb3J0KCk7XG5cdFx0XHRtb3VzZVkgPSAwO1xuXHRcdFx0cGxheWVyLnJlc2V0KCk7XG5cdFx0XHRwbGF5ZXIuc2V0TWFwUG9zaXRpb24oMCwgMCwgMCk7XG5cdFx0XHRhaUJyYWluLnJlc2V0KCk7XG5cdFx0XHR0aGlzLnN0YXJ0KCk7XG5cdFx0fS5iaW5kKHRoaXMpO1xuXG5cdFx0Z2FtZUxvb3Aub24oJzIwJywgdGhpcy5jeWNsZSk7XG5cdFx0Z2FtZUxvb3Aub24oJzIwJywgdGhpcy5kcmF3KTtcblx0fVxuXG5cdGdsb2JhbC5nYW1lID0gR2FtZTtcbn0pKCB0aGlzICk7XG5cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdGhpcy5nYW1lO1xufSIsIi8vIENyZWF0ZXMgYSByYW5kb20gSUQgc3RyaW5nXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgZnVuY3Rpb24gZ3VpZCAoKVxuICAgIHtcbiAgICAgICAgdmFyIFM0ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwIC8qIDY1NTM2ICovXG4gICAgICAgICAgICAgICAgKS50b1N0cmluZygxNik7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBTNCgpICsgUzQoKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICBTNCgpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgIFM0KCkgKyBcIi1cIiArXG4gICAgICAgICAgICAgICAgUzQoKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICBTNCgpICsgUzQoKSArIFM0KClcbiAgICAgICAgICAgICk7XG4gICAgfVxuICAgIGdsb2JhbC5ndWlkID0gZ3VpZDtcbn0pKHRoaXMpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRoaXMuZ3VpZDtcbn0iLCJmdW5jdGlvbiBJbmZvQm94KGRhdGEpIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdHRoYXQubGluZXMgPSBkYXRhLmluaXRpYWxMaW5lcztcblxuXHR0aGF0LnRvcCA9IGRhdGEucG9zaXRpb24udG9wO1xuXHR0aGF0LnJpZ2h0ID0gZGF0YS5wb3NpdGlvbi5yaWdodDtcblx0dGhhdC5ib3R0b20gPSBkYXRhLnBvc2l0aW9uLmJvdHRvbTtcblx0dGhhdC5sZWZ0ID0gZGF0YS5wb3NpdGlvbi5sZWZ0O1xuXG5cdHRoYXQud2lkdGggPSBkYXRhLndpZHRoO1xuXHR0aGF0LmhlaWdodCA9IGRhdGEuaGVpZ2h0O1xuXG5cdHRoYXQuc2V0TGluZXMgPSBmdW5jdGlvbiAobGluZXMpIHtcblx0XHR0aGF0LmxpbmVzID0gbGluZXM7XG5cdH07XG5cblx0dGhhdC5kcmF3ID0gZnVuY3Rpb24gKGRDb250ZXh0KSB7XG5cdFx0ZENvbnRleHQuZm9udCA9ICcxMXB4IG1vbm9zcGFjZSc7XG5cdFx0dmFyIHlPZmZzZXQgPSAwO1xuXHRcdHRoYXQubGluZXMuZWFjaChmdW5jdGlvbiAobGluZSkge1xuXHRcdFx0dmFyIGZvbnRTaXplID0gK2RDb250ZXh0LmZvbnQuc2xpY2UoMCwyKTtcblx0XHRcdHZhciB0ZXh0V2lkdGggPSBkQ29udGV4dC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aDtcblx0XHRcdHZhciB0ZXh0SGVpZ2h0ID0gZm9udFNpemUgKiAxLjU7XG5cdFx0XHR2YXIgeFBvcywgeVBvcztcblx0XHRcdGlmICh0aGF0LnRvcCkge1xuXHRcdFx0XHR5UG9zID0gdGhhdC50b3AgKyB5T2Zmc2V0O1xuXHRcdFx0fSBlbHNlIGlmICh0aGF0LmJvdHRvbSkge1xuXHRcdFx0XHR5UG9zID0gZENvbnRleHQuY2FudmFzLmhlaWdodCAtIHRoYXQudG9wIC0gdGV4dEhlaWdodCArIHlPZmZzZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGF0LnJpZ2h0KSB7XG5cdFx0XHRcdHhQb3MgPSBkQ29udGV4dC5jYW52YXMud2lkdGggLSB0aGF0LnJpZ2h0IC0gdGV4dFdpZHRoO1xuXHRcdFx0fSBlbHNlIGlmICh0aGF0LmxlZnQpIHtcblx0XHRcdFx0eFBvcyA9IHRoYXQubGVmdDtcblx0XHRcdH1cblxuXHRcdFx0eU9mZnNldCArPSB0ZXh0SGVpZ2h0O1xuXG5cblx0XHRcdGRDb250ZXh0LmZpbGxUZXh0KGxpbmUsIHhQb3MsIHlQb3MpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiB0aGF0O1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBJbmZvQm94O1xufVxuIiwiZnVuY3Rpb24gaXNNb2JpbGVEZXZpY2UoKSB7XG5cdGlmKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSkgfHxcblx0XHRuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC93ZWJPUy9pKSB8fFxuXHRcdG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZS9pKSB8fFxuXHRcdG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQYWQvaSkgfHxcblx0XHRuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pUG9kL2kpIHx8XG5cdFx0bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQmxhY2tCZXJyeS9pKSB8fFxuXHRcdG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1dpbmRvd3MgUGhvbmUvaSlcblx0KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNb2JpbGVEZXZpY2U7IiwidmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJyk7XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblx0ZnVuY3Rpb24gTW9uc3RlcihkYXRhKSB7XG5cdFx0dmFyIHRoYXQgPSBuZXcgU3ByaXRlKGRhdGEpO1xuXHRcdHZhciBzdXBlcl9kcmF3ID0gdGhhdC5kcmF3LmJpbmQodGhhdCk7XG5cdFx0dmFyIHNwcml0ZVZlcnNpb24gPSAxO1xuXHRcdHZhciBlYXRpbmdTdGFnZSA9IDA7XG5cdFx0dmFyIHN0YW5kYXJkU3BlZWQgPSA2O1xuXG5cdFx0dGhhdC5pc0VhdGluZyA9IGZhbHNlO1xuXHRcdHRoYXQuaXNGdWxsID0gZmFsc2U7XG5cdFx0dGhhdC5zZXRTcGVlZChzdGFuZGFyZFNwZWVkKTtcblxuXHRcdHRoYXQuZHJhdyA9IGZ1bmN0aW9uKGRDb250ZXh0KSB7XG5cdFx0XHR2YXIgc3ByaXRlUGFydFRvVXNlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgeERpZmYgPSB0aGF0Lm1vdmluZ1Rvd2FyZFswXSAtIHRoYXQuY2FudmFzWDtcblxuXHRcdFx0XHRpZiAodGhhdC5pc0VhdGluZykge1xuXHRcdFx0XHRcdHJldHVybiAnZWF0aW5nJyArIGVhdGluZ1N0YWdlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNwcml0ZVZlcnNpb24gKyAwLjEgPiAyKSB7XG5cdFx0XHRcdFx0c3ByaXRlVmVyc2lvbiA9IDAuMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzcHJpdGVWZXJzaW9uICs9IDAuMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeERpZmYgPj0gMCkge1xuXHRcdFx0XHRcdHJldHVybiAnc0Vhc3QnICsgTWF0aC5jZWlsKHNwcml0ZVZlcnNpb24pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHhEaWZmIDwgMCkge1xuXHRcdFx0XHRcdHJldHVybiAnc1dlc3QnICsgTWF0aC5jZWlsKHNwcml0ZVZlcnNpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gc3VwZXJfZHJhdyhkQ29udGV4dCwgc3ByaXRlUGFydFRvVXNlKCkpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBzdGFydEVhdGluZyAod2hlbkRvbmUpIHtcblx0XHRcdGVhdGluZ1N0YWdlICs9IDE7XG5cdFx0XHR0aGF0LmlzRWF0aW5nID0gdHJ1ZTtcblx0XHRcdHRoYXQuaXNNb3ZpbmcgPSBmYWxzZTtcblx0XHRcdGlmIChlYXRpbmdTdGFnZSA8IDYpIHtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c3RhcnRFYXRpbmcod2hlbkRvbmUpO1xuXHRcdFx0XHR9LCAzMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWF0aW5nU3RhZ2UgPSAwO1xuXHRcdFx0XHR0aGF0LmlzRWF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHRoYXQuaXNNb3ZpbmcgPSB0cnVlO1xuXHRcdFx0XHR3aGVuRG9uZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoYXQuc3RhcnRFYXRpbmcgPSBzdGFydEVhdGluZztcblxuXHRcdHJldHVybiB0aGF0O1xuXHR9XG5cblx0Z2xvYmFsLm1vbnN0ZXIgPSBNb25zdGVyO1xufSkoIHRoaXMgKTtcblxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB0aGlzLm1vbnN0ZXI7XG59IiwiLy8gQXZvaWQgYGNvbnNvbGVgIGVycm9ycyBpbiBicm93c2VycyB0aGF0IGxhY2sgYSBjb25zb2xlLlxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZXRob2Q7XG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG4gICAgdmFyIG1ldGhvZHMgPSBbXG4gICAgICAgICdhc3NlcnQnLCAnY2xlYXInLCAnY291bnQnLCAnZGVidWcnLCAnZGlyJywgJ2RpcnhtbCcsICdlcnJvcicsXG4gICAgICAgICdleGNlcHRpb24nLCAnZ3JvdXAnLCAnZ3JvdXBDb2xsYXBzZWQnLCAnZ3JvdXBFbmQnLCAnaW5mbycsICdsb2cnLFxuICAgICAgICAnbWFya1RpbWVsaW5lJywgJ3Byb2ZpbGUnLCAncHJvZmlsZUVuZCcsICd0YWJsZScsICd0aW1lJywgJ3RpbWVFbmQnLFxuICAgICAgICAndGltZVN0YW1wJywgJ3RyYWNlJywgJ3dhcm4nXG4gICAgXTtcbiAgICB2YXIgbGVuZ3RoID0gbWV0aG9kcy5sZW5ndGg7XG4gICAgdmFyIGNvbnNvbGUgPSAod2luZG93LmNvbnNvbGUgPSB3aW5kb3cuY29uc29sZSB8fCB7fSk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kc1tsZW5ndGhdO1xuXG4gICAgICAgIC8vIE9ubHkgc3R1YiB1bmRlZmluZWQgbWV0aG9kcy5cbiAgICAgICAgaWYgKCFjb25zb2xlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG59KCkpOyIsInZhciBTcHJpdGUgPSByZXF1aXJlKCcuL3Nwcml0ZScpO1xuaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG5cdG5hdmlnYXRvci52aWJyYXRlID0gbmF2aWdhdG9yLnZpYnJhdGUgfHxcblx0XHRuYXZpZ2F0b3Iud2Via2l0VmlicmF0ZSB8fFxuXHRcdG5hdmlnYXRvci5tb3pWaWJyYXRlIHx8XG5cdFx0bmF2aWdhdG9yLm1zVmlicmF0ZTtcbn0gZWxzZSB7XG5cdG5hdmlnYXRvciA9IHtcblx0XHR2aWJyYXRlOiBmYWxzZVxuXHR9O1xufVxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cdGZ1bmN0aW9uIFNraWVyKGRhdGEpIHtcblx0XHR2YXIgZGlzY3JldGVEaXJlY3Rpb25zID0ge1xuXHRcdFx0J3dlc3QnOiAyNzAsXG5cdFx0XHQnd3NXZXN0JzogMjQwLFxuXHRcdFx0J3NXZXN0JzogMTk1LFxuXHRcdFx0J3NvdXRoJzogMTgwLFxuXHRcdFx0J3NFYXN0JzogMTY1LFxuXHRcdFx0J2VzRWFzdCc6IDEyMCxcblx0XHRcdCdlYXN0JzogOTBcblx0XHR9O1xuXHRcdHZhciB0aGF0ID0gbmV3IFNwcml0ZShkYXRhKTtcblx0XHR2YXIgc3VwID0ge1xuXHRcdFx0ZHJhdzogdGhhdC5kcmF3LmJpbmQodGhhdCksXG5cdFx0XHRjeWNsZTogdGhhdC5jeWNsZS5iaW5kKHRoYXQpLFxuXHRcdFx0Z2V0U3BlZWRYOiB0aGF0LmdldFNwZWVkWC5iaW5kKHRoYXQpLFxuXHRcdFx0Z2V0U3BlZWRZOiB0aGF0LmdldFNwZWVkWS5iaW5kKHRoYXQpLFxuXHRcdFx0aGl0czogdGhhdC5oaXRzLmJpbmQodGhhdClcblx0XHR9O1xuXHRcdHZhciBkaXJlY3Rpb25zID0ge1xuXHRcdFx0ZXNFYXN0OiBmdW5jdGlvbih4RGlmZikgeyByZXR1cm4geERpZmYgPiAzMDA7IH0sXG5cdFx0XHRzRWFzdDogZnVuY3Rpb24oeERpZmYpIHsgcmV0dXJuIHhEaWZmID4gNzU7IH0sXG5cdFx0XHR3c1dlc3Q6IGZ1bmN0aW9uKHhEaWZmKSB7IHJldHVybiB4RGlmZiA8IC0zMDA7IH0sXG5cdFx0XHRzV2VzdDogZnVuY3Rpb24oeERpZmYpIHsgcmV0dXJuIHhEaWZmIDwgLTc1OyB9XG5cdFx0fTtcblxuXHRcdHZhciBjYW5jZWxhYmxlU3RhdGVUaW1lb3V0O1xuXHRcdHZhciBjYW5jZWxhYmxlU3RhdGVJbnRlcnZhbDtcblxuXHRcdHZhciBjYW5TcGVlZEJvb3N0ID0gdHJ1ZTtcblxuXHRcdHZhciBvYnN0YWNsZXNIaXQgPSBbXTtcblx0XHR2YXIgcGl4ZWxzVHJhdmVsbGVkID0gMDtcblx0XHR2YXIgc3RhbmRhcmRTcGVlZCA9IDU7XG5cdFx0dmFyIGJvb3N0TXVsdGlwbGllciA9IDI7XG5cdFx0dmFyIHR1cm5FYXNlQ3ljbGVzID0gNzA7XG5cdFx0dmFyIHNwZWVkWCA9IDA7XG5cdFx0dmFyIHNwZWVkWEZhY3RvciA9IDA7XG5cdFx0dmFyIHNwZWVkWSA9IDA7XG5cdFx0dmFyIHNwZWVkWUZhY3RvciA9IDE7XG5cdFx0dmFyIHRyaWNrU3RlcCA9IDA7IC8vIFRoZXJlIGFyZSB0aHJlZSBvZiB0aGVzZVxuXG5cdFx0dGhhdC5pc01vdmluZyA9IHRydWU7XG5cdFx0dGhhdC5oYXNCZWVuSGl0ID0gZmFsc2U7XG5cdFx0dGhhdC5pc0p1bXBpbmcgPSBmYWxzZTtcblx0XHR0aGF0LmlzUGVyZm9ybWluZ1RyaWNrID0gZmFsc2U7XG5cdFx0dGhhdC5vbkhpdE9ic3RhY2xlQ2IgPSBmdW5jdGlvbigpIHt9O1xuXHRcdHRoYXQuc2V0U3BlZWQoc3RhbmRhcmRTcGVlZCk7XG5cblx0XHR0aGF0LnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0b2JzdGFjbGVzSGl0ID0gW107XG5cdFx0XHRwaXhlbHNUcmF2ZWxsZWQgPSAwO1xuXHRcdFx0dGhhdC5pc01vdmluZyA9IHRydWU7XG5cdFx0XHR0aGF0Lmhhc0JlZW5IaXQgPSBmYWxzZTtcblx0XHRcdGNhblNwZWVkQm9vc3QgPSB0cnVlO1xuXHRcdFx0c2V0Tm9ybWFsKCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHNldE5vcm1hbCgpIHtcblx0XHRcdHRoYXQuc2V0U3BlZWQoc3RhbmRhcmRTcGVlZCk7XG5cdFx0XHR0aGF0LmlzTW92aW5nID0gdHJ1ZTtcblx0XHRcdHRoYXQuaGFzQmVlbkhpdCA9IGZhbHNlO1xuXHRcdFx0dGhhdC5pc0p1bXBpbmcgPSBmYWxzZTtcblx0XHRcdHRoYXQuaXNQZXJmb3JtaW5nVHJpY2sgPSBmYWxzZTtcblx0XHRcdGlmIChjYW5jZWxhYmxlU3RhdGVJbnRlcnZhbCkge1xuXHRcdFx0XHRjbGVhckludGVydmFsKGNhbmNlbGFibGVTdGF0ZUludGVydmFsKTtcblx0XHRcdH1cblx0XHRcdHRoYXQuc2V0TWFwUG9zaXRpb24odW5kZWZpbmVkLCB1bmRlZmluZWQsIDApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldENyYXNoZWQoKSB7XG5cdFx0XHR0aGF0LmlzTW92aW5nID0gZmFsc2U7XG5cdFx0XHR0aGF0Lmhhc0JlZW5IaXQgPSB0cnVlO1xuXHRcdFx0dGhhdC5pc0p1bXBpbmcgPSBmYWxzZTtcblx0XHRcdHRoYXQuaXNQZXJmb3JtaW5nVHJpY2sgPSBmYWxzZTtcblx0XHRcdGlmIChjYW5jZWxhYmxlU3RhdGVJbnRlcnZhbCkge1xuXHRcdFx0XHRjbGVhckludGVydmFsKGNhbmNlbGFibGVTdGF0ZUludGVydmFsKTtcblx0XHRcdH1cblx0XHRcdHRoYXQuc2V0TWFwUG9zaXRpb24odW5kZWZpbmVkLCB1bmRlZmluZWQsIDApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldEp1bXBpbmcoKSB7XG5cdFx0XHR2YXIgY3VycmVudFNwZWVkID0gdGhhdC5nZXRTcGVlZCgpO1xuXHRcdFx0dGhhdC5zZXRTcGVlZChjdXJyZW50U3BlZWQgKyAyKTtcblx0XHRcdHRoYXQuc2V0U3BlZWRZKGN1cnJlbnRTcGVlZCArIDIpO1xuXHRcdFx0dGhhdC5pc01vdmluZyA9IHRydWU7XG5cdFx0XHR0aGF0Lmhhc0JlZW5IaXQgPSBmYWxzZTtcblx0XHRcdHRoYXQuaXNKdW1waW5nID0gdHJ1ZTtcblx0XHRcdHRoYXQuc2V0TWFwUG9zaXRpb24odW5kZWZpbmVkLCB1bmRlZmluZWQsIDEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERpc2NyZXRlRGlyZWN0aW9uKCkge1xuXHRcdFx0aWYgKHRoYXQuZGlyZWN0aW9uKSB7XG5cdFx0XHRcdGlmICh0aGF0LmRpcmVjdGlvbiA8PSA5MCkge1xuXHRcdFx0XHRcdHJldHVybiAnZWFzdCc7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhhdC5kaXJlY3Rpb24gPiA5MCAmJiB0aGF0LmRpcmVjdGlvbiA8IDE1MCkge1xuXHRcdFx0XHRcdHJldHVybiAnZXNFYXN0Jztcblx0XHRcdFx0fSBlbHNlIGlmICh0aGF0LmRpcmVjdGlvbiA+PSAxNTAgJiYgdGhhdC5kaXJlY3Rpb24gPCAxODApIHtcblx0XHRcdFx0XHRyZXR1cm4gJ3NFYXN0Jztcblx0XHRcdFx0fSBlbHNlIGlmICh0aGF0LmRpcmVjdGlvbiA9PT0gMTgwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdzb3V0aCc7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhhdC5kaXJlY3Rpb24gPiAxODAgJiYgdGhhdC5kaXJlY3Rpb24gPD0gMjEwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdzV2VzdCc7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhhdC5kaXJlY3Rpb24gPiAyMTAgJiYgdGhhdC5kaXJlY3Rpb24gPCAyNzApIHtcblx0XHRcdFx0XHRyZXR1cm4gJ3dzV2VzdCc7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhhdC5kaXJlY3Rpb24gPj0gMjcwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICd3ZXN0Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gJ3NvdXRoJztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHhEaWZmID0gdGhhdC5tb3ZpbmdUb3dhcmRbMF0gLSB0aGF0Lm1hcFBvc2l0aW9uWzBdO1xuXHRcdFx0XHR2YXIgeURpZmYgPSB0aGF0Lm1vdmluZ1Rvd2FyZFsxXSAtIHRoYXQubWFwUG9zaXRpb25bMV07XG5cdFx0XHRcdGlmICh5RGlmZiA8PSAwKSB7XG5cdFx0XHRcdFx0aWYgKHhEaWZmID4gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdlYXN0Jztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuICd3ZXN0Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZGlyZWN0aW9ucy5lc0Vhc3QoeERpZmYpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdlc0Vhc3QnO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbnMuc0Vhc3QoeERpZmYpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdzRWFzdCc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGlyZWN0aW9ucy53c1dlc3QoeERpZmYpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICd3c1dlc3QnO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGRpcmVjdGlvbnMuc1dlc3QoeERpZmYpKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdzV2VzdCc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAnc291dGgnO1xuXHRcdH1cblxuXHRcdHRoYXQuZ2V0TXlEaXNjcmV0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCkge3JldHVybiBnZXREaXNjcmV0ZURpcmVjdGlvbigpO31cblxuXHRcdGZ1bmN0aW9uIHNldERpc2NyZXRlRGlyZWN0aW9uKGQpIHtcblx0XHRcdGlmIChkaXNjcmV0ZURpcmVjdGlvbnNbZF0pIHtcblx0XHRcdFx0dGhhdC5zZXREaXJlY3Rpb24oZGlzY3JldGVEaXJlY3Rpb25zW2RdKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGQgPT09ICd3ZXN0JyB8fCBkID09PSAnZWFzdCcpIHtcblx0XHRcdFx0dGhhdC5pc01vdmluZyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhhdC5pc01vdmluZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QmVpbmdFYXRlblNwcml0ZSgpIHtcblx0XHRcdHJldHVybiAnYmxhbmsnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEp1bXBpbmdTcHJpdGUoKSB7XG5cdFx0XHRyZXR1cm4gJ2p1bXBpbmcnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFRyaWNrU3ByaXRlKCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ1RyaWNrIHN0ZXAgaXMnLCB0cmlja1N0ZXApO1xuXHRcdFx0aWYgKHRyaWNrU3RlcCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ2p1bXBpbmcnO1xuXHRcdFx0fSBlbHNlIGlmICh0cmlja1N0ZXAgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuICdzb21lcnNhdWx0MSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gJ3NvbWVyc2F1bHQyJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGF0LnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhhdC5kaXJlY3Rpb24gPiAxODApIHtcblx0XHRcdFx0c2V0RGlzY3JldGVEaXJlY3Rpb24oJ3dlc3QnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNldERpc2NyZXRlRGlyZWN0aW9uKCdlYXN0Jyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoYXQudHVybkVhc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgZGlzY3JldGVEaXJlY3Rpb24gPSBnZXREaXNjcmV0ZURpcmVjdGlvbigpO1xuXG5cdFx0XHRzd2l0Y2ggKGRpc2NyZXRlRGlyZWN0aW9uKSB7XG5cdFx0XHRcdGNhc2UgJ3dlc3QnOlxuXHRcdFx0XHRcdHNldERpc2NyZXRlRGlyZWN0aW9uKCd3c1dlc3QnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnd3NXZXN0Jzpcblx0XHRcdFx0XHRzZXREaXNjcmV0ZURpcmVjdGlvbignc1dlc3QnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnc1dlc3QnOlxuXHRcdFx0XHRcdHNldERpc2NyZXRlRGlyZWN0aW9uKCdzb3V0aCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdzb3V0aCc6XG5cdFx0XHRcdFx0c2V0RGlzY3JldGVEaXJlY3Rpb24oJ3NFYXN0Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NFYXN0Jzpcblx0XHRcdFx0XHRzZXREaXNjcmV0ZURpcmVjdGlvbignZXNFYXN0Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2VzRWFzdCc6XG5cdFx0XHRcdFx0c2V0RGlzY3JldGVEaXJlY3Rpb24oJ2Vhc3QnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRzZXREaXNjcmV0ZURpcmVjdGlvbignc291dGgnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhhdC50dXJuV2VzdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBkaXNjcmV0ZURpcmVjdGlvbiA9IGdldERpc2NyZXRlRGlyZWN0aW9uKCk7XG5cblx0XHRcdHN3aXRjaCAoZGlzY3JldGVEaXJlY3Rpb24pIHtcblx0XHRcdFx0Y2FzZSAnZWFzdCc6XG5cdFx0XHRcdFx0c2V0RGlzY3JldGVEaXJlY3Rpb24oJ2VzRWFzdCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdlc0Vhc3QnOlxuXHRcdFx0XHRcdHNldERpc2NyZXRlRGlyZWN0aW9uKCdzRWFzdCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdzRWFzdCc6XG5cdFx0XHRcdFx0c2V0RGlzY3JldGVEaXJlY3Rpb24oJ3NvdXRoJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NvdXRoJzpcblx0XHRcdFx0XHRzZXREaXNjcmV0ZURpcmVjdGlvbignc1dlc3QnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnc1dlc3QnOlxuXHRcdFx0XHRcdHNldERpc2NyZXRlRGlyZWN0aW9uKCd3c1dlc3QnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnd3NXZXN0Jzpcblx0XHRcdFx0XHRzZXREaXNjcmV0ZURpcmVjdGlvbignd2VzdCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHNldERpc2NyZXRlRGlyZWN0aW9uKCdzb3V0aCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGF0LnN0ZXBXZXN0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5tYXBQb3NpdGlvblswXSAtPSB0aGF0LnNwZWVkICogMjtcblx0XHR9O1xuXG5cdFx0dGhhdC5zdGVwRWFzdCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQubWFwUG9zaXRpb25bMF0gKz0gdGhhdC5zcGVlZCAqIDI7XG5cdFx0fTtcblxuXHRcdHRoYXQuc2V0TWFwUG9zaXRpb25UYXJnZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuXHRcdFx0aWYgKHRoYXQuaGFzQmVlbkhpdCkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoTWF0aC5hYnModGhhdC5tYXBQb3NpdGlvblswXSAtIHgpIDw9IDc1KSB7XG5cdFx0XHRcdHggPSB0aGF0Lm1hcFBvc2l0aW9uWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGF0Lm1vdmluZ1Rvd2FyZCA9IFsgeCwgeSBdO1xuXG5cdFx0XHQvLyB0aGF0LnJlc2V0RGlyZWN0aW9uKCk7XG5cdFx0fTtcblxuXHRcdHRoYXQuc3RhcnRNb3ZpbmdJZlBvc3NpYmxlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGF0Lmhhc0JlZW5IaXQgJiYgIXRoYXQuaXNCZWluZ0VhdGVuKSB7XG5cdFx0XHRcdHRoYXQuaXNNb3ZpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGF0LnNldFR1cm5FYXNlQ3ljbGVzID0gZnVuY3Rpb24gKGMpIHtcblx0XHRcdHR1cm5FYXNlQ3ljbGVzID0gYztcblx0XHR9O1xuXG5cdFx0dGhhdC5nZXRQaXhlbHNUcmF2ZWxsZWREb3duTW91bnRhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gcGl4ZWxzVHJhdmVsbGVkO1xuXHRcdH07XG5cblx0XHR0aGF0LnJlc2V0U3BlZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0LnNldFNwZWVkKHN0YW5kYXJkU3BlZWQpO1xuXHRcdH07XG5cblx0XHR0aGF0LmN5Y2xlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCB0aGF0LmdldFNwZWVkWCgpIDw9IDAgJiYgdGhhdC5nZXRTcGVlZFkoKSA8PSAwICkge1xuXHRcdFx0XHRcdFx0dGhhdC5pc01vdmluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoYXQuaXNNb3ZpbmcpIHtcblx0XHRcdFx0cGl4ZWxzVHJhdmVsbGVkICs9IHRoYXQuc3BlZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGF0LmlzSnVtcGluZykge1xuXHRcdFx0XHR0aGF0LnNldE1hcFBvc2l0aW9uVGFyZ2V0KHVuZGVmaW5lZCwgdGhhdC5tYXBQb3NpdGlvblsxXSArIHRoYXQuZ2V0U3BlZWQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN1cC5jeWNsZSgpO1xuXHRcdFx0XG5cdFx0XHR0aGF0LmNoZWNrSGl0dGFibGVPYmplY3RzKCk7XG5cdFx0fTtcblxuXHRcdHRoYXQuZHJhdyA9IGZ1bmN0aW9uKGRDb250ZXh0KSB7XG5cdFx0XHR2YXIgc3ByaXRlUGFydFRvVXNlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodGhhdC5pc0JlaW5nRWF0ZW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0QmVpbmdFYXRlblNwcml0ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoYXQuaXNKdW1waW5nKSB7XG5cdFx0XHRcdFx0aWYgKHRoYXQuaXNQZXJmb3JtaW5nVHJpY2spIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRUcmlja1Nwcml0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZ2V0SnVtcGluZ1Nwcml0ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoYXQuaGFzQmVlbkhpdCkge1xuXHRcdFx0XHRcdHJldHVybiAnaGl0Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBnZXREaXNjcmV0ZURpcmVjdGlvbigpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIHN1cC5kcmF3KGRDb250ZXh0LCBzcHJpdGVQYXJ0VG9Vc2UoKSk7XG5cdFx0fTtcblxuXHRcdHRoYXQuaGl0cyA9IGZ1bmN0aW9uIChvYnMpIHtcblx0XHRcdGlmIChvYnN0YWNsZXNIaXQuaW5kZXhPZihvYnMuaWQpICE9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghb2JzLm9jY3VwaWVzWkluZGV4KHRoYXQubWFwUG9zaXRpb25bMl0pKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN1cC5oaXRzKG9icykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0dGhhdC5zcGVlZEJvb3N0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG9yaWdpbmFsU3BlZWQgPSB0aGF0LnNwZWVkO1xuXHRcdFx0aWYgKGNhblNwZWVkQm9vc3QpIHtcblx0XHRcdFx0Y2FuU3BlZWRCb29zdCA9IGZhbHNlO1xuXHRcdFx0XHR0aGF0LnNldFNwZWVkKHRoYXQuc3BlZWQgKiBib29zdE11bHRpcGxpZXIpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGF0LnNldFNwZWVkKG9yaWdpbmFsU3BlZWQpO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0Y2FuU3BlZWRCb29zdCA9IHRydWU7XG5cdFx0XHRcdFx0fSwgMTAwMDApO1xuXHRcdFx0XHR9LCAyMDAwKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhhdC5hdHRlbXB0VHJpY2sgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhhdC5pc0p1bXBpbmcpIHtcblx0XHRcdFx0dGhhdC5pc1BlcmZvcm1pbmdUcmljayA9IHRydWU7XG5cdFx0XHRcdGNhbmNlbGFibGVTdGF0ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICh0cmlja1N0ZXAgPj0gMikge1xuXHRcdFx0XHRcdFx0dHJpY2tTdGVwID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJpY2tTdGVwICs9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCAzMDApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGF0LmdldFN0YW5kYXJkU3BlZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc3RhbmRhcmRTcGVlZDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZWFzZVNwZWVkVG9UYXJnZXRVc2luZ0ZhY3RvcihzcCwgdGFyZ2V0U3BlZWQsIGYpIHtcblx0XHRcdGlmIChmID09PSAwIHx8IGYgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldFNwZWVkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3AgPCB0YXJnZXRTcGVlZCkge1xuXHRcdFx0XHRzcCArPSB0aGF0LmdldFNwZWVkKCkgKiAoZiAvIHR1cm5FYXNlQ3ljbGVzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNwID4gdGFyZ2V0U3BlZWQpIHtcblx0XHRcdFx0c3AgLT0gdGhhdC5nZXRTcGVlZCgpICogKGYgLyB0dXJuRWFzZUN5Y2xlcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzcDtcblx0XHR9XG5cblx0XHR0aGF0LmdldFNwZWVkWCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChnZXREaXNjcmV0ZURpcmVjdGlvbigpID09PSAnZXNFYXN0JyB8fCBnZXREaXNjcmV0ZURpcmVjdGlvbigpID09PSAnd3NXZXN0Jykge1xuXHRcdFx0XHRzcGVlZFhGYWN0b3IgPSAwLjU7XG5cdFx0XHRcdHNwZWVkWCA9IGVhc2VTcGVlZFRvVGFyZ2V0VXNpbmdGYWN0b3Ioc3BlZWRYLCB0aGF0LmdldFNwZWVkKCkgKiBzcGVlZFhGYWN0b3IsIHNwZWVkWEZhY3Rvcik7XG5cblx0XHRcdFx0cmV0dXJuIHNwZWVkWDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldERpc2NyZXRlRGlyZWN0aW9uKCkgPT09ICdzRWFzdCcgfHwgZ2V0RGlzY3JldGVEaXJlY3Rpb24oKSA9PT0gJ3NXZXN0Jykge1xuXHRcdFx0XHRzcGVlZFhGYWN0b3IgPSAwLjMzO1xuXHRcdFx0XHRzcGVlZFggPSBlYXNlU3BlZWRUb1RhcmdldFVzaW5nRmFjdG9yKHNwZWVkWCwgdGhhdC5nZXRTcGVlZCgpICogc3BlZWRYRmFjdG9yLCBzcGVlZFhGYWN0b3IpO1xuXG5cdFx0XHRcdHJldHVybiBzcGVlZFg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvIGl0IG11c3QgYmUgc291dGhcblxuXHRcdFx0c3BlZWRYID0gZWFzZVNwZWVkVG9UYXJnZXRVc2luZ0ZhY3RvcihzcGVlZFgsIDAsIHNwZWVkWEZhY3Rvcik7XG5cblx0XHRcdHJldHVybiBzcGVlZFg7XG5cdFx0fTtcblxuXHRcdHRoYXQuc2V0U3BlZWRZID0gZnVuY3Rpb24oc3kpIHtcblx0XHRcdHNwZWVkWSA9IHN5O1xuXHRcdH07XG5cblx0XHR0aGF0LmdldFNwZWVkWSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB0YXJnZXRTcGVlZDtcblxuXHRcdFx0aWYgKHRoYXQuaXNKdW1waW5nKSB7XG5cdFx0XHRcdHJldHVybiBzcGVlZFk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChnZXREaXNjcmV0ZURpcmVjdGlvbigpID09PSAnZXNFYXN0JyB8fCBnZXREaXNjcmV0ZURpcmVjdGlvbigpID09PSAnd3NXZXN0Jykge1xuXHRcdFx0XHRzcGVlZFlGYWN0b3IgPSAwLjY7XG5cdFx0XHRcdHNwZWVkWSA9IGVhc2VTcGVlZFRvVGFyZ2V0VXNpbmdGYWN0b3Ioc3BlZWRZLCB0aGF0LmdldFNwZWVkKCkgKiAwLjYsIDAuNik7XG5cblx0XHRcdFx0cmV0dXJuIHNwZWVkWTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldERpc2NyZXRlRGlyZWN0aW9uKCkgPT09ICdzRWFzdCcgfHwgZ2V0RGlzY3JldGVEaXJlY3Rpb24oKSA9PT0gJ3NXZXN0Jykge1xuXHRcdFx0XHRzcGVlZFlGYWN0b3IgPSAwLjg1O1xuXHRcdFx0XHRzcGVlZFkgPSBlYXNlU3BlZWRUb1RhcmdldFVzaW5nRmFjdG9yKHNwZWVkWSwgdGhhdC5nZXRTcGVlZCgpICogMC44NSwgMC44NSk7XG5cblx0XHRcdFx0cmV0dXJuIHNwZWVkWTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGdldERpc2NyZXRlRGlyZWN0aW9uKCkgPT09ICdlYXN0JyB8fCBnZXREaXNjcmV0ZURpcmVjdGlvbigpID09PSAnd2VzdCcpIHtcblx0XHRcdFx0c3BlZWRZRmFjdG9yID0gMTtcblx0XHRcdFx0c3BlZWRZID0gMDtcblxuXHRcdFx0XHRyZXR1cm4gc3BlZWRZO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTbyBpdCBtdXN0IGJlIHNvdXRoXG5cblx0XHRcdHNwZWVkWSA9IGVhc2VTcGVlZFRvVGFyZ2V0VXNpbmdGYWN0b3Ioc3BlZWRZLCB0aGF0LmdldFNwZWVkKCksIHNwZWVkWUZhY3Rvcik7XG5cblx0XHRcdHJldHVybiBzcGVlZFk7XG5cdFx0fTtcblxuXHRcdHRoYXQuaGFzSGl0T2JzdGFjbGUgPSBmdW5jdGlvbiAob2JzKSB7XG5cdFx0XHRzZXRDcmFzaGVkKCk7XG5cblx0XHRcdGlmIChuYXZpZ2F0b3IudmlicmF0ZSkge1xuXHRcdFx0XHRuYXZpZ2F0b3IudmlicmF0ZSg1MDApO1xuXHRcdFx0fVxuXG5cdFx0XHRvYnN0YWNsZXNIaXQucHVzaChvYnMuaWQpO1xuXG5cdFx0XHR0aGF0LnJlc2V0U3BlZWQoKTtcblx0XHRcdHRoYXQub25IaXRPYnN0YWNsZUNiKG9icyk7XG5cblx0XHRcdGlmIChjYW5jZWxhYmxlU3RhdGVUaW1lb3V0KSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dChjYW5jZWxhYmxlU3RhdGVUaW1lb3V0KTtcblx0XHRcdH1cblx0XHRcdGNhbmNlbGFibGVTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZXROb3JtYWwoKTtcblx0XHRcdH0sIDE1MDApO1xuXHRcdH07XG5cblx0XHR0aGF0Lmhhc0hpdEp1bXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZXRKdW1waW5nKCk7XG5cblx0XHRcdGlmIChjYW5jZWxhYmxlU3RhdGVUaW1lb3V0KSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dChjYW5jZWxhYmxlU3RhdGVUaW1lb3V0KTtcblx0XHRcdH1cblx0XHRcdGNhbmNlbGFibGVTdGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZXROb3JtYWwoKTtcblx0XHRcdH0sIDEwMDApO1xuXHRcdH07XG5cblx0XHR0aGF0LmlzRWF0ZW5CeSA9IGZ1bmN0aW9uIChtb25zdGVyLCB3aGVuRWF0ZW4pIHtcblx0XHRcdHRoYXQuaGFzSGl0T2JzdGFjbGUobW9uc3Rlcik7XG5cdFx0XHRtb25zdGVyLnN0YXJ0RWF0aW5nKHdoZW5FYXRlbik7XG5cdFx0XHRvYnN0YWNsZXNIaXQucHVzaChtb25zdGVyLmlkKTtcblx0XHRcdHRoYXQuaXNNb3ZpbmcgPSBmYWxzZTtcblx0XHRcdHRoYXQuaXNCZWluZ0VhdGVuID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0dGhhdC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdG9ic3RhY2xlc0hpdCA9IFtdO1xuXHRcdFx0cGl4ZWxzVHJhdmVsbGVkID0gMDtcblx0XHRcdHRoYXQuaXNNb3ZpbmcgPSB0cnVlO1xuXHRcdFx0dGhhdC5pc0p1bXBpbmcgPSBmYWxzZTtcblx0XHRcdHRoYXQuaGFzQmVlbkhpdCA9IGZhbHNlO1xuXHRcdFx0Y2FuU3BlZWRCb29zdCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdHRoYXQuc2V0SGl0T2JzdGFjbGVDYiA9IGZ1bmN0aW9uIChmbikge1xuXHRcdFx0dGhhdC5vbkhpdE9ic3RhY2xlQ2IgPSBmbiB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoYXQ7XG5cdH1cblxuXHRnbG9iYWwuc2tpZXIgPSBTa2llcjtcbn0pKHRoaXMpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB0aGlzLnNraWVyO1xufVxuIiwidmFyIFNwcml0ZSA9IHJlcXVpcmUoJy4vc3ByaXRlJyk7XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblx0ZnVuY3Rpb24gU25vd2JvYXJkZXIoZGF0YSkge1xuXHRcdHZhciB0aGF0ID0gbmV3IFNwcml0ZShkYXRhKTtcblx0XHR2YXIgc3VwID0ge1xuXHRcdFx0ZHJhdzogdGhhdC5kcmF3LmJpbmQodGhhdCksXG5cdFx0XHRjeWNsZTogdGhhdC5jeWNsZS5iaW5kKHRoYXQpXG5cdFx0fTtcblx0XHR2YXIgZGlyZWN0aW9ucyA9IHtcblx0XHRcdHNFYXN0OiBmdW5jdGlvbih4RGlmZikgeyByZXR1cm4geERpZmYgPiAwOyB9LFxuXHRcdFx0c1dlc3Q6IGZ1bmN0aW9uKHhEaWZmKSB7IHJldHVybiB4RGlmZiA8PSAwOyB9XG5cdFx0fTtcblx0XHR2YXIgc3RhbmRhcmRTcGVlZCA9IDM7XG5cblx0XHR0aGF0LnNldFNwZWVkKHN0YW5kYXJkU3BlZWQpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKCkge1xuXHRcdFx0dmFyIHhEaWZmID0gdGhhdC5tb3ZpbmdUb3dhcmRbMF0gLSB0aGF0Lm1hcFBvc2l0aW9uWzBdO1xuXHRcdFx0dmFyIHlEaWZmID0gdGhhdC5tb3ZpbmdUb3dhcmRbMV0gLSB0aGF0Lm1hcFBvc2l0aW9uWzFdO1xuXG5cdFx0XHRpZiAoZGlyZWN0aW9ucy5zRWFzdCh4RGlmZikpIHtcblx0XHRcdFx0cmV0dXJuICdzRWFzdCc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gJ3NXZXN0Jztcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGF0LmN5Y2xlID0gZnVuY3Rpb24gKGRDb250ZXh0KSB7XG5cdFx0XHRpZiAoTnVtYmVyLnJhbmRvbSgxMCkgPT09IDEpIHtcblx0XHRcdFx0dGhhdC5zZXRNYXBQb3NpdGlvblRhcmdldChkQ29udGV4dC5nZXRSYW5kb21seUluVGhlQ2VudHJlT2ZNYXAoKSk7XG5cdFx0XHRcdHRoYXQuc2V0U3BlZWQoc3RhbmRhcmRTcGVlZCArIE51bWJlci5yYW5kb20oLTEsIDEpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhhdC5zZXRNYXBQb3NpdGlvblRhcmdldCh1bmRlZmluZWQsIGRDb250ZXh0LmdldE1hcEJlbG93Vmlld3BvcnQoKSArIDYwMCk7XG5cblx0XHRcdHN1cC5jeWNsZSgpO1xuXHRcdH07XG5cblx0XHR0aGF0LmRyYXcgPSBmdW5jdGlvbihkQ29udGV4dCkge1xuXHRcdFx0dmFyIHNwcml0ZVBhcnRUb1VzZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGdldERpcmVjdGlvbigpO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIHN1cC5kcmF3KGRDb250ZXh0LCBzcHJpdGVQYXJ0VG9Vc2UoKSk7XG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGF0O1xuXHR9XG5cblx0Z2xvYmFsLnNub3dib2FyZGVyID0gU25vd2JvYXJkZXI7XG59KSggdGhpcyApO1xuXG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHRoaXMuc25vd2JvYXJkZXI7XG59IiwiKGZ1bmN0aW9uIChnbG9iYWwpIHtcblx0dmFyIEdVSUQgPSByZXF1aXJlKCcuL2d1aWQnKTtcblx0ZnVuY3Rpb24gU3ByaXRlIChkYXRhKSB7XG5cdFx0dmFyIGhpdHRhYmxlT2JqZWN0cyA9IHt9O1xuXHRcdHZhciB6SW5kZXhlc09jY3VwaWVkID0gWyAwIF07XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciB0cmFja2VkU3ByaXRlVG9Nb3ZlVG93YXJkO1xuXHRcdHRoYXQuZGlyZWN0aW9uID0gdW5kZWZpbmVkO1xuXHRcdHRoYXQubWFwUG9zaXRpb24gPSBbMCwgMCwgMF07XG5cdFx0dGhhdC5pZCA9IEdVSUQoKTtcblx0XHR0aGF0LmNhbnZhc1ggPSAwO1xuXHRcdHRoYXQuY2FudmFzWSA9IDA7XG5cdFx0dGhhdC5jYW52YXNaID0gMDtcblx0XHR0aGF0LmhlaWdodCA9IDA7XG5cdFx0dGhhdC5zcGVlZCA9IDA7XG5cdFx0dGhhdC5kYXRhID0gZGF0YSB8fCB7IHBhcnRzIDoge30gfTtcblx0XHR0aGF0Lm1vdmluZ1Rvd2FyZCA9IFsgMCwgMCBdO1xuXHRcdHRoYXQubWV0cmVzRG93blRoZU1vdW50YWluID0gMDtcblx0XHR0aGF0Lm1vdmluZ1dpdGhDb252aWN0aW9uID0gZmFsc2U7XG5cdFx0dGhhdC5kZWxldGVkID0gZmFsc2U7XG5cdFx0dGhhdC5tYXhIZWlnaHQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC52YWx1ZXModGhhdC5kYXRhLnBhcnRzKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHBbM107IH0pLm1heCgpO1xuXHRcdH0oKSk7XG5cdFx0dGhhdC5pc01vdmluZyA9IHRydWU7XG5cblx0XHRpZiAoIXRoYXQuZGF0YS5wYXJ0cykge1xuXHRcdFx0dGhhdC5kYXRhLnBhcnRzID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKGRhdGEgJiYgZGF0YS5pZCl7XG5cdFx0XHR0aGF0LmlkID0gZGF0YS5pZDtcblx0XHR9XG5cblx0XHRpZiAoZGF0YSAmJiBkYXRhLnpJbmRleGVzT2NjdXBpZWQpIHtcblx0XHRcdHpJbmRleGVzT2NjdXBpZWQgPSBkYXRhLnpJbmRleGVzT2NjdXBpZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5jcmVtZW50WChhbW91bnQpIHtcblx0XHRcdHRoYXQuY2FudmFzWCArPSBhbW91bnQudG9OdW1iZXIoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmNyZW1lbnRZKGFtb3VudCkge1xuXHRcdFx0dGhhdC5jYW52YXNZICs9IGFtb3VudC50b051bWJlcigpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEhpdEJveChmb3JaSW5kZXgpIHtcblx0XHRcdGlmICh0aGF0LmRhdGEuaGl0Qm94ZXMpIHtcblx0XHRcdFx0aWYgKGRhdGEuaGl0Qm94ZXNbZm9yWkluZGV4XSkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmhpdEJveGVzW2ZvclpJbmRleF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByb3VuZEhhbGYobnVtKSB7XG5cdFx0XHRudW0gPSBNYXRoLnJvdW5kKG51bSoyKS8yO1xuXHRcdFx0cmV0dXJuIG51bTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtb3ZlKCkge1xuXHRcdFx0aWYgKCF0aGF0LmlzTW92aW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnRYID0gdGhhdC5tYXBQb3NpdGlvblswXTtcblx0XHRcdHZhciBjdXJyZW50WSA9IHRoYXQubWFwUG9zaXRpb25bMV07XG5cblx0XHRcdGlmICh0eXBlb2YgdGhhdC5kaXJlY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIEZvciB0aGlzIHdlIG5lZWQgdG8gbW9kaWZ5IHRoZSB0aGF0LmRpcmVjdGlvbiBzbyBpdCByZWxhdGVzIHRvIHRoZSBob3Jpem9udGFsXG5cdFx0XHRcdHZhciBkID0gdGhhdC5kaXJlY3Rpb24gLSA5MDtcblx0XHRcdFx0aWYgKGQgPCAwKSBkID0gMzYwICsgZDtcblx0XHRcdFx0Y3VycmVudFggKz0gcm91bmRIYWxmKHRoYXQuc3BlZWQgKiBNYXRoLmNvcyhkICogKE1hdGguUEkgLyAxODApKSk7XG5cdFx0XHRcdGN1cnJlbnRZICs9IHJvdW5kSGFsZih0aGF0LnNwZWVkICogTWF0aC5zaW4oZCAqIChNYXRoLlBJIC8gMTgwKSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGF0Lm1vdmluZ1Rvd2FyZFswXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudFggPiB0aGF0Lm1vdmluZ1Rvd2FyZFswXSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFggLT0gTWF0aC5taW4odGhhdC5nZXRTcGVlZFgoKSwgTWF0aC5hYnMoY3VycmVudFggLSB0aGF0Lm1vdmluZ1Rvd2FyZFswXSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFggPCB0aGF0Lm1vdmluZ1Rvd2FyZFswXSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFggKz0gTWF0aC5taW4odGhhdC5nZXRTcGVlZFgoKSwgTWF0aC5hYnMoY3VycmVudFggLSB0aGF0Lm1vdmluZ1Rvd2FyZFswXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHR5cGVvZiB0aGF0Lm1vdmluZ1Rvd2FyZFsxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudFkgPiB0aGF0Lm1vdmluZ1Rvd2FyZFsxXSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFkgLT0gTWF0aC5taW4odGhhdC5nZXRTcGVlZFkoKSwgTWF0aC5hYnMoY3VycmVudFkgLSB0aGF0Lm1vdmluZ1Rvd2FyZFsxXSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFkgPCB0aGF0Lm1vdmluZ1Rvd2FyZFsxXSkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFkgKz0gTWF0aC5taW4odGhhdC5nZXRTcGVlZFkoKSwgTWF0aC5hYnMoY3VycmVudFkgLSB0aGF0Lm1vdmluZ1Rvd2FyZFsxXSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aGF0LnNldE1hcFBvc2l0aW9uKGN1cnJlbnRYLCBjdXJyZW50WSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kcmF3ID0gZnVuY3Rpb24gKGRDdHgsIHNwcml0ZUZyYW1lKSB7XG5cdFx0XHR2YXIgZnIgPSB0aGF0LmRhdGEucGFydHNbc3ByaXRlRnJhbWVdO1xuXHRcdFx0dGhhdC5oZWlnaHQgPSBmclszXTtcblx0XHRcdHRoYXQud2lkdGggPSBmclsyXTtcblxuXHRcdFx0dmFyIG5ld0NhbnZhc1Bvc2l0aW9uID0gZEN0eC5tYXBQb3NpdGlvblRvQ2FudmFzUG9zaXRpb24odGhhdC5tYXBQb3NpdGlvbik7XG5cdFx0XHR0aGF0LnNldENhbnZhc1Bvc2l0aW9uKG5ld0NhbnZhc1Bvc2l0aW9uWzBdLCBuZXdDYW52YXNQb3NpdGlvblsxXSk7XG5cblx0XHRcdGRDdHguZHJhd0ltYWdlKGRDdHguZ2V0TG9hZGVkSW1hZ2UodGhhdC5kYXRhLiRpbWFnZUZpbGUpLCBmclswXSwgZnJbMV0sIGZyWzJdLCBmclszXSwgdGhhdC5jYW52YXNYLCB0aGF0LmNhbnZhc1ksIGZyWzJdLCBmclszXSk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0TWFwUG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuXHRcdFx0aWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR4ID0gdGhhdC5tYXBQb3NpdGlvblswXTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0eSA9IHRoYXQubWFwUG9zaXRpb25bMV07XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIHogPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHogPSB0aGF0Lm1hcFBvc2l0aW9uWzJdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhhdC56SW5kZXhlc09jY3VwaWVkID0gWyB6IF07XG5cdFx0XHR9XG5cdFx0XHR0aGF0Lm1hcFBvc2l0aW9uID0gW3gsIHksIHpdO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldENhbnZhc1Bvc2l0aW9uID0gZnVuY3Rpb24gKGN4LCBjeSkge1xuXHRcdFx0aWYgKGN4KSB7XG5cdFx0XHRcdGlmIChPYmplY3QuaXNTdHJpbmcoY3gpICYmIChjeC5maXJzdCgpID09PSAnKycgfHwgY3guZmlyc3QoKSA9PT0gJy0nKSkgaW5jcmVtZW50WChjeCk7XG5cdFx0XHRcdGVsc2UgdGhhdC5jYW52YXNYID0gY3g7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChjeSkge1xuXHRcdFx0XHRpZiAoT2JqZWN0LmlzU3RyaW5nKGN5KSAmJiAoY3kuZmlyc3QoKSA9PT0gJysnIHx8IGN5LmZpcnN0KCkgPT09ICctJykpIGluY3JlbWVudFkoY3kpO1xuXHRcdFx0XHRlbHNlIHRoYXQuY2FudmFzWSA9IGN5O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLmdldENhbnZhc1Bvc2l0aW9uWCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGF0LmNhbnZhc1g7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Q2FudmFzUG9zaXRpb25ZID0gZnVuY3Rpb24gICgpIHtcblx0XHRcdHJldHVybiB0aGF0LmNhbnZhc1k7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0TGVmdEhpdEJveEVkZ2UgPSBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0XHR6SW5kZXggPSB6SW5kZXggfHwgMDtcblx0XHRcdHZhciBsaGJlID0gdGhpcy5nZXRDYW52YXNQb3NpdGlvblgoKTtcblx0XHRcdGlmIChnZXRIaXRCb3goekluZGV4KSkge1xuXHRcdFx0XHRsaGJlICs9IGdldEhpdEJveCh6SW5kZXgpWzBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxoYmU7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0VG9wSGl0Qm94RWRnZSA9IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHRcdHpJbmRleCA9IHpJbmRleCB8fCAwO1xuXHRcdFx0dmFyIHRoYmUgPSB0aGlzLmdldENhbnZhc1Bvc2l0aW9uWSgpO1xuXHRcdFx0aWYgKGdldEhpdEJveCh6SW5kZXgpKSB7XG5cdFx0XHRcdHRoYmUgKz0gZ2V0SGl0Qm94KHpJbmRleClbMV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhiZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5nZXRSaWdodEhpdEJveEVkZ2UgPSBmdW5jdGlvbiAoekluZGV4KSB7XG5cdFx0XHR6SW5kZXggPSB6SW5kZXggfHwgMDtcblxuXHRcdFx0aWYgKGdldEhpdEJveCh6SW5kZXgpKSB7XG5cdFx0XHRcdHJldHVybiB0aGF0LmNhbnZhc1ggKyBnZXRIaXRCb3goekluZGV4KVsyXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoYXQuY2FudmFzWCArIHRoYXQud2lkdGg7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0Qm90dG9tSGl0Qm94RWRnZSA9IGZ1bmN0aW9uICh6SW5kZXgpIHtcblx0XHRcdHpJbmRleCA9IHpJbmRleCB8fCAwO1xuXG5cdFx0XHRpZiAoZ2V0SGl0Qm94KHpJbmRleCkpIHtcblx0XHRcdFx0cmV0dXJuIHRoYXQuY2FudmFzWSArIGdldEhpdEJveCh6SW5kZXgpWzNdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhhdC5jYW52YXNZICsgdGhhdC5oZWlnaHQ7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0UG9zaXRpb25JbkZyb250T2YgPSBmdW5jdGlvbiAgKCkge1xuXHRcdFx0cmV0dXJuIFt0aGF0LmNhbnZhc1gsIHRoYXQuY2FudmFzWSArIHRoYXQuaGVpZ2h0XTtcblx0XHR9O1xuXG5cdFx0dGhpcy5zZXRTcGVlZCA9IGZ1bmN0aW9uIChzKSB7XG5cdFx0XHR0aGF0LnNwZWVkID0gcztcblx0XHRcdHRoYXQuc3BlZWRYID0gcztcblx0XHRcdHRoYXQuc3BlZWRZID0gcztcblx0XHR9O1xuXG5cdFx0dGhpcy5pbmNyZW1lbnRTcGVlZEJ5ID0gZnVuY3Rpb24gKHMpIHtcblx0XHRcdHRoYXQuc3BlZWQgKz0gcztcblx0XHR9O1xuXG5cdFx0dGhhdC5nZXRTcGVlZCA9IGZ1bmN0aW9uIGdldFNwZWVkICgpIHtcblx0XHRcdHJldHVybiB0aGF0LnNwZWVkO1xuXHRcdH07XG5cblx0XHR0aGF0LmdldFNwZWVkWCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGF0LnNwZWVkO1xuXHRcdH07XG5cblx0XHR0aGF0LmdldFNwZWVkWSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGF0LnNwZWVkO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoKSB7XG5cdFx0XHR0aGF0LmhlaWdodCA9IGg7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0V2lkdGggPSBmdW5jdGlvbiAodykge1xuXHRcdFx0dGhhdC53aWR0aCA9IHc7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0TWF4SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoYXQubWF4SGVpZ2h0O1xuXHRcdH07XG5cblx0XHR0aGF0LmdldE1vdmluZ1Rvd2FyZE9wcG9zaXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCF0aGF0LmlzTW92aW5nKSB7XG5cdFx0XHRcdHJldHVybiBbMCwgMF07XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkeCA9ICh0aGF0Lm1vdmluZ1Rvd2FyZFswXSAtIHRoYXQubWFwUG9zaXRpb25bMF0pO1xuXHRcdFx0dmFyIGR5ID0gKHRoYXQubW92aW5nVG93YXJkWzFdIC0gdGhhdC5tYXBQb3NpdGlvblsxXSk7XG5cblx0XHRcdHZhciBvcHBvc2l0ZVggPSAoTWF0aC5hYnMoZHgpID4gNzUgPyAwIC0gZHggOiAwKTtcblx0XHRcdHZhciBvcHBvc2l0ZVkgPSAtZHk7XG5cblx0XHRcdHJldHVybiBbIG9wcG9zaXRlWCwgb3Bwb3NpdGVZIF07XG5cdFx0fTtcblxuXHRcdHRoaXMuY2hlY2tIaXR0YWJsZU9iamVjdHMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhoaXR0YWJsZU9iamVjdHMsIGZ1bmN0aW9uIChrLCBvYmplY3REYXRhKSB7XG5cdFx0XHRcdGlmIChvYmplY3REYXRhLm9iamVjdC5kZWxldGVkKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGhpdHRhYmxlT2JqZWN0c1trXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAob2JqZWN0RGF0YS5vYmplY3QuaGl0cyh0aGF0KSkge1xuXHRcdFx0XHRcdFx0b2JqZWN0RGF0YS5jYWxsYmFja3MuZWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sodGhhdCwgb2JqZWN0RGF0YS5vYmplY3QpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5jeWNsZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoYXQuY2hlY2tIaXR0YWJsZU9iamVjdHMoKTtcblxuXHRcdFx0aWYgKHRyYWNrZWRTcHJpdGVUb01vdmVUb3dhcmQpIHtcblx0XHRcdFx0dGhhdC5zZXRNYXBQb3NpdGlvblRhcmdldCh0cmFja2VkU3ByaXRlVG9Nb3ZlVG93YXJkLm1hcFBvc2l0aW9uWzBdLCB0cmFja2VkU3ByaXRlVG9Nb3ZlVG93YXJkLm1hcFBvc2l0aW9uWzFdLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0bW92ZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldE1hcFBvc2l0aW9uVGFyZ2V0ID0gZnVuY3Rpb24gKHgsIHksIG92ZXJyaWRlKSB7XG5cdFx0XHRpZiAob3ZlcnJpZGUpIHtcblx0XHRcdFx0dGhhdC5tb3ZpbmdXaXRoQ29udmljdGlvbiA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoYXQubW92aW5nV2l0aENvbnZpY3Rpb24pIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHggPSB0aGF0Lm1vdmluZ1Rvd2FyZFswXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR5ID0gdGhhdC5tb3ZpbmdUb3dhcmRbMV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGF0Lm1vdmluZ1Rvd2FyZCA9IFsgeCwgeSBdO1xuXG5cdFx0XHRcdHRoYXQubW92aW5nV2l0aENvbnZpY3Rpb24gPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhhdC5yZXNldERpcmVjdGlvbigpO1xuXHRcdH07XG5cblx0XHR0aGlzLnNldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChhbmdsZSkge1xuXHRcdFx0aWYgKGFuZ2xlID49IDM2MCkge1xuXHRcdFx0XHRhbmdsZSA9IDM2MCAtIGFuZ2xlO1xuXHRcdFx0fVxuXHRcdFx0dGhhdC5kaXJlY3Rpb24gPSBhbmdsZTtcblx0XHRcdHRoYXQubW92aW5nVG93YXJkID0gdW5kZWZpbmVkO1xuXHRcdH07XG5cblx0XHR0aGlzLnJlc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5kaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMuc2V0TWFwUG9zaXRpb25UYXJnZXRXaXRoQ29udmljdGlvbiA9IGZ1bmN0aW9uIChjeCwgY3kpIHtcblx0XHRcdHRoYXQuc2V0TWFwUG9zaXRpb25UYXJnZXQoY3gsIGN5KTtcblx0XHRcdHRoYXQubW92aW5nV2l0aENvbnZpY3Rpb24gPSB0cnVlO1xuXHRcdFx0Ly8gdGhhdC5yZXNldERpcmVjdGlvbigpO1xuXHRcdH07XG5cblx0XHR0aGlzLmZvbGxvdyA9IGZ1bmN0aW9uIChzcHJpdGUpIHtcblx0XHRcdHRyYWNrZWRTcHJpdGVUb01vdmVUb3dhcmQgPSBzcHJpdGU7XG5cdFx0XHQvLyB0aGF0LnJlc2V0RGlyZWN0aW9uKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuc3RvcEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRyYWNrZWRTcHJpdGVUb01vdmVUb3dhcmQgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5vbkhpdHRpbmcgPSBmdW5jdGlvbiAob2JqZWN0VG9IaXQsIGNhbGxiYWNrKSB7XG5cdFx0XHRpZiAoaGl0dGFibGVPYmplY3RzW29iamVjdFRvSGl0LmlkXSkge1xuXHRcdFx0XHRyZXR1cm4gaGl0dGFibGVPYmplY3RzW29iamVjdFRvSGl0LmlkXS5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0XHR9XG5cblx0XHRcdGhpdHRhYmxlT2JqZWN0c1tvYmplY3RUb0hpdC5pZF0gPSB7XG5cdFx0XHRcdG9iamVjdDogb2JqZWN0VG9IaXQsXG5cdFx0XHRcdGNhbGxiYWNrczogWyBjYWxsYmFjayBdXG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHR0aGlzLmRlbGV0ZU9uTmV4dEN5Y2xlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhhdC5kZWxldGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0dGhpcy5vY2N1cGllc1pJbmRleCA9IGZ1bmN0aW9uICh6KSB7XG5cdFx0XHRyZXR1cm4gekluZGV4ZXNPY2N1cGllZC5pbmRleE9mKHopID49IDA7XG5cdFx0fTtcblxuXHRcdHRoaXMuaGl0cyA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdFx0dmFyIHZlcnRpY2FsSW50ZXJzZWN0ID0gZmFsc2U7XG5cdFx0XHR2YXIgaG9yaXpvbnRhbEludGVyc2VjdCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBUZXN0IHRoYXQgVEhJUyBoYXMgYSBib3R0b20gZWRnZSBpbnNpZGUgb2YgdGhlIG90aGVyIG9iamVjdFxuXHRcdFx0aWYgKG90aGVyLmdldFRvcEhpdEJveEVkZ2UodGhhdC5tYXBQb3NpdGlvblsyXSkgPD0gdGhhdC5nZXRCb3R0b21IaXRCb3hFZGdlKHRoYXQubWFwUG9zaXRpb25bMl0pICYmIG90aGVyLmdldEJvdHRvbUhpdEJveEVkZ2UodGhhdC5tYXBQb3NpdGlvblsyXSkgPj0gdGhhdC5nZXRCb3R0b21IaXRCb3hFZGdlKHRoYXQubWFwUG9zaXRpb25bMl0pKSB7XG5cdFx0XHRcdHZlcnRpY2FsSW50ZXJzZWN0ID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGVzdCB0aGF0IFRISVMgaGFzIGEgdG9wIGVkZ2UgaW5zaWRlIG9mIHRoZSBvdGhlciBvYmplY3Rcblx0XHRcdGlmIChvdGhlci5nZXRUb3BIaXRCb3hFZGdlKHRoYXQubWFwUG9zaXRpb25bMl0pIDw9IHRoYXQuZ2V0VG9wSGl0Qm94RWRnZSh0aGF0Lm1hcFBvc2l0aW9uWzJdKSAmJiBvdGhlci5nZXRCb3R0b21IaXRCb3hFZGdlKHRoYXQubWFwUG9zaXRpb25bMl0pID49IHRoYXQuZ2V0VG9wSGl0Qm94RWRnZSh0aGF0Lm1hcFBvc2l0aW9uWzJdKSkge1xuXHRcdFx0XHR2ZXJ0aWNhbEludGVyc2VjdCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRlc3QgdGhhdCBUSElTIGhhcyBhIHJpZ2h0IGVkZ2UgaW5zaWRlIG9mIHRoZSBvdGhlciBvYmplY3Rcblx0XHRcdGlmIChvdGhlci5nZXRMZWZ0SGl0Qm94RWRnZSh0aGF0Lm1hcFBvc2l0aW9uWzJdKSA8PSB0aGF0LmdldFJpZ2h0SGl0Qm94RWRnZSh0aGF0Lm1hcFBvc2l0aW9uWzJdKSAmJiBvdGhlci5nZXRSaWdodEhpdEJveEVkZ2UodGhhdC5tYXBQb3NpdGlvblsyXSkgPj0gdGhhdC5nZXRSaWdodEhpdEJveEVkZ2UodGhhdC5tYXBQb3NpdGlvblsyXSkpIHtcblx0XHRcdFx0aG9yaXpvbnRhbEludGVyc2VjdCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRlc3QgdGhhdCBUSElTIGhhcyBhIGxlZnQgZWRnZSBpbnNpZGUgb2YgdGhlIG90aGVyIG9iamVjdFxuXHRcdFx0aWYgKG90aGVyLmdldExlZnRIaXRCb3hFZGdlKHRoYXQubWFwUG9zaXRpb25bMl0pIDw9IHRoYXQuZ2V0TGVmdEhpdEJveEVkZ2UodGhhdC5tYXBQb3NpdGlvblsyXSkgJiYgb3RoZXIuZ2V0UmlnaHRIaXRCb3hFZGdlKHRoYXQubWFwUG9zaXRpb25bMl0pID49IHRoYXQuZ2V0TGVmdEhpdEJveEVkZ2UodGhhdC5tYXBQb3NpdGlvblsyXSkpIHtcblx0XHRcdFx0aG9yaXpvbnRhbEludGVyc2VjdCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2ZXJ0aWNhbEludGVyc2VjdCAmJiBob3Jpem9udGFsSW50ZXJzZWN0O1xuXHRcdH07XG5cblx0XHR0aGlzLmlzQWJvdmVPbkNhbnZhcyA9IGZ1bmN0aW9uIChjeSkge1xuXHRcdFx0cmV0dXJuICh0aGF0LmNhbnZhc1kgKyB0aGF0LmhlaWdodCkgPCBjeTtcblx0XHR9O1xuXG5cdFx0dGhpcy5pc0JlbG93T25DYW52YXMgPSBmdW5jdGlvbiAoY3kpIHtcblx0XHRcdHJldHVybiAodGhhdC5jYW52YXNZKSA+IGN5O1xuXHRcdH07XG5cblx0XHRyZXR1cm4gdGhhdDtcblx0fVxuXG5cdFNwcml0ZS5jcmVhdGVPYmplY3RzID0gZnVuY3Rpb24gY3JlYXRlT2JqZWN0cyhzcHJpdGVJbmZvQXJyYXksIG9wdHMpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoc3ByaXRlSW5mb0FycmF5KSkgc3ByaXRlSW5mb0FycmF5ID0gWyBzcHJpdGVJbmZvQXJyYXkgXTtcblx0XHRvcHRzID0gT2JqZWN0Lm1lcmdlKG9wdHMsIHtcblx0XHRcdHJhdGVNb2RpZmllcjogMCxcblx0XHRcdGRyb3BSYXRlOiAxLFxuXHRcdFx0cG9zaXRpb246IFswLCAwXVxuXHRcdH0sIGZhbHNlLCBmYWxzZSk7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVPbmUgKHNwcml0ZUluZm8pIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IG9wdHMucG9zaXRpb247XG5cdFx0XHRpZiAoTnVtYmVyLnJhbmRvbSgxMDAgKyBvcHRzLnJhdGVNb2RpZmllcikgPD0gc3ByaXRlSW5mby5kcm9wUmF0ZSkge1xuXHRcdFx0XHR2YXIgc3ByaXRlID0gbmV3IFNwcml0ZShzcHJpdGVJbmZvLnNwcml0ZSk7XG5cdFx0XHRcdHNwcml0ZS5zZXRTcGVlZCgwKTtcblxuXHRcdFx0XHRpZiAoT2JqZWN0LmlzRnVuY3Rpb24ocG9zaXRpb24pKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gPSBwb3NpdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3ByaXRlLnNldE1hcFBvc2l0aW9uKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSk7XG5cblx0XHRcdFx0aWYgKHNwcml0ZUluZm8uc3ByaXRlLmhpdEJlaGF2aW91ciAmJiBzcHJpdGVJbmZvLnNwcml0ZS5oaXRCZWhhdmlvdXIuc2tpZXIgJiYgb3B0cy5wbGF5ZXIpIHtcblx0XHRcdFx0XHRzcHJpdGUub25IaXR0aW5nKG9wdHMucGxheWVyLCBzcHJpdGVJbmZvLnNwcml0ZS5oaXRCZWhhdmlvdXIuc2tpZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHNwcml0ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgb2JqZWN0cyA9IHNwcml0ZUluZm9BcnJheS5tYXAoY3JlYXRlT25lKS5yZW1vdmUodW5kZWZpbmVkKTtcblxuXHRcdHJldHVybiBvYmplY3RzO1xuXHR9O1xuXG5cdGdsb2JhbC5zcHJpdGUgPSBTcHJpdGU7XG59KSggdGhpcyApO1xuXG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHRoaXMuc3ByaXRlO1xufSIsIihmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cdGZ1bmN0aW9uIFNwcml0ZUFycmF5KCkge1xuXHRcdHRoaXMucHVzaEhhbmRsZXJzID0gW107XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdFNwcml0ZUFycmF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcblxuXHRTcHJpdGVBcnJheS5wcm90b3R5cGUub25QdXNoID0gZnVuY3Rpb24oZiwgcmV0cm9hY3RpdmUpIHtcblx0XHR0aGlzLnB1c2hIYW5kbGVycy5wdXNoKGYpO1xuXG5cdFx0aWYgKHJldHJvYWN0aXZlKSB7XG5cdFx0XHR0aGlzLmVhY2goZik7XG5cdFx0fVxuXHR9O1xuXG5cdFNwcml0ZUFycmF5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBvYmopO1xuXHRcdHRoaXMucHVzaEhhbmRsZXJzLmVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlcihvYmopO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFNwcml0ZUFycmF5LnByb3RvdHlwZS5jdWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uIChvYmosIGkpIHtcblx0XHRcdGlmIChvYmouZGVsZXRlZCkge1xuXHRcdFx0XHRyZXR1cm4gKGRlbGV0ZSB0aGlzW2ldKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRnbG9iYWwuc3ByaXRlQXJyYXkgPSBTcHJpdGVBcnJheTtcbn0pKHRoaXMpO1xuXG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHRoaXMuc3ByaXRlQXJyYXk7XG59IiwiLy8gR2xvYmFsIGRlcGVuZGVuY2llcyB3aGljaCByZXR1cm4gbm8gbW9kdWxlc1xucmVxdWlyZSgnLi9saWIvY2FudmFzUmVuZGVyaW5nQ29udGV4dDJERXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9saWIvcGx1Z2lucycpO1xuXG4vLyBFeHRlcm5hbCBkZXBlbmRlbmNpZXNcbnZhciBIYW1tZXIgPSByZXF1aXJlKCdoYW1tZXJqcycpO1xudmFyIE1vdXNldHJhcCA9IHJlcXVpcmUoJ2JyLW1vdXNldHJhcCcpO1xuXG4vLyBNZXRob2QgbW9kdWxlc1xudmFyIGlzTW9iaWxlRGV2aWNlID0gcmVxdWlyZSgnLi9saWIvaXNNb2JpbGVEZXZpY2UnKTtcblxuLy8gR2FtZSBPYmplY3RzXG52YXIgU3ByaXRlQXJyYXkgPSByZXF1aXJlKCcuL2xpYi9zcHJpdGVBcnJheScpO1xudmFyIE1vbnN0ZXIgPSByZXF1aXJlKCcuL2xpYi9tb25zdGVyJyk7XG52YXIgU3ByaXRlID0gcmVxdWlyZSgnLi9saWIvc3ByaXRlJyk7XG52YXIgU25vd2JvYXJkZXIgPSByZXF1aXJlKCcuL2xpYi9zbm93Ym9hcmRlcicpO1xudmFyIFNraWVyID0gcmVxdWlyZSgnLi9saWIvc2tpZXInKTtcbnZhciBJbmZvQm94ID0gcmVxdWlyZSgnLi9saWIvaW5mb0JveCcpO1xudmFyIEdhbWUgPSByZXF1aXJlKCcuL2xpYi9nYW1lJyk7XG5cbi8vIExvY2FsIHZhcmlhYmxlcyBmb3Igc3RhcnRpbmcgdGhlIGdhbWVcbnZhciBtYWluQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NraWZyZWUtY2FudmFzJyk7XG52YXIgZENvbnRleHQgPSBtYWluQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG52YXIgaW1hZ2VTb3VyY2VzID0gWyAnc3ByaXRlLWNoYXJhY3RlcnMucG5nJywgJ3NraWZyZWUtb2JqZWN0cy5wbmcnIF07XG52YXIgZ2xvYmFsID0gdGhpcztcbnZhciBpbmZvQm94Q29udHJvbHMgPSAnVXNlIHRoZSBtb3VzZSBvciBXQVNEIHRvIGNvbnRyb2wgdGhlIHBsYXllcic7XG5pZiAoaXNNb2JpbGVEZXZpY2UoKSkgaW5mb0JveENvbnRyb2xzID0gJ1RhcCBvciBkcmFnIG9uIHRoZSBwaXN0ZSB0byBjb250cm9sIHRoZSBwbGF5ZXInO1xudmFyIHNwcml0ZXMgPSByZXF1aXJlKCcuL3Nwcml0ZUluZm8nKTtcblxudmFyIHBpeGVsc1Blck1ldHJlID0gMTg7XG52YXIgZGlzdGFuY2VUcmF2ZWxsZWRJbk1ldHJlcyA9IDA7XG52YXIgbW9uc3RlckRpc3RhbmNlVGhyZXNob2xkID0gMjAwMDtcbnZhciBsaXZlc0xlZnQgPSA1O1xudmFyIGhpZ2hTY29yZSA9IDA7XG52YXIgbG9zZUxpZmVPbk9ic3RhY2xlSGl0ID0gZmFsc2U7XG52YXIgZHJvcFJhdGVzID0ge3NtYWxsVHJlZTogNCwgdGFsbFRyZWU6IDIsIGp1bXA6IDEsIHRoaWNrU25vdzogMSwgcm9jazogMX07XG5pZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2hpZ2hTY29yZScpKSBoaWdoU2NvcmUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGlnaFNjb3JlJyk7XG5cbmZ1bmN0aW9uIGxvYWRJbWFnZXMgKHNvdXJjZXMsIG5leHQpIHtcblx0dmFyIGxvYWRlZCA9IDA7XG5cdHZhciBpbWFnZXMgPSB7fTtcblxuXHRmdW5jdGlvbiBmaW5pc2ggKCkge1xuXHRcdGxvYWRlZCArPSAxO1xuXHRcdGlmIChsb2FkZWQgPT09IHNvdXJjZXMubGVuZ3RoKSB7XG5cdFx0XHRuZXh0KGltYWdlcyk7XG5cdFx0fVxuXHR9XG5cblx0c291cmNlcy5lYWNoKGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgaW0gPSBuZXcgSW1hZ2UoKTtcblx0XHRpbS5vbmxvYWQgPSBmaW5pc2g7XG5cdFx0aW0uc3JjID0gc3JjO1xuXHRcdGRDb250ZXh0LnN0b3JlTG9hZGVkSW1hZ2Uoc3JjLCBpbSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtb25zdGVySGl0c1NraWVyQmVoYXZpb3VyKG1vbnN0ZXIsIHNraWVyKSB7XG5cdHNraWVyLmlzRWF0ZW5CeShtb25zdGVyLCBmdW5jdGlvbiAoKSB7XG5cdFx0bGl2ZXNMZWZ0IC09IDE7XG5cdFx0bW9uc3Rlci5pc0Z1bGwgPSB0cnVlO1xuXHRcdG1vbnN0ZXIuaXNFYXRpbmcgPSBmYWxzZTtcblx0XHRza2llci5pc0JlaW5nRWF0ZW4gPSBmYWxzZTtcblx0XHRtb25zdGVyLnNldFNwZWVkKHNraWVyLmdldFNwZWVkKCkpO1xuXHRcdG1vbnN0ZXIuc3RvcEZvbGxvd2luZygpO1xuXHRcdHZhciByYW5kb21Qb3NpdGlvbkFib3ZlID0gZENvbnRleHQuZ2V0UmFuZG9tTWFwUG9zaXRpb25BYm92ZVZpZXdwb3J0KCk7XG5cdFx0bW9uc3Rlci5zZXRNYXBQb3NpdGlvblRhcmdldChyYW5kb21Qb3NpdGlvbkFib3ZlWzBdLCByYW5kb21Qb3NpdGlvbkFib3ZlWzFdKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TmV2ZXJFbmRpbmdHYW1lIChpbWFnZXMpIHtcblx0dmFyIHBsYXllcjtcblx0dmFyIHN0YXJ0U2lnbjtcblx0dmFyIGluZm9Cb3g7XG5cdHZhciBnYW1lO1xuXG5cdGZ1bmN0aW9uIHJlc2V0R2FtZSAoKSB7XG5cdFx0ZGlzdGFuY2VUcmF2ZWxsZWRJbk1ldHJlcyA9IDA7XG5cdFx0bGl2ZXNMZWZ0ID0gNTtcblx0XHRoaWdoU2NvcmUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGlnaFNjb3JlJyk7XG5cdFx0Z2FtZS5yZXNldCgpO1xuXHRcdGdhbWUuYWRkU3RhdGljT2JqZWN0KHN0YXJ0U2lnbik7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXRlY3RFbmQgKCkge1xuXHRcdGlmICghZ2FtZS5pc1BhdXNlZCgpKSB7XG5cdFx0XHRoaWdoU2NvcmUgPSBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnaGlnaFNjb3JlJywgZGlzdGFuY2VUcmF2ZWxsZWRJbk1ldHJlcyk7XG5cdFx0XHRpbmZvQm94LnNldExpbmVzKFtcblx0XHRcdFx0J0dhbWUgb3ZlciEnLFxuXHRcdFx0XHQnSGl0IHNwYWNlIHRvIHJlc3RhcnQnXG5cdFx0XHRdKTtcblx0XHRcdGdhbWUucGF1c2UoKTtcblx0XHRcdGdhbWUuY3ljbGUoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByYW5kb21seVNwYXduTlBDKHNwYXduRnVuY3Rpb24sIGRyb3BSYXRlKSB7XG5cdFx0dmFyIHJhdGVNb2RpZmllciA9IE1hdGgubWF4KDgwMCAtIG1haW5DYW52YXMud2lkdGgsIDApO1xuXHRcdGlmIChOdW1iZXIucmFuZG9tKDEwMDAgKyByYXRlTW9kaWZpZXIpIDw9IGRyb3BSYXRlKSB7XG5cdFx0XHRzcGF3bkZ1bmN0aW9uKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc3Bhd25Nb25zdGVyICgpIHtcblx0XHR2YXIgbmV3TW9uc3RlciA9IG5ldyBNb25zdGVyKHNwcml0ZXMubW9uc3Rlcik7XG5cdFx0dmFyIHJhbmRvbVBvc2l0aW9uID0gZENvbnRleHQuZ2V0UmFuZG9tTWFwUG9zaXRpb25BYm92ZVZpZXdwb3J0KCk7XG5cdFx0bmV3TW9uc3Rlci5zZXRNYXBQb3NpdGlvbihyYW5kb21Qb3NpdGlvblswXSwgcmFuZG9tUG9zaXRpb25bMV0pO1xuXHRcdG5ld01vbnN0ZXIuZm9sbG93KHBsYXllcik7XG5cdFx0bmV3TW9uc3Rlci5zZXRTcGVlZChwbGF5ZXIuZ2V0U3RhbmRhcmRTcGVlZCgpKTtcblx0XHRuZXdNb25zdGVyLm9uSGl0dGluZyhwbGF5ZXIsIG1vbnN0ZXJIaXRzU2tpZXJCZWhhdmlvdXIpO1xuXG5cdFx0Z2FtZS5hZGRNb3ZpbmdPYmplY3QobmV3TW9uc3RlciwgJ21vbnN0ZXInKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNwYXduQm9hcmRlciAoKSB7XG5cdFx0dmFyIG5ld0JvYXJkZXIgPSBuZXcgU25vd2JvYXJkZXIoc3ByaXRlcy5zbm93Ym9hcmRlcik7XG5cdFx0dmFyIHJhbmRvbVBvc2l0aW9uQWJvdmUgPSBkQ29udGV4dC5nZXRSYW5kb21NYXBQb3NpdGlvbkFib3ZlVmlld3BvcnQoKTtcblx0XHR2YXIgcmFuZG9tUG9zaXRpb25CZWxvdyA9IGRDb250ZXh0LmdldFJhbmRvbU1hcFBvc2l0aW9uQmVsb3dWaWV3cG9ydCgpO1xuXHRcdG5ld0JvYXJkZXIuc2V0TWFwUG9zaXRpb24ocmFuZG9tUG9zaXRpb25BYm92ZVswXSwgcmFuZG9tUG9zaXRpb25BYm92ZVsxXSk7XG5cdFx0bmV3Qm9hcmRlci5zZXRNYXBQb3NpdGlvblRhcmdldChyYW5kb21Qb3NpdGlvbkJlbG93WzBdLCByYW5kb21Qb3NpdGlvbkJlbG93WzFdKTtcblx0XHRuZXdCb2FyZGVyLm9uSGl0dGluZyhwbGF5ZXIsIHNwcml0ZXMuc25vd2JvYXJkZXIuaGl0QmVoYXZpb3VyLnNraWVyKTtcblxuXHRcdGdhbWUuYWRkTW92aW5nT2JqZWN0KG5ld0JvYXJkZXIpO1xuXHR9XG5cblx0cGxheWVyID0gbmV3IFNraWVyKHNwcml0ZXMuc2tpZXIpO1xuXHRwbGF5ZXIuc2V0TWFwUG9zaXRpb24oMCwgMCk7XG5cdHBsYXllci5zZXRNYXBQb3NpdGlvblRhcmdldCgwLCAtMTApO1xuXHRpZiAoIGxvc2VMaWZlT25PYnN0YWNsZUhpdCApIHtcblx0XHRwbGF5ZXIuc2V0SGl0T2JzdGFjbGVDYihmdW5jdGlvbigpIHtcblx0XHRcdGxpdmVzTGVmdCAtPSAxO1xuXHRcdH0pO1xuXHR9XG5cblx0Z2FtZSA9IG5ldyBHYW1lKG1haW5DYW52YXMsIHBsYXllcik7XG5cblx0c3RhcnRTaWduID0gbmV3IFNwcml0ZShzcHJpdGVzLnNpZ25TdGFydCk7XG5cdGdhbWUuYWRkU3RhdGljT2JqZWN0KHN0YXJ0U2lnbik7XG5cdHN0YXJ0U2lnbi5zZXRNYXBQb3NpdGlvbigtNTAsIDApO1xuXHRkQ29udGV4dC5mb2xsb3dTcHJpdGUocGxheWVyKTtcblxuXHRpbmZvQm94ID0gbmV3IEluZm9Cb3goe1xuXHRcdGluaXRpYWxMaW5lcyA6IFtcblx0XHRcdCdTa2lGcmVlLmpzJyxcblx0XHRcdGluZm9Cb3hDb250cm9scyxcblx0XHRcdCdUcmF2ZWxsZWQgMG0nLFxuXHRcdFx0J0hpZ2ggU2NvcmU6ICcgKyBoaWdoU2NvcmUsXG5cdFx0XHQnU2tpZXJzIGxlZnQ6ICcgKyBsaXZlc0xlZnQsXG5cdFx0XHQnQ3JlYXRlZCBieSBEYW4gSG91Z2ggKEBiYXNpY2FsbHlkYW4pJ1xuXHRcdF0sXG5cdFx0cG9zaXRpb246IHtcblx0XHRcdHRvcDogMTUsXG5cdFx0XHRyaWdodDogMTBcblx0XHR9XG5cdH0pO1xuXG5cdGdhbWUuYmVmb3JlQ3ljbGUoZnVuY3Rpb24gKCkge1xuXHRcdHZhciBuZXdPYmplY3RzID0gW107XG5cdFx0aWYgKHBsYXllci5pc01vdmluZykge1xuXHRcdFx0bmV3T2JqZWN0cyA9IFNwcml0ZS5jcmVhdGVPYmplY3RzKFtcblx0XHRcdFx0eyBzcHJpdGU6IHNwcml0ZXMuc21hbGxUcmVlLCBkcm9wUmF0ZTogZHJvcFJhdGVzLnNtYWxsVHJlZSB9LFxuXHRcdFx0XHR7IHNwcml0ZTogc3ByaXRlcy50YWxsVHJlZSwgZHJvcFJhdGU6IGRyb3BSYXRlcy50YWxsVHJlZSB9LFxuXHRcdFx0XHR7IHNwcml0ZTogc3ByaXRlcy5qdW1wLCBkcm9wUmF0ZTogZHJvcFJhdGVzLmp1bXAgfSxcblx0XHRcdFx0eyBzcHJpdGU6IHNwcml0ZXMudGhpY2tTbm93LCBkcm9wUmF0ZTogZHJvcFJhdGVzLnRoaWNrU25vdyB9LFxuXHRcdFx0XHR7IHNwcml0ZTogc3ByaXRlcy5yb2NrLCBkcm9wUmF0ZTogZHJvcFJhdGVzLnJvY2sgfSxcblx0XHRcdF0sIHtcblx0XHRcdFx0cmF0ZU1vZGlmaWVyOiBNYXRoLm1heCg4MDAgLSBtYWluQ2FudmFzLndpZHRoLCAwKSxcblx0XHRcdFx0cG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZENvbnRleHQuZ2V0UmFuZG9tTWFwUG9zaXRpb25CZWxvd1ZpZXdwb3J0KCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHBsYXllcjogcGxheWVyXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYgKCFnYW1lLmlzUGF1c2VkKCkpIHtcblx0XHRcdGdhbWUuYWRkU3RhdGljT2JqZWN0cyhuZXdPYmplY3RzKTtcblxuXHRcdFx0cmFuZG9tbHlTcGF3bk5QQyhzcGF3bkJvYXJkZXIsIDAuMSk7XG5cdFx0XHRkaXN0YW5jZVRyYXZlbGxlZEluTWV0cmVzID0gcGFyc2VGbG9hdChwbGF5ZXIuZ2V0UGl4ZWxzVHJhdmVsbGVkRG93bk1vdW50YWluKCkgLyBwaXhlbHNQZXJNZXRyZSkudG9GaXhlZCgxKTtcblxuXHRcdFx0aWYgKGRpc3RhbmNlVHJhdmVsbGVkSW5NZXRyZXMgPiBtb25zdGVyRGlzdGFuY2VUaHJlc2hvbGQpIHtcblx0XHRcdFx0cmFuZG9tbHlTcGF3bk5QQyhzcGF3bk1vbnN0ZXIsIDAuMDAxKTtcblx0XHRcdH1cblxuXHRcdFx0aW5mb0JveC5zZXRMaW5lcyhbXG5cdFx0XHRcdCdTa2lGcmVlLmpzJyxcblx0XHRcdFx0aW5mb0JveENvbnRyb2xzLFxuXHRcdFx0XHQnVHJhdmVsbGVkICcgKyBkaXN0YW5jZVRyYXZlbGxlZEluTWV0cmVzICsgJ20nLFxuXHRcdFx0XHQnU2tpZXJzIGxlZnQ6ICcgKyBsaXZlc0xlZnQsXG5cdFx0XHRcdCdIaWdoIFNjb3JlOiAnICsgaGlnaFNjb3JlLFxuXHRcdFx0XHQnQ3JlYXRlZCBieSBEYW4gSG91Z2ggKEBiYXNpY2FsbHlkYW4pJyxcblx0XHRcdFx0J0N1cnJlbnQgU3BlZWQ6ICcgKyBwbGF5ZXIuZ2V0U3BlZWQoKS8qLFxuXHRcdFx0XHQnU2tpZXIgTWFwIFBvc2l0aW9uOiAnICsgcGxheWVyLm1hcFBvc2l0aW9uWzBdLnRvRml4ZWQoMSkgKyAnLCAnICsgcGxheWVyLm1hcFBvc2l0aW9uWzFdLnRvRml4ZWQoMSksXG5cdFx0XHRcdCdNb3VzZSBNYXAgUG9zaXRpb246ICcgKyBtb3VzZU1hcFBvc2l0aW9uWzBdLnRvRml4ZWQoMSkgKyAnLCAnICsgbW91c2VNYXBQb3NpdGlvblsxXS50b0ZpeGVkKDEpKi9cblx0XHRcdF0pO1xuXHRcdH1cblx0fSk7XG5cblx0Z2FtZS5hZnRlckN5Y2xlKGZ1bmN0aW9uKCkge1xuXHRcdGlmIChsaXZlc0xlZnQgPT09IDApIHtcblx0XHRcdGRldGVjdEVuZCgpO1xuXHRcdH1cblx0fSk7XG5cblx0Z2FtZS5hZGRVSUVsZW1lbnQoaW5mb0JveCk7XG5cdFxuXHQkKG1haW5DYW52YXMpXG5cdC5tb3VzZW1vdmUoZnVuY3Rpb24gKGUpIHtcblx0XHRnYW1lLnNldE1vdXNlWChlLnBhZ2VYKTtcblx0XHRnYW1lLnNldE1vdXNlWShlLnBhZ2VZKTtcblx0XHRwbGF5ZXIucmVzZXREaXJlY3Rpb24oKTtcblx0XHRwbGF5ZXIuc3RhcnRNb3ZpbmdJZlBvc3NpYmxlKCk7XG5cdH0pXG5cdC5iaW5kKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdFx0Z2FtZS5zZXRNb3VzZVgoZS5wYWdlWCk7XG5cdFx0Z2FtZS5zZXRNb3VzZVkoZS5wYWdlWSk7XG5cdFx0cGxheWVyLnJlc2V0RGlyZWN0aW9uKCk7XG5cdFx0cGxheWVyLnN0YXJ0TW92aW5nSWZQb3NzaWJsZSgpO1xuXHR9KVxuXHQuZm9jdXMoKTsgLy8gU28gd2UgY2FuIGxpc3RlbiB0byBldmVudHMgaW1tZWRpYXRlbHlcblxuXHRNb3VzZXRyYXAuYmluZCgnZicsIHBsYXllci5zcGVlZEJvb3N0KTtcblx0TW91c2V0cmFwLmJpbmQoJ3QnLCBwbGF5ZXIuYXR0ZW1wdFRyaWNrKTtcblx0TW91c2V0cmFwLmJpbmQoWyd3JywgJ3VwJ10sIGZ1bmN0aW9uICgpIHtcblx0XHRwbGF5ZXIuc3RvcCgpO1xuXHR9KTtcblx0TW91c2V0cmFwLmJpbmQoWydhJywgJ2xlZnQnXSwgZnVuY3Rpb24gKCkge1xuXHRcdGlmIChwbGF5ZXIuZGlyZWN0aW9uID09PSAyNzApIHtcblx0XHRcdHBsYXllci5zdGVwV2VzdCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwbGF5ZXIudHVybldlc3QoKTtcblx0XHR9XG5cdH0pO1xuXHRNb3VzZXRyYXAuYmluZChbJ3MnLCAnZG93biddLCBmdW5jdGlvbiAoKSB7XG5cdFx0cGxheWVyLnNldERpcmVjdGlvbigxODApO1xuXHRcdHBsYXllci5zdGFydE1vdmluZ0lmUG9zc2libGUoKTtcblx0fSk7XG5cdE1vdXNldHJhcC5iaW5kKFsnZCcsICdyaWdodCddLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHBsYXllci5kaXJlY3Rpb24gPT09IDkwKSB7XG5cdFx0XHRwbGF5ZXIuc3RlcEVhc3QoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGxheWVyLnR1cm5FYXN0KCk7XG5cdFx0fVxuXHR9KTtcblx0TW91c2V0cmFwLmJpbmQoJ20nLCBzcGF3bk1vbnN0ZXIpO1xuXHRNb3VzZXRyYXAuYmluZCgnYicsIHNwYXduQm9hcmRlcik7XG5cdE1vdXNldHJhcC5iaW5kKCdzcGFjZScsIHJlc2V0R2FtZSk7XG5cblx0dmFyIGhhbW1lcnRpbWUgPSBIYW1tZXIobWFpbkNhbnZhcykub24oJ3ByZXNzJywgZnVuY3Rpb24gKGUpIHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Z2FtZS5zZXRNb3VzZVgoZS5nZXN0dXJlLmNlbnRlci54KTtcblx0XHRnYW1lLnNldE1vdXNlWShlLmdlc3R1cmUuY2VudGVyLnkpO1xuXHR9KS5vbigndGFwJywgZnVuY3Rpb24gKGUpIHtcblx0XHRnYW1lLnNldE1vdXNlWChlLmdlc3R1cmUuY2VudGVyLngpO1xuXHRcdGdhbWUuc2V0TW91c2VZKGUuZ2VzdHVyZS5jZW50ZXIueSk7XG5cdH0pLm9uKCdwYW4nLCBmdW5jdGlvbiAoZSkge1xuXHRcdGdhbWUuc2V0TW91c2VYKGUuZ2VzdHVyZS5jZW50ZXIueCk7XG5cdFx0Z2FtZS5zZXRNb3VzZVkoZS5nZXN0dXJlLmNlbnRlci55KTtcblx0XHRwbGF5ZXIucmVzZXREaXJlY3Rpb24oKTtcblx0XHRwbGF5ZXIuc3RhcnRNb3ZpbmdJZlBvc3NpYmxlKCk7XG5cdH0pLm9uKCdkb3VibGV0YXAnLCBmdW5jdGlvbiAoZSkge1xuXHRcdHBsYXllci5zcGVlZEJvb3N0KCk7XG5cdH0pO1xuXG5cdHBsYXllci5pc01vdmluZyA9IGZhbHNlO1xuXHRwbGF5ZXIuc2V0RGlyZWN0aW9uKDI3MCk7XG5cblx0Z2FtZS5zdGFydCgpO1xufVxuXG5mdW5jdGlvbiByZXNpemVDYW52YXMoKSB7XG5cdG1haW5DYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcblx0bWFpbkNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMsIGZhbHNlKTtcblxucmVzaXplQ2FudmFzKCk7XG5cbmxvYWRJbWFnZXMoaW1hZ2VTb3VyY2VzLCBzdGFydE5ldmVyRW5kaW5nR2FtZSk7XG5cbnRoaXMuZXhwb3J0cyA9IHdpbmRvdztcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKSB7XG5cdHZhciBzcHJpdGVzID0ge1xuXHRcdCdza2llcicgOiB7XG5cdFx0XHQkaW1hZ2VGaWxlIDogJ3Nwcml0ZS1jaGFyYWN0ZXJzLnBuZycsXG5cdFx0XHRwYXJ0cyA6IHtcblx0XHRcdFx0YmxhbmsgOiBbIDAsIDAsIDAsIDAgXSxcblx0XHRcdFx0ZWFzdCA6IFsgMCwgMCwgMjQsIDM0IF0sXG5cdFx0XHRcdGVzRWFzdCA6IFsgMjQsIDAsIDI0LCAzNCBdLFxuXHRcdFx0XHRzRWFzdCA6IFsgNDksIDAsIDE3LCAzNCBdLFxuXHRcdFx0XHRzb3V0aCA6IFsgNjUsIDAsIDE3LCAzNCBdLFxuXHRcdFx0XHRzV2VzdCA6IFsgNDksIDM3LCAxNywgMzQgXSxcblx0XHRcdFx0d3NXZXN0IDogWyAyNCwgMzcsIDI0LCAzNCBdLFxuXHRcdFx0XHR3ZXN0IDogWyAwLCAzNywgMjQsIDM0IF0sXG5cdFx0XHRcdGhpdCA6IFsgMCwgNzgsIDMxLCAzMSBdLFxuXHRcdFx0XHRqdW1waW5nIDogWyA4NCwgMCwgMzIsIDM0IF0sXG5cdFx0XHRcdHNvbWVyc2F1bHQxIDogWyAxMTYsIDAsIDMyLCAzNCBdLFxuXHRcdFx0XHRzb21lcnNhdWx0MiA6IFsgMTQ4LCAwLCAzMiwgMzQgXVxuXHRcdFx0fSxcblx0XHRcdGhpdEJveGVzOiB7XG5cdFx0XHRcdDA6IFsgNywgMjAsIDI3LCAzNCBdXG5cdFx0XHR9LFxuXHRcdFx0aWQgOiAncGxheWVyJyxcblx0XHRcdGhpdEJlaGF2aW91cjoge31cblx0XHR9LFxuXHRcdCdzbWFsbFRyZWUnIDoge1xuXHRcdFx0JGltYWdlRmlsZSA6ICdza2lmcmVlLW9iamVjdHMucG5nJyxcblx0XHRcdHBhcnRzIDoge1xuXHRcdFx0XHRtYWluIDogWyAwLCAyOCwgMzAsIDM0IF1cblx0XHRcdH0sXG5cdFx0XHRoaXRCb3hlczoge1xuXHRcdFx0XHQwOiBbIDAsIDE4LCAzMCwgMzQgXVxuXHRcdFx0fSxcblx0XHRcdGhpdEJlaGF2aW91cjoge31cblx0XHR9LFxuXHRcdCd0YWxsVHJlZScgOiB7XG5cdFx0XHQkaW1hZ2VGaWxlIDogJ3NraWZyZWUtb2JqZWN0cy5wbmcnLFxuXHRcdFx0cGFydHMgOiB7XG5cdFx0XHRcdG1haW4gOiBbIDk1LCA2NiwgMzIsIDY0IF1cblx0XHRcdH0sXG5cdFx0XHR6SW5kZXhlc09jY3VwaWVkIDogWzAsIDFdLFxuXHRcdFx0aGl0Qm94ZXM6IHtcblx0XHRcdFx0MDogWzAsIDU0LCAzMiwgNjRdLFxuXHRcdFx0XHQxOiBbMCwgMTAsIDMyLCA1NF1cblx0XHRcdH0sXG5cdFx0XHRoaXRCZWhhdmlvdXI6IHt9XG5cdFx0fSxcblx0XHQndGhpY2tTbm93JyA6IHtcblx0XHRcdCRpbWFnZUZpbGUgOiAnc2tpZnJlZS1vYmplY3RzLnBuZycsXG5cdFx0XHRwYXJ0cyA6IHtcblx0XHRcdFx0bWFpbiA6IFsgMTQzLCA1MywgNDMsIDEwIF1cblx0XHRcdH0sXG5cdFx0XHRoaXRCZWhhdmlvdXI6IHt9XG5cdFx0fSxcblx0XHQncm9jaycgOiB7XG5cdFx0XHQkaW1hZ2VGaWxlIDogJ3NraWZyZWUtb2JqZWN0cy5wbmcnLFxuXHRcdFx0cGFydHMgOiB7XG5cdFx0XHRcdG1haW4gOiBbIDMwLCA1MiwgMjMsIDExIF1cblx0XHRcdH0sXG5cdFx0XHRoaXRCZWhhdmlvdXI6IHt9XG5cdFx0fSxcblx0XHQnbW9uc3RlcicgOiB7XG5cdFx0XHQkaW1hZ2VGaWxlIDogJ3Nwcml0ZS1jaGFyYWN0ZXJzLnBuZycsXG5cdFx0XHRwYXJ0cyA6IHtcblx0XHRcdFx0c0Vhc3QxIDogWyA2NCwgMTEyLCAyNiwgNDMgXSxcblx0XHRcdFx0c0Vhc3QyIDogWyA5MCwgMTEyLCAzMiwgNDMgXSxcblx0XHRcdFx0c1dlc3QxIDogWyA2NCwgMTU4LCAyNiwgNDMgXSxcblx0XHRcdFx0c1dlc3QyIDogWyA5MCwgMTU4LCAzMiwgNDMgXSxcblx0XHRcdFx0ZWF0aW5nMSA6IFsgMTIyLCAxMTIsIDM0LCA0MyBdLFxuXHRcdFx0XHRlYXRpbmcyIDogWyAxNTYsIDExMiwgMzEsIDQzIF0sXG5cdFx0XHRcdGVhdGluZzMgOiBbIDE4NywgMTEyLCAzMSwgNDMgXSxcblx0XHRcdFx0ZWF0aW5nNCA6IFsgMjE5LCAxMTIsIDI1LCA0MyBdLFxuXHRcdFx0XHRlYXRpbmc1IDogWyAyNDMsIDExMiwgMjYsIDQzIF1cblx0XHRcdH0sXG5cdFx0XHRoaXRCZWhhdmlvdXI6IHt9XG5cdFx0fSxcblx0XHQnanVtcCcgOiB7XG5cdFx0XHQkaW1hZ2VGaWxlIDogJ3NraWZyZWUtb2JqZWN0cy5wbmcnLFxuXHRcdFx0cGFydHMgOiB7XG5cdFx0XHRcdG1haW4gOiBbIDEwOSwgNTUsIDMyLCA4IF1cblx0XHRcdH0sXG5cdFx0XHRoaXRCZWhhdmlvdXI6IHt9XG5cdFx0fSxcblx0XHQnc2lnblN0YXJ0JyA6IHtcblx0XHRcdCRpbWFnZUZpbGUgOiAnc2tpZnJlZS1vYmplY3RzLnBuZycsXG5cdFx0XHRwYXJ0cyA6IHtcblx0XHRcdFx0bWFpbiA6IFsgMjYwLCAxMDMsIDQyLCAyNyBdXG5cdFx0XHR9LFxuXHRcdFx0aGl0QmVoYXZpb3VyOiB7fVxuXHRcdH0sXG5cdFx0J3Nub3dib2FyZGVyJyA6IHtcblx0XHRcdCRpbWFnZUZpbGUgOiAnc3ByaXRlLWNoYXJhY3RlcnMucG5nJyxcblx0XHRcdHBhcnRzIDoge1xuXHRcdFx0XHRzRWFzdCA6IFsgNzMsIDIyOSwgMjAsIDI5IF0sXG5cdFx0XHRcdHNXZXN0IDogWyA5NSwgMjI4LCAyNiwgMzAgXVxuXHRcdFx0fSxcblx0XHRcdGhpdEJlaGF2aW91cjoge31cblx0XHR9LFxuXHRcdCdlbXB0eUNoYWlyTGlmdCc6IHtcblx0XHRcdCRpbWFnZUZpbGUgOiAnc2tpZnJlZS1vYmplY3RzLnBuZycsXG5cdFx0XHRwYXJ0czoge1xuXHRcdFx0XHRtYWluIDogWyA5MiwgMTM2LCAyNiwgMzAgXVxuXHRcdFx0fSxcblx0XHRcdHpJbmRleGVzT2NjdXBpZWQgOiBbMV0sXG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIG1vbnN0ZXJIaXRzVHJlZUJlaGF2aW91cihtb25zdGVyKSB7XG5cdFx0bW9uc3Rlci5kZWxldGVPbk5leHRDeWNsZSgpO1xuXHR9XG5cblx0c3ByaXRlcy5tb25zdGVyLmhpdEJlaGF2aW91ci50cmVlID0gbW9uc3RlckhpdHNUcmVlQmVoYXZpb3VyO1xuXG5cdGZ1bmN0aW9uIHRyZWVIaXRzTW9uc3RlckJlaGF2aW91cih0cmVlLCBtb25zdGVyKSB7XG5cdFx0bW9uc3Rlci5kZWxldGVPbk5leHRDeWNsZSgpO1xuXHR9XG5cblx0c3ByaXRlcy5zbWFsbFRyZWUuaGl0QmVoYXZpb3VyLm1vbnN0ZXIgPSB0cmVlSGl0c01vbnN0ZXJCZWhhdmlvdXI7XG5cdHNwcml0ZXMudGFsbFRyZWUuaGl0QmVoYXZpb3VyLm1vbnN0ZXIgPSB0cmVlSGl0c01vbnN0ZXJCZWhhdmlvdXI7XG5cblx0ZnVuY3Rpb24gc2tpZXJIaXRzVHJlZUJlaGF2aW91cihza2llciwgdHJlZSkge1xuXHRcdHNraWVyLmhhc0hpdE9ic3RhY2xlKHRyZWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJlZUhpdHNTa2llckJlaGF2aW91cih0cmVlLCBza2llcikge1xuXHRcdHNraWVyLmhhc0hpdE9ic3RhY2xlKHRyZWUpO1xuXHR9XG5cblx0c3ByaXRlcy5zbWFsbFRyZWUuaGl0QmVoYXZpb3VyLnNraWVyID0gdHJlZUhpdHNTa2llckJlaGF2aW91cjtcblx0c3ByaXRlcy50YWxsVHJlZS5oaXRCZWhhdmlvdXIuc2tpZXIgPSB0cmVlSGl0c1NraWVyQmVoYXZpb3VyO1xuXG5cdGZ1bmN0aW9uIHJvY2tIaXRzU2tpZXJCZWhhdmlvdXIocm9jaywgc2tpZXIpIHtcblx0XHRza2llci5oYXNIaXRPYnN0YWNsZShyb2NrKTtcblx0fVxuXG5cdHNwcml0ZXMucm9jay5oaXRCZWhhdmlvdXIuc2tpZXIgPSByb2NrSGl0c1NraWVyQmVoYXZpb3VyO1xuXG5cdGZ1bmN0aW9uIHNraWVySGl0c0p1bXBCZWhhdmlvdXIoc2tpZXIsIGp1bXApIHtcblx0XHRza2llci5oYXNIaXRKdW1wKGp1bXApO1xuXHR9XG5cblx0ZnVuY3Rpb24ganVtcEhpdHNTa2llckJlaGF2aW91cihqdW1wLCBza2llcikge1xuXHRcdHNraWVyLmhhc0hpdEp1bXAoanVtcCk7XG5cdH1cblxuXHRzcHJpdGVzLmp1bXAuaGl0QmVoYXZpb3VyLnNraWVyID0ganVtcEhpdHNTa2llckJlaGF2aW91cjtcblxuLy8gUmVhbGx5IG5vdCBhIGZhbiBvZiB0aGlzIGJlaGF2aW91ci5cbi8qXHRmdW5jdGlvbiBza2llckhpdHNUaGlja1Nub3dCZWhhdmlvdXIoc2tpZXIsIHRoaWNrU25vdykge1xuXHRcdC8vIE5lZWQgdG8gaW1wbGVtZW50IHRoaXMgcHJvcGVybHlcblx0XHRza2llci5zZXRTcGVlZCgyKTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0c2tpZXIucmVzZXRTcGVlZCgpO1xuXHRcdH0sIDcwMCk7XG5cdH1cblxuXHRmdW5jdGlvbiB0aGlja1Nub3dIaXRzU2tpZXJCZWhhdmlvdXIodGhpY2tTbm93LCBza2llcikge1xuXHRcdC8vIE5lZWQgdG8gaW1wbGVtZW50IHRoaXMgcHJvcGVybHlcblx0XHRza2llci5zZXRTcGVlZCgyKTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0c2tpZXIucmVzZXRTcGVlZCgpO1xuXHRcdH0sIDMwMCk7XG5cdH0qL1xuXG5cdC8vIHNwcml0ZXMudGhpY2tTbm93LmhpdEJlaGF2aW91ci5za2llciA9IHRoaWNrU25vd0hpdHNTa2llckJlaGF2aW91cjtcblxuXHRmdW5jdGlvbiBzbm93Ym9hcmRlckhpdHNTa2llckJlaGF2aW91cihzbm93Ym9hcmRlciwgc2tpZXIpIHtcblx0XHRza2llci5oYXNIaXRPYnN0YWNsZShzbm93Ym9hcmRlcik7XG5cdH1cblxuXHRzcHJpdGVzLnNub3dib2FyZGVyLmhpdEJlaGF2aW91ci5za2llciA9IHNub3dib2FyZGVySGl0c1NraWVyQmVoYXZpb3VyO1xuXG5cdGdsb2JhbC5zcHJpdGVJbmZvID0gc3ByaXRlcztcbn0pKCB0aGlzICk7XG5cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdGhpcy5zcHJpdGVJbmZvO1xufSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTIgQ3JhaWcgQ2FtcGJlbGxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBNb3VzZXRyYXAgaXMgYSBzaW1wbGUga2V5Ym9hcmQgc2hvcnRjdXQgbGlicmFyeSBmb3IgSmF2YXNjcmlwdCB3aXRoXG4gKiBubyBleHRlcm5hbCBkZXBlbmRlbmNpZXNcbiAqXG4gKiBAdmVyc2lvbiAxLjEuM1xuICogQHVybCBjcmFpZy5pcy9raWxsaW5nL21pY2VcbiAqL1xuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogbWFwcGluZyBvZiBzcGVjaWFsIGtleWNvZGVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcga2V5c1xuICAgICAqXG4gICAgICogZXZlcnl0aGluZyBpbiB0aGlzIGRpY3Rpb25hcnkgY2Fubm90IHVzZSBrZXlwcmVzcyBldmVudHNcbiAgICAgKiBzbyBpdCBoYXMgdG8gYmUgaGVyZSB0byBtYXAgdG8gdGhlIGNvcnJlY3Qga2V5Y29kZXMgZm9yXG4gICAgICoga2V5dXAva2V5ZG93biBldmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9NQVAgPSB7XG4gICAgICAgICAgICA4OiAnYmFja3NwYWNlJyxcbiAgICAgICAgICAgIDk6ICd0YWInLFxuICAgICAgICAgICAgMTM6ICdlbnRlcicsXG4gICAgICAgICAgICAxNjogJ3NoaWZ0JyxcbiAgICAgICAgICAgIDE3OiAnY3RybCcsXG4gICAgICAgICAgICAxODogJ2FsdCcsXG4gICAgICAgICAgICAyMDogJ2NhcHNsb2NrJyxcbiAgICAgICAgICAgIDI3OiAnZXNjJyxcbiAgICAgICAgICAgIDMyOiAnc3BhY2UnLFxuICAgICAgICAgICAgMzM6ICdwYWdldXAnLFxuICAgICAgICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAgICAgICAzNTogJ2VuZCcsXG4gICAgICAgICAgICAzNjogJ2hvbWUnLFxuICAgICAgICAgICAgMzc6ICdsZWZ0JyxcbiAgICAgICAgICAgIDM4OiAndXAnLFxuICAgICAgICAgICAgMzk6ICdyaWdodCcsXG4gICAgICAgICAgICA0MDogJ2Rvd24nLFxuICAgICAgICAgICAgNDU6ICdpbnMnLFxuICAgICAgICAgICAgNDY6ICdkZWwnLFxuICAgICAgICAgICAgOTE6ICdtZXRhJyxcbiAgICAgICAgICAgIDkzOiAnbWV0YScsXG4gICAgICAgICAgICAyMjQ6ICdtZXRhJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXBwaW5nIGZvciBzcGVjaWFsIGNoYXJhY3RlcnMgc28gdGhleSBjYW4gc3VwcG9ydFxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGlzIGRpY3Rpb25hcnkgaXMgb25seSB1c2VkIGluY2FzZSB5b3Ugd2FudCB0byBiaW5kIGFcbiAgICAgICAgICoga2V5dXAgb3Iga2V5ZG93biBldmVudCB0byBvbmUgb2YgdGhlc2Uga2V5c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgX0tFWUNPREVfTUFQID0ge1xuICAgICAgICAgICAgMTA2OiAnKicsXG4gICAgICAgICAgICAxMDc6ICcrJyxcbiAgICAgICAgICAgIDEwOTogJy0nLFxuICAgICAgICAgICAgMTEwOiAnLicsXG4gICAgICAgICAgICAxMTEgOiAnLycsXG4gICAgICAgICAgICAxODY6ICc7JyxcbiAgICAgICAgICAgIDE4NzogJz0nLFxuICAgICAgICAgICAgMTg4OiAnLCcsXG4gICAgICAgICAgICAxODk6ICctJyxcbiAgICAgICAgICAgIDE5MDogJy4nLFxuICAgICAgICAgICAgMTkxOiAnLycsXG4gICAgICAgICAgICAxOTI6ICdgJyxcbiAgICAgICAgICAgIDIxOTogJ1snLFxuICAgICAgICAgICAgMjIwOiAnXFxcXCcsXG4gICAgICAgICAgICAyMjE6ICddJyxcbiAgICAgICAgICAgIDIyMjogJ1xcJydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGhpcyBpcyBhIG1hcHBpbmcgb2Yga2V5cyB0aGF0IHJlcXVpcmUgc2hpZnQgb24gYSBVUyBrZXlwYWRcbiAgICAgICAgICogYmFjayB0byB0aGUgbm9uIHNoaWZ0IGVxdWl2ZWxlbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIHRoaXMgaXMgc28geW91IGNhbiB1c2Uga2V5dXAgZXZlbnRzIHdpdGggdGhlc2Uga2V5c1xuICAgICAgICAgKlxuICAgICAgICAgKiBub3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayByZWxpYWJseSBvbiBVUyBrZXlib2FyZHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIF9TSElGVF9NQVAgPSB7XG4gICAgICAgICAgICAnfic6ICdgJyxcbiAgICAgICAgICAgICchJzogJzEnLFxuICAgICAgICAgICAgJ0AnOiAnMicsXG4gICAgICAgICAgICAnIyc6ICczJyxcbiAgICAgICAgICAgICckJzogJzQnLFxuICAgICAgICAgICAgJyUnOiAnNScsXG4gICAgICAgICAgICAnXic6ICc2JyxcbiAgICAgICAgICAgICcmJzogJzcnLFxuICAgICAgICAgICAgJyonOiAnOCcsXG4gICAgICAgICAgICAnKCc6ICc5JyxcbiAgICAgICAgICAgICcpJzogJzAnLFxuICAgICAgICAgICAgJ18nOiAnLScsXG4gICAgICAgICAgICAnKyc6ICc9JyxcbiAgICAgICAgICAgICc6JzogJzsnLFxuICAgICAgICAgICAgJ1xcXCInOiAnXFwnJyxcbiAgICAgICAgICAgICc8JzogJywnLFxuICAgICAgICAgICAgJz4nOiAnLicsXG4gICAgICAgICAgICAnPyc6ICcvJyxcbiAgICAgICAgICAgICd8JzogJ1xcXFwnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoaXMgaXMgYSBsaXN0IG9mIHNwZWNpYWwgc3RyaW5ncyB5b3UgY2FuIHVzZSB0byBtYXBcbiAgICAgICAgICogdG8gbW9kaWZpZXIga2V5cyB3aGVuIHlvdSBzcGVjaWZ5IHlvdXIga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBfU1BFQ0lBTF9BTElBU0VTID0ge1xuICAgICAgICAgICAgJ29wdGlvbic6ICdhbHQnLFxuICAgICAgICAgICAgJ2NvbW1hbmQnOiAnbWV0YScsXG4gICAgICAgICAgICAncmV0dXJuJzogJ2VudGVyJyxcbiAgICAgICAgICAgICdlc2NhcGUnOiAnZXNjJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YXJpYWJsZSB0byBzdG9yZSB0aGUgZmxpcHBlZCB2ZXJzaW9uIG9mIF9NQVAgZnJvbSBhYm92ZVxuICAgICAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSBrZXlwcmVzcyBvciBub3Qgd2hlbiBubyBhY3Rpb25cbiAgICAgICAgICogaXMgc3BlY2lmaWVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgX1JFVkVSU0VfTUFQLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhIGxpc3Qgb2YgYWxsIHRoZSBjYWxsYmFja3Mgc2V0dXAgdmlhIE1vdXNldHJhcC5iaW5kKClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIF9jYWxsYmFja3MgPSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGlyZWN0IG1hcCBvZiBzdHJpbmcgY29tYmluYXRpb25zIHRvIGNhbGxiYWNrcyB1c2VkIGZvciB0cmlnZ2VyKClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIF9kaXJlY3RfbWFwID0ge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGtlZXBzIHRyYWNrIG9mIHdoYXQgbGV2ZWwgZWFjaCBzZXF1ZW5jZSBpcyBhdCBzaW5jZSBtdWx0aXBsZVxuICAgICAgICAgKiBzZXF1ZW5jZXMgY2FuIHN0YXJ0IG91dCB3aXRoIHRoZSBzYW1lIHNlcXVlbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBfc2VxdWVuY2VfbGV2ZWxzID0ge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBzZXRUaW1lb3V0IGNhbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bGx8bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3Jlc2V0X3RpbWVyLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0ZW1wb3Jhcnkgc3RhdGUgd2hlcmUgd2Ugd2lsbCBpZ25vcmUgdGhlIG5leHQga2V5dXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgX2lnbm9yZV9uZXh0X2tleXVwID0gZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFyZSB3ZSBjdXJyZW50bHkgaW5zaWRlIG9mIGEgc2VxdWVuY2U/XG4gICAgICAgICAqIHR5cGUgb2YgYWN0aW9uIChcImtleXVwXCIgb3IgXCJrZXlkb3duXCIgb3IgXCJrZXlwcmVzc1wiKSBvciBmYWxzZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBfaW5zaWRlX3NlcXVlbmNlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBsb29wIHRocm91Z2ggdGhlIGYga2V5cywgZjEgdG8gZjE5IGFuZCBhZGQgdGhlbSB0byB0aGUgbWFwXG4gICAgICogcHJvZ3JhbWF0aWNhbGx5XG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAyMDsgKytpKSB7XG4gICAgICAgIF9NQVBbMTExICsgaV0gPSAnZicgKyBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb3AgdGhyb3VnaCB0byBtYXAgbnVtYmVycyBvbiB0aGUgbnVtZXJpYyBrZXlwYWRcbiAgICAgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDw9IDk7ICsraSkge1xuICAgICAgICBfTUFQW2kgKyA5Nl0gPSBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyb3NzIGJyb3dzZXIgYWRkIGV2ZW50IG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEhUTUxEb2N1bWVudH0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYWRkRXZlbnQob2JqZWN0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAob2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3QuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyB0aGUgZXZlbnQgYW5kIHJldHVybnMgdGhlIGtleSBjaGFyYWN0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2NoYXJhY3RlckZyb21FdmVudChlKSB7XG5cbiAgICAgICAgLy8gZm9yIGtleXByZXNzIGV2ZW50cyB3ZSBzaG91bGQgcmV0dXJuIHRoZSBjaGFyYWN0ZXIgYXMgaXNcbiAgICAgICAgaWYgKGUudHlwZSA9PSAna2V5cHJlc3MnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBub24ga2V5cHJlc3MgZXZlbnRzIHRoZSBzcGVjaWFsIG1hcHMgYXJlIG5lZWRlZFxuICAgICAgICBpZiAoX01BUFtlLndoaWNoXSkge1xuICAgICAgICAgICAgcmV0dXJuIF9NQVBbZS53aGljaF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX0tFWUNPREVfTUFQW2Uud2hpY2hdKSB7XG4gICAgICAgICAgICByZXR1cm4gX0tFWUNPREVfTUFQW2Uud2hpY2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgbm90IGluIHRoZSBzcGVjaWFsIG1hcFxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiB0d28gYXJyYXlzIGFyZSBlcXVhbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzMVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyczJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbW9kaWZpZXJzTWF0Y2gobW9kaWZpZXJzMSwgbW9kaWZpZXJzMikge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzMS5zb3J0KCkuam9pbignLCcpID09PSBtb2RpZmllcnMyLnNvcnQoKS5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVzZXRzIGFsbCBzZXF1ZW5jZSBjb3VudGVycyBleGNlcHQgZm9yIHRoZSBvbmVzIHBhc3NlZCBpblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvX25vdF9yZXNldFxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcmVzZXRTZXF1ZW5jZXMoZG9fbm90X3Jlc2V0KSB7XG4gICAgICAgIGRvX25vdF9yZXNldCA9IGRvX25vdF9yZXNldCB8fCB7fTtcblxuICAgICAgICB2YXIgYWN0aXZlX3NlcXVlbmNlcyA9IGZhbHNlLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGZvciAoa2V5IGluIF9zZXF1ZW5jZV9sZXZlbHMpIHtcbiAgICAgICAgICAgIGlmIChkb19ub3RfcmVzZXRba2V5XSkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZV9zZXF1ZW5jZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3NlcXVlbmNlX2xldmVsc1trZXldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0aXZlX3NlcXVlbmNlcykge1xuICAgICAgICAgICAgX2luc2lkZV9zZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgYWxsIGNhbGxiYWNrcyB0aGF0IG1hdGNoIGJhc2VkIG9uIHRoZSBrZXljb2RlLCBtb2RpZmllcnMsXG4gICAgICogYW5kIGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7RXZlbnR8T2JqZWN0fSBlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVtb3ZlIC0gc2hvdWxkIHdlIHJlbW92ZSBhbnkgbWF0Y2hlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gY29tYmluYXRpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldE1hdGNoZXMoY2hhcmFjdGVyLCBtb2RpZmllcnMsIGUsIHJlbW92ZSwgY29tYmluYXRpb24pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgICAgICAgIGFjdGlvbiA9IGUudHlwZTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIHJlbGF0ZWQgdG8gdGhpcyBrZXljb2RlXG4gICAgICAgIGlmICghX2NhbGxiYWNrc1tjaGFyYWN0ZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIG1vZGlmaWVyIGtleSBpcyBjb21pbmcgdXAgb24gaXRzIG93biB3ZSBzaG91bGQgYWxsb3cgaXRcbiAgICAgICAgaWYgKGFjdGlvbiA9PSAna2V5dXAnICYmIF9pc01vZGlmaWVyKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycyA9IFtjaGFyYWN0ZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBrZXkgdGhhdCB3YXMgcHJlc3NlZFxuICAgICAgICAvLyBhbmQgc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfY2FsbGJhY2tzW2NoYXJhY3Rlcl0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gX2NhbGxiYWNrc1tjaGFyYWN0ZXJdW2ldO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgc2VxdWVuY2UgYnV0IGl0IGlzIG5vdCBhdCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgICAgICAgIC8vIHRoZW4gbW92ZSBvbnRvIHRoZSBuZXh0IG1hdGNoXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2suc2VxICYmIF9zZXF1ZW5jZV9sZXZlbHNbY2FsbGJhY2suc2VxXSAhPSBjYWxsYmFjay5sZXZlbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgYWN0aW9uIHdlIGFyZSBsb29raW5nIGZvciBkb2Vzbid0IG1hdGNoIHRoZSBhY3Rpb24gd2UgZ290XG4gICAgICAgICAgICAvLyB0aGVuIHdlIHNob3VsZCBrZWVwIGdvaW5nXG4gICAgICAgICAgICBpZiAoYWN0aW9uICE9IGNhbGxiYWNrLmFjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEga2V5cHJlc3MgZXZlbnQgYW5kIHRoZSBtZXRhIGtleSBhbmQgY29udHJvbCBrZXlcbiAgICAgICAgICAgIC8vIGFyZSBub3QgcHJlc3NlZCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBvbmx5IGxvb2sgYXQgdGhlXG4gICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG90aGVyd2lzZSBjaGVjayB0aGUgbW9kaWZpZXJzIGFzIHdlbGxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBjaHJvbWUgd2lsbCBub3QgZmlyZSBhIGtleXByZXNzIGlmIG1ldGEgb3IgY29udHJvbCBpcyBkb3duXG4gICAgICAgICAgICAvLyBzYWZhcmkgd2lsbCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBtZXRhK3NoaWZ0IGlzIGRvd25cbiAgICAgICAgICAgIC8vIGZpcmVmb3ggd2lsbCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBjb250cm9sIGlzIGRvd25cbiAgICAgICAgICAgIGlmICgoYWN0aW9uID09ICdrZXlwcmVzcycgJiYgIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5KSB8fCBfbW9kaWZpZXJzTWF0Y2gobW9kaWZpZXJzLCBjYWxsYmFjay5tb2RpZmllcnMpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgaXMgdXNlZCBzbyBpZiB5b3UgY2hhbmdlIHlvdXIgbWluZCBhbmQgY2FsbCBiaW5kIGFcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmQgdGltZSB3aXRoIGEgbmV3IGZ1bmN0aW9uIHRoZSBmaXJzdCBvbmUgaXMgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlICYmIGNhbGxiYWNrLmNvbWJvID09IGNvbWJpbmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFja3NbY2hhcmFjdGVyXS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRha2VzIGEga2V5IGV2ZW50IGFuZCBmaWd1cmVzIG91dCB3aGF0IHRoZSBtb2RpZmllcnMgYXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9ldmVudE1vZGlmaWVycyhlKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSBbXTtcblxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3NoaWZ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdhbHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdjdHJsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnbWV0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhY3R1YWxseSBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIGlmIHlvdXIgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSB0aGlzIHdpbGwgdXNlIHRoZSBqcXVlcnlcbiAgICAgKiBjb252ZW50aW9uIC0gcHJldmVudCBkZWZhdWx0IGFuZCBzdG9wIHByb3BvZ2F0aW9uIG9uIHRoZSBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhhbmRsZXMgYSBjaGFyYWN0ZXIga2V5IGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaGFuZGxlQ2hhcmFjdGVyKGNoYXJhY3RlciwgZSkge1xuXG4gICAgICAgIC8vIGlmIHRoaXMgZXZlbnQgc2hvdWxkIG5vdCBoYXBwZW4gc3RvcCBoZXJlXG4gICAgICAgIGlmIChNb3VzZXRyYXAuc3RvcENhbGxiYWNrKGUsIGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFja3MgPSBfZ2V0TWF0Y2hlcyhjaGFyYWN0ZXIsIF9ldmVudE1vZGlmaWVycyhlKSwgZSksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgZG9fbm90X3Jlc2V0ID0ge30sXG4gICAgICAgICAgICBwcm9jZXNzZWRfc2VxdWVuY2VfY2FsbGJhY2sgPSBmYWxzZTtcblxuICAgICAgICAvLyBsb29wIHRocm91Z2ggbWF0Y2hpbmcgY2FsbGJhY2tzIGZvciB0aGlzIGtleSBldmVudFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgZm9yIGFsbCBzZXF1ZW5jZSBjYWxsYmFja3NcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBpZiBmb3IgZXhhbXBsZSB5b3UgaGF2ZSBtdWx0aXBsZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vIGJvdW5kIHN1Y2ggYXMgXCJnIGlcIiBhbmQgXCJnIHRcIiB0aGV5IGJvdGggbmVlZCB0byBmaXJlIHRoZVxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgZm9yIG1hdGNoaW5nIGcgY2F1c2Ugb3RoZXJ3aXNlIHlvdSBjYW4gb25seSBldmVyXG4gICAgICAgICAgICAvLyBtYXRjaCB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLnNlcSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZF9zZXF1ZW5jZV9jYWxsYmFjayA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBrZWVwIGEgbGlzdCBvZiB3aGljaCBzZXF1ZW5jZXMgd2VyZSBtYXRjaGVzIGZvciBsYXRlclxuICAgICAgICAgICAgICAgIGRvX25vdF9yZXNldFtjYWxsYmFja3NbaV0uc2VxXSA9IDE7XG4gICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFja3NbaV0uY2FsbGJhY2ssIGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3ZXJlIG5vIHNlcXVlbmNlIG1hdGNoZXMgYnV0IHdlIGFyZSBzdGlsbCBoZXJlXG4gICAgICAgICAgICAvLyB0aGF0IG1lYW5zIHRoaXMgaXMgYSByZWd1bGFyIG1hdGNoIHNvIHdlIHNob3VsZCBmaXJlIHRoYXRcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkX3NlcXVlbmNlX2NhbGxiYWNrICYmICFfaW5zaWRlX3NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFja3NbaV0uY2FsbGJhY2ssIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgeW91IGFyZSBpbnNpZGUgb2YgYSBzZXF1ZW5jZSBhbmQgdGhlIGtleSB5b3UgYXJlIHByZXNzaW5nXG4gICAgICAgIC8vIGlzIG5vdCBhIG1vZGlmaWVyIGtleSB0aGVuIHdlIHNob3VsZCByZXNldCBhbGwgc2VxdWVuY2VzXG4gICAgICAgIC8vIHRoYXQgd2VyZSBub3QgbWF0Y2hlZCBieSB0aGlzIGtleSBldmVudFxuICAgICAgICBpZiAoZS50eXBlID09IF9pbnNpZGVfc2VxdWVuY2UgJiYgIV9pc01vZGlmaWVyKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIF9yZXNldFNlcXVlbmNlcyhkb19ub3RfcmVzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlcyBhIGtleWRvd24gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2hhbmRsZUtleShlKSB7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGUud2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyODU2MjcvamF2YXNjcmlwdC1rZXljb2RlLXZzLWNoYXJjb2RlLXV0dGVyLWNvbmZ1c2lvblxuICAgICAgICBlLndoaWNoID0gdHlwZW9mIGUud2hpY2ggPT0gXCJudW1iZXJcIiA/IGUud2hpY2ggOiBlLmtleUNvZGU7XG5cbiAgICAgICAgdmFyIGNoYXJhY3RlciA9IF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSk7XG5cbiAgICAgICAgLy8gbm8gY2hhcmFjdGVyIGZvdW5kIHRoZW4gc3RvcFxuICAgICAgICBpZiAoIWNoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PSAna2V5dXAnICYmIF9pZ25vcmVfbmV4dF9rZXl1cCA9PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIF9pZ25vcmVfbmV4dF9rZXl1cCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX2hhbmRsZUNoYXJhY3RlcihjaGFyYWN0ZXIsIGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZXMgaWYgdGhlIGtleWNvZGUgc3BlY2lmaWVkIGlzIGEgbW9kaWZpZXIga2V5IG9yIG5vdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9pc01vZGlmaWVyKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzaGlmdCcgfHwga2V5ID09ICdjdHJsJyB8fCBrZXkgPT0gJ2FsdCcgfHwga2V5ID09ICdtZXRhJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgdG8gc2V0IGEgMSBzZWNvbmQgdGltZW91dCBvbiB0aGUgc3BlY2lmaWVkIHNlcXVlbmNlXG4gICAgICpcbiAgICAgKiB0aGlzIGlzIHNvIGFmdGVyIGVhY2gga2V5IHByZXNzIGluIHRoZSBzZXF1ZW5jZSB5b3UgaGF2ZSAxIHNlY29uZFxuICAgICAqIHRvIHByZXNzIHRoZSBuZXh0IGtleSBiZWZvcmUgeW91IGhhdmUgdG8gc3RhcnQgb3ZlclxuICAgICAqXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9yZXNldFNlcXVlbmNlVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChfcmVzZXRfdGltZXIpO1xuICAgICAgICBfcmVzZXRfdGltZXIgPSBzZXRUaW1lb3V0KF9yZXNldFNlcXVlbmNlcywgMTAwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV2ZXJzZXMgdGhlIG1hcCBsb29rdXAgc28gdGhhdCB3ZSBjYW4gbG9vayBmb3Igc3BlY2lmaWMga2V5c1xuICAgICAqIHRvIHNlZSB3aGF0IGNhbiBhbmQgY2FuJ3QgdXNlIGtleXByZXNzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldFJldmVyc2VNYXAoKSB7XG4gICAgICAgIGlmICghX1JFVkVSU0VfTUFQKSB7XG4gICAgICAgICAgICBfUkVWRVJTRV9NQVAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBfTUFQKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBwdWxsIG91dCB0aGUgbnVtZXJpYyBrZXlwYWQgZnJvbSBoZXJlIGNhdXNlIGtleXByZXNzIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIGJlIGFibGUgdG8gZGV0ZWN0IHRoZSBrZXlzIGZyb20gdGhlIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPiA5NSAmJiBrZXkgPCAxMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9NQVAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBfUkVWRVJTRV9NQVBbX01BUFtrZXldXSA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9SRVZFUlNFX01BUDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwaWNrcyB0aGUgYmVzdCBhY3Rpb24gYmFzZWQgb24gdGhlIGtleSBjb21iaW5hdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGNoYXJhY3RlciBmb3Iga2V5XG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb24gcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3BpY2tCZXN0QWN0aW9uKGtleSwgbW9kaWZpZXJzLCBhY3Rpb24pIHtcblxuICAgICAgICAvLyBpZiBubyBhY3Rpb24gd2FzIHBpY2tlZCBpbiB3ZSBzaG91bGQgdHJ5IHRvIHBpY2sgdGhlIG9uZVxuICAgICAgICAvLyB0aGF0IHdlIHRoaW5rIHdvdWxkIHdvcmsgYmVzdCBmb3IgdGhpcyBrZXlcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IF9nZXRSZXZlcnNlTWFwKClba2V5XSA/ICdrZXlkb3duJyA6ICdrZXlwcmVzcyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb2RpZmllciBrZXlzIGRvbid0IHdvcmsgYXMgZXhwZWN0ZWQgd2l0aCBrZXlwcmVzcyxcbiAgICAgICAgLy8gc3dpdGNoIHRvIGtleWRvd25cbiAgICAgICAgaWYgKGFjdGlvbiA9PSAna2V5cHJlc3MnICYmIG1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9ICdrZXlkb3duJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmluZHMgYSBrZXkgc2VxdWVuY2UgdG8gYW4gZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21ibyAtIGNvbWJvIHNwZWNpZmllZCBpbiBiaW5kIGNhbGxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYmluZFNlcXVlbmNlKGNvbWJvLCBrZXlzLCBjYWxsYmFjaywgYWN0aW9uKSB7XG5cbiAgICAgICAgLy8gc3RhcnQgb2ZmIGJ5IGFkZGluZyBhIHNlcXVlbmNlIGxldmVsIHJlY29yZCBmb3IgdGhpcyBjb21iaW5hdGlvblxuICAgICAgICAvLyBhbmQgc2V0dGluZyB0aGUgbGV2ZWwgdG8gMFxuICAgICAgICBfc2VxdWVuY2VfbGV2ZWxzW2NvbWJvXSA9IDA7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYWN0aW9uIHBpY2sgdGhlIGJlc3Qgb25lIGZvciB0aGUgZmlyc3Qga2V5XG4gICAgICAgIC8vIGluIHRoZSBzZXF1ZW5jZVxuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uID0gX3BpY2tCZXN0QWN0aW9uKGtleXNbMF0sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjYWxsYmFjayB0byBpbmNyZWFzZSB0aGUgc2VxdWVuY2UgbGV2ZWwgZm9yIHRoaXMgc2VxdWVuY2UgYW5kIHJlc2V0XG4gICAgICAgICAqIGFsbCBvdGhlciBzZXF1ZW5jZXMgdGhhdCB3ZXJlIGFjdGl2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfaW5jcmVhc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBfaW5zaWRlX3NlcXVlbmNlID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgICsrX3NlcXVlbmNlX2xldmVsc1tjb21ib107XG4gICAgICAgICAgICAgICAgX3Jlc2V0U2VxdWVuY2VUaW1lcigpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB3cmFwcyB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uIGluIG9yZGVyXG4gICAgICAgICAgICAgKiB0byByZXNldCBhbGwgc2VxdWVuY2UgY291bnRlcnMgYXMgc29vbiBhcyB0aGlzIHNlcXVlbmNlIGlzIGRvbmVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF9jYWxsYmFja0FuZFJlc2V0ID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgbmV4dCBrZXkgdXAgaWYgdGhlIGFjdGlvbiBpcyBrZXkgZG93blxuICAgICAgICAgICAgICAgIC8vIG9yIGtleXByZXNzLiAgdGhpcyBpcyBzbyBpZiB5b3UgZmluaXNoIGEgc2VxdWVuY2UgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSB0aGUga2V5IHRoZSBmaW5hbCBrZXkgd2lsbCBub3QgdHJpZ2dlciBhIGtleXVwXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgICAgICBfaWdub3JlX25leHRfa2V5dXAgPSBfY2hhcmFjdGVyRnJvbUV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHdlaXJkIHJhY2UgY29uZGl0aW9uIGlmIGEgc2VxdWVuY2UgZW5kcyB3aXRoIHRoZSBrZXlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIHNlcXVlbmNlIGJlZ2lucyB3aXRoXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChfcmVzZXRTZXF1ZW5jZXMsIDEwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBrZXlzIG9uZSBhdCBhIHRpbWUgYW5kIGJpbmQgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrXG4gICAgICAgIC8vIGZ1bmN0aW9uLiAgZm9yIGFueSBrZXkgbGVhZGluZyB1cCB0byB0aGUgZmluYWwgb25lIGl0IHNob3VsZFxuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2VxdWVuY2UuIGFmdGVyIHRoZSBmaW5hbCwgaXQgc2hvdWxkIHJlc2V0IGFsbCBzZXF1ZW5jZXNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIF9iaW5kU2luZ2xlKGtleXNbaV0sIGkgPCBrZXlzLmxlbmd0aCAtIDEgPyBfaW5jcmVhc2VTZXF1ZW5jZSA6IF9jYWxsYmFja0FuZFJlc2V0LCBhY3Rpb24sIGNvbWJvLCBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmRzIGEgc2luZ2xlIGtleWJvYXJkIGNvbWJpbmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tYmluYXRpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZXF1ZW5jZV9uYW1lIC0gbmFtZSBvZiBzZXF1ZW5jZSBpZiBwYXJ0IG9mIHNlcXVlbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBsZXZlbCAtIHdoYXQgcGFydCBvZiB0aGUgc2VxdWVuY2UgdGhlIGNvbW1hbmQgaXNcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2JpbmRTaW5nbGUoY29tYmluYXRpb24sIGNhbGxiYWNrLCBhY3Rpb24sIHNlcXVlbmNlX25hbWUsIGxldmVsKSB7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIG11bHRpcGxlIHNwYWNlcyBpbiBhIHJvdyBiZWNvbWUgYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgY29tYmluYXRpb24gPSBjb21iaW5hdGlvbi5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG5cbiAgICAgICAgdmFyIHNlcXVlbmNlID0gY29tYmluYXRpb24uc3BsaXQoJyAnKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgbW9kaWZpZXJzID0gW107XG5cbiAgICAgICAgLy8gaWYgdGhpcyBwYXR0ZXJuIGlzIGEgc2VxdWVuY2Ugb2Yga2V5cyB0aGVuIHJ1biB0aHJvdWdoIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIHRvIHJlcHJvY2VzcyBlYWNoIHBhdHRlcm4gb25lIGtleSBhdCBhIHRpbWVcbiAgICAgICAgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIF9iaW5kU2VxdWVuY2UoY29tYmluYXRpb24sIHNlcXVlbmNlLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRha2UgdGhlIGtleXMgZnJvbSB0aGlzIHBhdHRlcm4gYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgYWN0dWFsXG4gICAgICAgIC8vIHBhdHRlcm4gaXMgYWxsIGFib3V0XG4gICAgICAgIGtleXMgPSBjb21iaW5hdGlvbiA9PT0gJysnID8gWycrJ10gOiBjb21iaW5hdGlvbi5zcGxpdCgnKycpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICAvLyBub3JtYWxpemUga2V5IG5hbWVzXG4gICAgICAgICAgICBpZiAoX1NQRUNJQUxfQUxJQVNFU1trZXldKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gX1NQRUNJQUxfQUxJQVNFU1trZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGtleXByZXNzIGV2ZW50IHRoZW4gd2Ugc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSBzbWFydCBhYm91dCB1c2luZyBzaGlmdCBrZXlzXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgb25seSB3b3JrIGZvciBVUyBrZXlib2FyZHMgaG93ZXZlclxuICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24gIT0gJ2tleXByZXNzJyAmJiBfU0hJRlRfTUFQW2tleV0pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBfU0hJRlRfTUFQW2tleV07XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3NoaWZ0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMga2V5IGlzIGEgbW9kaWZpZXIgdGhlbiBhZGQgaXQgdG8gdGhlIGxpc3Qgb2YgbW9kaWZpZXJzXG4gICAgICAgICAgICBpZiAoX2lzTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gd2hhdCB0aGUga2V5IGNvbWJpbmF0aW9uIGlzXG4gICAgICAgIC8vIHdlIHdpbGwgdHJ5IHRvIHBpY2sgdGhlIGJlc3QgZXZlbnQgZm9yIGl0XG4gICAgICAgIGFjdGlvbiA9IF9waWNrQmVzdEFjdGlvbihrZXksIG1vZGlmaWVycywgYWN0aW9uKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW5pdGlhbGl6ZSBhcnJheSBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIC8vIGEgY2FsbGJhY2sgaXMgYWRkZWQgZm9yIHRoaXMga2V5XG4gICAgICAgIGlmICghX2NhbGxiYWNrc1trZXldKSB7XG4gICAgICAgICAgICBfY2FsbGJhY2tzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBhbiBleGlzdGluZyBtYXRjaCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgX2dldE1hdGNoZXMoa2V5LCBtb2RpZmllcnMsIHt0eXBlOiBhY3Rpb259LCAhc2VxdWVuY2VfbmFtZSwgY29tYmluYXRpb24pO1xuXG4gICAgICAgIC8vIGFkZCB0aGlzIGNhbGwgYmFjayB0byB0aGUgYXJyYXlcbiAgICAgICAgLy8gaWYgaXQgaXMgYSBzZXF1ZW5jZSBwdXQgaXQgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAvLyBpZiBub3QgcHV0IGl0IGF0IHRoZSBlbmRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgd2F5IHRoZXNlIGFyZSBwcm9jZXNzZWQgZXhwZWN0c1xuICAgICAgICAvLyB0aGUgc2VxdWVuY2Ugb25lcyB0byBjb21lIGZpcnN0XG4gICAgICAgIF9jYWxsYmFja3Nba2V5XVtzZXF1ZW5jZV9uYW1lID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXSh7XG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgc2VxOiBzZXF1ZW5jZV9uYW1lLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgY29tYm86IGNvbWJpbmF0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmRzIG11bHRpcGxlIGNvbWJpbmF0aW9ucyB0byB0aGUgc2FtZSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29tYmluYXRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYmluZE11bHRpcGxlKGNvbWJpbmF0aW9ucywgY2FsbGJhY2ssIGFjdGlvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbWJpbmF0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX2JpbmRTaW5nbGUoY29tYmluYXRpb25zW2ldLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0YXJ0IVxuICAgIF9hZGRFdmVudChkb2N1bWVudCwgJ2tleXByZXNzJywgX2hhbmRsZUtleSk7XG4gICAgX2FkZEV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicsIF9oYW5kbGVLZXkpO1xuICAgIF9hZGRFdmVudChkb2N1bWVudCwgJ2tleXVwJywgX2hhbmRsZUtleSk7XG5cbiAgICB2YXIgTW91c2V0cmFwID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBhbiBldmVudCB0byBtb3VzZXRyYXBcbiAgICAgICAgICpcbiAgICAgICAgICogY2FuIGJlIGEgc2luZ2xlIGtleSwgYSBjb21iaW5hdGlvbiBvZiBrZXlzIHNlcGFyYXRlZCB3aXRoICssXG4gICAgICAgICAqIGFuIGFycmF5IG9mIGtleXMsIG9yIGEgc2VxdWVuY2Ugb2Yga2V5cyBzZXBhcmF0ZWQgYnkgc3BhY2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIGJlIHN1cmUgdG8gbGlzdCB0aGUgbW9kaWZpZXIga2V5cyBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgICAgICogY29ycmVjdCBrZXkgZW5kcyB1cCBnZXR0aW5nIGJvdW5kICh0aGUgbGFzdCBrZXkgaW4gdGhlIHBhdHRlcm4pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uIC0gJ2tleXByZXNzJywgJ2tleWRvd24nLCBvciAna2V5dXAnXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIF9iaW5kTXVsdGlwbGUoa2V5cyBpbnN0YW5jZW9mIEFycmF5ID8ga2V5cyA6IFtrZXlzXSwgY2FsbGJhY2ssIGFjdGlvbik7XG4gICAgICAgICAgICBfZGlyZWN0X21hcFtrZXlzICsgJzonICsgYWN0aW9uXSA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuYmluZHMgYW4gZXZlbnQgdG8gbW91c2V0cmFwXG4gICAgICAgICAqXG4gICAgICAgICAqIHRoZSB1bmJpbmRpbmcgc2V0cyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIHNwZWNpZmllZCBrZXkgY29tYm9cbiAgICAgICAgICogdG8gYW4gZW1wdHkgZnVuY3Rpb24gYW5kIGRlbGV0ZXMgdGhlIGNvcnJlc3BvbmRpbmcga2V5IGluIHRoZVxuICAgICAgICAgKiBfZGlyZWN0X21hcCBkaWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGUga2V5Y29tYm8rYWN0aW9uIGhhcyB0byBiZSBleGFjdGx5IHRoZSBzYW1lIGFzXG4gICAgICAgICAqIGl0IHdhcyBkZWZpbmVkIGluIHRoZSBiaW5kIG1ldGhvZFxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBhY3R1YWxseSByZW1vdmUgdGhpcyBmcm9tIHRoZSBfY2FsbGJhY2tzIGRpY3Rpb25hcnkgaW5zdGVhZFxuICAgICAgICAgKiBvZiBiaW5kaW5nIGFuIGVtcHR5IGZ1bmN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbihrZXlzLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChfZGlyZWN0X21hcFtrZXlzICsgJzonICsgYWN0aW9uXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfZGlyZWN0X21hcFtrZXlzICsgJzonICsgYWN0aW9uXTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmQoa2V5cywgZnVuY3Rpb24oKSB7fSwgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cmlnZ2VycyBhbiBldmVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oa2V5cywgYWN0aW9uKSB7XG4gICAgICAgICAgICBfZGlyZWN0X21hcFtrZXlzICsgJzonICsgYWN0aW9uXSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlc2V0cyB0aGUgbGlicmFyeSBiYWNrIHRvIGl0cyBpbml0aWFsIHN0YXRlLiAgdGhpcyBpcyB1c2VmdWxcbiAgICAgICAgICogaWYgeW91IHdhbnQgdG8gY2xlYXIgb3V0IHRoZSBjdXJyZW50IGtleWJvYXJkIHNob3J0Y3V0cyBhbmQgYmluZFxuICAgICAgICAgKiBuZXcgb25lcyAtIGZvciBleGFtcGxlIGlmIHlvdSBzd2l0Y2ggdG8gYW5vdGhlciBwYWdlXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgICAgIF9kaXJlY3RfbWFwID0ge307XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICAqIHNob3VsZCB3ZSBzdG9wIHRoaXMgZXZlbnQgYmVmb3JlIGZpcmluZyBvZmYgY2FsbGJhY2tzXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgKi9cbiAgICAgICAgc3RvcENhbGxiYWNrOiBmdW5jdGlvbihlLCBlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdG9wIGZvciBpbnB1dCwgc2VsZWN0LCBhbmQgdGV4dGFyZWFcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT0gJ0lOUFVUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT0gJ1NFTEVDVCcgfHwgZWxlbWVudC50YWdOYW1lID09ICdURVhUQVJFQScgfHwgKGVsZW1lbnQuY29udGVudEVkaXRhYmxlICYmIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID09ICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXhwb3NlIG1vdXNldHJhcCB0byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIHdpbmRvdy5Nb3VzZXRyYXAgPSBNb3VzZXRyYXA7XG5cbiAgICAvLyBleHBvc2UgbW91c2V0cmFwIGFzIGFuIEFNRCBtb2R1bGVcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdtb3VzZXRyYXAnLCBmdW5jdGlvbigpIHsgcmV0dXJuIE1vdXNldHJhcDsgfSk7XG4gICAgfVxuICAgIC8vIGJyb3dzZXJpZnkgc3VwcG9ydFxuICAgIGlmKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gTW91c2V0cmFwO1xuICAgIH1cbn0pICgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ3Jvc3NWYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtOZXVyYWxOZXR3b3JrfGNvbnN0cnVjdG9yfSBDbGFzc2lmaWVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGZ1bmN0aW9uIENyb3NzVmFsaWRhdGUoQ2xhc3NpZmllciwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDcm9zc1ZhbGlkYXRlKTtcblxuICAgIHRoaXMuQ2xhc3NpZmllciA9IENsYXNzaWZpZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmpzb24gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0cmFpbk9wdHNcbiAgICogQHBhcmFtIHtvYmplY3R9IHRyYWluU2V0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0ZXN0U2V0XG4gICAqIEByZXR1cm5zIHt2b2lkfCp9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKENyb3NzVmFsaWRhdGUsIFt7XG4gICAga2V5OiAndGVzdFBhcnRpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3RQYXJ0aXRpb24odHJhaW5PcHRzLCB0cmFpblNldCwgdGVzdFNldCkge1xuICAgICAgdmFyIGNsYXNzaWZpZXIgPSBuZXcgdGhpcy5DbGFzc2lmaWVyKHRoaXMub3B0aW9ucyk7XG4gICAgICB2YXIgYmVnaW5UcmFpbiA9IERhdGUubm93KCk7XG4gICAgICB2YXIgdHJhaW5pbmdTdGF0cyA9IGNsYXNzaWZpZXIudHJhaW4odHJhaW5TZXQsIHRyYWluT3B0cyk7XG4gICAgICB2YXIgYmVnaW5UZXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHZhciB0ZXN0U3RhdHMgPSBjbGFzc2lmaWVyLnRlc3QodGVzdFNldCk7XG4gICAgICB2YXIgZW5kVGVzdCA9IERhdGUubm93KCk7XG4gICAgICB2YXIgc3RhdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0ZXN0U3RhdHMsIHtcbiAgICAgICAgdHJhaW5UaW1lOiBiZWdpblRlc3QgLSBiZWdpblRyYWluLFxuICAgICAgICB0ZXN0VGltZTogZW5kVGVzdCAtIGJlZ2luVGVzdCxcbiAgICAgICAgaXRlcmF0aW9uczogdHJhaW5pbmdTdGF0cy5pdGVyYXRpb25zLFxuICAgICAgICBlcnJvcjogdHJhaW5pbmdTdGF0cy5lcnJvcixcbiAgICAgICAgdG90YWw6IHRlc3RTdGF0cy50b3RhbCxcbiAgICAgICAgbGVhcm5pbmdSYXRlOiBjbGFzc2lmaWVyLnRyYWluT3B0cy5sZWFybmluZ1JhdGUsXG4gICAgICAgIGhpZGRlbkxheWVyczogY2xhc3NpZmllci5oaWRkZW5MYXllcnMsXG4gICAgICAgIG5ldHdvcms6IGNsYXNzaWZpZXIudG9KU09OKClcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmFuZG9taXplIGFycmF5IGVsZW1lbnQgb3JkZXIgaW4tcGxhY2UuXG4gICAgICogVXNpbmcgRHVyc3RlbmZlbGQgc2h1ZmZsZSBhbGdvcml0aG0uXG4gICAgICogc291cmNlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjY0Njg2NC8xMzI0MDM5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NodWZmbGVBcnJheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNodWZmbGVBcnJheShhcnJheSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgdmFyIHRlbXAgPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgYXJyYXlbal0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdHJhaW5PcHRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtrXVxuICAgICAqIEByZXR1cm5zIHtcbiAgICAgKiAge1xuICAgICAqICAgIGF2Z3M6IHtcbiAgICAgKiAgICAgIGVycm9yOiBudW1iZXIsXG4gICAgICogICAgICB0cmFpblRpbWU6IG51bWJlcixcbiAgICAgKiAgICAgIHRlc3RUaW1lOiBudW1iZXIsXG4gICAgICogICAgICBpdGVyYXRpb25zOiBudW1iZXIsXG4gICAgICogICAgICBlcnJvcjogbnVtYmVyXG4gICAgICogICAgfSxcbiAgICAgKiAgICBzdGF0czoge1xuICAgICAqICAgICAgdHJ1ZVBvczogbnVtYmVyLFxuICAgICAqICAgICAgdHJ1ZU5lZzogbnVtYmVyLFxuICAgICAqICAgICAgZmFsc2VQb3M6IG51bWJlcixcbiAgICAgKiAgICAgIGZhbHNlTmVnOiBudW1iZXIsXG4gICAgICogICAgICB0b3RhbDogbnVtYmVyXG4gICAgICogICAgfSxcbiAgICAgKiAgICBzZXRzOiBBcnJheVxuICAgICAqICB9XG4gICAgICogfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0cmFpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWluKGRhdGEpIHtcbiAgICAgIHZhciB0cmFpbk9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGsgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDQ7XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA8IGspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFpbmluZyBzZXQgc2l6ZSBpcyB0b28gc21hbGwgZm9yICcgKyBkYXRhLmxlbmd0aCArICcgayBmb2xkcyBvZiAnICsgayk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplID0gZGF0YS5sZW5ndGggLyBrO1xuXG4gICAgICBpZiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgdGhpcy5zaHVmZmxlQXJyYXkoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgICB0aGlzLnNodWZmbGVBcnJheShPYmplY3Qua2V5cyhkYXRhKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgbmV3RGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YSA9IG5ld0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdmdzID0ge1xuICAgICAgICB0cmFpblRpbWU6IDAsXG4gICAgICAgIHRlc3RUaW1lOiAwLFxuICAgICAgICBpdGVyYXRpb25zOiAwLFxuICAgICAgICBlcnJvcjogMFxuICAgICAgfTtcblxuICAgICAgdmFyIHN0YXRzID0ge1xuICAgICAgICB0b3RhbDogMFxuICAgICAgfTtcblxuICAgICAgdmFyIGJpbmFyeVN0YXRzID0ge1xuICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgdHJ1ZVBvczogMCxcbiAgICAgICAgdHJ1ZU5lZzogMCxcbiAgICAgICAgZmFsc2VQb3M6IDAsXG4gICAgICAgIGZhbHNlTmVnOiAwXG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgdmFyIHN0YXQgPSB2b2lkIDA7XG4gICAgICB2YXIgaXNCaW5hcnkgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICB2YXIgZGNsb25lID0gZGF0YS5zbGljZSgwKTtcbiAgICAgICAgdmFyIHRlc3RTZXQgPSBkY2xvbmUuc3BsaWNlKGkgKiBzaXplLCBzaXplKTtcbiAgICAgICAgdmFyIHRyYWluU2V0ID0gZGNsb25lO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50ZXN0UGFydGl0aW9uKHRyYWluT3B0cywgdHJhaW5TZXQsIHRlc3RTZXQpO1xuXG4gICAgICAgIGlmIChpc0JpbmFyeSA9PT0gbnVsbCkge1xuICAgICAgICAgIGlzQmluYXJ5ID0gcmVzdWx0Lmhhc093blByb3BlcnR5KCdmYWxzZU5lZycpICYmIHJlc3VsdC5oYXNPd25Qcm9wZXJ0eSgnZmFsc2VQb3MnKSAmJiByZXN1bHQuaGFzT3duUHJvcGVydHkoJ3RydWVOZWcnKSAmJiByZXN1bHQuaGFzT3duUHJvcGVydHkoJ3RydWVQb3MnKTtcbiAgICAgICAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3RhdHMsIGJpbmFyeVN0YXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHN0YXQgaW4gYXZncykge1xuICAgICAgICAgIGlmIChzdGF0IGluIGF2Z3MpIHtcbiAgICAgICAgICAgIGF2Z3Nbc3RhdF0gKz0gcmVzdWx0W3N0YXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoc3RhdCBpbiBzdGF0cykge1xuICAgICAgICAgIGlmIChzdGF0IGluIHN0YXRzKSB7XG4gICAgICAgICAgICBzdGF0c1tzdGF0XSArPSByZXN1bHRbc3RhdF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoc3RhdCBpbiBhdmdzKSB7XG4gICAgICAgIGlmIChzdGF0IGluIGF2Z3MpIHtcbiAgICAgICAgICBhdmdzW3N0YXRdIC89IGs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgIHN0YXRzLnByZWNpc2lvbiA9IHN0YXRzLnRydWVQb3MgLyAoc3RhdHMudHJ1ZVBvcyArIHN0YXRzLmZhbHNlUG9zKTtcbiAgICAgICAgc3RhdHMucmVjYWxsID0gc3RhdHMudHJ1ZVBvcyAvIChzdGF0cy50cnVlUG9zICsgc3RhdHMuZmFsc2VOZWcpO1xuICAgICAgICBzdGF0cy5hY2N1cmFjeSA9IChzdGF0cy50cnVlTmVnICsgc3RhdHMudHJ1ZVBvcykgLyBzdGF0cy50b3RhbDtcbiAgICAgIH1cblxuICAgICAgc3RhdHMudGVzdFNpemUgPSBzaXplO1xuICAgICAgc3RhdHMudHJhaW5TaXplID0gZGF0YS5sZW5ndGggLSBzaXplO1xuXG4gICAgICByZXR1cm4gdGhpcy5qc29uID0ge1xuICAgICAgICBhdmdzOiBhdmdzLFxuICAgICAgICBzdGF0czogc3RhdHMsXG4gICAgICAgIHNldHM6IHJlc3VsdHNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9OZXVyYWxOZXR3b3JrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9OZXVyYWxOZXR3b3JrKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbUpTT04odGhpcy5qc29uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5qc29uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zyb21KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oY3Jvc3NWYWxpZGF0ZUpzb24pIHtcbiAgICAgIHZhciBDbGFzc2lmaWVyID0gdGhpcy5DbGFzc2lmaWVyO1xuICAgICAgdmFyIGpzb24gPSBjcm9zc1ZhbGlkYXRlSnNvbi5zZXRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiBwcmV2LmVycm9yIDwgY3VyLmVycm9yID8gcHJldiA6IGN1cjtcbiAgICAgIH0sIHsgZXJyb3I6IEluZmluaXR5IH0pLm5ldHdvcms7XG4gICAgICBpZiAoQ2xhc3NpZmllci5mcm9tSlNPTikge1xuICAgICAgICByZXR1cm4gQ2xhc3NpZmllci5mcm9tSlNPTihqc29uKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDbGFzc2lmaWVyKCk7XG4gICAgICBpbnN0YW5jZS5mcm9tSlNPTihqc29uKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3Jvc3NWYWxpZGF0ZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ3Jvc3NWYWxpZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyb3NzLXZhbGlkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbGlrZWx5O1xuLyoqXG4gKlxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHBhcmFtIHticmFpbi5OZXVyYWxOZXR3b3JrfSBuZXRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBsaWtlbHkoaW5wdXQsIG5ldCkge1xuICB2YXIgb3V0cHV0ID0gbmV0LnJ1bihpbnB1dCk7XG4gIHZhciBtYXhQcm9wID0gbnVsbDtcbiAgdmFyIG1heFZhbHVlID0gLTE7XG4gIGZvciAodmFyIHByb3AgaW4gb3V0cHV0KSB7XG4gICAgdmFyIHZhbHVlID0gb3V0cHV0W3Byb3BdO1xuICAgIGlmICh2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICBtYXhQcm9wID0gcHJvcDtcbiAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhQcm9wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlrZWx5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiBGdW5jdGlvbnMgZm9yIHR1cm5pbmcgc3BhcnNlIGhhc2hlcyBpbnRvIGFycmF5cyBhbmQgdmljZSB2ZXJzYSAqL1xudmFyIGxvb2t1cCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gbG9va3VwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBsb29rdXApO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKGxvb2t1cCwgbnVsbCwgW3tcbiAgICBrZXk6ICd0b1RhYmxlJyxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGBbe2E6IDF9LCB7YjogNiwgYzogN31dIC0+IHthOiAwLCBiOiAxLCBjOiAyfWBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaGVzXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9UYWJsZShoYXNoZXMpIHtcbiAgICAgIHZhciBoYXNoID0gaGFzaGVzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgaGFzaCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtZW1vLCBoYXNoKTtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgcmV0dXJuIGxvb2t1cC50b0hhc2goaGFzaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYFt7YTogMX0sIHtiOiA2LCBjOiA3fV0gLT4ge2E6IDAsIGI6IDEsIGM6IDJ9YFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzMkRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1RhYmxlMkQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1RhYmxlMkQob2JqZWN0czJEKSB7XG4gICAgICB2YXIgdGFibGUgPSB7fTtcbiAgICAgIHZhciB2YWx1ZUluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0czJELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gb2JqZWN0czJEW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tqXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwKSAmJiAhdGFibGUuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgdGFibGVbcF0gPSB2YWx1ZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9JbnB1dFRhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JbnB1dFRhYmxlKGRhdGEpIHtcbiAgICAgIHZhciB0YWJsZSA9IHt9O1xuICAgICAgdmFyIHRhYmxlSW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YS5sZW5ndGg7IGRhdGFJbmRleCsrKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gZGF0YVtkYXRhSW5kZXhdLmlucHV0KSB7XG4gICAgICAgICAgaWYgKCF0YWJsZS5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgdGFibGVbcF0gPSB0YWJsZUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9JbnB1dFRhYmxlMkQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0lucHV0VGFibGUyRChkYXRhKSB7XG4gICAgICB2YXIgdGFibGUgPSB7fTtcbiAgICAgIHZhciB0YWJsZUluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGRhdGFJbmRleCA9IDA7IGRhdGFJbmRleCA8IGRhdGEubGVuZ3RoOyBkYXRhSW5kZXgrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBkYXRhW2RhdGFJbmRleF0uaW5wdXQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gaW5wdXRbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghdGFibGUuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgdGFibGVbcF0gPSB0YWJsZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9PdXRwdXRUYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvT3V0cHV0VGFibGUoZGF0YSkge1xuICAgICAgdmFyIHRhYmxlID0ge307XG4gICAgICB2YXIgdGFibGVJbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBkYXRhSW5kZXggPSAwOyBkYXRhSW5kZXggPCBkYXRhLmxlbmd0aDsgZGF0YUluZGV4KyspIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBkYXRhW2RhdGFJbmRleF0ub3V0cHV0KSB7XG4gICAgICAgICAgaWYgKCF0YWJsZS5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgdGFibGVbcF0gPSB0YWJsZUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9PdXRwdXRUYWJsZTJEJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9PdXRwdXRUYWJsZTJEKGRhdGEpIHtcbiAgICAgIHZhciB0YWJsZSA9IHt9O1xuICAgICAgdmFyIHRhYmxlSW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgZGF0YUluZGV4ID0gMDsgZGF0YUluZGV4IDwgZGF0YS5sZW5ndGg7IGRhdGFJbmRleCsrKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBkYXRhW2RhdGFJbmRleF0ub3V0cHV0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBvdXRwdXRbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghdGFibGUuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgdGFibGVbcF0gPSB0YWJsZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGVyZm9ybXMgYHthOiA2LCBiOiA3fSAtPiB7YTogMCwgYjogMX1gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2hcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b0hhc2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hhc2goaGFzaCkge1xuICAgICAgdmFyIGxvb2t1cCA9IHt9O1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgaW4gaGFzaCkge1xuICAgICAgICBsb29rdXBbaV0gPSBpbmRleCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwZXJmb3JtcyBge2E6IDAsIGI6IDF9LCB7YTogNn0gLT4gWzYsIDBdYFxuICAgICAqIEBwYXJhbSB7Kn0gbG9va3VwXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3RcbiAgICAgKiBAcGFyYW0geyp9IGFycmF5TGVuZ3RoXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9BcnJheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkobG9va3VwLCBvYmplY3QsIGFycmF5TGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBwIGluIGxvb2t1cCkge1xuICAgICAgICByZXN1bHRbbG9va3VwW3BdXSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwKSA/IG9iamVjdFtwXSA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvQXJyYXlTaG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXlTaG9ydChsb29rdXAsIG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgcCBpbiBsb29rdXApIHtcbiAgICAgICAgaWYgKCFvYmplY3QuaGFzT3duUHJvcGVydHkocCkpIGJyZWFrO1xuICAgICAgICByZXN1bHRbbG9va3VwW3BdXSA9IG9iamVjdFtwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXkuZnJvbShyZXN1bHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvQXJyYXlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheXMobG9va3VwLCBvYmplY3RzLCBhcnJheUxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMudG9BcnJheShsb29rdXAsIG9iamVjdHNbaV0sIGFycmF5TGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBlcmZvcm1zIGB7YTogMCwgYjogMX0sIFs2LCA3XSAtPiB7YTogNiwgYjogN31gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvb2t1cFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9PYmplY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdChsb29rdXAsIGFycmF5KSB7XG4gICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGxvb2t1cCkge1xuICAgICAgICBvYmplY3RbcF0gPSBhcnJheVtsb29rdXBbcF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b09iamVjdFBhcnRpYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdFBhcnRpYWwobG9va3VwLCBhcnJheSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHZhciBsaW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcblxuICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgZm9yICh2YXIgcCBpbiBsb29rdXApIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICBpZiAoaSsrIDwgb2Zmc2V0KSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgaWYgKGkrKyA+PSBsaW1pdCkgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W3BdID0gYXJyYXlbbG9va3VwW3BdIC0gb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdsb29rdXBGcm9tQXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29rdXBGcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsb29rdXAgPSB7fTtcbiAgICAgIHZhciB6ID0gMDtcbiAgICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgbG9va3VwW2FycmF5W2ldXSA9IHorKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb29rdXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGF0YVNoYXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0YVNoYXBlKGRhdGEpIHtcbiAgICAgIHZhciBzaGFwZSA9IFtdO1xuXG4gICAgICBpZiAoZGF0YS5pbnB1dCkge1xuICAgICAgICBzaGFwZS5wdXNoKCdkYXR1bScpO1xuICAgICAgICBkYXRhID0gZGF0YS5pbnB1dDtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBpZiAoZGF0YVswXS5pbnB1dCkge1xuICAgICAgICAgIHNoYXBlLnB1c2goJ2FycmF5JywgJ2RhdHVtJyk7XG4gICAgICAgICAgZGF0YSA9IGRhdGFbMF0uaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGUucHVzaCgnYXJyYXknKTtcbiAgICAgICAgICBkYXRhID0gZGF0YVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHZvaWQgMDtcbiAgICAgIHdoaWxlIChkYXRhKSB7XG4gICAgICAgIGZvciAocCBpbiBkYXRhKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KHApKSBicmVhaztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHNoYXBlLnB1c2goJ2FycmF5Jyk7XG4gICAgICAgICAgZGF0YSA9IGRhdGFbcF07XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgc2hhcGUucHVzaCgnb2JqZWN0Jyk7XG4gICAgICAgICAgZGF0YSA9IGRhdGFbcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmhhbmRsZWQgc2lnbmF0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNoYXBlLnB1c2godHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKTtcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRLZXlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkS2V5cyh2YWx1ZSwgdGFibGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuO1xuICAgICAgdGFibGUgPSB0YWJsZSB8fCB7fTtcbiAgICAgIHZhciBpID0gT2JqZWN0LmtleXModGFibGUpLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIHAgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGlmICh0YWJsZS5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIHRhYmxlW3BdID0gaSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBsb29rdXA7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGxvb2t1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvb2t1cC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9uZXVyYWxOZXR3b3JrID0gcmVxdWlyZSgnLi9uZXVyYWwtbmV0d29yaycpO1xuXG52YXIgX25ldXJhbE5ldHdvcmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbmV1cmFsTmV0d29yayk7XG5cbnZhciBfbG9va3VwID0gcmVxdWlyZSgnLi9sb29rdXAnKTtcblxudmFyIF9sb29rdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9va3VwKTtcblxudmFyIF9ncHUgPSByZXF1aXJlKCdncHUuanMnKTtcblxudmFyIF9ncHUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3B1KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBOZXVyYWxOZXR3b3JrR1BVID0gZnVuY3Rpb24gKF9OZXVyYWxOZXR3b3JrKSB7XG4gIF9pbmhlcml0cyhOZXVyYWxOZXR3b3JrR1BVLCBfTmV1cmFsTmV0d29yayk7XG5cbiAgZnVuY3Rpb24gTmV1cmFsTmV0d29ya0dQVSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV1cmFsTmV0d29ya0dQVSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTmV1cmFsTmV0d29ya0dQVS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE5ldXJhbE5ldHdvcmtHUFUpKS5jYWxsKHRoaXMsIG9wdGlvbnMpKTtcblxuICAgIF90aGlzLmZvcndhcmRQcm9wYWdhdGUgPSBbXTtcbiAgICBfdGhpcy5iYWNrd2FyZFByb3BhZ2F0ZSA9IFtdO1xuICAgIF90aGlzLmNoYW5nZXNQcm9wYWdhdGUgPSBbXTtcbiAgICBfdGhpcy5iaWFzZXNQcm9wYWdhdGUgPSBbXTtcbiAgICBfdGhpcy5iaWFzQ29waWVzID0gW107XG4gICAgX3RoaXMuY29weUJpYXMgPSBbXTtcbiAgICBfdGhpcy5jaGFuZ2VzQ29waWVzID0gW107XG4gICAgX3RoaXMuY29weUNoYW5nZXMgPSBbXTtcbiAgICBfdGhpcy53ZWlnaHRzQ29waWVzID0gW107XG4gICAgX3RoaXMuY29weVdlaWdodHMgPSBbXTtcbiAgICBfdGhpcy5lcnJvckNoZWNrSW50ZXJ2YWwgPSAxMDA7XG4gICAgX3RoaXMuZ3B1ID0gbmV3IF9ncHUyLmRlZmF1bHQoeyBtb2RlOiBvcHRpb25zLm1vZGUgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5ldXJhbE5ldHdvcmtHUFUsIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICBfZ2V0KE5ldXJhbE5ldHdvcmtHUFUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTmV1cmFsTmV0d29ya0dQVS5wcm90b3R5cGUpLCAnaW5pdGlhbGl6ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLmJ1aWxkUnVuSW5wdXQoKTtcbiAgICAgIHRoaXMuYnVpbGRDYWxjdWxhdGVEZWx0YXMoKTtcbiAgICAgIHRoaXMuYnVpbGRHZXRDaGFuZ2VzKCk7XG4gICAgICB0aGlzLmJ1aWxkQ2hhbmdlQmlhc2VzKCk7XG4gICAgICB0aGlzLmJ1aWxkR2V0TVNFKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0QWN0aXZhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFjdGl2YXRpb24oKSB7fVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gbG9nRXJyb3JSYXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluUGF0dGVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWluUGF0dGVybih2YWx1ZSwgbG9nRXJyb3JSYXRlKSB7XG4gICAgICAvLyBmb3J3YXJkIHByb3BhZ2F0ZVxuICAgICAgdGhpcy5ydW5JbnB1dCh2YWx1ZS5pbnB1dCk7XG5cbiAgICAgIC8vIGJhY2sgcHJvcGFnYXRlXG4gICAgICB0aGlzLmNhbGN1bGF0ZURlbHRhcyh2YWx1ZS5vdXRwdXQpO1xuICAgICAgdGhpcy5hZGp1c3RXZWlnaHRzKCk7XG5cbiAgICAgIGlmIChsb2dFcnJvclJhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TVNFKHRoaXMuZXJyb3JzW3RoaXMub3V0cHV0TGF5ZXJdKVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkanVzdFdlaWdodHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RXZWlnaHRzKCkge1xuICAgICAgdGhpcy5nZXRDaGFuZ2VzKCk7XG4gICAgICB0aGlzLmNoYW5nZUJpYXNlcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkUnVuSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFJ1bklucHV0KCkge1xuICAgICAgdmFyIHdlaWdodGVkU3VtID0gbnVsbDtcblxuICAgICAgc3dpdGNoICh0aGlzLmFjdGl2YXRpb24pIHtcbiAgICAgICAgY2FzZSAnc2lnbW9pZCc6XG4gICAgICAgICAgd2VpZ2h0ZWRTdW0gPSB3ZWlnaHRlZFN1bVNpZ21vaWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlbHUnOlxuICAgICAgICAgIHdlaWdodGVkU3VtID0gd2VpZ2h0ZWRTdW1SZWx1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWFreS1yZWx1JzpcbiAgICAgICAgICB3ZWlnaHRlZFN1bSA9IHdlaWdodGVkU3VtTGVha3lSZWx1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0YW5oJzpcbiAgICAgICAgICB3ZWlnaHRlZFN1bSA9IHdlaWdodGVkU3VtVGFuaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYWN0aXZhdGlvbiAnICsgdGhpcy5hY3RpdmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAxOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZFByb3BhZ2F0ZVtsYXllcl0gPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwod2VpZ2h0ZWRTdW0sIHtcbiAgICAgICAgICBvdXRwdXQ6IFt0aGlzLnNpemVzW2xheWVyXV0sXG4gICAgICAgICAgb3V0cHV0VG9UZXh0dXJlOiB0cnVlLFxuICAgICAgICAgIGhhcmRjb2RlQ29uc3RhbnRzOiB0cnVlLFxuICAgICAgICAgIGNvbnN0YW50czoge1xuICAgICAgICAgICAgc2l6ZTogdGhpcy5zaXplc1tsYXllciAtIDFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0dXJpemVJbnB1dERhdGEgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVt0aGlzLnRocmVhZC54XTtcbiAgICAgIH0sIHtcbiAgICAgICAgb3V0cHV0OiBbdGhpcy5zaXplc1sxXV0sXG4gICAgICAgIG91dHB1dFRvVGV4dHVyZTogdHJ1ZSxcbiAgICAgICAgaGFyZGNvZGVDb25zdGFudHM6IHRydWUsXG4gICAgICAgIG91dHB1dEltbXV0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncnVuSW5wdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5JbnB1dChpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMub3V0cHV0c1swXSA9IGlucHV0O1xuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAxOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHRoaXMub3V0cHV0c1tsYXllcl0gPSB0aGlzLmZvcndhcmRQcm9wYWdhdGVbbGF5ZXJdKHRoaXMud2VpZ2h0c1tsYXllcl0sIHRoaXMuYmlhc2VzW2xheWVyXSwgaW5wdXQpO1xuICAgICAgICBvdXRwdXQgPSBpbnB1dCA9IHRoaXMub3V0cHV0c1tsYXllcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2J1aWxkQ2FsY3VsYXRlRGVsdGFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRDYWxjdWxhdGVEZWx0YXMoKSB7XG4gICAgICB2YXIgY2FsY0RlbHRhcyA9IG51bGw7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5hY3RpdmF0aW9uKSB7XG4gICAgICAgIGNhc2UgJ3NpZ21vaWQnOlxuICAgICAgICAgIGNhbGNEZWx0YXMgPSBjYWxjRGVsdGFzU2lnbW9pZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVsdSc6XG4gICAgICAgICAgY2FsY0RlbHRhcyA9IGNhbGNEZWx0YXNSZWx1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWFreS1yZWx1JzpcbiAgICAgICAgICBjYWxjRGVsdGFzID0gY2FsY0RlbHRhc0xlYWt5UmVsdTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFuaCc6XG4gICAgICAgICAgY2FsY0RlbHRhcyA9IGNhbGNEZWx0YXNUYW5oO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBhY3RpdmF0aW9uICcgKyB0aGlzLmFjdGl2YXRpb24pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsYXllciA9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyID4gMDsgbGF5ZXItLSkge1xuICAgICAgICBpZiAobGF5ZXIgPT09IHRoaXMub3V0cHV0TGF5ZXIpIHtcbiAgICAgICAgICB0aGlzLmJhY2t3YXJkUHJvcGFnYXRlW2xheWVyXSA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbE1hcCh7XG4gICAgICAgICAgICBlcnJvcjogX2dwdTIuZGVmYXVsdC5hbGlhcygnY2FsY0Vycm9yT3V0cHV0JywgY2FsY0Vycm9yT3V0cHV0KSxcbiAgICAgICAgICAgIGRlbHRhczogX2dwdTIuZGVmYXVsdC5hbGlhcygnY2FsY0RlbHRhcycsIGNhbGNEZWx0YXMpXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKG91dHB1dHMsIHRhcmdldHMpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBvdXRwdXRzW3RoaXMudGhyZWFkLnhdO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGNEZWx0YXMoY2FsY0Vycm9yT3V0cHV0KG91dHB1dCwgdGFyZ2V0cyksIG91dHB1dCk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb3V0cHV0OiBbdGhpcy5zaXplc1tsYXllcl1dLFxuICAgICAgICAgICAgb3V0cHV0VG9UZXh0dXJlOiB0cnVlLFxuICAgICAgICAgICAgaGFyZGNvZGVDb25zdGFudHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmJhY2t3YXJkUHJvcGFnYXRlW2xheWVyXSA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbE1hcCh7XG4gICAgICAgICAgICBlcnJvcjogX2dwdTIuZGVmYXVsdC5hbGlhcygnY2FsY0Vycm9yJywgY2FsY0Vycm9yKSxcbiAgICAgICAgICAgIGRlbHRhczogX2dwdTIuZGVmYXVsdC5hbGlhcygnY2FsY0RlbHRhcycsIGNhbGNEZWx0YXMpXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKG5leHRXZWlnaHRzLCBvdXRwdXRzLCBuZXh0RGVsdGFzKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gb3V0cHV0c1t0aGlzLnRocmVhZC54XTtcbiAgICAgICAgICAgIHJldHVybiBjYWxjRGVsdGFzKGNhbGNFcnJvcihuZXh0V2VpZ2h0cywgbmV4dERlbHRhcyksIG91dHB1dCk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb3V0cHV0OiBbdGhpcy5zaXplc1tsYXllcl1dLFxuICAgICAgICAgICAgb3V0cHV0VG9UZXh0dXJlOiB0cnVlLFxuICAgICAgICAgICAgaGFyZGNvZGVDb25zdGFudHM6IHRydWUsXG4gICAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgICAgc2l6ZTogdGhpcy5kZWx0YXNbbGF5ZXIgKyAxXS5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZURlbHRhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhcyh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIgPiAwOyBsYXllci0tKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGxheWVyID09PSB0aGlzLm91dHB1dExheWVyKSB7XG4gICAgICAgICAgb3V0cHV0ID0gdGhpcy5iYWNrd2FyZFByb3BhZ2F0ZVtsYXllcl0odGhpcy5vdXRwdXRzW2xheWVyXSwgdGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQgPSB0aGlzLmJhY2t3YXJkUHJvcGFnYXRlW2xheWVyXSh0aGlzLndlaWdodHNbbGF5ZXIgKyAxXSwgdGhpcy5vdXRwdXRzW2xheWVyXSwgdGhpcy5kZWx0YXNbbGF5ZXIgKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlbHRhc1tsYXllcl0gPSBvdXRwdXQuZGVsdGFzO1xuICAgICAgICB0aGlzLmVycm9yc1tsYXllcl0gPSBvdXRwdXQuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRHZXRDaGFuZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVpbGRHZXRDaGFuZ2VzKCkge1xuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAxOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlc1Byb3BhZ2F0ZVtsYXllcl0gPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWxNYXAoe1xuICAgICAgICAgIHdlaWdodHM6IF9ncHUyLmRlZmF1bHQuYWxpYXMoJ2FkZFdlaWdodHMnLCBhZGRXZWlnaHRzKSxcbiAgICAgICAgICBjaGFuZ2VzOiBfZ3B1Mi5kZWZhdWx0LmFsaWFzKCdjYWxjQ2hhbmdlcycsIGNhbGNDaGFuZ2VzKVxuICAgICAgICB9LCBmdW5jdGlvbiAocHJldmlvdXNPdXRwdXRzLCBkZWx0YXMsIHdlaWdodHMsIGNoYW5nZXMpIHtcbiAgICAgICAgICB2YXIgY2hhbmdlID0gY2FsY0NoYW5nZXMoY2hhbmdlcywgZGVsdGFzLCBwcmV2aW91c091dHB1dHMpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZFdlaWdodHMoY2hhbmdlLCB3ZWlnaHRzKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG91dHB1dDogW3RoaXMuc2l6ZXNbbGF5ZXIgLSAxXSwgdGhpcy5zaXplc1tsYXllcl1dLFxuICAgICAgICAgIG91dHB1dFRvVGV4dHVyZTogdHJ1ZSxcbiAgICAgICAgICBoYXJkY29kZUNvbnN0YW50czogdHJ1ZSxcbiAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgIHNpemU6IHRoaXMub3V0cHV0c1tsYXllciAtIDFdLmxlbmd0aCxcbiAgICAgICAgICAgIGxlYXJuaW5nUmF0ZTogdGhpcy50cmFpbk9wdHMubGVhcm5pbmdSYXRlLFxuICAgICAgICAgICAgbW9tZW50dW06IHRoaXMudHJhaW5PcHRzLm1vbWVudHVtXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvcHlDaGFuZ2VzW2xheWVyXSA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IHRoaXMuY2hhbmdlc1Byb3BhZ2F0ZVtsYXllcl0ub3V0cHV0LFxuICAgICAgICAgIG91dHB1dFRvVGV4dHVyZTogdHJ1ZSxcbiAgICAgICAgICBoYXJkQ29kZUNvbnN0YW50czogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvcHlXZWlnaHRzW2xheWVyXSA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvdXRwdXQ6IHRoaXMuY2hhbmdlc1Byb3BhZ2F0ZVtsYXllcl0ub3V0cHV0LFxuICAgICAgICAgIG91dHB1dFRvVGV4dHVyZTogdHJ1ZSxcbiAgICAgICAgICBoYXJkQ29kZUNvbnN0YW50czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDaGFuZ2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhbmdlcygpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gMTsgbGF5ZXIgPD0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIrKykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5jaGFuZ2VzUHJvcGFnYXRlW2xheWVyXSh0aGlzLm91dHB1dHNbbGF5ZXIgLSAxXSwgdGhpcy5kZWx0YXNbbGF5ZXJdLCB0aGlzLndlaWdodHNDb3BpZXNbbGF5ZXJdIHx8IHRoaXMud2VpZ2h0c1tsYXllcl0sIHRoaXMuY2hhbmdlc0NvcGllc1tsYXllcl0gfHwgdGhpcy5jaGFuZ2VzW2xheWVyXSk7XG4gICAgICAgIHRoaXMuY2hhbmdlc1tsYXllcl0gPSBvdXRwdXQuY2hhbmdlcztcbiAgICAgICAgdGhpcy53ZWlnaHRzW2xheWVyXSA9IG91dHB1dC53ZWlnaHRzO1xuXG4gICAgICAgIHRoaXMuY2hhbmdlc0NvcGllc1tsYXllcl0gPSB0aGlzLmNvcHlDaGFuZ2VzW2xheWVyXShvdXRwdXQuY2hhbmdlcyk7XG4gICAgICAgIHRoaXMud2VpZ2h0c0NvcGllc1tsYXllcl0gPSB0aGlzLmNvcHlXZWlnaHRzW2xheWVyXShvdXRwdXQud2VpZ2h0cyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRDaGFuZ2VCaWFzZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZENoYW5nZUJpYXNlcygpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gMTsgbGF5ZXIgPD0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIrKykge1xuICAgICAgICB0aGlzLmJpYXNlc1Byb3BhZ2F0ZVtsYXllcl0gPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoYWRkQmlhc2VzLCB7XG4gICAgICAgICAgb3V0cHV0OiBbdGhpcy5zaXplc1tsYXllcl1dLFxuICAgICAgICAgIG91dHB1dFRvVGV4dHVyZTogdHJ1ZSxcbiAgICAgICAgICBoYXJkY29kZUNvbnN0YW50czogdHJ1ZSxcbiAgICAgICAgICBjb25zdGFudHM6IHtcbiAgICAgICAgICAgIGxlYXJuaW5nUmF0ZTogdGhpcy50cmFpbk9wdHMubGVhcm5pbmdSYXRlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb3B5Qmlhc1tsYXllcl0gPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlW3RoaXMudGhyZWFkLnhdO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgb3V0cHV0OiB0aGlzLmJpYXNlc1Byb3BhZ2F0ZVtsYXllcl0ub3V0cHV0LFxuICAgICAgICAgIG91dHB1dFRvVGV4dHVyZTogdHJ1ZSxcbiAgICAgICAgICBoYXJkQ29kZUNvbnN0YW50czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjaGFuZ2VCaWFzZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VCaWFzZXMoKSB7XG4gICAgICBmb3IgKHZhciBsYXllciA9IDE7IGxheWVyIDw9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyKyspIHtcbiAgICAgICAgdGhpcy5iaWFzZXNbbGF5ZXJdID0gdGhpcy5iaWFzZXNQcm9wYWdhdGVbbGF5ZXJdKHRoaXMuYmlhc0NvcGllc1tsYXllcl0gfHwgdGhpcy5iaWFzZXNbbGF5ZXJdLCB0aGlzLmRlbHRhc1tsYXllcl0pO1xuICAgICAgICB0aGlzLmJpYXNDb3BpZXNbbGF5ZXJdID0gdGhpcy5jb3B5Qmlhc1tsYXllcl0odGhpcy5iaWFzZXNbbGF5ZXJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdidWlsZEdldE1TRScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkR2V0TVNFKCkge1xuICAgICAgdGhpcy5nZXRNU0UgPSB0aGlzLmdwdS5jcmVhdGVLZXJuZWwobXNlLCB7XG4gICAgICAgIG91dHB1dDogWzFdLFxuICAgICAgICBoYXJkY29kZUNvbnN0YW50czogdHJ1ZSxcbiAgICAgICAgY29uc3RhbnRzOiB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zaXplc1t0aGlzLm91dHB1dExheWVyXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oaW5wdXQpIHtcbiAgICAgIGlmICghdGhpcy5pc1J1bm5hYmxlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlucHV0TG9va3VwKSB7XG4gICAgICAgIGlucHV0ID0gX2xvb2t1cDIuZGVmYXVsdC50b0FycmF5KHRoaXMuaW5wdXRMb29rdXAsIGlucHV0LCB0aGlzLmlucHV0TG9va3VwTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnB1dFRleHR1cmUgPSB0aGlzLnRleHR1cml6ZUlucHV0RGF0YShpbnB1dCk7XG4gICAgICB2YXIgb3V0cHV0VGV4dHVyZXMgPSB0aGlzLnJ1bklucHV0KGlucHV0VGV4dHVyZSk7XG4gICAgICB2YXIgb3V0cHV0ID0gdm9pZCAwO1xuICAgICAgaWYgKG91dHB1dFRleHR1cmVzLnRvQXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0VGV4dHVyZXMudG9BcnJheSh0aGlzLmdwdSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBvdXRwdXRUZXh0dXJlcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3V0cHV0TG9va3VwKSB7XG4gICAgICAgIG91dHB1dCA9IF9sb29rdXAyLmRlZmF1bHQudG9PYmplY3QodGhpcy5vdXRwdXRMb29rdXAsIG91dHB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHsgZGF0YSwgc3RhdHVzLCBlbmRUaW1lIH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJlcFRyYWluaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcFRyYWluaW5nKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLnVwZGF0ZVRyYWluaW5nT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGRhdGEgPSB0aGlzLmZvcm1hdERhdGEoZGF0YSk7XG4gICAgICB2YXIgZW5kVGltZSA9IERhdGUubm93KCkgKyB0aGlzLnRyYWluT3B0cy50aW1lb3V0O1xuXG4gICAgICB2YXIgc3RhdHVzID0ge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgaXRlcmF0aW9uczogMFxuICAgICAgfTtcblxuICAgICAgdGhpcy52ZXJpZnlJc0luaXRpYWxpemVkKGRhdGEpO1xuXG4gICAgICB2YXIgdGV4dHVyaXplT3V0cHV0RGF0YSA9IHRoaXMuZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW3RoaXMudGhyZWFkLnhdO1xuICAgICAgfSwge1xuICAgICAgICBvdXRwdXQ6IFtkYXRhWzBdLm91dHB1dC5sZW5ndGhdLFxuICAgICAgICBvdXRwdXRUb1RleHR1cmU6IHRydWUsXG4gICAgICAgIGhhcmRjb2RlQ29uc3RhbnRzOiB0cnVlLFxuICAgICAgICBvdXRwdXRJbW11dGFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBkYXRhLm1hcChmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiBfdGhpczIudGV4dHVyaXplSW5wdXREYXRhKHNldC5pbnB1dCksXG4gICAgICAgICAgICBvdXRwdXQ6IHRleHR1cml6ZU91dHB1dERhdGEoc2V0Lm91dHB1dClcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIGVuZFRpbWU6IGVuZFRpbWVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy53ZWlnaHRzWzFdLnRvQXJyYXkpIHtcbiAgICAgICAgLy8gaW4gZmFsbGJhY2sgbW9kZVxuICAgICAgICByZXR1cm4gX2dldChOZXVyYWxOZXR3b3JrR1BVLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE5ldXJhbE5ldHdvcmtHUFUucHJvdG90eXBlKSwgJ3RvSlNPTicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGluIEdQVSBtb2RlXG4gICAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgICAgdmFyIGJpYXNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAxOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHdlaWdodHNbbGF5ZXJdID0gQXJyYXkuZnJvbSh0aGlzLndlaWdodHNbbGF5ZXJdLnRvQXJyYXkodGhpcy5ncHUpKTtcbiAgICAgICAgYmlhc2VzW2xheWVyXSA9IEFycmF5LmZyb20odGhpcy5iaWFzZXNbbGF5ZXJdLnRvQXJyYXkodGhpcy5ncHUpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHNldWRvIGxvLWZpIGRlY29yYXRvclxuICAgICAgcmV0dXJuIF9uZXVyYWxOZXR3b3JrMi5kZWZhdWx0LnByb3RvdHlwZS50b0pTT04uY2FsbCh7XG4gICAgICAgIGlucHV0TG9va3VwOiB0aGlzLmlucHV0TG9va3VwLFxuICAgICAgICBvdXRwdXRMb29rdXA6IHRoaXMub3V0cHV0TG9va3VwLFxuICAgICAgICBvdXRwdXRMYXllcjogdGhpcy5vdXRwdXRMYXllcixcbiAgICAgICAgc2l6ZXM6IHRoaXMuc2l6ZXMsXG4gICAgICAgIGdldFRyYWluT3B0c0pTT046IGZ1bmN0aW9uIGdldFRyYWluT3B0c0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5nZXRUcmFpbk9wdHNKU09OKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlaWdodHM6IHdlaWdodHMsXG4gICAgICAgIGJpYXNlczogYmlhc2VzXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV1cmFsTmV0d29ya0dQVTtcbn0oX25ldXJhbE5ldHdvcmsyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBOZXVyYWxOZXR3b3JrR1BVO1xuXG5cbmZ1bmN0aW9uIHdlaWdodGVkU3VtU2lnbW9pZCh3ZWlnaHRzLCBiaWFzZXMsIGlucHV0cykge1xuICB2YXIgc3VtID0gYmlhc2VzW3RoaXMudGhyZWFkLnhdO1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuY29uc3RhbnRzLnNpemU7IGsrKykge1xuICAgIHN1bSArPSB3ZWlnaHRzW3RoaXMudGhyZWFkLnhdW2tdICogaW5wdXRzW2tdO1xuICB9XG4gIC8vc2lnbW9pZFxuICByZXR1cm4gMSAvICgxICsgTWF0aC5leHAoLXN1bSkpO1xufVxuXG5mdW5jdGlvbiB3ZWlnaHRlZFN1bVJlbHUod2VpZ2h0cywgYmlhc2VzLCBpbnB1dHMpIHtcbiAgdmFyIHN1bSA9IGJpYXNlc1t0aGlzLnRocmVhZC54XTtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmNvbnN0YW50cy5zaXplOyBrKyspIHtcbiAgICBzdW0gKz0gd2VpZ2h0c1t0aGlzLnRocmVhZC54XVtrXSAqIGlucHV0c1trXTtcbiAgfVxuICAvL3JlbHVcbiAgcmV0dXJuIHN1bSA8IDAgPyAwIDogc3VtO1xufVxuXG5mdW5jdGlvbiB3ZWlnaHRlZFN1bUxlYWt5UmVsdSh3ZWlnaHRzLCBiaWFzZXMsIGlucHV0cykge1xuICB2YXIgc3VtID0gYmlhc2VzW3RoaXMudGhyZWFkLnhdO1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuY29uc3RhbnRzLnNpemU7IGsrKykge1xuICAgIHN1bSArPSB3ZWlnaHRzW3RoaXMudGhyZWFkLnhdW2tdICogaW5wdXRzW2tdO1xuICB9XG4gIC8vbGVha3kgcmVsdVxuICByZXR1cm4gc3VtIDwgMCA/IDAgOiAwLjAxICogc3VtO1xufVxuXG5mdW5jdGlvbiB3ZWlnaHRlZFN1bVRhbmgod2VpZ2h0cywgYmlhc2VzLCBpbnB1dHMpIHtcbiAgdmFyIHN1bSA9IGJpYXNlc1t0aGlzLnRocmVhZC54XTtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmNvbnN0YW50cy5zaXplOyBrKyspIHtcbiAgICBzdW0gKz0gd2VpZ2h0c1t0aGlzLnRocmVhZC54XVtrXSAqIGlucHV0c1trXTtcbiAgfVxuICAvL3RhbmhcbiAgcmV0dXJuIE1hdGgudGFuaChzdW0pO1xufVxuXG5mdW5jdGlvbiBjYWxjRXJyb3JPdXRwdXQob3V0cHV0LCB0YXJnZXRzKSB7XG4gIHJldHVybiB0YXJnZXRzW3RoaXMudGhyZWFkLnhdIC0gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjYWxjRGVsdGFzU2lnbW9pZChlcnJvciwgb3V0cHV0KSB7XG4gIC8vc2lnbW9pZCBkZXJpdmF0aXZlXG4gIHJldHVybiBlcnJvciAqIG91dHB1dCAqICgxIC0gb3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gY2FsY0RlbHRhc1JlbHUoZXJyb3IsIG91dHB1dCkge1xuICAvL3JlbHUgZGVyaXZhdGl2ZVxuICByZXR1cm4gb3V0cHV0ID4gMCA/IGVycm9yIDogMDtcbn1cblxuZnVuY3Rpb24gY2FsY0RlbHRhc0xlYWt5UmVsdShlcnJvciwgb3V0cHV0KSB7XG4gIC8vbGVha3kgcmVsdSBkZXJpdmF0aXZlXG4gIHJldHVybiBvdXRwdXQgPiAwID8gZXJyb3IgOiAwLjAxICogZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGNhbGNEZWx0YXNUYW5oKGVycm9yLCBvdXRwdXQpIHtcbiAgLy90YW5oIGRlcml2YXRpdmVcbiAgcmV0dXJuICgxIC0gb3V0cHV0ICogb3V0cHV0KSAqIGVycm9yO1xufVxuXG5mdW5jdGlvbiBjYWxjRXJyb3IobmV4dFdlaWdodHMsIG5leHREZWx0YXMpIHtcbiAgdmFyIGVycm9yID0gMDtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmNvbnN0YW50cy5zaXplOyBrKyspIHtcbiAgICBlcnJvciArPSBuZXh0RGVsdGFzW2tdICogbmV4dFdlaWdodHNba11bdGhpcy50aHJlYWQueF07XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBjYWxjQ2hhbmdlcyhwcmV2aW91c0NoYW5nZXMsIGRlbHRhcywgcHJldmlvdXNPdXRwdXRzKSB7XG4gIHJldHVybiB0aGlzLmNvbnN0YW50cy5sZWFybmluZ1JhdGUgKiBkZWx0YXNbdGhpcy50aHJlYWQueV0gKiBwcmV2aW91c091dHB1dHNbdGhpcy50aHJlYWQueF0gKyB0aGlzLmNvbnN0YW50cy5tb21lbnR1bSAqIHByZXZpb3VzQ2hhbmdlc1t0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcbn1cblxuZnVuY3Rpb24gYWRkV2VpZ2h0cyhjaGFuZ2UsIHdlaWdodHMpIHtcbiAgcmV0dXJuIGNoYW5nZSArIHdlaWdodHNbdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG59XG5cbmZ1bmN0aW9uIGFkZEJpYXNlcyhiaWFzZXMsIGRlbHRhcykge1xuICByZXR1cm4gYmlhc2VzW3RoaXMudGhyZWFkLnhdICsgZGVsdGFzW3RoaXMudGhyZWFkLnhdICogdGhpcy5jb25zdGFudHMubGVhcm5pbmdSYXRlO1xufVxuXG4vLyBtZWFuIHNxdWFyZWQgZXJyb3IsIHJlaW1wbGVtZW50ZWQgZm9yIEdQVVxuZnVuY3Rpb24gbXNlKGVycm9ycykge1xuICB2YXIgc3VtID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnN0YW50cy5zaXplOyBpKyspIHtcbiAgICBzdW0gKz0gTWF0aC5wb3coZXJyb3JzW2ldLCAyKTtcbiAgfVxuICByZXR1cm4gc3VtIC8gdGhpcy5jb25zdGFudHMuc2l6ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldXJhbC1uZXR3b3JrLWdwdS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdGhhdyA9IHJlcXVpcmUoJ3RoYXcuanMnKTtcblxudmFyIF90aGF3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoYXcpO1xuXG52YXIgX2xvb2t1cDIgPSByZXF1aXJlKCcuL2xvb2t1cCcpO1xuXG52YXIgX2xvb2t1cDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb29rdXAyKTtcblxudmFyIF9tYXggPSByZXF1aXJlKCcuL3V0aWxpdGllcy9tYXgnKTtcblxudmFyIF9tYXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF4KTtcblxudmFyIF9tc2UgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9tc2UnKTtcblxudmFyIF9tc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXNlKTtcblxudmFyIF9yYW5kb3MgPSByZXF1aXJlKCcuL3V0aWxpdGllcy9yYW5kb3MnKTtcblxudmFyIF9yYW5kb3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZG9zKTtcblxudmFyIF9yYW5nZSA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL3JhbmdlJyk7XG5cbnZhciBfcmFuZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZ2UpO1xuXG52YXIgX3RvQXJyYXkgPSByZXF1aXJlKCcuL3V0aWxpdGllcy90by1hcnJheScpO1xuXG52YXIgX3RvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9BcnJheSk7XG5cbnZhciBfemVyb3MgPSByZXF1aXJlKCcuL3V0aWxpdGllcy96ZXJvcycpO1xuXG52YXIgX3plcm9zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3plcm9zKTtcblxudmFyIF9sb29rdXBUYWJsZSA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzL2xvb2t1cC10YWJsZScpO1xuXG52YXIgX2xvb2t1cFRhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvb2t1cFRhYmxlKTtcblxudmFyIF9jYXN0ID0gcmVxdWlyZSgnLi91dGlsaXRpZXMvY2FzdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE5ldXJhbE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhOZXVyYWxOZXR3b3JrLCBudWxsLCBbe1xuICAgIGtleTogJ3RyYWluRGVmYXVsdHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlcmF0aW9uczogMjAwMDAsIC8vIHRoZSBtYXhpbXVtIHRpbWVzIHRvIGl0ZXJhdGUgdGhlIHRyYWluaW5nIGRhdGFcbiAgICAgICAgZXJyb3JUaHJlc2g6IDAuMDA1LCAvLyB0aGUgYWNjZXB0YWJsZSBlcnJvciBwZXJjZW50YWdlIGZyb20gdHJhaW5pbmcgZGF0YVxuICAgICAgICBsb2c6IGZhbHNlLCAvLyB0cnVlIHRvIHVzZSBjb25zb2xlLmxvZywgd2hlbiBhIGZ1bmN0aW9uIGlzIHN1cHBsaWVkIGl0IGlzIHVzZWRcbiAgICAgICAgbG9nUGVyaW9kOiAxMCwgLy8gaXRlcmF0aW9ucyBiZXR3ZWVuIGxvZ2dpbmcgb3V0XG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4zLCAvLyBtdWx0aXBseSdzIGFnYWluc3QgdGhlIGlucHV0IGFuZCB0aGUgZGVsdGEgdGhlbiBhZGRzIHRvIG1vbWVudHVtXG4gICAgICAgIG1vbWVudHVtOiAwLjEsIC8vIG11bHRpcGx5J3MgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIFwiY2hhbmdlXCIgdGhlbiBhZGRzIHRvIGxlYXJuaW5nIHJhdGUgZm9yIGNoYW5nZVxuICAgICAgICBjYWxsYmFjazogbnVsbCwgLy8gYSBwZXJpb2RpYyBjYWxsIGJhY2sgdGhhdCBjYW4gYmUgdHJpZ2dlcmVkIHdoaWxlIHRyYWluaW5nXG4gICAgICAgIGNhbGxiYWNrUGVyaW9kOiAxMCwgLy8gdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRocm91Z2ggdGhlIHRyYWluaW5nIGRhdGEgYmV0d2VlbiBjYWxsYmFjayBjYWxsc1xuICAgICAgICB0aW1lb3V0OiBJbmZpbml0eSwgLy8gdGhlIG1heCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRyYWluIGZvclxuICAgICAgICBwcmF4aXM6IG51bGwsXG4gICAgICAgIGJldGExOiAwLjksXG4gICAgICAgIGJldGEyOiAwLjk5OSxcbiAgICAgICAgZXBzaWxvbjogMWUtOFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWZhdWx0cycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWFreVJlbHVBbHBoYTogMC4wMSxcbiAgICAgICAgYmluYXJ5VGhyZXNoOiAwLjUsXG4gICAgICAgIGhpZGRlbkxheWVyczogbnVsbCwgLy8gYXJyYXkgb2YgaW50cyBmb3IgdGhlIHNpemVzIG9mIHRoZSBoaWRkZW4gbGF5ZXJzIGluIHRoZSBuZXR3b3JrXG4gICAgICAgIGFjdGl2YXRpb246ICdzaWdtb2lkJyAvLyBTdXBwb3J0ZWQgYWN0aXZhdGlvbiB0eXBlcyBbJ3NpZ21vaWQnLCAncmVsdScsICdsZWFreS1yZWx1JywgJ3RhbmgnXVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBOZXVyYWxOZXR3b3JrKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZXVyYWxOZXR3b3JrKTtcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdGhpcy50cmFpbk9wdHMgPSB7fTtcbiAgICB0aGlzLnVwZGF0ZVRyYWluaW5nT3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbnN0cnVjdG9yLnRyYWluRGVmYXVsdHMsIG9wdGlvbnMpKTtcblxuICAgIHRoaXMuc2l6ZXMgPSBudWxsO1xuICAgIHRoaXMub3V0cHV0TGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuYmlhc2VzID0gbnVsbDsgLy8gd2VpZ2h0cyBmb3IgYmlhcyBub2Rlc1xuICAgIHRoaXMud2VpZ2h0cyA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXRzID0gbnVsbDtcblxuICAgIC8vIHN0YXRlIGZvciB0cmFpbmluZ1xuICAgIHRoaXMuZGVsdGFzID0gbnVsbDtcbiAgICB0aGlzLmNoYW5nZXMgPSBudWxsOyAvLyBmb3IgbW9tZW50dW1cbiAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgdGhpcy5lcnJvckNoZWNrSW50ZXJ2YWwgPSAxO1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3J1bklucHV0JykpIHtcbiAgICAgIHRoaXMucnVuSW5wdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdjYWxjdWxhdGVEZWx0YXMnKSkge1xuICAgICAgdGhpcy5jYWxjdWxhdGVEZWx0YXMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmlucHV0TG9va3VwID0gbnVsbDtcbiAgICB0aGlzLmlucHV0TG9va3VwTGVuZ3RoID0gbnVsbDtcbiAgICB0aGlzLm91dHB1dExvb2t1cCA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXRMb29rdXBMZW5ndGggPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEV4cGVjdHMgdGhpcy5zaXplcyB0byBoYXZlIGJlZW4gc2V0XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE5ldXJhbE5ldHdvcmssIFt7XG4gICAga2V5OiAnaW5pdGlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICBpZiAoIXRoaXMuc2l6ZXMpIHRocm93IG5ldyBFcnJvcignU2l6ZXMgbXVzdCBiZSBzZXQgYmVmb3JlIGluaXRpYWxpemluZycpO1xuXG4gICAgICB0aGlzLm91dHB1dExheWVyID0gdGhpcy5zaXplcy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5iaWFzZXMgPSBbXTsgLy8gd2VpZ2h0cyBmb3IgYmlhcyBub2Rlc1xuICAgICAgdGhpcy53ZWlnaHRzID0gW107XG4gICAgICB0aGlzLm91dHB1dHMgPSBbXTtcblxuICAgICAgLy8gc3RhdGUgZm9yIHRyYWluaW5nXG4gICAgICB0aGlzLmRlbHRhcyA9IFtdO1xuICAgICAgdGhpcy5jaGFuZ2VzID0gW107IC8vIGZvciBtb21lbnR1bVxuICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAwOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplc1tsYXllcl07XG4gICAgICAgIHRoaXMuZGVsdGFzW2xheWVyXSA9ICgwLCBfemVyb3MyLmRlZmF1bHQpKHNpemUpO1xuICAgICAgICB0aGlzLmVycm9yc1tsYXllcl0gPSAoMCwgX3plcm9zMi5kZWZhdWx0KShzaXplKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzW2xheWVyXSA9ICgwLCBfemVyb3MyLmRlZmF1bHQpKHNpemUpO1xuXG4gICAgICAgIGlmIChsYXllciA+IDApIHtcbiAgICAgICAgICB0aGlzLmJpYXNlc1tsYXllcl0gPSAoMCwgX3JhbmRvczIuZGVmYXVsdCkoc2l6ZSk7XG4gICAgICAgICAgdGhpcy53ZWlnaHRzW2xheWVyXSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZXNbbGF5ZXJdID0gbmV3IEFycmF5KHNpemUpO1xuXG4gICAgICAgICAgZm9yICh2YXIgbm9kZSA9IDA7IG5vZGUgPCBzaXplOyBub2RlKyspIHtcbiAgICAgICAgICAgIHZhciBwcmV2U2l6ZSA9IHRoaXMuc2l6ZXNbbGF5ZXIgLSAxXTtcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0c1tsYXllcl1bbm9kZV0gPSAoMCwgX3JhbmRvczIuZGVmYXVsdCkocHJldlNpemUpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzW2xheWVyXVtub2RlXSA9ICgwLCBfemVyb3MyLmRlZmF1bHQpKHByZXZTaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRBY3RpdmF0aW9uKCk7XG4gICAgICBpZiAodGhpcy50cmFpbk9wdHMucHJheGlzID09PSAnYWRhbScpIHtcbiAgICAgICAgdGhpcy5fc2V0dXBBZGFtKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aXZhdGlvbiBzdXBwb3J0ZWQgaW5wdXRzOiAnc2lnbW9pZCcsICdyZWx1JywgJ2xlYWt5LXJlbHUnLCAndGFuaCdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0QWN0aXZhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEFjdGl2YXRpb24oYWN0aXZhdGlvbikge1xuICAgICAgdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbiA/IGFjdGl2YXRpb24gOiB0aGlzLmFjdGl2YXRpb247XG4gICAgICBzd2l0Y2ggKHRoaXMuYWN0aXZhdGlvbikge1xuICAgICAgICBjYXNlICdzaWdtb2lkJzpcbiAgICAgICAgICB0aGlzLnJ1bklucHV0ID0gdGhpcy5ydW5JbnB1dCB8fCB0aGlzLl9ydW5JbnB1dFNpZ21vaWQ7XG4gICAgICAgICAgdGhpcy5jYWxjdWxhdGVEZWx0YXMgPSB0aGlzLmNhbGN1bGF0ZURlbHRhcyB8fCB0aGlzLl9jYWxjdWxhdGVEZWx0YXNTaWdtb2lkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyZWx1JzpcbiAgICAgICAgICB0aGlzLnJ1bklucHV0ID0gdGhpcy5ydW5JbnB1dCB8fCB0aGlzLl9ydW5JbnB1dFJlbHU7XG4gICAgICAgICAgdGhpcy5jYWxjdWxhdGVEZWx0YXMgPSB0aGlzLmNhbGN1bGF0ZURlbHRhcyB8fCB0aGlzLl9jYWxjdWxhdGVEZWx0YXNSZWx1O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWFreS1yZWx1JzpcbiAgICAgICAgICB0aGlzLnJ1bklucHV0ID0gdGhpcy5ydW5JbnB1dCB8fCB0aGlzLl9ydW5JbnB1dExlYWt5UmVsdTtcbiAgICAgICAgICB0aGlzLmNhbGN1bGF0ZURlbHRhcyA9IHRoaXMuY2FsY3VsYXRlRGVsdGFzIHx8IHRoaXMuX2NhbGN1bGF0ZURlbHRhc0xlYWt5UmVsdTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGFuaCc6XG4gICAgICAgICAgdGhpcy5ydW5JbnB1dCA9IHRoaXMucnVuSW5wdXQgfHwgdGhpcy5fcnVuSW5wdXRUYW5oO1xuICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRGVsdGFzID0gdGhpcy5jYWxjdWxhdGVEZWx0YXMgfHwgdGhpcy5fY2FsY3VsYXRlRGVsdGFzVGFuaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYWN0aXZhdGlvbiAnICsgdGhpcy5hY3RpdmF0aW9uICsgJywgVGhlIGFjdGl2YXRpb24gc2hvdWxkIGJlIG9uZSBvZiBbXFwnc2lnbW9pZFxcJywgXFwncmVsdVxcJywgXFwnbGVha3ktcmVsdVxcJywgXFwndGFuaFxcJ10nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncnVuJyxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKGlucHV0KSB7XG4gICAgICBpZiAoIXRoaXMuaXNSdW5uYWJsZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodGhpcy5pbnB1dExvb2t1cCkge1xuICAgICAgICBpbnB1dCA9IF9sb29rdXAzLmRlZmF1bHQudG9BcnJheSh0aGlzLmlucHV0TG9va3VwLCBpbnB1dCwgdGhpcy5pbnB1dExvb2t1cExlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzLnJ1bklucHV0KGlucHV0KS5zbGljZSgwKTtcblxuICAgICAgaWYgKHRoaXMub3V0cHV0TG9va3VwKSB7XG4gICAgICAgIG91dHB1dCA9IF9sb29rdXAzLmRlZmF1bHQudG9PYmplY3QodGhpcy5vdXRwdXRMb29rdXAsIG91dHB1dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyYWlucyB2aWEgc2lnbW9pZFxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfcnVuSW5wdXRTaWdtb2lkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1bklucHV0U2lnbW9pZChpbnB1dCkge1xuICAgICAgdGhpcy5vdXRwdXRzWzBdID0gaW5wdXQ7IC8vIHNldCBvdXRwdXQgc3RhdGUgb2YgaW5wdXQgbGF5ZXJcblxuICAgICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBsYXllciA9IDE7IGxheWVyIDw9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyKyspIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IDA7IG5vZGUgPCB0aGlzLnNpemVzW2xheWVyXTsgbm9kZSsrKSB7XG4gICAgICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLndlaWdodHNbbGF5ZXJdW25vZGVdO1xuXG4gICAgICAgICAgdmFyIHN1bSA9IHRoaXMuYmlhc2VzW2xheWVyXVtub2RlXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHdlaWdodHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB3ZWlnaHRzW2tdICogaW5wdXRba107XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vc2lnbW9pZFxuICAgICAgICAgIHRoaXMub3V0cHV0c1tsYXllcl1bbm9kZV0gPSAxIC8gKDEgKyBNYXRoLmV4cCgtc3VtKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0gaW5wdXQgPSB0aGlzLm91dHB1dHNbbGF5ZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcnVuSW5wdXRSZWx1JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1bklucHV0UmVsdShpbnB1dCkge1xuICAgICAgdGhpcy5vdXRwdXRzWzBdID0gaW5wdXQ7IC8vIHNldCBvdXRwdXQgc3RhdGUgb2YgaW5wdXQgbGF5ZXJcblxuICAgICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBsYXllciA9IDE7IGxheWVyIDw9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyKyspIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IDA7IG5vZGUgPCB0aGlzLnNpemVzW2xheWVyXTsgbm9kZSsrKSB7XG4gICAgICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLndlaWdodHNbbGF5ZXJdW25vZGVdO1xuXG4gICAgICAgICAgdmFyIHN1bSA9IHRoaXMuYmlhc2VzW2xheWVyXVtub2RlXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHdlaWdodHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB3ZWlnaHRzW2tdICogaW5wdXRba107XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vcmVsdVxuICAgICAgICAgIHRoaXMub3V0cHV0c1tsYXllcl1bbm9kZV0gPSBzdW0gPCAwID8gMCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBpbnB1dCA9IHRoaXMub3V0cHV0c1tsYXllcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19ydW5JbnB1dExlYWt5UmVsdScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW5JbnB1dExlYWt5UmVsdShpbnB1dCkge1xuICAgICAgdGhpcy5vdXRwdXRzWzBdID0gaW5wdXQ7IC8vIHNldCBvdXRwdXQgc3RhdGUgb2YgaW5wdXQgbGF5ZXJcbiAgICAgIHZhciBhbHBoYSA9IHRoaXMubGVha3lSZWx1QWxwaGE7XG4gICAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGxheWVyID0gMTsgbGF5ZXIgPD0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIrKykge1xuICAgICAgICBmb3IgKHZhciBub2RlID0gMDsgbm9kZSA8IHRoaXMuc2l6ZXNbbGF5ZXJdOyBub2RlKyspIHtcbiAgICAgICAgICB2YXIgd2VpZ2h0cyA9IHRoaXMud2VpZ2h0c1tsYXllcl1bbm9kZV07XG5cbiAgICAgICAgICB2YXIgc3VtID0gdGhpcy5iaWFzZXNbbGF5ZXJdW25vZGVdO1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgd2VpZ2h0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgc3VtICs9IHdlaWdodHNba10gKiBpbnB1dFtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9sZWFreSByZWx1XG4gICAgICAgICAgdGhpcy5vdXRwdXRzW2xheWVyXVtub2RlXSA9IHN1bSA8IDAgPyAwIDogYWxwaGEgKiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0gaW5wdXQgPSB0aGlzLm91dHB1dHNbbGF5ZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcnVuSW5wdXRUYW5oJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1bklucHV0VGFuaChpbnB1dCkge1xuICAgICAgdGhpcy5vdXRwdXRzWzBdID0gaW5wdXQ7IC8vIHNldCBvdXRwdXQgc3RhdGUgb2YgaW5wdXQgbGF5ZXJcblxuICAgICAgdmFyIG91dHB1dCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBsYXllciA9IDE7IGxheWVyIDw9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyKyspIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IDA7IG5vZGUgPCB0aGlzLnNpemVzW2xheWVyXTsgbm9kZSsrKSB7XG4gICAgICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLndlaWdodHNbbGF5ZXJdW25vZGVdO1xuXG4gICAgICAgICAgdmFyIHN1bSA9IHRoaXMuYmlhc2VzW2xheWVyXVtub2RlXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHdlaWdodHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN1bSArPSB3ZWlnaHRzW2tdICogaW5wdXRba107XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdGFuaFxuICAgICAgICAgIHRoaXMub3V0cHV0c1tsYXllcl1bbm9kZV0gPSBNYXRoLnRhbmgoc3VtKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSBpbnB1dCA9IHRoaXMub3V0cHV0c1tsYXllcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBWZXJpZmllcyBuZXR3b3JrIHNpemVzIGFyZSBpbml0aWFsaXplZFxuICAgICAqIElmIHRoZXkgYXJlIG5vdCBpdCB3aWxsIGluaXRpYWxpemUgdGhlbSBiYXNlZCBvZmYgdGhlIGRhdGEgc2V0LlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnlJc0luaXRpYWxpemVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5SXNJbml0aWFsaXplZChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zaXplcykgcmV0dXJuO1xuXG4gICAgICB0aGlzLnNpemVzID0gW107XG4gICAgICB0aGlzLnNpemVzLnB1c2goZGF0YVswXS5pbnB1dC5sZW5ndGgpO1xuICAgICAgaWYgKCF0aGlzLmhpZGRlbkxheWVycykge1xuICAgICAgICB0aGlzLnNpemVzLnB1c2goTWF0aC5tYXgoMywgTWF0aC5mbG9vcihkYXRhWzBdLmlucHV0Lmxlbmd0aCAvIDIpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGRlbkxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgX3RoaXMuc2l6ZXMucHVzaChzaXplKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpemVzLnB1c2goZGF0YVswXS5vdXRwdXQubGVuZ3RoKTtcblxuICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqICAgIFN1cHBvcnRzIGFsbCBgdHJhaW5EZWZhdWx0c2AgcHJvcGVydGllc1xuICAgICAqICAgIGFsc28gc3VwcG9ydHM6XG4gICAgICogICAgICAgbGVhcm5pbmdSYXRlOiAobnVtYmVyKSxcbiAgICAgKiAgICAgICBtb21lbnR1bTogKG51bWJlciksXG4gICAgICogICAgICAgYWN0aXZhdGlvbjogJ3NpZ21vaWQnLCAncmVsdScsICdsZWFreS1yZWx1JywgJ3RhbmgnXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZVRyYWluaW5nT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVRyYWluaW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgdHJhaW5EZWZhdWx0cyA9IHRoaXMuY29uc3RydWN0b3IudHJhaW5EZWZhdWx0cztcbiAgICAgIGZvciAodmFyIHAgaW4gdHJhaW5EZWZhdWx0cykge1xuICAgICAgICBpZiAoIXRyYWluRGVmYXVsdHMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLnRyYWluT3B0c1twXSA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkocCkgPyBvcHRpb25zW3BdIDogdHJhaW5EZWZhdWx0c1twXTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGVUcmFpbmluZ09wdGlvbnModGhpcy50cmFpbk9wdHMpO1xuICAgICAgdGhpcy5zZXRMb2dNZXRob2Qob3B0aW9ucy5sb2cgfHwgdGhpcy50cmFpbk9wdHMubG9nKTtcbiAgICAgIHRoaXMuYWN0aXZhdGlvbiA9IG9wdGlvbnMuYWN0aXZhdGlvbiB8fCB0aGlzLmFjdGl2YXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2YWxpZGF0ZVRyYWluaW5nT3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlVHJhaW5pbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciB2YWxpZGF0aW9ucyA9IHtcbiAgICAgICAgaXRlcmF0aW9uczogZnVuY3Rpb24gaXRlcmF0aW9ucyh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgdmFsID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JUaHJlc2g6IGZ1bmN0aW9uIGVycm9yVGhyZXNoKHZhbCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgPiAwICYmIHZhbCA8IDE7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZzogZnVuY3Rpb24gbG9nKHZhbCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbiAgICAgICAgfSxcbiAgICAgICAgbG9nUGVyaW9kOiBmdW5jdGlvbiBsb2dQZXJpb2QodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxlYXJuaW5nUmF0ZTogZnVuY3Rpb24gbGVhcm5pbmdSYXRlKHZhbCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgPiAwICYmIHZhbCA8IDE7XG4gICAgICAgIH0sXG4gICAgICAgIG1vbWVudHVtOiBmdW5jdGlvbiBtb21lbnR1bSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgdmFsID4gMCAmJiB2YWwgPCAxO1xuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgdmFsID09PSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBjYWxsYmFja1BlcmlvZDogZnVuY3Rpb24gY2FsbGJhY2tQZXJpb2QodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIHRpbWVvdXQodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCA+IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBwIGluIHZhbGlkYXRpb25zKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb25zW3BdKG9wdGlvbnNbcF0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbJyArIHAgKyAnLCAnICsgb3B0aW9uc1twXSArICddIGlzIG91dCBvZiBub3JtYWwgdHJhaW5pbmcgcmFuZ2UsIHlvdXIgbmV0d29yayB3aWxsIHByb2JhYmx5IG5vdCB0cmFpbi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEdldHMgSlNPTiBvZiB0cmFpbk9wdHMgb2JqZWN0XG4gICAgICogICAgTk9URTogQWN0aXZhdGlvbiBpcyBzdG9yZWQgZGlyZWN0bHkgb24gSlNPTiBvYmplY3QgYW5kIG5vdCBpbiB0aGUgdHJhaW5pbmcgb3B0aW9uc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRUcmFpbk9wdHNKU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhaW5PcHRzSlNPTigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci50cmFpbkRlZmF1bHRzKS5yZWR1Y2UoZnVuY3Rpb24gKG9wdHMsIG9wdCkge1xuICAgICAgICBpZiAob3B0ID09PSAndGltZW91dCcgJiYgX3RoaXMyLnRyYWluT3B0c1tvcHRdID09PSBJbmZpbml0eSkgcmV0dXJuIG9wdHM7XG4gICAgICAgIGlmIChvcHQgPT09ICdjYWxsYmFjaycpIHJldHVybiBvcHRzO1xuICAgICAgICBpZiAoX3RoaXMyLnRyYWluT3B0c1tvcHRdKSBvcHRzW29wdF0gPSBfdGhpczIudHJhaW5PcHRzW29wdF07XG4gICAgICAgIGlmIChvcHQgPT09ICdsb2cnKSBvcHRzLmxvZyA9IHR5cGVvZiBvcHRzLmxvZyA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9nXG4gICAgICogaWYgYSBtZXRob2QgaXMgcGFzc2VkIGluIG1ldGhvZCBpcyB1c2VkXG4gICAgICogaWYgZmFsc2UgcGFzc2VkIGluIG5vdGhpbmcgaXMgbG9nZ2VkXG4gICAgICogQHJldHVybnMgZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0TG9nTWV0aG9kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TG9nTWV0aG9kKGxvZykge1xuICAgICAgaWYgKHR5cGVvZiBsb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy50cmFpbk9wdHMubG9nID0gbG9nO1xuICAgICAgfSBlbHNlIGlmIChsb2cpIHtcbiAgICAgICAgdGhpcy50cmFpbk9wdHMubG9nID0gY29uc29sZS5sb2c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYWluT3B0cy5sb2cgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge051bWJlcn0gZXJyb3JcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2FsY3VsYXRlVHJhaW5pbmdFcnJvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVRyYWluaW5nRXJyb3IoZGF0YSkge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc3VtICs9IHRoaXMudHJhaW5QYXR0ZXJuKGRhdGFbaV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bSAvIGRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluUGF0dGVybnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFpblBhdHRlcm5zKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLnRyYWluUGF0dGVybihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN0YXR1cyB7IGl0ZXJhdGlvbnM6IG51bWJlciwgZXJyb3I6IG51bWJlciB9XG4gICAgICogQHBhcmFtIGVuZFRpbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHJhaW5pbmdUaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW5pbmdUaWNrKGRhdGEsIHN0YXR1cywgZW5kVGltZSkge1xuICAgICAgaWYgKHN0YXR1cy5pdGVyYXRpb25zID49IHRoaXMudHJhaW5PcHRzLml0ZXJhdGlvbnMgfHwgc3RhdHVzLmVycm9yIDw9IHRoaXMudHJhaW5PcHRzLmVycm9yVGhyZXNoIHx8IERhdGUubm93KCkgPj0gZW5kVGltZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cy5pdGVyYXRpb25zKys7XG5cbiAgICAgIGlmICh0aGlzLnRyYWluT3B0cy5sb2cgJiYgc3RhdHVzLml0ZXJhdGlvbnMgJSB0aGlzLnRyYWluT3B0cy5sb2dQZXJpb2QgPT09IDApIHtcbiAgICAgICAgc3RhdHVzLmVycm9yID0gdGhpcy5jYWxjdWxhdGVUcmFpbmluZ0Vycm9yKGRhdGEpO1xuICAgICAgICB0aGlzLnRyYWluT3B0cy5sb2coJ2l0ZXJhdGlvbnM6ICcgKyBzdGF0dXMuaXRlcmF0aW9ucyArICcsIHRyYWluaW5nIGVycm9yOiAnICsgc3RhdHVzLmVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMuaXRlcmF0aW9ucyAlIHRoaXMuZXJyb3JDaGVja0ludGVydmFsID09PSAwKSB7XG4gICAgICAgICAgc3RhdHVzLmVycm9yID0gdGhpcy5jYWxjdWxhdGVUcmFpbmluZ0Vycm9yKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudHJhaW5QYXR0ZXJucyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50cmFpbk9wdHMuY2FsbGJhY2sgJiYgc3RhdHVzLml0ZXJhdGlvbnMgJSB0aGlzLnRyYWluT3B0cy5jYWxsYmFja1BlcmlvZCA9PT0gMCkge1xuICAgICAgICB0aGlzLnRyYWluT3B0cy5jYWxsYmFjayh7XG4gICAgICAgICAgaXRlcmF0aW9uczogc3RhdHVzLml0ZXJhdGlvbnMsXG4gICAgICAgICAgZXJyb3I6IHN0YXR1cy5lcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHsgZGF0YSwgc3RhdHVzLCBlbmRUaW1lIH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJlcFRyYWluaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcFRyYWluaW5nKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhaW5pbmdPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgZGF0YSA9IHRoaXMuZm9ybWF0RGF0YShkYXRhKTtcbiAgICAgIHZhciBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHRoaXMudHJhaW5PcHRzLnRpbWVvdXQ7XG5cbiAgICAgIHZhciBzdGF0dXMgPSB7XG4gICAgICAgIGVycm9yOiAxLFxuICAgICAgICBpdGVyYXRpb25zOiAwXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnZlcmlmeUlzSW5pdGlhbGl6ZWQoZGF0YSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBlbmRUaW1lOiBlbmRUaW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHtlcnJvcjogbnVtYmVyLCBpdGVyYXRpb25zOiBudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW4oZGF0YSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICB2YXIgc3RhdHVzID0gdm9pZCAwLFxuICAgICAgICAgIGVuZFRpbWUgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBfcHJlcFRyYWluaW5nID0gdGhpcy5wcmVwVHJhaW5pbmcoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgIGRhdGEgPSBfcHJlcFRyYWluaW5nLmRhdGE7XG4gICAgICBzdGF0dXMgPSBfcHJlcFRyYWluaW5nLnN0YXR1cztcbiAgICAgIGVuZFRpbWUgPSBfcHJlcFRyYWluaW5nLmVuZFRpbWU7XG5cblxuICAgICAgd2hpbGUgKHRoaXMudHJhaW5pbmdUaWNrKGRhdGEsIHN0YXR1cywgZW5kVGltZSkpIHt9XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqIEByZXNvbHZlcyB7e2Vycm9yOiBudW1iZXIsIGl0ZXJhdGlvbnM6IG51bWJlcn19XG4gICAgICogQHJlamVjdHMge3t0cmFpbkVycm9yOiBzdHJpbmcsIHN0YXR1czoge2Vycm9yOiBudW1iZXIsIGl0ZXJhdGlvbnM6IG51bWJlcn19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluQXN5bmMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFpbkFzeW5jKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciBzdGF0dXMgPSB2b2lkIDAsXG4gICAgICAgICAgZW5kVGltZSA9IHZvaWQgMDtcblxuICAgICAgdmFyIF9wcmVwVHJhaW5pbmcyID0gdGhpcy5wcmVwVHJhaW5pbmcoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgIGRhdGEgPSBfcHJlcFRyYWluaW5nMi5kYXRhO1xuICAgICAgc3RhdHVzID0gX3ByZXBUcmFpbmluZzIuc3RhdHVzO1xuICAgICAgZW5kVGltZSA9IF9wcmVwVHJhaW5pbmcyLmVuZFRpbWU7XG5cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdGhhd2VkVHJhaW4gPSBuZXcgX3RoYXcyLmRlZmF1bHQobmV3IEFycmF5KF90aGlzMy50cmFpbk9wdHMuaXRlcmF0aW9ucyksIHtcbiAgICAgICAgICAgIGRlbGF5OiB0cnVlLFxuICAgICAgICAgICAgZWFjaDogZnVuY3Rpb24gZWFjaCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy50cmFpbmluZ1RpY2soZGF0YSwgc3RhdHVzLCBlbmRUaW1lKSB8fCB0aGF3ZWRUcmFpbi5zdG9wKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGF3ZWRUcmFpbi50aWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHRyYWluRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoeyB0cmFpbkVycm9yOiB0cmFpbkVycm9yLCBzdGF0dXM6IHN0YXR1cyB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb2dFcnJvclJhdGVdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RyYWluUGF0dGVybicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWluUGF0dGVybih2YWx1ZSwgbG9nRXJyb3JSYXRlKSB7XG4gICAgICAvLyBmb3J3YXJkIHByb3BhZ2F0ZVxuICAgICAgdGhpcy5ydW5JbnB1dCh2YWx1ZS5pbnB1dCk7XG5cbiAgICAgIC8vIGJhY2sgcHJvcGFnYXRlXG4gICAgICB0aGlzLmNhbGN1bGF0ZURlbHRhcyh2YWx1ZS5vdXRwdXQpO1xuICAgICAgdGhpcy5hZGp1c3RXZWlnaHRzKCk7XG5cbiAgICAgIGlmIChsb2dFcnJvclJhdGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfbXNlMi5kZWZhdWx0KSh0aGlzLmVycm9yc1t0aGlzLm91dHB1dExheWVyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NhbGN1bGF0ZURlbHRhc1NpZ21vaWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRGVsdGFzU2lnbW9pZCh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIgPj0gMDsgbGF5ZXItLSkge1xuICAgICAgICBmb3IgKHZhciBub2RlID0gMDsgbm9kZSA8IHRoaXMuc2l6ZXNbbGF5ZXJdOyBub2RlKyspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2xheWVyXVtub2RlXTtcblxuICAgICAgICAgIHZhciBlcnJvciA9IDA7XG4gICAgICAgICAgaWYgKGxheWVyID09PSB0aGlzLm91dHB1dExheWVyKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRhcmdldFtub2RlXSAtIG91dHB1dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlbHRhcyA9IHRoaXMuZGVsdGFzW2xheWVyICsgMV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRlbHRhcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBlcnJvciArPSBkZWx0YXNba10gKiB0aGlzLndlaWdodHNbbGF5ZXIgKyAxXVtrXVtub2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lcnJvcnNbbGF5ZXJdW25vZGVdID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5kZWx0YXNbbGF5ZXJdW25vZGVdID0gZXJyb3IgKiBvdXRwdXQgKiAoMSAtIG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NhbGN1bGF0ZURlbHRhc1JlbHUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRGVsdGFzUmVsdSh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIgPj0gMDsgbGF5ZXItLSkge1xuICAgICAgICBmb3IgKHZhciBub2RlID0gMDsgbm9kZSA8IHRoaXMuc2l6ZXNbbGF5ZXJdOyBub2RlKyspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2xheWVyXVtub2RlXTtcblxuICAgICAgICAgIHZhciBlcnJvciA9IDA7XG4gICAgICAgICAgaWYgKGxheWVyID09PSB0aGlzLm91dHB1dExheWVyKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRhcmdldFtub2RlXSAtIG91dHB1dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlbHRhcyA9IHRoaXMuZGVsdGFzW2xheWVyICsgMV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRlbHRhcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBlcnJvciArPSBkZWx0YXNba10gKiB0aGlzLndlaWdodHNbbGF5ZXIgKyAxXVtrXVtub2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lcnJvcnNbbGF5ZXJdW25vZGVdID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5kZWx0YXNbbGF5ZXJdW25vZGVdID0gb3V0cHV0ID4gMCA/IGVycm9yIDogMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdfY2FsY3VsYXRlRGVsdGFzTGVha3lSZWx1JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZURlbHRhc0xlYWt5UmVsdSh0YXJnZXQpIHtcbiAgICAgIHZhciBhbHBoYSA9IHRoaXMubGVha3lSZWx1QWxwaGE7XG4gICAgICBmb3IgKHZhciBsYXllciA9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyID49IDA7IGxheWVyLS0pIHtcbiAgICAgICAgZm9yICh2YXIgbm9kZSA9IDA7IG5vZGUgPCB0aGlzLnNpemVzW2xheWVyXTsgbm9kZSsrKSB7XG4gICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMub3V0cHV0c1tsYXllcl1bbm9kZV07XG5cbiAgICAgICAgICB2YXIgZXJyb3IgPSAwO1xuICAgICAgICAgIGlmIChsYXllciA9PT0gdGhpcy5vdXRwdXRMYXllcikge1xuICAgICAgICAgICAgZXJyb3IgPSB0YXJnZXRbbm9kZV0gLSBvdXRwdXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZWx0YXMgPSB0aGlzLmRlbHRhc1tsYXllciArIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBkZWx0YXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgZXJyb3IgKz0gZGVsdGFzW2tdICogdGhpcy53ZWlnaHRzW2xheWVyICsgMV1ba11bbm9kZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXJyb3JzW2xheWVyXVtub2RlXSA9IGVycm9yO1xuICAgICAgICAgIHRoaXMuZGVsdGFzW2xheWVyXVtub2RlXSA9IG91dHB1dCA+IDAgPyBlcnJvciA6IGFscGhhICogZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX2NhbGN1bGF0ZURlbHRhc1RhbmgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRGVsdGFzVGFuaCh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIgPj0gMDsgbGF5ZXItLSkge1xuICAgICAgICBmb3IgKHZhciBub2RlID0gMDsgbm9kZSA8IHRoaXMuc2l6ZXNbbGF5ZXJdOyBub2RlKyspIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5vdXRwdXRzW2xheWVyXVtub2RlXTtcblxuICAgICAgICAgIHZhciBlcnJvciA9IDA7XG4gICAgICAgICAgaWYgKGxheWVyID09PSB0aGlzLm91dHB1dExheWVyKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRhcmdldFtub2RlXSAtIG91dHB1dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlbHRhcyA9IHRoaXMuZGVsdGFzW2xheWVyICsgMV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRlbHRhcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBlcnJvciArPSBkZWx0YXNba10gKiB0aGlzLndlaWdodHNbbGF5ZXIgKyAxXVtrXVtub2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lcnJvcnNbbGF5ZXJdW25vZGVdID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5kZWx0YXNbbGF5ZXJdW25vZGVdID0gKDEgLSBvdXRwdXQgKiBvdXRwdXQpICogZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoYW5nZXMgd2VpZ2h0cyBvZiBuZXR3b3Jrc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGp1c3RXZWlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0V2VpZ2h0cygpIHtcbiAgICAgIGZvciAodmFyIGxheWVyID0gMTsgbGF5ZXIgPD0gdGhpcy5vdXRwdXRMYXllcjsgbGF5ZXIrKykge1xuICAgICAgICB2YXIgaW5jb21pbmcgPSB0aGlzLm91dHB1dHNbbGF5ZXIgLSAxXTtcblxuICAgICAgICBmb3IgKHZhciBub2RlID0gMDsgbm9kZSA8IHRoaXMuc2l6ZXNbbGF5ZXJdOyBub2RlKyspIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLmRlbHRhc1tsYXllcl1bbm9kZV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGluY29taW5nLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gdGhpcy5jaGFuZ2VzW2xheWVyXVtub2RlXVtrXTtcblxuICAgICAgICAgICAgY2hhbmdlID0gdGhpcy50cmFpbk9wdHMubGVhcm5pbmdSYXRlICogZGVsdGEgKiBpbmNvbWluZ1trXSArIHRoaXMudHJhaW5PcHRzLm1vbWVudHVtICogY2hhbmdlO1xuXG4gICAgICAgICAgICB0aGlzLmNoYW5nZXNbbGF5ZXJdW25vZGVdW2tdID0gY2hhbmdlO1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRzW2xheWVyXVtub2RlXVtrXSArPSBjaGFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYmlhc2VzW2xheWVyXVtub2RlXSArPSB0aGlzLnRyYWluT3B0cy5sZWFybmluZ1JhdGUgKiBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19zZXR1cEFkYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBBZGFtKCkge1xuICAgICAgdGhpcy5iaWFzQ2hhbmdlc0xvdyA9IFtdO1xuICAgICAgdGhpcy5iaWFzQ2hhbmdlc0hpZ2ggPSBbXTtcbiAgICAgIHRoaXMuY2hhbmdlc0xvdyA9IFtdO1xuICAgICAgdGhpcy5jaGFuZ2VzSGlnaCA9IFtdO1xuICAgICAgdGhpcy5pdGVyYXRpb25zID0gMDtcblxuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAwOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplc1tsYXllcl07XG4gICAgICAgIGlmIChsYXllciA+IDApIHtcbiAgICAgICAgICB0aGlzLmJpYXNDaGFuZ2VzTG93W2xheWVyXSA9ICgwLCBfemVyb3MyLmRlZmF1bHQpKHNpemUpO1xuICAgICAgICAgIHRoaXMuYmlhc0NoYW5nZXNIaWdoW2xheWVyXSA9ICgwLCBfemVyb3MyLmRlZmF1bHQpKHNpemUpO1xuICAgICAgICAgIHRoaXMuY2hhbmdlc0xvd1tsYXllcl0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VzSGlnaFtsYXllcl0gPSBuZXcgQXJyYXkoc2l6ZSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBub2RlID0gMDsgbm9kZSA8IHNpemU7IG5vZGUrKykge1xuICAgICAgICAgICAgdmFyIHByZXZTaXplID0gdGhpcy5zaXplc1tsYXllciAtIDFdO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzTG93W2xheWVyXVtub2RlXSA9ICgwLCBfemVyb3MyLmRlZmF1bHQpKHByZXZTaXplKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlc0hpZ2hbbGF5ZXJdW25vZGVdID0gKDAsIF96ZXJvczIuZGVmYXVsdCkocHJldlNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFkanVzdFdlaWdodHMgPSB0aGlzLl9hZGp1c3RXZWlnaHRzQWRhbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfYWRqdXN0V2VpZ2h0c0FkYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRqdXN0V2VpZ2h0c0FkYW0oKSB7XG4gICAgICB2YXIgdHJhaW5PcHRzID0gdGhpcy50cmFpbk9wdHM7XG4gICAgICB0aGlzLml0ZXJhdGlvbnMrKztcblxuICAgICAgZm9yICh2YXIgbGF5ZXIgPSAxOyBsYXllciA8PSB0aGlzLm91dHB1dExheWVyOyBsYXllcisrKSB7XG4gICAgICAgIHZhciBpbmNvbWluZyA9IHRoaXMub3V0cHV0c1tsYXllciAtIDFdO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGUgPSAwOyBub2RlIDwgdGhpcy5zaXplc1tsYXllcl07IG5vZGUrKykge1xuICAgICAgICAgIHZhciBkZWx0YSA9IHRoaXMuZGVsdGFzW2xheWVyXVtub2RlXTtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5jb21pbmcubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IGRlbHRhICogaW5jb21pbmdba107XG4gICAgICAgICAgICB2YXIgY2hhbmdlTG93ID0gdGhpcy5jaGFuZ2VzTG93W2xheWVyXVtub2RlXVtrXSAqIHRyYWluT3B0cy5iZXRhMSArICgxIC0gdHJhaW5PcHRzLmJldGExKSAqIGdyYWRpZW50O1xuICAgICAgICAgICAgdmFyIGNoYW5nZUhpZ2ggPSB0aGlzLmNoYW5nZXNIaWdoW2xheWVyXVtub2RlXVtrXSAqIHRyYWluT3B0cy5iZXRhMiArICgxIC0gdHJhaW5PcHRzLmJldGEyKSAqIGdyYWRpZW50ICogZ3JhZGllbnQ7XG5cbiAgICAgICAgICAgIHZhciBtb21lbnR1bUNvcnJlY3Rpb24gPSBjaGFuZ2VMb3cgLyAoMSAtIE1hdGgucG93KHRyYWluT3B0cy5iZXRhMSwgdGhpcy5pdGVyYXRpb25zKSk7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRDb3JyZWN0aW9uID0gY2hhbmdlSGlnaCAvICgxIC0gTWF0aC5wb3codHJhaW5PcHRzLmJldGEyLCB0aGlzLml0ZXJhdGlvbnMpKTtcblxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzTG93W2xheWVyXVtub2RlXVtrXSA9IGNoYW5nZUxvdztcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlc0hpZ2hbbGF5ZXJdW25vZGVdW2tdID0gY2hhbmdlSGlnaDtcbiAgICAgICAgICAgIHRoaXMud2VpZ2h0c1tsYXllcl1bbm9kZV1ba10gKz0gdGhpcy50cmFpbk9wdHMubGVhcm5pbmdSYXRlICogbW9tZW50dW1Db3JyZWN0aW9uIC8gKE1hdGguc3FydChncmFkaWVudENvcnJlY3Rpb24pICsgdHJhaW5PcHRzLmVwc2lsb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBiaWFzR3JhZGllbnQgPSB0aGlzLmRlbHRhc1tsYXllcl1bbm9kZV07XG4gICAgICAgICAgdmFyIGJpYXNDaGFuZ2VMb3cgPSB0aGlzLmJpYXNDaGFuZ2VzTG93W2xheWVyXVtub2RlXSAqIHRyYWluT3B0cy5iZXRhMSArICgxIC0gdHJhaW5PcHRzLmJldGExKSAqIGJpYXNHcmFkaWVudDtcbiAgICAgICAgICB2YXIgYmlhc0NoYW5nZUhpZ2ggPSB0aGlzLmJpYXNDaGFuZ2VzSGlnaFtsYXllcl1bbm9kZV0gKiB0cmFpbk9wdHMuYmV0YTIgKyAoMSAtIHRyYWluT3B0cy5iZXRhMikgKiBiaWFzR3JhZGllbnQgKiBiaWFzR3JhZGllbnQ7XG5cbiAgICAgICAgICB2YXIgYmlhc01vbWVudHVtQ29ycmVjdGlvbiA9IHRoaXMuYmlhc0NoYW5nZXNMb3dbbGF5ZXJdW25vZGVdIC8gKDEgLSBNYXRoLnBvdyh0cmFpbk9wdHMuYmV0YTEsIHRoaXMuaXRlcmF0aW9ucykpO1xuICAgICAgICAgIHZhciBiaWFzR3JhZGllbnRDb3JyZWN0aW9uID0gdGhpcy5iaWFzQ2hhbmdlc0hpZ2hbbGF5ZXJdW25vZGVdIC8gKDEgLSBNYXRoLnBvdyh0cmFpbk9wdHMuYmV0YTIsIHRoaXMuaXRlcmF0aW9ucykpO1xuXG4gICAgICAgICAgdGhpcy5iaWFzQ2hhbmdlc0xvd1tsYXllcl1bbm9kZV0gPSBiaWFzQ2hhbmdlTG93O1xuICAgICAgICAgIHRoaXMuYmlhc0NoYW5nZXNIaWdoW2xheWVyXVtub2RlXSA9IGJpYXNDaGFuZ2VIaWdoO1xuICAgICAgICAgIHRoaXMuYmlhc2VzW2xheWVyXVtub2RlXSArPSB0cmFpbk9wdHMubGVhcm5pbmdSYXRlICogYmlhc01vbWVudHVtQ29ycmVjdGlvbiAvIChNYXRoLnNxcnQoYmlhc0dyYWRpZW50Q29ycmVjdGlvbikgKyB0cmFpbk9wdHMuZXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2Zvcm1hdERhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXREYXRhKGRhdGEpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAvLyB0dXJuIHN0cmVhbSBkYXR1bSBpbnRvIGFycmF5XG4gICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhWzBdLmlucHV0KSkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dExvb2t1cCkge1xuICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSBPYmplY3Qua2V5cyh0aGlzLmlucHV0TG9va3VwKS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlucHV0TG9va3VwID0gbmV3IF9sb29rdXBUYWJsZTIuZGVmYXVsdChkYXRhLCAnaW5wdXQnKTtcbiAgICAgICAgICB0aGlzLmlucHV0TG9va3VwID0gaW5wdXRMb29rdXAudGFibGU7XG4gICAgICAgICAgdGhpcy5pbnB1dExvb2t1cExlbmd0aCA9IGlucHV0TG9va3VwLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YVswXS5vdXRwdXQpKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dExvb2t1cCkge1xuICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwTGVuZ3RoID0gT2JqZWN0LmtleXModGhpcy5vdXRwdXRMb29rdXApLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2xvb2t1cCA9IG5ldyBfbG9va3VwVGFibGUyLmRlZmF1bHQoZGF0YSwgJ291dHB1dCcpO1xuICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwID0gX2xvb2t1cC50YWJsZTtcbiAgICAgICAgICB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IF9sb29rdXAubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZm9ybWF0SW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2Zvcm1hdElucHV0ID0gZ2V0VHlwZWRBcnJheUZuKGRhdGFbMF0uaW5wdXQsIHRoaXMuaW5wdXRMb29rdXApO1xuICAgICAgICB0aGlzLl9mb3JtYXRPdXRwdXQgPSBnZXRUeXBlZEFycmF5Rm4oZGF0YVswXS5vdXRwdXQsIHRoaXMub3V0cHV0TG9va3VwKTtcbiAgICAgIH1cblxuICAgICAgLy8gdHVybiBzcGFyc2UgaGFzaCBpbnB1dCBpbnRvIGFycmF5cyB3aXRoIDBzIGFzIGZpbGxlclxuICAgICAgaWYgKHRoaXMuX2Zvcm1hdElucHV0ICYmIHRoaXMuX2Zvcm1hdE91dHB1dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9mb3JtYXRJbnB1dChkYXRhW2ldLmlucHV0KSxcbiAgICAgICAgICAgIG91dHB1dDogdGhpcy5fZm9ybWF0T3V0cHV0KGRhdGFbaV0ub3V0cHV0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2Zvcm1hdElucHV0KSB7XG4gICAgICAgIHZhciBfcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkYXRhLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIF9yZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5fZm9ybWF0SW5wdXQoZGF0YVtfaV0uaW5wdXQpLFxuICAgICAgICAgICAgb3V0cHV0OiBkYXRhW19pXS5vdXRwdXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZm9ybWF0T3V0cHV0KSB7XG4gICAgICAgIHZhciBfcmVzdWx0MiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBkYXRhLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBfcmVzdWx0Mi5wdXNoKHtcbiAgICAgICAgICAgIGlucHV0OiBkYXRhW19pMl0uaW5wdXQsXG4gICAgICAgICAgICBvdXRwdXQ6IHRoaXMuX2Zvcm1hdE91dHB1dChkYXRhW19pMl0ub3V0cHV0KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0MjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZEZvcm1hdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvcm1hdChkYXRhKSB7XG4gICAgICB0aGlzLmlucHV0TG9va3VwID0gX2xvb2t1cDMuZGVmYXVsdC5hZGRLZXlzKGRhdGEuaW5wdXQsIHRoaXMuaW5wdXRMb29rdXApO1xuICAgICAgaWYgKHRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgdGhpcy5pbnB1dExvb2t1cExlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuaW5wdXRMb29rdXApLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMub3V0cHV0TG9va3VwID0gX2xvb2t1cDMuZGVmYXVsdC5hZGRLZXlzKGRhdGEub3V0cHV0LCB0aGlzLm91dHB1dExvb2t1cCk7XG4gICAgICBpZiAodGhpcy5vdXRwdXRMb29rdXApIHtcbiAgICAgICAgdGhpcy5vdXRwdXRMb29rdXBMZW5ndGggPSBPYmplY3Qua2V5cyh0aGlzLm91dHB1dExvb2t1cCkubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7XG4gICAgICogIHtcbiAgICAgKiAgICBlcnJvcjogbnVtYmVyLFxuICAgICAqICAgIG1pc2NsYXNzZXM6IEFycmF5LFxuICAgICAqICB9XG4gICAgICogfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChkYXRhKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgZGF0YSA9IHRoaXMuZm9ybWF0RGF0YShkYXRhKTtcbiAgICAgIC8vIGZvciBiaW5hcnkgY2xhc3NpZmljYXRpb24gcHJvYmxlbXMgd2l0aCBvbmUgb3V0cHV0IG5vZGVcbiAgICAgIHZhciBpc0JpbmFyeSA9IGRhdGFbMF0ub3V0cHV0Lmxlbmd0aCA9PT0gMTtcbiAgICAgIC8vIGZvciBjbGFzc2lmaWNhdGlvbiBwcm9ibGVtc1xuICAgICAgdmFyIG1pc2NsYXNzZXMgPSBbXTtcbiAgICAgIC8vIHJ1biBlYWNoIHBhdHRlcm4gdGhyb3VnaCB0aGUgdHJhaW5lZCBuZXR3b3JrIGFuZCBjb2xsZWN0XG4gICAgICAvLyBlcnJvciBhbmQgbWlzY2xhc3NpZmljYXRpb24gc3RhdGlzdGljc1xuICAgICAgdmFyIGVycm9yU3VtID0gMDtcblxuICAgICAgaWYgKGlzQmluYXJ5KSB7XG4gICAgICAgIHZhciBmYWxzZVBvcyA9IDA7XG4gICAgICAgIHZhciBmYWxzZU5lZyA9IDA7XG4gICAgICAgIHZhciB0cnVlUG9zID0gMDtcbiAgICAgICAgdmFyIHRydWVOZWcgPSAwO1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICB2YXIgb3V0cHV0ID0gX3RoaXM0LnJ1bklucHV0KGRhdGFbaV0uaW5wdXQpO1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBkYXRhW2ldLm91dHB1dDtcbiAgICAgICAgICB2YXIgYWN0dWFsID0gb3V0cHV0WzBdID4gX3RoaXM0LmJpbmFyeVRocmVzaCA/IDEgOiAwO1xuICAgICAgICAgIHZhciBleHBlY3RlZCA9IHRhcmdldFswXTtcblxuICAgICAgICAgIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgbWlzY2xhc3MgPSBkYXRhW2ldO1xuICAgICAgICAgICAgbWlzY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgaW5wdXQ6IG1pc2NsYXNzLmlucHV0LFxuICAgICAgICAgICAgICBvdXRwdXQ6IG1pc2NsYXNzLm91dHB1dCxcbiAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdHVhbCA9PT0gMCAmJiBleHBlY3RlZCA9PT0gMCkge1xuICAgICAgICAgICAgdHJ1ZU5lZysrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsID09PSAxICYmIGV4cGVjdGVkID09PSAxKSB7XG4gICAgICAgICAgICB0cnVlUG9zKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IDAgJiYgZXhwZWN0ZWQgPT09IDEpIHtcbiAgICAgICAgICAgIGZhbHNlTmVnKys7XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IDEgJiYgZXhwZWN0ZWQgPT09IDApIHtcbiAgICAgICAgICAgIGZhbHNlUG9zKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3JTdW0gKz0gKDAsIF9tc2UyLmRlZmF1bHQpKG91dHB1dC5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2ldIC0gdmFsdWU7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcjogZXJyb3JTdW0gLyBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBtaXNjbGFzc2VzOiBtaXNjbGFzc2VzLFxuICAgICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB0cnVlTmVnOiB0cnVlTmVnLFxuICAgICAgICAgIHRydWVQb3M6IHRydWVQb3MsXG4gICAgICAgICAgZmFsc2VOZWc6IGZhbHNlTmVnLFxuICAgICAgICAgIGZhbHNlUG9zOiBmYWxzZVBvcyxcbiAgICAgICAgICBwcmVjaXNpb246IHRydWVQb3MgPiAwID8gdHJ1ZVBvcyAvICh0cnVlUG9zICsgZmFsc2VQb3MpIDogMCxcbiAgICAgICAgICByZWNhbGw6IHRydWVQb3MgPiAwID8gdHJ1ZVBvcyAvICh0cnVlUG9zICsgZmFsc2VOZWcpIDogMCxcbiAgICAgICAgICBhY2N1cmFjeTogKHRydWVOZWcgKyB0cnVlUG9zKSAvIGRhdGEubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gX3RoaXM0LnJ1bklucHV0KGRhdGFbaV0uaW5wdXQpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZGF0YVtpXS5vdXRwdXQ7XG4gICAgICAgIHZhciBhY3R1YWwgPSBvdXRwdXQuaW5kZXhPZigoMCwgX21heDIuZGVmYXVsdCkob3V0cHV0KSk7XG4gICAgICAgIHZhciBleHBlY3RlZCA9IHRhcmdldC5pbmRleE9mKCgwLCBfbWF4Mi5kZWZhdWx0KSh0YXJnZXQpKTtcblxuICAgICAgICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgICAgICAgIHZhciBtaXNjbGFzcyA9IGRhdGFbaV07XG4gICAgICAgICAgbWlzY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgIGlucHV0OiBtaXNjbGFzcy5pbnB1dCxcbiAgICAgICAgICAgIG91dHB1dDogbWlzY2xhc3Mub3V0cHV0LFxuICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yU3VtICs9ICgwLCBfbXNlMi5kZWZhdWx0KShvdXRwdXQubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXRbaV0gLSB2YWx1ZTtcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wMihpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBlcnJvclN1bSAvIGRhdGEubGVuZ3RoLFxuICAgICAgICBtaXNjbGFzc2VzOiBtaXNjbGFzc2VzLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqICB7XG4gICAgICogICAgbGF5ZXJzOiBbXG4gICAgICogICAgICB7XG4gICAgICogICAgICAgIHg6IHt9LFxuICAgICAqICAgICAgICB5OiB7fVxuICAgICAqICAgICAgfSxcbiAgICAgKiAgICAgIHtcbiAgICAgKiAgICAgICAgJzAnOiB7XG4gICAgICogICAgICAgICAgYmlhczogLTAuOTg3NzEzMTMsXG4gICAgICogICAgICAgICAgd2VpZ2h0czoge1xuICAgICAqICAgICAgICAgICAgeDogMC44Mzc0ODM4LFxuICAgICAqICAgICAgICAgICAgeTogMS4yNDU4NThcbiAgICAgKiAgICAgICAgICB9LFxuICAgICAqICAgICAgICAnMSc6IHtcbiAgICAgKiAgICAgICAgICBiaWFzOiAzLjQ4MTkyMDA0LFxuICAgICAqICAgICAgICAgIHdlaWdodHM6IHtcbiAgICAgKiAgICAgICAgICAgIHg6IDEuNzgyNTgyMSxcbiAgICAgKiAgICAgICAgICAgIHk6IC0yLjY3ODk5XG4gICAgICogICAgICAgICAgfVxuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9LFxuICAgICAqICAgICAge1xuICAgICAqICAgICAgICBmOiB7XG4gICAgICogICAgICAgICAgYmlhczogMC4yNzIwNTczOSxcbiAgICAgKiAgICAgICAgICB3ZWlnaHRzOiB7XG4gICAgICogICAgICAgICAgICAnMCc6IDEuMzE2MTgyMSxcbiAgICAgKiAgICAgICAgICAgICcxJzogMi4wMDQzNlxuICAgICAqICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgfVxuICAgICAqICAgIF1cbiAgICAgKiAgfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b0pTT04nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgbGF5ZXJzID0gW107XG4gICAgICBmb3IgKHZhciBsYXllciA9IDA7IGxheWVyIDw9IHRoaXMub3V0cHV0TGF5ZXI7IGxheWVyKyspIHtcbiAgICAgICAgbGF5ZXJzW2xheWVyXSA9IHt9O1xuXG4gICAgICAgIHZhciBub2RlcyA9IHZvaWQgMDtcbiAgICAgICAgLy8gdHVybiBhbnkgaW50ZXJuYWwgYXJyYXlzIGJhY2sgaW50byBoYXNoZXMgZm9yIHJlYWRhYmxlIGpzb25cbiAgICAgICAgaWYgKGxheWVyID09PSAwICYmIHRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgICBub2RlcyA9IE9iamVjdC5rZXlzKHRoaXMuaW5wdXRMb29rdXApO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3V0cHV0TG9va3VwICYmIGxheWVyID09PSB0aGlzLm91dHB1dExheWVyKSB7XG4gICAgICAgICAgbm9kZXMgPSBPYmplY3Qua2V5cyh0aGlzLm91dHB1dExvb2t1cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZXMgPSAoMCwgX3JhbmdlMi5kZWZhdWx0KSgwLCB0aGlzLnNpemVzW2xheWVyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgICBsYXllcnNbbGF5ZXJdW25vZGVdID0ge307XG5cbiAgICAgICAgICBpZiAobGF5ZXIgPiAwKSB7XG4gICAgICAgICAgICBsYXllcnNbbGF5ZXJdW25vZGVdLmJpYXMgPSB0aGlzLmJpYXNlc1tsYXllcl1bal07XG4gICAgICAgICAgICBsYXllcnNbbGF5ZXJdW25vZGVdLndlaWdodHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbGF5ZXJzW2xheWVyIC0gMV0pIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaztcbiAgICAgICAgICAgICAgaWYgKGxheWVyID09PSAxICYmIHRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5wdXRMb29rdXBba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGF5ZXJzW2xheWVyXVtub2RlXS53ZWlnaHRzW2tdID0gdGhpcy53ZWlnaHRzW2xheWVyXVtqXVtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogdGhpcy5zaXplcy5zbGljZSgwKSxcbiAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgIG91dHB1dExvb2t1cDogdGhpcy5vdXRwdXRMb29rdXAgIT09IG51bGwsXG4gICAgICAgIGlucHV0TG9va3VwOiB0aGlzLmlucHV0TG9va3VwICE9PSBudWxsLFxuICAgICAgICBhY3RpdmF0aW9uOiB0aGlzLmFjdGl2YXRpb24sXG4gICAgICAgIHRyYWluT3B0czogdGhpcy5nZXRUcmFpbk9wdHNKU09OKClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvblxuICAgICAqIEByZXR1cm5zIHtOZXVyYWxOZXR3b3JrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cywganNvbik7XG4gICAgICB0aGlzLnNpemVzID0ganNvbi5zaXplcztcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB0aGlzLm91dHB1dExheWVyOyBpKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0ganNvbi5sYXllcnNbaV07XG4gICAgICAgIGlmIChpID09PSAwICYmICghbGF5ZXJbMF0gfHwganNvbi5pbnB1dExvb2t1cCkpIHtcbiAgICAgICAgICB0aGlzLmlucHV0TG9va3VwID0gX2xvb2t1cDMuZGVmYXVsdC50b0hhc2gobGF5ZXIpO1xuICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSBPYmplY3Qua2V5cyh0aGlzLmlucHV0TG9va3VwKS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gdGhpcy5vdXRwdXRMYXllciAmJiAoIWxheWVyWzBdIHx8IGpzb24ub3V0cHV0TG9va3VwKSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwID0gX2xvb2t1cDMuZGVmYXVsdC50b0hhc2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHZhciBub2RlcyA9IE9iamVjdC5rZXlzKGxheWVyKTtcbiAgICAgICAgICB0aGlzLnNpemVzW2ldID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGogaW4gbm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbal07XG4gICAgICAgICAgICB0aGlzLmJpYXNlc1tpXVtqXSA9IGxheWVyW25vZGVdLmJpYXM7XG4gICAgICAgICAgICB0aGlzLndlaWdodHNbaV1bal0gPSAoMCwgX3RvQXJyYXkyLmRlZmF1bHQpKGxheWVyW25vZGVdLndlaWdodHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGpzb24uaGFzT3duUHJvcGVydHkoJ3RyYWluT3B0cycpKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhaW5pbmdPcHRpb25zKGpzb24udHJhaW5PcHRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b0Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9GdW5jdGlvbigpIHtcbiAgICAgIHZhciBhY3RpdmF0aW9uID0gdGhpcy5hY3RpdmF0aW9uO1xuICAgICAgdmFyIGxlYWt5UmVsdUFscGhhID0gdGhpcy5sZWFreVJlbHVBbHBoYTtcbiAgICAgIHZhciBuZWVkc1ZhciA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gbm9kZUhhbmRsZShsYXllcnMsIGxheWVyTnVtYmVyLCBub2RlS2V5KSB7XG4gICAgICAgIGlmIChsYXllck51bWJlciA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycgPyAnaW5wdXRbXFwnJyArIG5vZGVLZXkgKyAnXFwnXScgOiAnaW5wdXRbJyArIG5vZGVLZXkgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbbGF5ZXJOdW1iZXJdO1xuICAgICAgICB2YXIgbm9kZSA9IGxheWVyW25vZGVLZXldO1xuICAgICAgICB2YXIgcmVzdWx0ID0gWycoJywgbm9kZS5iaWFzXTtcbiAgICAgICAgZm9yICh2YXIgdyBpbiBub2RlLndlaWdodHMpIHtcbiAgICAgICAgICBpZiAobm9kZS53ZWlnaHRzW3ddIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS53ZWlnaHRzW3ddICsgJyonICsgbm9kZUhhbmRsZShsYXllcnMsIGxheWVyTnVtYmVyIC0gMSwgdykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKycgKyBub2RlLndlaWdodHNbd10gKyAnKicgKyBub2RlSGFuZGxlKGxheWVycywgbGF5ZXJOdW1iZXIgLSAxLCB3KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG5cbiAgICAgICAgc3dpdGNoIChhY3RpdmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnc2lnbW9pZCc6XG4gICAgICAgICAgICByZXR1cm4gJzEvKDErMS9NYXRoLmV4cCgnICsgcmVzdWx0LmpvaW4oJycpICsgJykpJztcbiAgICAgICAgICBjYXNlICdyZWx1JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmVlZHNWYXIgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gJygodj0nICsgcmVzdWx0LmpvaW4oJycpICsgJyk8MD8wOnYpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsZWFreS1yZWx1JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmVlZHNWYXIgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gJygodj0nICsgcmVzdWx0LmpvaW4oJycpICsgJyk8MD8wOicgKyBsZWFreVJlbHVBbHBoYSArICcqdiknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3RhbmgnOlxuICAgICAgICAgICAgcmV0dXJuICdNYXRoLnRhbmgoJyArIHJlc3VsdC5qb2luKCcnKSArICcpJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFjdGl2YXRpb24gdHlwZSAnICsgYWN0aXZhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxheWVycyA9IHRoaXMudG9KU09OKCkubGF5ZXJzO1xuICAgICAgdmFyIGxheWVyc0FzTWF0aCA9IFtdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgaW4gbGF5ZXJzW2xheWVycy5sZW5ndGggLSAxXSkge1xuICAgICAgICBsYXllcnNBc01hdGgucHVzaChub2RlSGFuZGxlKGxheWVycywgbGF5ZXJzLmxlbmd0aCAtIDEsIGkpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm91dHB1dExvb2t1cCkge1xuICAgICAgICByZXN1bHQgPSAneycgKyBPYmplY3Qua2V5cyh0aGlzLm91dHB1dExvb2t1cCkubWFwKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICByZXR1cm4gJ1xcJycgKyBrZXkgKyAnXFwnOicgKyBsYXllcnNBc01hdGhbaV07XG4gICAgICAgIH0pICsgJ30nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gJ1snICsgbGF5ZXJzQXNNYXRoLmpvaW4oJywnKSArICddJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignaW5wdXQnLCAobmVlZHNWYXIgPyAndmFyIHY7JyA6ICcnKSArICdyZXR1cm4gJyArIHJlc3VsdCArICc7Jyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNSdW5uYWJsZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLnJ1bklucHV0KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjdGl2YXRpb24gZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLCBkaWQgeW91IHJ1biB0cmFpbigpPycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja0ZucyA9IFsnc2l6ZXMnLCAnb3V0cHV0TGF5ZXInLCAnYmlhc2VzJywgJ3dlaWdodHMnLCAnb3V0cHV0cycsICdkZWx0YXMnLCAnY2hhbmdlcycsICdlcnJvcnMnXS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNVtjXSA9PT0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2hlY2tGbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTb21lIHNldHRpbmdzIGhhdmUgbm90IGJlZW4gaW5pdGlhbGl6ZWQgY29ycmVjdGx5LCBkaWQgeW91IHJ1biB0cmFpbigpPyBGb3VuZCBpc3N1ZXMgd2l0aDogJyArIGNoZWNrRm5zLmpvaW4oJywgJykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV1cmFsTmV0d29yaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTmV1cmFsTmV0d29yaztcblxuXG5mdW5jdGlvbiBnZXRUeXBlZEFycmF5Rm4odmFsdWUsIHRhYmxlKSB7XG4gIGlmICh2YWx1ZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIF9jYXN0LmFycmF5VG9GbG9hdDMyQXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IE9iamVjdC5rZXlzKHRhYmxlKS5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICB2YXIgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBwIGluIHRhYmxlKSB7XG4gICAgICAgIGFycmF5W3RhYmxlW3BdXSA9IHZbcF0gfHwgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9O1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXVyYWwtbmV0d29yay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgnKTtcblxudmFyIF9tYXRyaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0cml4KTtcblxudmFyIF9ncnUgPSByZXF1aXJlKCcuL2dydScpO1xuXG52YXIgX2dydTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncnUpO1xuXG52YXIgX3JublRpbWVTdGVwID0gcmVxdWlyZSgnLi9ybm4tdGltZS1zdGVwJyk7XG5cbnZhciBfcm5uVGltZVN0ZXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm5uVGltZVN0ZXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHUlVUaW1lU3RlcCA9IGZ1bmN0aW9uIChfUk5OVGltZVN0ZXApIHtcbiAgX2luaGVyaXRzKEdSVVRpbWVTdGVwLCBfUk5OVGltZVN0ZXApO1xuXG4gIGZ1bmN0aW9uIEdSVVRpbWVTdGVwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHUlVUaW1lU3RlcCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEdSVVRpbWVTdGVwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR1JVVGltZVN0ZXApKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHUlVUaW1lU3RlcCwgW3tcbiAgICBrZXk6ICdnZXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZGVsKGhpZGRlblNpemUsIHByZXZTaXplKSB7XG4gICAgICByZXR1cm4gX2dydTIuZGVmYXVsdC5wcm90b3R5cGUuZ2V0TW9kZWwoaGlkZGVuU2l6ZSwgcHJldlNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcXVhdGlvbn0gZXF1YXRpb25cbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gaW5wdXRNYXRyaXhcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gcHJldmlvdXNSZXN1bHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGlkZGVuTGF5ZXJcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRFcXVhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVxdWF0aW9uKGVxdWF0aW9uLCBpbnB1dE1hdHJpeCwgcHJldmlvdXNSZXN1bHQsIGhpZGRlbkxheWVyKSB7XG4gICAgICByZXR1cm4gX2dydTIuZGVmYXVsdC5wcm90b3R5cGUuZ2V0RXF1YXRpb24oZXF1YXRpb24sIGlucHV0TWF0cml4LCBwcmV2aW91c1Jlc3VsdCwgaGlkZGVuTGF5ZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHUlVUaW1lU3RlcDtcbn0oX3JublRpbWVTdGVwMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gR1JVVGltZVN0ZXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncnUtdGltZS1zdGVwLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG52YXIgX21hdHJpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRyaXgpO1xuXG52YXIgX3JhbmRvbU1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4L3JhbmRvbS1tYXRyaXgnKTtcblxudmFyIF9yYW5kb21NYXRyaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFuZG9tTWF0cml4KTtcblxudmFyIF9ybm4gPSByZXF1aXJlKCcuL3JubicpO1xuXG52YXIgX3JubjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ybm4pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHUlUgPSBmdW5jdGlvbiAoX1JOTikge1xuICBfaW5oZXJpdHMoR1JVLCBfUk5OKTtcblxuICBmdW5jdGlvbiBHUlUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdSVSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEdSVS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdSVSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdSVSwgW3tcbiAgICBrZXk6ICdnZXRNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vZGVsKGhpZGRlblNpemUsIHByZXZTaXplKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyB1cGRhdGUgR2F0ZVxuICAgICAgICAvL3d6eGhcbiAgICAgICAgdXBkYXRlR2F0ZUlucHV0TWF0cml4OiBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCBwcmV2U2l6ZSwgMC4wOCksXG4gICAgICAgIC8vd3poaFxuICAgICAgICB1cGRhdGVHYXRlSGlkZGVuTWF0cml4OiBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCBoaWRkZW5TaXplLCAwLjA4KSxcbiAgICAgICAgLy9ielxuICAgICAgICB1cGRhdGVHYXRlQmlhczogbmV3IF9tYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgMSksXG5cbiAgICAgICAgLy8gcmVzZXQgR2F0ZVxuICAgICAgICAvL3dyeGhcbiAgICAgICAgcmVzZXRHYXRlSW5wdXRNYXRyaXg6IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KGhpZGRlblNpemUsIHByZXZTaXplLCAwLjA4KSxcbiAgICAgICAgLy93cmhoXG4gICAgICAgIHJlc2V0R2F0ZUhpZGRlbk1hdHJpeDogbmV3IF9yYW5kb21NYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgaGlkZGVuU2l6ZSwgMC4wOCksXG4gICAgICAgIC8vYnJcbiAgICAgICAgcmVzZXRHYXRlQmlhczogbmV3IF9tYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgMSksXG5cbiAgICAgICAgLy8gY2VsbCB3cml0ZSBwYXJhbWV0ZXJzXG4gICAgICAgIC8vd2N4aFxuICAgICAgICBjZWxsV3JpdGVJbnB1dE1hdHJpeDogbmV3IF9yYW5kb21NYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgcHJldlNpemUsIDAuMDgpLFxuICAgICAgICAvL3djaGhcbiAgICAgICAgY2VsbFdyaXRlSGlkZGVuTWF0cml4OiBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCBoaWRkZW5TaXplLCAwLjA4KSxcbiAgICAgICAgLy9iY1xuICAgICAgICBjZWxsV3JpdGVCaWFzOiBuZXcgX21hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCAxKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXF1YXRpb259IGVxdWF0aW9uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGlucHV0TWF0cml4XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHByZXZpb3VzUmVzdWx0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhpZGRlbkxheWVyXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0RXF1YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFcXVhdGlvbihlcXVhdGlvbiwgaW5wdXRNYXRyaXgsIHByZXZpb3VzUmVzdWx0LCBoaWRkZW5MYXllcikge1xuICAgICAgdmFyIHNpZ21vaWQgPSBlcXVhdGlvbi5zaWdtb2lkLmJpbmQoZXF1YXRpb24pO1xuICAgICAgdmFyIGFkZCA9IGVxdWF0aW9uLmFkZC5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciBtdWx0aXBseSA9IGVxdWF0aW9uLm11bHRpcGx5LmJpbmQoZXF1YXRpb24pO1xuICAgICAgdmFyIG11bHRpcGx5RWxlbWVudCA9IGVxdWF0aW9uLm11bHRpcGx5RWxlbWVudC5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciB0YW5oID0gZXF1YXRpb24udGFuaC5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciBhbGxPbmVzID0gZXF1YXRpb24uYWxsT25lcy5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciBjbG9uZU5lZ2F0aXZlID0gZXF1YXRpb24uY2xvbmVOZWdhdGl2ZS5iaW5kKGVxdWF0aW9uKTtcblxuICAgICAgLy8gdXBkYXRlIGdhdGVcbiAgICAgIHZhciB1cGRhdGVHYXRlID0gc2lnbW9pZChhZGQoYWRkKG11bHRpcGx5KGhpZGRlbkxheWVyLnVwZGF0ZUdhdGVJbnB1dE1hdHJpeCwgaW5wdXRNYXRyaXgpLCBtdWx0aXBseShoaWRkZW5MYXllci51cGRhdGVHYXRlSGlkZGVuTWF0cml4LCBwcmV2aW91c1Jlc3VsdCkpLCBoaWRkZW5MYXllci51cGRhdGVHYXRlQmlhcykpO1xuXG4gICAgICAvLyByZXNldCBnYXRlXG4gICAgICB2YXIgcmVzZXRHYXRlID0gc2lnbW9pZChhZGQoYWRkKG11bHRpcGx5KGhpZGRlbkxheWVyLnJlc2V0R2F0ZUlucHV0TWF0cml4LCBpbnB1dE1hdHJpeCksIG11bHRpcGx5KGhpZGRlbkxheWVyLnJlc2V0R2F0ZUhpZGRlbk1hdHJpeCwgcHJldmlvdXNSZXN1bHQpKSwgaGlkZGVuTGF5ZXIucmVzZXRHYXRlQmlhcykpO1xuXG4gICAgICAvLyBjZWxsXG4gICAgICB2YXIgY2VsbCA9IHRhbmgoYWRkKGFkZChtdWx0aXBseShoaWRkZW5MYXllci5jZWxsV3JpdGVJbnB1dE1hdHJpeCwgaW5wdXRNYXRyaXgpLCBtdWx0aXBseShoaWRkZW5MYXllci5jZWxsV3JpdGVIaWRkZW5NYXRyaXgsIG11bHRpcGx5RWxlbWVudChyZXNldEdhdGUsIHByZXZpb3VzUmVzdWx0KSkpLCBoaWRkZW5MYXllci5jZWxsV3JpdGVCaWFzKSk7XG5cbiAgICAgIC8vIGNvbXB1dGUgaGlkZGVuIHN0YXRlIGFzIGdhdGVkLCBzYXR1cmF0ZWQgY2VsbCBhY3RpdmF0aW9uc1xuICAgICAgLy8gbmVnYXRlIHVwZGF0ZUdhdGVcbiAgICAgIHJldHVybiBhZGQobXVsdGlwbHlFbGVtZW50KGFkZChhbGxPbmVzKHVwZGF0ZUdhdGUucm93cywgdXBkYXRlR2F0ZS5jb2x1bW5zKSwgY2xvbmVOZWdhdGl2ZSh1cGRhdGVHYXRlKSksIGNlbGwpLCBtdWx0aXBseUVsZW1lbnQocHJldmlvdXNSZXN1bHQsIHVwZGF0ZUdhdGUpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR1JVO1xufShfcm5uMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gR1JVO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3J1LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG52YXIgX21hdHJpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRyaXgpO1xuXG52YXIgX2xzdG0gPSByZXF1aXJlKCcuL2xzdG0nKTtcblxudmFyIF9sc3RtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xzdG0pO1xuXG52YXIgX3JublRpbWVTdGVwID0gcmVxdWlyZSgnLi9ybm4tdGltZS1zdGVwJyk7XG5cbnZhciBfcm5uVGltZVN0ZXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm5uVGltZVN0ZXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBMU1RNVGltZVN0ZXAgPSBmdW5jdGlvbiAoX1JOTlRpbWVTdGVwKSB7XG4gIF9pbmhlcml0cyhMU1RNVGltZVN0ZXAsIF9STk5UaW1lU3RlcCk7XG5cbiAgZnVuY3Rpb24gTFNUTVRpbWVTdGVwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMU1RNVGltZVN0ZXApO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChMU1RNVGltZVN0ZXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihMU1RNVGltZVN0ZXApKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMU1RNVGltZVN0ZXAsIFt7XG4gICAga2V5OiAnZ2V0TW9kZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlbChoaWRkZW5TaXplLCBwcmV2U2l6ZSkge1xuICAgICAgcmV0dXJuIF9sc3RtMi5kZWZhdWx0LnByb3RvdHlwZS5nZXRNb2RlbC5jYWxsKHRoaXMsIGhpZGRlblNpemUsIHByZXZTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXF1YXRpb259IGVxdWF0aW9uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGlucHV0TWF0cml4XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHByZXZpb3VzUmVzdWx0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhpZGRlbkxheWVyXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0RXF1YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFcXVhdGlvbihlcXVhdGlvbiwgaW5wdXRNYXRyaXgsIHByZXZpb3VzUmVzdWx0LCBoaWRkZW5MYXllcikge1xuICAgICAgcmV0dXJuIF9sc3RtMi5kZWZhdWx0LnByb3RvdHlwZS5nZXRFcXVhdGlvbi5jYWxsKHRoaXMsIGVxdWF0aW9uLCBpbnB1dE1hdHJpeCwgcHJldmlvdXNSZXN1bHQsIGhpZGRlbkxheWVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTFNUTVRpbWVTdGVwO1xufShfcm5uVGltZVN0ZXAyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMU1RNVGltZVN0ZXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sc3RtLXRpbWUtc3RlcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgnKTtcblxudmFyIF9tYXRyaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0cml4KTtcblxudmFyIF9yYW5kb21NYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeC9yYW5kb20tbWF0cml4Jyk7XG5cbnZhciBfcmFuZG9tTWF0cml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhbmRvbU1hdHJpeCk7XG5cbnZhciBfcm5uID0gcmVxdWlyZSgnLi9ybm4nKTtcblxudmFyIF9ybm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm5uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTFNUTSA9IGZ1bmN0aW9uIChfUk5OKSB7XG4gIF9pbmhlcml0cyhMU1RNLCBfUk5OKTtcblxuICBmdW5jdGlvbiBMU1RNKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMU1RNKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoTFNUTS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKExTVE0pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMU1RNLCBbe1xuICAgIGtleTogJ2dldE1vZGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kZWwoaGlkZGVuU2l6ZSwgcHJldlNpemUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGdhdGVzIHBhcmFtZXRlcnNcbiAgICAgICAgLy93aXhcbiAgICAgICAgaW5wdXRNYXRyaXg6IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KGhpZGRlblNpemUsIHByZXZTaXplLCAwLjA4KSxcbiAgICAgICAgLy93aWhcbiAgICAgICAgaW5wdXRIaWRkZW46IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KGhpZGRlblNpemUsIGhpZGRlblNpemUsIDAuMDgpLFxuICAgICAgICAvL2JpXG4gICAgICAgIGlucHV0QmlhczogbmV3IF9tYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgMSksXG5cbiAgICAgICAgLy93ZnhcbiAgICAgICAgZm9yZ2V0TWF0cml4OiBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCBwcmV2U2l6ZSwgMC4wOCksXG4gICAgICAgIC8vd2ZoXG4gICAgICAgIGZvcmdldEhpZGRlbjogbmV3IF9yYW5kb21NYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgaGlkZGVuU2l6ZSwgMC4wOCksXG4gICAgICAgIC8vYmZcbiAgICAgICAgZm9yZ2V0QmlhczogbmV3IF9tYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgMSksXG5cbiAgICAgICAgLy93b3hcbiAgICAgICAgb3V0cHV0TWF0cml4OiBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCBwcmV2U2l6ZSwgMC4wOCksXG4gICAgICAgIC8vd29oXG4gICAgICAgIG91dHB1dEhpZGRlbjogbmV3IF9yYW5kb21NYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgaGlkZGVuU2l6ZSwgMC4wOCksXG4gICAgICAgIC8vYm9cbiAgICAgICAgb3V0cHV0QmlhczogbmV3IF9tYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgMSksXG5cbiAgICAgICAgLy8gY2VsbCB3cml0ZSBwYXJhbXNcbiAgICAgICAgLy93Y3hcbiAgICAgICAgY2VsbEFjdGl2YXRpb25NYXRyaXg6IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KGhpZGRlblNpemUsIHByZXZTaXplLCAwLjA4KSxcbiAgICAgICAgLy93Y2hcbiAgICAgICAgY2VsbEFjdGl2YXRpb25IaWRkZW46IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KGhpZGRlblNpemUsIGhpZGRlblNpemUsIDAuMDgpLFxuICAgICAgICAvL2JjXG4gICAgICAgIGNlbGxBY3RpdmF0aW9uQmlhczogbmV3IF9tYXRyaXgyLmRlZmF1bHQoaGlkZGVuU2l6ZSwgMSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VxdWF0aW9ufSBlcXVhdGlvblxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBpbnB1dE1hdHJpeFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBwcmV2aW91c1Jlc3VsdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoaWRkZW5MYXllclxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldEVxdWF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXF1YXRpb24oZXF1YXRpb24sIGlucHV0TWF0cml4LCBwcmV2aW91c1Jlc3VsdCwgaGlkZGVuTGF5ZXIpIHtcbiAgICAgIHZhciBzaWdtb2lkID0gZXF1YXRpb24uc2lnbW9pZC5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciBhZGQgPSBlcXVhdGlvbi5hZGQuYmluZChlcXVhdGlvbik7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBlcXVhdGlvbi5tdWx0aXBseS5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciBtdWx0aXBseUVsZW1lbnQgPSBlcXVhdGlvbi5tdWx0aXBseUVsZW1lbnQuYmluZChlcXVhdGlvbik7XG4gICAgICB2YXIgdGFuaCA9IGVxdWF0aW9uLnRhbmguYmluZChlcXVhdGlvbik7XG5cbiAgICAgIHZhciBpbnB1dEdhdGUgPSBzaWdtb2lkKGFkZChhZGQobXVsdGlwbHkoaGlkZGVuTGF5ZXIuaW5wdXRNYXRyaXgsIGlucHV0TWF0cml4KSwgbXVsdGlwbHkoaGlkZGVuTGF5ZXIuaW5wdXRIaWRkZW4sIHByZXZpb3VzUmVzdWx0KSksIGhpZGRlbkxheWVyLmlucHV0QmlhcykpO1xuXG4gICAgICB2YXIgZm9yZ2V0R2F0ZSA9IHNpZ21vaWQoYWRkKGFkZChtdWx0aXBseShoaWRkZW5MYXllci5mb3JnZXRNYXRyaXgsIGlucHV0TWF0cml4KSwgbXVsdGlwbHkoaGlkZGVuTGF5ZXIuZm9yZ2V0SGlkZGVuLCBwcmV2aW91c1Jlc3VsdCkpLCBoaWRkZW5MYXllci5mb3JnZXRCaWFzKSk7XG5cbiAgICAgIC8vIG91dHB1dCBnYXRlXG4gICAgICB2YXIgb3V0cHV0R2F0ZSA9IHNpZ21vaWQoYWRkKGFkZChtdWx0aXBseShoaWRkZW5MYXllci5vdXRwdXRNYXRyaXgsIGlucHV0TWF0cml4KSwgbXVsdGlwbHkoaGlkZGVuTGF5ZXIub3V0cHV0SGlkZGVuLCBwcmV2aW91c1Jlc3VsdCkpLCBoaWRkZW5MYXllci5vdXRwdXRCaWFzKSk7XG5cbiAgICAgIC8vIHdyaXRlIG9wZXJhdGlvbiBvbiBjZWxsc1xuICAgICAgdmFyIGNlbGxXcml0ZSA9IHRhbmgoYWRkKGFkZChtdWx0aXBseShoaWRkZW5MYXllci5jZWxsQWN0aXZhdGlvbk1hdHJpeCwgaW5wdXRNYXRyaXgpLCBtdWx0aXBseShoaWRkZW5MYXllci5jZWxsQWN0aXZhdGlvbkhpZGRlbiwgcHJldmlvdXNSZXN1bHQpKSwgaGlkZGVuTGF5ZXIuY2VsbEFjdGl2YXRpb25CaWFzKSk7XG5cbiAgICAgIC8vIGNvbXB1dGUgbmV3IGNlbGwgYWN0aXZhdGlvblxuICAgICAgdmFyIHJldGFpbkNlbGwgPSBtdWx0aXBseUVsZW1lbnQoZm9yZ2V0R2F0ZSwgcHJldmlvdXNSZXN1bHQpOyAvLyB3aGF0IGRvIHdlIGtlZXAgZnJvbSBjZWxsXG4gICAgICB2YXIgd3JpdGVDZWxsID0gbXVsdGlwbHlFbGVtZW50KGlucHV0R2F0ZSwgY2VsbFdyaXRlKTsgLy8gd2hhdCBkbyB3ZSB3cml0ZSB0byBjZWxsXG4gICAgICB2YXIgY2VsbCA9IGFkZChyZXRhaW5DZWxsLCB3cml0ZUNlbGwpOyAvLyBuZXcgY2VsbCBjb250ZW50c1xuXG4gICAgICAvLyBjb21wdXRlIGhpZGRlbiBzdGF0ZSBhcyBnYXRlZCwgc2F0dXJhdGVkIGNlbGwgYWN0aXZhdGlvbnNcbiAgICAgIHJldHVybiBtdWx0aXBseUVsZW1lbnQob3V0cHV0R2F0ZSwgdGFuaChjZWxsKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExTVE07XG59KF9ybm4yLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMU1RNO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHN0bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkZEI7XG4vKipcbiAqIGFkZHMge2Zyb219IGRlbHRhcyB0byB7bGVmdH0gYW5kIHtyaWdodH0gZGVsdGFzXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqIEBwYXJhbSB7TWF0cml4fSByaWdodFxuICovXG5mdW5jdGlvbiBhZGRCKHByb2R1Y3QsIGxlZnQsIHJpZ2h0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZHVjdC5kZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZWZ0LmRlbHRhc1tpXSA9IHByb2R1Y3QuZGVsdGFzW2ldO1xuICAgIHJpZ2h0LmRlbHRhc1tpXSA9IHByb2R1Y3QuZGVsdGFzW2ldO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkZDtcbi8qKlxuICogYWRkIHtsZWZ0fSBhbmQge3JpZ2h0fSBtYXRyaXggd2VpZ2h0cyBpbnRvIHtpbnRvfVxuICogQHBhcmFtIHtNYXRyaXh9IHByb2R1Y3RcbiAqIEBwYXJhbSB7TWF0cml4fSBsZWZ0XG4gKiBAcGFyYW0ge01hdHJpeH0gcmlnaHRcbiAqL1xuZnVuY3Rpb24gYWRkKHByb2R1Y3QsIGxlZnQsIHJpZ2h0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC53ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdC53ZWlnaHRzW2ldID0gbGVmdC53ZWlnaHRzW2ldICsgcmlnaHQud2VpZ2h0c1tpXTtcbiAgICBwcm9kdWN0LmRlbHRhc1tpXSA9IDA7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFsbE9uZXM7XG4vKipcbiAqIG1ha2VzIG1hdHJpeCB3ZWlnaHRzIGFuZCBkZWx0YXMgYWxsIG9uZXNcbiAqIEBwYXJhbSB7TWF0cml4fSBwcm9kdWN0XG4gKi9cbmZ1bmN0aW9uIGFsbE9uZXMocHJvZHVjdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2R1Y3Qud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgIHByb2R1Y3Qud2VpZ2h0c1tpXSA9IDE7XG4gICAgcHJvZHVjdC5kZWx0YXNbaV0gPSAwO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGwtb25lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lTmVnYXRpdmU7XG4vKipcbiAqXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVOZWdhdGl2ZShwcm9kdWN0LCBsZWZ0KSB7XG4gIHByb2R1Y3Qucm93cyA9IHBhcnNlSW50KGxlZnQucm93cyk7XG4gIHByb2R1Y3QuY29sdW1ucyA9IHBhcnNlSW50KGxlZnQuY29sdW1ucyk7XG4gIHByb2R1Y3Qud2VpZ2h0cyA9IGxlZnQud2VpZ2h0cy5zbGljZSgwKTtcbiAgcHJvZHVjdC5kZWx0YXMgPSBsZWZ0LmRlbHRhcy5zbGljZSgwKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0LndlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9kdWN0LndlaWdodHNbaV0gPSAtbGVmdC53ZWlnaHRzW2ldO1xuICAgIHByb2R1Y3QuZGVsdGFzW2ldID0gMDtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmUtbmVnYXRpdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjb3B5O1xuLypcbiAqXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqL1xuZnVuY3Rpb24gY29weShwcm9kdWN0LCBsZWZ0KSB7XG4gIHByb2R1Y3Qucm93cyA9IHBhcnNlSW50KGxlZnQucm93cyk7XG4gIHByb2R1Y3QuY29sdW1ucyA9IHBhcnNlSW50KGxlZnQuY29sdW1ucyk7XG4gIHByb2R1Y3Qud2VpZ2h0cyA9IGxlZnQud2VpZ2h0cy5zbGljZSgwKTtcbiAgcHJvZHVjdC5kZWx0YXMgPSBsZWZ0LmRlbHRhcy5zbGljZSgwKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcHkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgXyA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciBfMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoXyk7XG5cbnZhciBfb25lc01hdHJpeCA9IHJlcXVpcmUoJy4vb25lcy1tYXRyaXgnKTtcblxudmFyIF9vbmVzTWF0cml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29uZXNNYXRyaXgpO1xuXG52YXIgX2NvcHkgPSByZXF1aXJlKCcuL2NvcHknKTtcblxudmFyIF9jb3B5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcHkpO1xuXG52YXIgX2Nsb25lTmVnYXRpdmUyID0gcmVxdWlyZSgnLi9jbG9uZS1uZWdhdGl2ZScpO1xuXG52YXIgX2Nsb25lTmVnYXRpdmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xvbmVOZWdhdGl2ZTIpO1xuXG52YXIgX2FkZDIgPSByZXF1aXJlKCcuL2FkZCcpO1xuXG52YXIgX2FkZDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hZGQyKTtcblxudmFyIF9hZGRCID0gcmVxdWlyZSgnLi9hZGQtYicpO1xuXG52YXIgX2FkZEIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkQik7XG5cbnZhciBfYWxsT25lczIgPSByZXF1aXJlKCcuL2FsbC1vbmVzJyk7XG5cbnZhciBfYWxsT25lczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hbGxPbmVzMik7XG5cbnZhciBfbXVsdGlwbHkyID0gcmVxdWlyZSgnLi9tdWx0aXBseScpO1xuXG52YXIgX211bHRpcGx5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX211bHRpcGx5Mik7XG5cbnZhciBfbXVsdGlwbHlCID0gcmVxdWlyZSgnLi9tdWx0aXBseS1iJyk7XG5cbnZhciBfbXVsdGlwbHlCMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX211bHRpcGx5Qik7XG5cbnZhciBfbXVsdGlwbHlFbGVtZW50MiA9IHJlcXVpcmUoJy4vbXVsdGlwbHktZWxlbWVudCcpO1xuXG52YXIgX211bHRpcGx5RWxlbWVudDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tdWx0aXBseUVsZW1lbnQyKTtcblxudmFyIF9tdWx0aXBseUVsZW1lbnRCID0gcmVxdWlyZSgnLi9tdWx0aXBseS1lbGVtZW50LWInKTtcblxudmFyIF9tdWx0aXBseUVsZW1lbnRCMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX211bHRpcGx5RWxlbWVudEIpO1xuXG52YXIgX3JlbHUyID0gcmVxdWlyZSgnLi9yZWx1Jyk7XG5cbnZhciBfcmVsdTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWx1Mik7XG5cbnZhciBfcmVsdUIgPSByZXF1aXJlKCcuL3JlbHUtYicpO1xuXG52YXIgX3JlbHVCMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbHVCKTtcblxudmFyIF9yb3dQbHVjayA9IHJlcXVpcmUoJy4vcm93LXBsdWNrJyk7XG5cbnZhciBfcm93UGx1Y2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm93UGx1Y2spO1xuXG52YXIgX3Jvd1BsdWNrQiA9IHJlcXVpcmUoJy4vcm93LXBsdWNrLWInKTtcblxudmFyIF9yb3dQbHVja0IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm93UGx1Y2tCKTtcblxudmFyIF9zaWdtb2lkMiA9IHJlcXVpcmUoJy4vc2lnbW9pZCcpO1xuXG52YXIgX3NpZ21vaWQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2lnbW9pZDIpO1xuXG52YXIgX3NpZ21vaWRCID0gcmVxdWlyZSgnLi9zaWdtb2lkLWInKTtcblxudmFyIF9zaWdtb2lkQjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaWdtb2lkQik7XG5cbnZhciBfdGFuaDIgPSByZXF1aXJlKCcuL3RhbmgnKTtcblxudmFyIF90YW5oMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhbmgyKTtcblxudmFyIF90YW5oQiA9IHJlcXVpcmUoJy4vdGFuaC1iJyk7XG5cbnZhciBfdGFuaEIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFuaEIpO1xuXG52YXIgX3NvZnRtYXggPSByZXF1aXJlKCcuL3NvZnRtYXgnKTtcblxudmFyIF9zb2Z0bWF4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvZnRtYXgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRXF1YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVxdWF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcXVhdGlvbik7XG5cbiAgICB0aGlzLmlucHV0Um93ID0gMDtcbiAgICB0aGlzLmlucHV0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMuc3RhdGVzID0gW107XG4gIH1cblxuICAvKipcbiAgICogY29ubmVjdHMgdHdvIG1hdHJpY2VzIHRvZ2V0aGVyIGJ5IGFkZFxuICAgKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICAgKiBAcGFyYW0ge01hdHJpeH0gcmlnaHRcbiAgICogQHJldHVybnMge01hdHJpeH1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoRXF1YXRpb24sIFt7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAobGVmdC53ZWlnaHRzLmxlbmd0aCAhPT0gcmlnaHQud2VpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNhbGlnbmVkIG1hdHJpY2VzJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvZHVjdCA9IG5ldyBfMi5kZWZhdWx0KGxlZnQucm93cywgbGVmdC5jb2x1bW5zKTtcbiAgICAgIHRoaXMuc3RhdGVzLnB1c2goe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHByb2R1Y3Q6IHByb2R1Y3QsXG4gICAgICAgIGZvcndhcmRGbjogX2FkZDMuZGVmYXVsdCxcbiAgICAgICAgYmFja3Byb3BhZ2F0aW9uRm46IF9hZGRCMi5kZWZhdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uc1xuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FsbE9uZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxPbmVzKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgIHZhciBwcm9kdWN0ID0gbmV3IF8yLmRlZmF1bHQocm93cywgY29sdW1ucyk7XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHtcbiAgICAgICAgbGVmdDogcHJvZHVjdCxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgZm9yd2FyZEZuOiBfYWxsT25lczMuZGVmYXVsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2xvbmVOZWdhdGl2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lTmVnYXRpdmUobSkge1xuICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgXzIuZGVmYXVsdChtLnJvd3MsIG0uY29sdW1ucyk7XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHtcbiAgICAgICAgbGVmdDogbSxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgZm9yd2FyZEZuOiBfY2xvbmVOZWdhdGl2ZTMuZGVmYXVsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0cyB0d28gbWF0cmljZXMgdG9nZXRoZXIgYnkgc3VidHJhY3RcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSByaWdodFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N1YnRyYWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmIChsZWZ0LndlaWdodHMubGVuZ3RoICE9PSByaWdodC53ZWlnaHRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc2FsaWduZWQgbWF0cmljZXMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmFkZCh0aGlzLmFkZCh0aGlzLmFsbE9uZXMobGVmdC5yb3dzLCBsZWZ0LmNvbHVtbnMpLCB0aGlzLmNsb25lTmVnYXRpdmUobGVmdCkpLCByaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29ubmVjdHMgdHdvIG1hdHJpY2VzIHRvZ2V0aGVyIGJ5IG11bHRpcGx5XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gcmlnaHRcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtdWx0aXBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAobGVmdC5jb2x1bW5zICE9PSByaWdodC5yb3dzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzYWxpZ25lZCBtYXRyaWNlcycpO1xuICAgICAgfVxuICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgXzIuZGVmYXVsdChsZWZ0LnJvd3MsIHJpZ2h0LmNvbHVtbnMpO1xuICAgICAgdGhpcy5zdGF0ZXMucHVzaCh7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgZm9yd2FyZEZuOiBfbXVsdGlwbHkzLmRlZmF1bHQsXG4gICAgICAgIGJhY2twcm9wYWdhdGlvbkZuOiBfbXVsdGlwbHlCMi5kZWZhdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3RzIHR3byBtYXRyaWNlcyB0b2dldGhlciBieSBtdWx0aXBseUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSByaWdodFxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ211bHRpcGx5RWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5RWxlbWVudChsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKGxlZnQud2VpZ2h0cy5sZW5ndGggIT09IHJpZ2h0LndlaWdodHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzYWxpZ25lZCBtYXRyaWNlcycpO1xuICAgICAgfVxuICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgXzIuZGVmYXVsdChsZWZ0LnJvd3MsIGxlZnQuY29sdW1ucyk7XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0LFxuICAgICAgICBmb3J3YXJkRm46IF9tdWx0aXBseUVsZW1lbnQzLmRlZmF1bHQsXG4gICAgICAgIGJhY2twcm9wYWdhdGlvbkZuOiBfbXVsdGlwbHlFbGVtZW50QjIuZGVmYXVsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb25uZWN0cyBhIG1hdHJpeCB0byByZWx1XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IG1cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWx1JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsdShtKSB7XG4gICAgICB2YXIgcHJvZHVjdCA9IG5ldyBfMi5kZWZhdWx0KG0ucm93cywgbS5jb2x1bW5zKTtcbiAgICAgIHRoaXMuc3RhdGVzLnB1c2goe1xuICAgICAgICBsZWZ0OiBtLFxuICAgICAgICBwcm9kdWN0OiBwcm9kdWN0LFxuICAgICAgICBmb3J3YXJkRm46IF9yZWx1My5kZWZhdWx0LFxuICAgICAgICBiYWNrcHJvcGFnYXRpb25GbjogX3JlbHVCMi5kZWZhdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvcHkgYSBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0KF9pbnB1dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5zdGF0ZXMucHVzaCh7XG4gICAgICAgIHByb2R1Y3Q6IF9pbnB1dCxcbiAgICAgICAgZm9yd2FyZEZuOiBmdW5jdGlvbiBmb3J3YXJkRm4ocHJvZHVjdCkge1xuICAgICAgICAgIHByb2R1Y3Qud2VpZ2h0cyA9IF9pbnB1dC53ZWlnaHRzID0gX3RoaXMuaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2lucHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3RzIGEgbWF0cml4IHZpYSBhIHJvd1xuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5wdXRNYXRyaXhUb1JvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlucHV0TWF0cml4VG9Sb3cobSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgXzIuZGVmYXVsdChtLmNvbHVtbnMsIDEpO1xuICAgICAgdGhpcy5zdGF0ZXMucHVzaCh7XG4gICAgICAgIGxlZnQ6IG0sXG4gICAgICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5pbnB1dFJvdztcbiAgICAgICAgfSxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgZm9yd2FyZEZuOiBfcm93UGx1Y2syLmRlZmF1bHQsXG4gICAgICAgIGJhY2twcm9wYWdhdGlvbkZuOiBfcm93UGx1Y2tCMi5kZWZhdWx0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3RzIGEgbWF0cml4IHRvIHNpZ21vaWRcbiAgICAgKiBAcGFyYW0ge01hdHJpeH0gbVxuICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3NpZ21vaWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWdtb2lkKG0pIHtcbiAgICAgIHZhciBwcm9kdWN0ID0gbmV3IF8yLmRlZmF1bHQobS5yb3dzLCBtLmNvbHVtbnMpO1xuICAgICAgdGhpcy5zdGF0ZXMucHVzaCh7XG4gICAgICAgIGxlZnQ6IG0sXG4gICAgICAgIHByb2R1Y3Q6IHByb2R1Y3QsXG4gICAgICAgIGZvcndhcmRGbjogX3NpZ21vaWQzLmRlZmF1bHQsXG4gICAgICAgIGJhY2twcm9wYWdhdGlvbkZuOiBfc2lnbW9pZEIyLmRlZmF1bHRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29ubmVjdHMgYSBtYXRyaXggdG8gdGFuaFxuICAgICAqIEBwYXJhbSB7TWF0cml4fSBtXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndGFuaCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhbmgobSkge1xuICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgXzIuZGVmYXVsdChtLnJvd3MsIG0uY29sdW1ucyk7XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHtcbiAgICAgICAgbGVmdDogbSxcbiAgICAgICAgcHJvZHVjdDogcHJvZHVjdCxcbiAgICAgICAgZm9yd2FyZEZuOiBfdGFuaDMuZGVmYXVsdCxcbiAgICAgICAgYmFja3Byb3BhZ2F0aW9uRm46IF90YW5oQjIuZGVmYXVsdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb2JzZXJ2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ic2VydmUobSkge1xuICAgICAgdmFyIGlGb3J3YXJkID0gMDtcbiAgICAgIHZhciBpQmFja3Byb3BhZ2F0ZSA9IDA7XG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHtcbiAgICAgICAgZm9yd2FyZEZuOiBmdW5jdGlvbiBmb3J3YXJkRm4oKSB7XG4gICAgICAgICAgaUZvcndhcmQrKztcbiAgICAgICAgfSxcbiAgICAgICAgYmFja3Byb3BhZ2F0aW9uRm46IGZ1bmN0aW9uIGJhY2twcm9wYWdhdGlvbkZuKCkge1xuICAgICAgICAgIGlCYWNrcHJvcGFnYXRlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhdGFtIHtOdW1iZXJ9IFtyb3dJbmRleF1cbiAgICAgKiBAb3V0cHV0IHtNYXRyaXh9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3J1bkluZGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuSW5kZXgoKSB7XG4gICAgICB2YXIgcm93SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgIHRoaXMuaW5wdXRSb3cgPSByb3dJbmRleDtcbiAgICAgIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSB0aGlzLnN0YXRlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhdGVzW2ldO1xuICAgICAgICBpZiAoIXN0YXRlLmhhc093blByb3BlcnR5KCdmb3J3YXJkRm4nKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZvcndhcmRGbihzdGF0ZS5wcm9kdWN0LCBzdGF0ZS5sZWZ0LCBzdGF0ZS5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZS5wcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXRhbSB7TnVtYmVyfSBbcm93SW5kZXhdXG4gICAgICogQG91dHB1dCB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdydW5JbnB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bklucHV0KGlucHV0VmFsdWUpIHtcbiAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWU7XG4gICAgICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gdGhpcy5zdGF0ZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlc1tpXTtcbiAgICAgICAgaWYgKCFzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgnZm9yd2FyZEZuJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mb3J3YXJkRm4oc3RhdGUucHJvZHVjdCwgc3RhdGUubGVmdCwgc3RhdGUucmlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGUucHJvZHVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGF0YW0ge051bWJlcn0gW3Jvd0luZGV4XVxuICAgICAqIEBvdXRwdXQge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYmFja3Byb3BhZ2F0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhY2twcm9wYWdhdGUoKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuc3RhdGVzLmxlbmd0aDtcbiAgICAgIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZXNbaV07XG4gICAgICAgIGlmICghc3RhdGUuaGFzT3duUHJvcGVydHkoJ2JhY2twcm9wYWdhdGlvbkZuJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrcHJvcGFnYXRpb25GbihzdGF0ZS5wcm9kdWN0LCBzdGF0ZS5sZWZ0LCBzdGF0ZS5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0ZS5wcm9kdWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXRhbSB7TnVtYmVyfSBbcm93SW5kZXhdXG4gICAgICogQG91dHB1dCB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiYWNrcHJvcGFnYXRlSW5kZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYWNrcHJvcGFnYXRlSW5kZXgoKSB7XG4gICAgICB2YXIgcm93SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgIHRoaXMuaW5wdXRSb3cgPSByb3dJbmRleDtcblxuICAgICAgdmFyIGkgPSB0aGlzLnN0YXRlcy5sZW5ndGg7XG4gICAgICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuc3RhdGVzW2ldO1xuICAgICAgICBpZiAoIXN0YXRlLmhhc093blByb3BlcnR5KCdiYWNrcHJvcGFnYXRpb25GbicpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFja3Byb3BhZ2F0aW9uRm4oc3RhdGUucHJvZHVjdCwgc3RhdGUubGVmdCwgc3RhdGUucmlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGUucHJvZHVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwcmVkaWN0VGFyZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlZGljdFRhcmdldChpbnB1dCwgdGFyZ2V0KSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5ydW5JbnB1dChpbnB1dCk7XG4gICAgICB2YXIgZXJyb3JTdW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSBvdXRwdXQud2VpZ2h0c1tpXSAtIHRhcmdldFtpXTtcbiAgICAgICAgLy8gc2V0IGdyYWRpZW50cyBpbnRvIGxvZyBwcm9iYWJpbGl0aWVzXG4gICAgICAgIGVycm9yU3VtICs9IE1hdGguYWJzKGVycm9yKTtcbiAgICAgICAgLy8gd3JpdGUgZ3JhZGllbnRzIGludG8gbG9nIHByb2JhYmlsaXRpZXNcbiAgICAgICAgb3V0cHV0LmRlbHRhc1tpXSA9IGVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yU3VtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3ByZWRpY3RUYXJnZXRJbmRleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWRpY3RUYXJnZXRJbmRleChpbnB1dCwgdGFyZ2V0KSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5ydW5JbmRleChpbnB1dCk7XG4gICAgICAvLyBzZXQgZ3JhZGllbnRzIGludG8gbG9nIHByb2JhYmlsaXRpZXNcbiAgICAgIHZhciBsb2dQcm9iYWJpbGl0aWVzID0gb3V0cHV0OyAvLyBpbnRlcnByZXQgb3V0cHV0IGFzIGxvZyBwcm9iYWJpbGl0aWVzXG4gICAgICB2YXIgcHJvYmFiaWxpdGllcyA9ICgwLCBfc29mdG1heDIuZGVmYXVsdCkob3V0cHV0KTsgLy8gY29tcHV0ZSB0aGUgc29mdG1heCBwcm9iYWJpbGl0aWVzXG5cbiAgICAgIC8vIHdyaXRlIGdyYWRpZW50cyBpbnRvIGxvZyBwcm9iYWJpbGl0aWVzXG4gICAgICBsb2dQcm9iYWJpbGl0aWVzLmRlbHRhcyA9IHByb2JhYmlsaXRpZXMud2VpZ2h0cy5zbGljZSgwKTtcbiAgICAgIGxvZ1Byb2JhYmlsaXRpZXMuZGVsdGFzW3RhcmdldF0gLT0gMTtcblxuICAgICAgLy8gYWNjdW11bGF0ZSBiYXNlIDIgbG9nIHByb2IgYW5kIGRvIHNtb290aGluZ1xuICAgICAgcmV0dXJuIC1NYXRoLmxvZzIocHJvYmFiaWxpdGllcy53ZWlnaHRzW3RhcmdldF0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFcXVhdGlvbjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXF1YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhdGlvbi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfemVyb3MgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvemVyb3MnKTtcblxudmFyIF96ZXJvczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF96ZXJvcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcm93c11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29sdW1uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRyaXgocm93cywgY29sdW1ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRyaXgpO1xuXG4gICAgaWYgKHJvd3MgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmIChjb2x1bW5zID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICB0aGlzLndlaWdodHMgPSAoMCwgX3plcm9zMi5kZWZhdWx0KShyb3dzICogY29sdW1ucyk7XG4gICAgdGhpcy5kZWx0YXMgPSAoMCwgX3plcm9zMi5kZWZhdWx0KShyb3dzICogY29sdW1ucyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl8QXJyYXl9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKE1hdHJpeCwgW3tcbiAgICBrZXk6ICdnZXRXZWlnaHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V2VpZ2h0cyhyb3csIGNvbCkge1xuICAgICAgLy8gc2xvdyBidXQgY2FyZWZ1bCBhY2Nlc3NvciBmdW5jdGlvblxuICAgICAgLy8gd2Ugd2FudCByb3ctbWFqb3Igb3JkZXJcbiAgICAgIHZhciBpeCA9IHRoaXMuY29sdW1ucyAqIHJvdyArIGNvbDtcbiAgICAgIGlmIChpeCA8IDAgJiYgaXggPj0gdGhpcy53ZWlnaHRzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdnZXQgYWNjZXNzb3IgaXMgc2tld2VkJyk7XG4gICAgICByZXR1cm4gdGhpcy53ZWlnaHRzW2l4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAgICogQHBhcmFtIHZcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRXZWlnaHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXZWlnaHQocm93LCBjb2wsIHYpIHtcbiAgICAgIC8vIHNsb3cgYnV0IGNhcmVmdWwgYWNjZXNzb3IgZnVuY3Rpb25cbiAgICAgIHZhciBpeCA9IHRoaXMuY29sdW1ucyAqIHJvdyArIGNvbDtcbiAgICAgIGlmIChpeCA8IDAgJiYgaXggPj0gdGhpcy53ZWlnaHRzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdzZXQgYWNjZXNzb3IgaXMgc2tld2VkJyk7XG4gICAgICB0aGlzLndlaWdodHNbaXhdID0gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAgICogQHBhcmFtIHZcbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXREZWx0YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWx0YXMocm93LCBjb2wsIHYpIHtcbiAgICAgIC8vIHNsb3cgYnV0IGNhcmVmdWwgYWNjZXNzb3IgZnVuY3Rpb25cbiAgICAgIHZhciBpeCA9IHRoaXMuY29sdW1ucyAqIHJvdyArIGNvbDtcbiAgICAgIGlmIChpeCA8IDAgJiYgaXggPj0gdGhpcy53ZWlnaHRzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdzZXQgYWNjZXNzb3IgaXMgc2tld2VkJyk7XG4gICAgICB0aGlzLmRlbHRhc1tpeF0gPSB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3tyb3dzOiAqLCBjb2x1bW5zOiAqLCB3ZWlnaHRzOiBBcnJheX19XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvd3M6IHRoaXMucm93cyxcbiAgICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxuICAgICAgICB3ZWlnaHRzOiB0aGlzLndlaWdodHMuc2xpY2UoMClcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnd2VpZ2h0c1RvQXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3ZWlnaHRzVG9BcnJheSgpIHtcbiAgICAgIHZhciBkZWx0YXMgPSBbXTtcbiAgICAgIHZhciByb3cgPSAwO1xuICAgICAgdmFyIGNvbHVtbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgZGVsdGFzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIGRlbHRhc1tyb3ddLnB1c2godGhpcy53ZWlnaHRzW2ldKTtcbiAgICAgICAgY29sdW1uKys7XG4gICAgICAgIGlmIChjb2x1bW4gPj0gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgY29sdW1uID0gMDtcbiAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbHRhcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWx0YXNUb0FycmF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsdGFzVG9BcnJheSgpIHtcbiAgICAgIHZhciBkZWx0YXMgPSBbXTtcbiAgICAgIHZhciByb3cgPSAwO1xuICAgICAgdmFyIGNvbHVtbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IDApIHtcbiAgICAgICAgICBkZWx0YXMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsdGFzW3Jvd10ucHVzaCh0aGlzLmRlbHRhc1tpXSk7XG4gICAgICAgIGNvbHVtbisrO1xuICAgICAgICBpZiAoY29sdW1uID49IHRoaXMuY29sdW1ucykge1xuICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YXM7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdmcm9tSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KGpzb24ucm93cywganNvbi5jb2x1bW5zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBqc29uLnJvd3MgKiBqc29uLmNvbHVtbnM7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBtYXRyaXgud2VpZ2h0c1tpXSA9IGpzb24ud2VpZ2h0c1tpXTsgLy8gY29weSBvdmVyIHdlaWdodHNcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2VpZ2h0Um93c1xuICAgICAqIEBwYXJhbSBbZGVsdGFzUm93c11cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tQXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkod2VpZ2h0Um93cywgZGVsdGFzUm93cykge1xuICAgICAgdmFyIHJvd3MgPSB3ZWlnaHRSb3dzLmxlbmd0aDtcbiAgICAgIHZhciBjb2x1bW5zID0gd2VpZ2h0Um93c1swXS5sZW5ndGg7XG4gICAgICB2YXIgbSA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG5cbiAgICAgIGRlbHRhc1Jvd3MgPSBkZWx0YXNSb3dzIHx8IHdlaWdodFJvd3M7XG5cbiAgICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dzOyByb3dJbmRleCsrKSB7XG4gICAgICAgIHZhciB3ZWlnaHRWYWx1ZXMgPSB3ZWlnaHRSb3dzW3Jvd0luZGV4XTtcbiAgICAgICAgdmFyIGRlbHRhc1ZhbHVlcyA9IGRlbHRhc1Jvd3Nbcm93SW5kZXhdO1xuICAgICAgICBmb3IgKHZhciBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1uczsgY29sdW1uSW5kZXgrKykge1xuICAgICAgICAgIG0uc2V0V2VpZ2h0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgd2VpZ2h0VmFsdWVzW2NvbHVtbkluZGV4XSk7XG4gICAgICAgICAgbS5zZXREZWx0YXMocm93SW5kZXgsIGNvbHVtbkluZGV4LCBkZWx0YXNWYWx1ZXNbY29sdW1uSW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWF0cml4O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNYXRyaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1heEk7XG4vKipcbiAqXG4gKiBAcGFyYW0ge01hdHJpeH0gbVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gbWF4SShtKSB7XG4gIC8vIGFyZ21heCBvZiBhcnJheSB3XG4gIHZhciB3ZWlnaHRzID0gbS53ZWlnaHRzO1xuXG4gIHZhciBtYXh2ID0gd2VpZ2h0c1swXTtcbiAgdmFyIG1heGl4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHYgPSB3ZWlnaHRzW2ldO1xuICAgIGlmICh2IDwgbWF4dikgY29udGludWU7XG5cbiAgICBtYXhpeCA9IGk7XG4gICAgbWF4diA9IHY7XG4gIH1cbiAgcmV0dXJuIG1heGl4O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC1pLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbXVsdGlwbHlCO1xuLyoqXG4gKiBtdWx0aXBsaWVzIHtmcm9tfSBkZWx0YXMgdG8ge2xlZnR9IGFuZCB7cmlnaHR9XG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqIEBwYXJhbSB7TWF0cml4fSByaWdodFxuICovXG5mdW5jdGlvbiBtdWx0aXBseUIocHJvZHVjdCwgbGVmdCwgcmlnaHQpIHtcbiAgdmFyIGxlZnRSb3dzID0gbGVmdC5yb3dzO1xuICB2YXIgbGVmdENvbHVtbnMgPSBsZWZ0LmNvbHVtbnM7XG4gIHZhciByaWdodENvbHVtbnMgPSByaWdodC5jb2x1bW5zO1xuXG4gIC8vIGxvb3Agb3ZlciByb3dzIG9mIGxlZnRcbiAgZm9yICh2YXIgbGVmdFJvdyA9IDA7IGxlZnRSb3cgPCBsZWZ0Um93czsgbGVmdFJvdysrKSB7XG4gICAgdmFyIGxlZnRSb3dCYXNlID0gbGVmdENvbHVtbnMgKiBsZWZ0Um93O1xuICAgIHZhciByaWdodFJvd0Jhc2UgPSByaWdodENvbHVtbnMgKiBsZWZ0Um93O1xuICAgIC8vIGxvb3Agb3ZlciBjb2xzIG9mIHJpZ2h0XG4gICAgZm9yICh2YXIgcmlnaHRDb2x1bW4gPSAwOyByaWdodENvbHVtbiA8IHJpZ2h0Q29sdW1uczsgcmlnaHRDb2x1bW4rKykge1xuXG4gICAgICAvL2xvb3Agb3ZlciBjb2x1bW5zIG9mIGxlZnRcbiAgICAgIGZvciAodmFyIGxlZnRDb2x1bW4gPSAwOyBsZWZ0Q29sdW1uIDwgbGVmdENvbHVtbnM7IGxlZnRDb2x1bW4rKykge1xuICAgICAgICB2YXIgcmlnaHRDb2x1bW5CYXNlID0gcmlnaHRDb2x1bW5zICogbGVmdENvbHVtbjtcbiAgICAgICAgdmFyIF9sZWZ0Um93ID0gbGVmdFJvd0Jhc2UgKyBsZWZ0Q29sdW1uO1xuICAgICAgICB2YXIgcmlnaHRSb3cgPSByaWdodENvbHVtbkJhc2UgKyByaWdodENvbHVtbjtcbiAgICAgICAgdmFyIGJhY2tQcm9wYWdhdGVWYWx1ZSA9IHByb2R1Y3QuZGVsdGFzW3JpZ2h0Um93QmFzZSArIHJpZ2h0Q29sdW1uXTtcbiAgICAgICAgbGVmdC5kZWx0YXNbX2xlZnRSb3ddICs9IHJpZ2h0LndlaWdodHNbcmlnaHRSb3ddICogYmFja1Byb3BhZ2F0ZVZhbHVlO1xuICAgICAgICByaWdodC5kZWx0YXNbcmlnaHRSb3ddICs9IGxlZnQud2VpZ2h0c1tfbGVmdFJvd10gKiBiYWNrUHJvcGFnYXRlVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBseS1iLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbXVsdGlwbHlFbGVtZW50Qjtcbi8qKlxuICogbXVsdGlwbGllcyB7bGVmdH0gYW5kIHtyaWdodH0gd2VpZ2h0IGJ5IHtmcm9tfSBkZWx0YXMgaW50byB7bGVmdH0gYW5kIHtyaWdodH0gZGVsdGFzXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqIEBwYXJhbSB7TWF0cml4fSByaWdodFxuICovXG5mdW5jdGlvbiBtdWx0aXBseUVsZW1lbnRCKHByb2R1Y3QsIGxlZnQsIHJpZ2h0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC53ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVmdC5kZWx0YXNbaV0gPSByaWdodC53ZWlnaHRzW2ldICogcHJvZHVjdC5kZWx0YXNbaV07XG4gICAgcmlnaHQuZGVsdGFzW2ldID0gbGVmdC53ZWlnaHRzW2ldICogcHJvZHVjdC5kZWx0YXNbaV07XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpcGx5LWVsZW1lbnQtYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG11bHRpcGx5RWxlbWVudDtcbi8qKlxuICogQHBhcmFtIHtNYXRyaXh9IHByb2R1Y3RcbiAqIEBwYXJhbSB7TWF0cml4fSBsZWZ0XG4gKiBAcGFyYW0ge01hdHJpeH0gcmlnaHRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHlFbGVtZW50KHByb2R1Y3QsIGxlZnQsIHJpZ2h0KSB7XG4gIHZhciB3ZWlnaHRzID0gbGVmdC53ZWlnaHRzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgIHByb2R1Y3Qud2VpZ2h0c1tpXSA9IGxlZnQud2VpZ2h0c1tpXSAqIHJpZ2h0LndlaWdodHNbaV07XG4gICAgcHJvZHVjdC5kZWx0YXNbaV0gPSAwO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBseS1lbGVtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbXVsdGlwbHk7XG4vKipcbiAqIG11bHRpcGx5IHtsZWZ0fSBhbmQge3JpZ2h0fSBtYXRyaXggd2VpZ2h0cyB0byB7aW50b31cbiAqIEBwYXJhbSB7TWF0cml4fSBwcm9kdWN0XG4gKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICogQHBhcmFtIHtNYXRyaXh9IHJpZ2h0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KHByb2R1Y3QsIGxlZnQsIHJpZ2h0KSB7XG4gIHZhciBsZWZ0Um93cyA9IGxlZnQucm93cztcbiAgdmFyIGxlZnRDb2x1bW5zID0gbGVmdC5jb2x1bW5zO1xuICB2YXIgcmlnaHRDb2x1bW5zID0gcmlnaHQuY29sdW1ucztcblxuICAvLyBsb29wIG92ZXIgcm93cyBvZiBsZWZ0XG4gIGZvciAodmFyIGxlZnRSb3cgPSAwOyBsZWZ0Um93IDwgbGVmdFJvd3M7IGxlZnRSb3crKykge1xuICAgIHZhciBsZWZ0Um93QmFzZSA9IGxlZnRDb2x1bW5zICogbGVmdFJvdztcbiAgICB2YXIgcmlnaHRSb3dCYXNlID0gcmlnaHRDb2x1bW5zICogbGVmdFJvdztcbiAgICAvLyBsb29wIG92ZXIgY29scyBvZiByaWdodFxuICAgIGZvciAodmFyIHJpZ2h0Q29sdW1uID0gMDsgcmlnaHRDb2x1bW4gPCByaWdodENvbHVtbnM7IHJpZ2h0Q29sdW1uKyspIHtcblxuICAgICAgLy8gZG90IHByb2R1Y3QgbG9vcFxuICAgICAgdmFyIGRvdCA9IDA7XG4gICAgICAvL2xvb3Agb3ZlciBjb2x1bW5zIG9mIGxlZnRcbiAgICAgIGZvciAodmFyIGxlZnRDb2x1bW4gPSAwOyBsZWZ0Q29sdW1uIDwgbGVmdENvbHVtbnM7IGxlZnRDb2x1bW4rKykge1xuICAgICAgICB2YXIgcmlnaHRDb2x1bW5CYXNlID0gcmlnaHRDb2x1bW5zICogbGVmdENvbHVtbjtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IGxlZnRSb3dCYXNlICsgbGVmdENvbHVtbjtcbiAgICAgICAgdmFyIHJpZ2h0SW5kZXggPSByaWdodENvbHVtbkJhc2UgKyByaWdodENvbHVtbjtcbiAgICAgICAgZG90ICs9IGxlZnQud2VpZ2h0c1tsZWZ0SW5kZXhdICogcmlnaHQud2VpZ2h0c1tyaWdodEluZGV4XTtcbiAgICAgICAgbGVmdC5kZWx0YXNbbGVmdEluZGV4XSA9IDA7XG4gICAgICAgIHJpZ2h0LmRlbHRhc1tyaWdodEluZGV4XSA9IDA7XG4gICAgICB9XG4gICAgICBwcm9kdWN0LndlaWdodHNbcmlnaHRSb3dCYXNlICsgcmlnaHRDb2x1bW5dID0gZG90O1xuICAgIH1cbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbHkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgXyA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciBfMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoXyk7XG5cbnZhciBfb25lcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9vbmVzJyk7XG5cbnZhciBfb25lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiogcmV0dXJuIE1hdHJpeCBidXQgZmlsbGVkIHdpdGggcmFuZG9tIG51bWJlcnMgZnJvbSBnYXVzc2lhblxuICogQHBhcmFtIHtOdW1iZXJ9IFtyb3dzXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb2x1bW5zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPbmVzTWF0cml4ID0gZnVuY3Rpb24gKF9NYXRyaXgpIHtcbiAgX2luaGVyaXRzKE9uZXNNYXRyaXgsIF9NYXRyaXgpO1xuXG4gIGZ1bmN0aW9uIE9uZXNNYXRyaXgocm93cywgY29sdW1ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPbmVzTWF0cml4KTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPbmVzTWF0cml4Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT25lc01hdHJpeCkpLmNhbGwodGhpcywgcm93cywgY29sdW1ucykpO1xuXG4gICAgX3RoaXMucm93cyA9IHJvd3M7XG4gICAgX3RoaXMuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgX3RoaXMud2VpZ2h0cyA9ICgwLCBfb25lczIuZGVmYXVsdCkocm93cyAqIGNvbHVtbnMpO1xuICAgIF90aGlzLmRlbHRhcyA9ICgwLCBfb25lczIuZGVmYXVsdCkocm93cyAqIGNvbHVtbnMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBPbmVzTWF0cml4O1xufShfMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gT25lc01hdHJpeDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZXMtbWF0cml4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF8gPSByZXF1aXJlKCcuLycpO1xuXG52YXIgXzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF8pO1xuXG52YXIgX3JhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9yYW5kb20nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKiogcmV0dXJuIE1hdHJpeCBidXQgZmlsbGVkIHdpdGggcmFuZG9tIG51bWJlcnMgZnJvbSBnYXVzc2lhblxuICogQHBhcmFtIHtOdW1iZXJ9IFtyb3dzXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtjb2x1bW5zXVxuICogQHBhcmFtIHN0ZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSYW5kb21NYXRyaXggPSBmdW5jdGlvbiAoX01hdHJpeCkge1xuICBfaW5oZXJpdHMoUmFuZG9tTWF0cml4LCBfTWF0cml4KTtcblxuICBmdW5jdGlvbiBSYW5kb21NYXRyaXgocm93cywgY29sdW1ucywgc3RkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhbmRvbU1hdHJpeCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmFuZG9tTWF0cml4Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmFuZG9tTWF0cml4KSkuY2FsbCh0aGlzLCByb3dzLCBjb2x1bW5zKSk7XG5cbiAgICBfdGhpcy5yb3dzID0gcm93cztcbiAgICBfdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgICBfdGhpcy5zdGQgPSBzdGQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IF90aGlzLndlaWdodHMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIF90aGlzLndlaWdodHNbaV0gPSAoMCwgX3JhbmRvbS5yYW5kb21GKSgtc3RkLCBzdGQpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUmFuZG9tTWF0cml4O1xufShfMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmFuZG9tTWF0cml4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLW1hdHJpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbHVCO1xuLyoqXG4gKiBhZGRzIHtmcm9tfSBkZWx0YXMgdG8ge219IGRlbHRhcyB3aGVuIHttfSB3ZWlnaHRzIGFyZSBhYm92ZSBvdGhlciBhIHRocmVzaG9sZCBvZiAwXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IG1cbiAqL1xuZnVuY3Rpb24gcmVsdUIocHJvZHVjdCwgbGVmdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2R1Y3QuZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGVmdC5kZWx0YXNbaV0gPSBsZWZ0LndlaWdodHNbaV0gPiAwID8gcHJvZHVjdC5kZWx0YXNbaV0gOiAwO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWx1LWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZWx1O1xuLyoqXG4gKlxuICogcmVsdSB7bX0gd2VpZ2h0cyB0byB7aW50b30gd2VpZ2h0c1xuICogQHBhcmFtIHtNYXRyaXh9IHByb2R1Y3RcbiAqIEBwYXJhbSB7TWF0cml4fSBsZWZ0XG4gKi9cbmZ1bmN0aW9uIHJlbHUocHJvZHVjdCwgbGVmdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgIHByb2R1Y3Qud2VpZ2h0c1tpXSA9IE1hdGgubWF4KDAsIGxlZnQud2VpZ2h0c1tpXSk7IC8vIHJlbHVcbiAgICBwcm9kdWN0LmRlbHRhc1tpXSA9IDA7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbHUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByb3dQbHVja0I7XG4vKipcbiAqIGFkZHMge2Zyb219IGRlbHRhcyBpbnRvIHttfSBkZWx0YXNcbiAqIEBwYXJhbSB7TWF0cml4fSBwcm9kdWN0XG4gKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJvd0luZGV4XG4gKi9cbmZ1bmN0aW9uIHJvd1BsdWNrQihwcm9kdWN0LCBsZWZ0LCByb3dJbmRleCkge1xuICB2YXIgY29sdW1ucyA9IGxlZnQuY29sdW1ucztcbiAgdmFyIHJvd0Jhc2UgPSBjb2x1bW5zICogcm93SW5kZXg7XG4gIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgbGVmdC5kZWx0YXNbcm93QmFzZSArIGNvbHVtbl0gPSBwcm9kdWN0LmRlbHRhc1tjb2x1bW5dO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3ctcGx1Y2stYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJvd1BsdWNrO1xuLyoqXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqIEBwYXJhbSB7TnVtYmVyfSByb3dQbHVja0luZGV4XG4gKi9cbmZ1bmN0aW9uIHJvd1BsdWNrKHByb2R1Y3QsIGxlZnQsIHJvd1BsdWNrSW5kZXgpIHtcbiAgdmFyIGNvbHVtbnMgPSBsZWZ0LmNvbHVtbnM7XG4gIHZhciByb3dCYXNlID0gY29sdW1ucyAqIHJvd1BsdWNrSW5kZXg7XG4gIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IGNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgcHJvZHVjdC53ZWlnaHRzW2NvbHVtbl0gPSBsZWZ0LndlaWdodHNbcm93QmFzZSArIGNvbHVtbl07XG4gICAgcHJvZHVjdC5kZWx0YXNbY29sdW1uXSA9IDA7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdy1wbHVjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzYW1wbGVJO1xuXG52YXIgX3JhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9yYW5kb20nKTtcblxuLy9wcmV2ZW50IHBhcnNlciBmcm9tIHJlbmFtaW5nIHdoZW4gY2FsbGluZyB0b1N0cmluZygpIG1ldGhvZCBsYXRlclxudmFyIHJhbmRvbUYgPSBfcmFuZG9tLnJhbmRvbUY7XG4vKipcbiAqXG4gKiBAcGFyYW0ge01hdHJpeH0gbVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2FtcGxlSShtKSB7XG4gIC8vIHNhbXBsZSBhcmdtYXggZnJvbSB3LCBhc3N1bWluZyB3IGFyZVxuICAvLyBwcm9iYWJpbGl0aWVzIHRoYXQgc3VtIHRvIG9uZVxuICB2YXIgciA9IHJhbmRvbUYoMCwgMSk7XG4gIHZhciB4ID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgdyA9IG0ud2VpZ2h0cztcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHggKz0gd1tpXTtcbiAgICBpZiAoeCA+IHIpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhbXBsZS1pLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gc2lnbW9pZEI7XG4vKipcbiAqXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqL1xuZnVuY3Rpb24gc2lnbW9pZEIocHJvZHVjdCwgbGVmdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2R1Y3QuZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG13aSA9IHByb2R1Y3Qud2VpZ2h0c1tpXTtcbiAgICBsZWZ0LmRlbHRhc1tpXSA9IG13aSAqICgxIC0gbXdpKSAqIHByb2R1Y3QuZGVsdGFzW2ldO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWdtb2lkLWIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzaWdtb2lkO1xuLyoqXG4gKiBAcGFyYW0ge01hdHJpeH0gcHJvZHVjdFxuICogQHBhcmFtIHtNYXRyaXh9IGxlZnRcbiAqL1xuZnVuY3Rpb24gc2lnbW9pZChwcm9kdWN0LCBsZWZ0KSB7XG4gIC8vIHNpZ21vaWQgbm9ubGluZWFyaXR5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdC53ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdC53ZWlnaHRzW2ldID0gMSAvICgxICsgTWF0aC5leHAoLWxlZnQud2VpZ2h0c1tpXSkpO1xuICAgIHByb2R1Y3QuZGVsdGFzW2ldID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaWcoeCkge1xuICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbXB1dGluZyBzaWdtb2lkXG4gIHJldHVybiAxIC8gKDEgKyBNYXRoLmV4cCgteCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbW9pZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzb2Z0bWF4O1xuXG52YXIgXyA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciBfMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoXyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7TWF0cml4fSBtXG4gKiBAcmV0dXJucyB7TWF0cml4fVxuICovXG5mdW5jdGlvbiBzb2Z0bWF4KG0pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBfMi5kZWZhdWx0KG0ucm93cywgbS5jb2x1bW5zKTsgLy8gcHJvYmFiaWxpdHkgdm9sdW1lXG4gIHZhciBtYXhWYWwgPSAtOTk5OTk5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ud2VpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtLndlaWdodHNbaV0gPiBtYXhWYWwpIHtcbiAgICAgIG1heFZhbCA9IG0ud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cblxuICB2YXIgcyA9IDA7XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBtLndlaWdodHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgcmVzdWx0LndlaWdodHNbX2ldID0gTWF0aC5leHAobS53ZWlnaHRzW19pXSAtIG1heFZhbCk7XG4gICAgcyArPSByZXN1bHQud2VpZ2h0c1tfaV07XG4gIH1cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBtLndlaWdodHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHJlc3VsdC53ZWlnaHRzW19pMl0gLz0gcztcbiAgfVxuXG4gIC8vIG5vIGJhY2t3YXJkIHBhc3MgaGVyZSBuZWVkZWRcbiAgLy8gc2luY2Ugd2Ugd2lsbCB1c2UgdGhlIGNvbXB1dGVkIHByb2JhYmlsaXRpZXMgb3V0c2lkZVxuICAvLyB0byBzZXQgZ3JhZGllbnRzIGRpcmVjdGx5IG9uIG1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvZnRtYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0YW5oQjtcbi8qKlxuICpcbiAqIEBwYXJhbSB7TWF0cml4fSBwcm9kdWN0XG4gKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICovXG5mdW5jdGlvbiB0YW5oQihwcm9kdWN0LCBsZWZ0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZHVjdC5kZWx0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBncmFkIGZvciB6ID0gdGFuaCh4KSBpcyAoMSAtIHpeMilcbiAgICB2YXIgbXdpID0gcHJvZHVjdC53ZWlnaHRzW2ldO1xuICAgIGxlZnQuZGVsdGFzW2ldID0gKDEgLSBtd2kgKiBtd2kpICogcHJvZHVjdC5kZWx0YXNbaV07XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhbmgtYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRhbmg7XG4vKipcbiAqIEBwYXJhbSB7TWF0cml4fSBwcm9kdWN0XG4gKiBAcGFyYW0ge01hdHJpeH0gbGVmdFxuICovXG5mdW5jdGlvbiB0YW5oKHByb2R1Y3QsIGxlZnQpIHtcbiAgLy8gdGFuaCBub25saW5lYXJpdHlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0LndlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9kdWN0LndlaWdodHNbaV0gPSBNYXRoLnRhbmgobGVmdC53ZWlnaHRzW2ldKTtcbiAgICBwcm9kdWN0LmRlbHRhc1tpXSA9IDA7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhbmguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG5cbnZhciBfbWF0cml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdHJpeCk7XG5cbnZhciBfcmFuZG9tTWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgvcmFuZG9tLW1hdHJpeCcpO1xuXG52YXIgX3JhbmRvbU1hdHJpeDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5kb21NYXRyaXgpO1xuXG52YXIgX2VxdWF0aW9uID0gcmVxdWlyZSgnLi9tYXRyaXgvZXF1YXRpb24nKTtcblxudmFyIF9lcXVhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lcXVhdGlvbik7XG5cbnZhciBfcm5uID0gcmVxdWlyZSgnLi9ybm4nKTtcblxudmFyIF9ybm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm5uKTtcblxudmFyIF96ZXJvcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy96ZXJvcycpO1xuXG52YXIgX3plcm9zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3plcm9zKTtcblxudmFyIF9zb2Z0bWF4ID0gcmVxdWlyZSgnLi9tYXRyaXgvc29mdG1heCcpO1xuXG52YXIgX3NvZnRtYXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc29mdG1heCk7XG5cbnZhciBfcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL3JhbmRvbScpO1xuXG52YXIgX3NhbXBsZUkgPSByZXF1aXJlKCcuL21hdHJpeC9zYW1wbGUtaScpO1xuXG52YXIgX3NhbXBsZUkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2FtcGxlSSk7XG5cbnZhciBfbWF4SSA9IHJlcXVpcmUoJy4vbWF0cml4L21heC1pJyk7XG5cbnZhciBfbWF4STIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXhJKTtcblxudmFyIF9sb29rdXAgPSByZXF1aXJlKCcuLi9sb29rdXAnKTtcblxudmFyIF9sb29rdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9va3VwKTtcblxudmFyIF9sb29rdXBUYWJsZTIgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvbG9va3VwLXRhYmxlJyk7XG5cbnZhciBfbG9va3VwVGFibGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9va3VwVGFibGUyKTtcblxudmFyIF9hcnJheUxvb2t1cFRhYmxlID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2FycmF5LWxvb2t1cC10YWJsZScpO1xuXG52YXIgX2FycmF5TG9va3VwVGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlMb29rdXBUYWJsZSk7XG5cbnZhciBfY2FzdCA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9jYXN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJOTlRpbWVTdGVwID0gZnVuY3Rpb24gKF9STk4pIHtcbiAgX2luaGVyaXRzKFJOTlRpbWVTdGVwLCBfUk5OKTtcblxuICBmdW5jdGlvbiBSTk5UaW1lU3RlcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUk5OVGltZVN0ZXApO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChSTk5UaW1lU3RlcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJOTlRpbWVTdGVwKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUk5OVGltZVN0ZXAsIFt7XG4gICAga2V5OiAnY3JlYXRlT3V0cHV0TWF0cml4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlT3V0cHV0TWF0cml4KCkge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgIHZhciBvdXRwdXRTaXplID0gdGhpcy5vdXRwdXRTaXplO1xuICAgICAgdmFyIGxhc3RIaWRkZW5TaXplID0gdGhpcy5oaWRkZW5MYXllcnNbdGhpcy5oaWRkZW5MYXllcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgIC8vd2hkXG4gICAgICBtb2RlbC5vdXRwdXRDb25uZWN0b3IgPSBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChvdXRwdXRTaXplLCBsYXN0SGlkZGVuU2l6ZSwgMC4wOCk7XG4gICAgICAvL2JkXG4gICAgICBtb2RlbC5vdXRwdXQgPSBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChvdXRwdXRTaXplLCAxLCAwLjA4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdiaW5kRXF1YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXF1YXRpb24oKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIGhpZGRlbkxheWVycyA9IHRoaXMuaGlkZGVuTGF5ZXJzO1xuICAgICAgdmFyIGxheWVycyA9IG1vZGVsLmhpZGRlbkxheWVycztcbiAgICAgIHZhciBlcXVhdGlvbiA9IG5ldyBfZXF1YXRpb24yLmRlZmF1bHQoKTtcbiAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICB2YXIgZXF1YXRpb25Db25uZWN0aW9uID0gbW9kZWwuZXF1YXRpb25Db25uZWN0aW9ucy5sZW5ndGggPiAwID8gbW9kZWwuZXF1YXRpb25Db25uZWN0aW9uc1ttb2RlbC5lcXVhdGlvbkNvbm5lY3Rpb25zLmxlbmd0aCAtIDFdIDogdGhpcy5pbml0aWFsTGF5ZXJJbnB1dHM7XG5cbiAgICAgIC8vIDAgaW5kZXhcbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmdldEVxdWF0aW9uKGVxdWF0aW9uLCBlcXVhdGlvbi5pbnB1dChuZXcgX21hdHJpeDIuZGVmYXVsdCh0aGlzLmlucHV0U2l6ZSwgMSkpLCBlcXVhdGlvbkNvbm5lY3Rpb25bMF0sIGxheWVyc1swXSk7XG4gICAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgIC8vIDErIGluZGljZXNcbiAgICAgIGZvciAodmFyIGkgPSAxLCBtYXggPSBoaWRkZW5MYXllcnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgb3V0cHV0ID0gdGhpcy5nZXRFcXVhdGlvbihlcXVhdGlvbiwgb3V0cHV0LCBlcXVhdGlvbkNvbm5lY3Rpb25baV0sIGxheWVyc1tpXSk7XG4gICAgICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICBtb2RlbC5lcXVhdGlvbkNvbm5lY3Rpb25zLnB1c2gob3V0cHV0cyk7XG4gICAgICBlcXVhdGlvbi5hZGQoZXF1YXRpb24ubXVsdGlwbHkobW9kZWwub3V0cHV0Q29ubmVjdG9yLCBvdXRwdXQpLCBtb2RlbC5vdXRwdXQpO1xuICAgICAgbW9kZWwuZXF1YXRpb25zLnB1c2goZXF1YXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21hcE1vZGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwTW9kZWwoKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIGhpZGRlbkxheWVycyA9IG1vZGVsLmhpZGRlbkxheWVycztcbiAgICAgIHZhciBhbGxNYXRyaWNlcyA9IG1vZGVsLmFsbE1hdHJpY2VzO1xuICAgICAgdGhpcy5pbml0aWFsTGF5ZXJJbnB1dHMgPSB0aGlzLmhpZGRlbkxheWVycy5tYXAoZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfbWF0cml4Mi5kZWZhdWx0KHNpemUsIDEpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY3JlYXRlSGlkZGVuTGF5ZXJzKCk7XG4gICAgICBpZiAoIW1vZGVsLmhpZGRlbkxheWVycy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignbmV0LmhpZGRlbkxheWVycyBub3Qgc2V0Jyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gaGlkZGVuTGF5ZXJzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIHZhciBoaWRkZW5NYXRyaXggPSBoaWRkZW5MYXllcnNbaV07XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGhpZGRlbk1hdHJpeCkge1xuICAgICAgICAgIGlmICghaGlkZGVuTWF0cml4Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkgY29udGludWU7XG4gICAgICAgICAgYWxsTWF0cmljZXMucHVzaChoaWRkZW5NYXRyaXhbcHJvcGVydHldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNyZWF0ZU91dHB1dE1hdHJpeCgpO1xuICAgICAgaWYgKCFtb2RlbC5vdXRwdXRDb25uZWN0b3IpIHRocm93IG5ldyBFcnJvcignbmV0Lm1vZGVsLm91dHB1dENvbm5lY3RvciBub3Qgc2V0Jyk7XG4gICAgICBpZiAoIW1vZGVsLm91dHB1dCkgdGhyb3cgbmV3IEVycm9yKCduZXQubW9kZWwub3V0cHV0IG5vdCBzZXQnKTtcblxuICAgICAgYWxsTWF0cmljZXMucHVzaChtb2RlbC5vdXRwdXRDb25uZWN0b3IpO1xuICAgICAgYWxsTWF0cmljZXMucHVzaChtb2RlbC5vdXRwdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JhY2twcm9wYWdhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYWNrcHJvcGFnYXRlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubW9kZWwuZXF1YXRpb25zLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIHRoaXMubW9kZWwuZXF1YXRpb25zW2ldLmJhY2twcm9wYWdhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW118bnVtYmVyW11bXXxvYmplY3R8b2JqZWN0W11bXX0gW3Jhd0lucHV0XVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXXxudW1iZXJ8b2JqZWN0fG9iamVjdFtdfG9iamVjdFtdW119XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3J1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bihyYXdJbnB1dCkge1xuICAgICAgaWYgKHRoaXMuaW5wdXRTaXplID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dExvb2t1cCkge1xuICAgICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW5PYmplY3Q7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucnVuT2JqZWN0KHJhd0lucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1biA9IHRoaXMucnVuTnVtYmVycztcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuTnVtYmVycyhyYXdJbnB1dCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJ1biA9IHRoaXMucnVuQXJyYXlzO1xuICAgICAgcmV0dXJuIHRoaXMucnVuQXJyYXlzKHJhd0lucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmb3JlY2FzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmVjYXN0KGlucHV0LCBjb3VudCkge1xuICAgICAgaWYgKHRoaXMuaW5wdXRTaXplID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dExvb2t1cCkge1xuICAgICAgICAgIHRoaXMuZm9yZWNhc3QgPSB0aGlzLnJ1bk9iamVjdDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ydW5PYmplY3QoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yZWNhc3QgPSB0aGlzLmZvcmVjYXN0TnVtYmVycztcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yZWNhc3ROdW1iZXJzKGlucHV0LCBjb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdXRwdXRMb29rdXApIHtcbiAgICAgICAgdGhpcy5mb3JlY2FzdCA9IHRoaXMuZm9yZWNhc3RPYmplY3RzO1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JlY2FzdE9iamVjdHMoaW5wdXQsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yZWNhc3QgPSB0aGlzLmZvcmVjYXN0QXJyYXlzO1xuICAgICAgcmV0dXJuIHRoaXMuZm9yZWNhc3RBcnJheXMoaW5wdXQsIGNvdW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W118U3RyaW5nW119IGRhdGEgYW4gYXJyYXkgb2Ygb2JqZWN0czogYHtpbnB1dDogJ3N0cmluZycsIG91dHB1dDogJ3N0cmluZyd9YCBvciBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEByZXR1cm5zIHt7ZXJyb3I6IG51bWJlciwgaXRlcmF0aW9uczogbnVtYmVyfX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHJhaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFpbihkYXRhKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHRoaXMudHJhaW5PcHRzID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uc3RydWN0b3IudHJhaW5EZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IG9wdGlvbnMuaXRlcmF0aW9ucztcbiAgICAgIHZhciBlcnJvclRocmVzaCA9IG9wdGlvbnMuZXJyb3JUaHJlc2g7XG4gICAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2cgPT09IHRydWUgPyBjb25zb2xlLmxvZyA6IG9wdGlvbnMubG9nO1xuICAgICAgdmFyIGxvZ1BlcmlvZCA9IG9wdGlvbnMubG9nUGVyaW9kO1xuICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICAgIHZhciBjYWxsYmFja1BlcmlvZCA9IG9wdGlvbnMuY2FsbGJhY2tQZXJpb2Q7XG5cbiAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSA9PT0gMSB8fCAhdGhpcy5pbnB1dFNpemUpIHtcbiAgICAgICAgdGhpcy5zZXRTaXplKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gdGhpcy5mb3JtYXREYXRhKGRhdGEpO1xuICAgICAgdmFyIGVycm9yID0gSW5maW5pdHk7XG4gICAgICB2YXIgaSA9IHZvaWQgMDtcblxuICAgICAgdGhpcy52ZXJpZnlJc0luaXRpYWxpemVkKGRhdGEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlcmF0aW9ucyAmJiBlcnJvciA+IGVycm9yVGhyZXNoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlcnIgPSB0aGlzLnRyYWluUGF0dGVybihkYXRhW2pdLCB0cnVlKTtcbiAgICAgICAgICBzdW0gKz0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gc3VtIC8gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGlzTmFOKGVycm9yKSkgdGhyb3cgbmV3IEVycm9yKCduZXR3b3JrIGVycm9yIHJhdGUgaXMgdW5leHBlY3RlZCBOYU4sIGNoZWNrIG5ldHdvcmsgY29uZmlndXJhdGlvbnMgYW5kIHRyeSBhZ2FpbicpO1xuICAgICAgICBpZiAobG9nICYmIGkgJSBsb2dQZXJpb2QgPT09IDApIHtcbiAgICAgICAgICBsb2coJ2l0ZXJhdGlvbnM6ICcgKyBpICsgJywgdHJhaW5pbmcgZXJyb3I6ICcgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIGkgJSBjYWxsYmFja1BlcmlvZCA9PT0gMCkge1xuICAgICAgICAgIGNhbGxiYWNrKHsgZXJyb3I6IGVycm9yLCBpdGVyYXRpb25zOiBpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgaXRlcmF0aW9uczogaVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogVmVyaWZpZXMgbmV0d29yayBzaXplcyBhcmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBJZiB0aGV5IGFyZSBub3QgaXQgd2lsbCBpbml0aWFsaXplIHRoZW0gYmFzZWQgb2ZmIHRoZSBkYXRhIHNldC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5SXNJbml0aWFsaXplZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUlzSW5pdGlhbGl6ZWQoZGF0YSkge1xuICAgICAgaWYgKGRhdGFbMF0uaW5wdXQpIHtcbiAgICAgICAgdGhpcy50cmFpbklucHV0ID0gdGhpcy50cmFpbklucHV0T3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChkYXRhWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGRhdGFbMF1bMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMudHJhaW5JbnB1dCA9IHRoaXMudHJhaW5BcnJheXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXRTaXplID4gMSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbklucHV0ID0gdGhpcy50cmFpbkFycmF5cztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFpbklucHV0ID0gdGhpcy50cmFpbk51bWJlcnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5tb2RlbCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZShkYXRhKSB7XG4gICAgICB2YXIgZGF0YVNoYXBlID0gX2xvb2t1cDIuZGVmYXVsdC5kYXRhU2hhcGUoZGF0YSkuam9pbignLCcpO1xuICAgICAgc3dpdGNoIChkYXRhU2hhcGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXksYXJyYXksbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYXJyYXksb2JqZWN0LG51bWJlcic6XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLGFycmF5LG51bWJlcic6XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIC8vIHByb2JhYmx5IDFcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyYXksYXJyYXksYXJyYXksbnVtYmVyJzpcbiAgICAgICAgICB0aGlzLmlucHV0U2l6ZSA9IHRoaXMub3V0cHV0U2l6ZSA9IGRhdGFbMF1bMF0ubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheSxhcnJheSxvYmplY3QsbnVtYmVyJzpcbiAgICAgICAgICB0aGlzLmlucHV0U2l6ZSA9IHRoaXMub3V0cHV0U2l6ZSA9IE9iamVjdC5rZXlzKF9sb29rdXAyLmRlZmF1bHQudG9UYWJsZTJEKGRhdGEpKS5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLGFycmF5LGFycmF5LG51bWJlcic6XG4gICAgICAgICAgdGhpcy5pbnB1dFNpemUgPSB0aGlzLm91dHB1dFNpemUgPSBkYXRhWzBdLmlucHV0WzBdLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyYXksZGF0dW0sYXJyYXksb2JqZWN0LG51bWJlcic6XG4gICAgICAgICAgdGhpcy5pbnB1dFNpemUgPSBPYmplY3Qua2V5cyhfbG9va3VwMi5kZWZhdWx0LnRvSW5wdXRUYWJsZTJEKGRhdGEpKS5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5vdXRwdXRTaXplID0gT2JqZWN0LmtleXMoX2xvb2t1cDIuZGVmYXVsdC50b091dHB1dFRhYmxlMkQoZGF0YSkpLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZGF0YSBzaGFwZSBvciBjb25maWd1cmF0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJhaW5OdW1iZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW5OdW1iZXJzKGlucHV0KSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIGVxdWF0aW9ucyA9IG1vZGVsLmVxdWF0aW9ucztcbiAgICAgIHdoaWxlIChlcXVhdGlvbnMubGVuZ3RoIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmluZEVxdWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JTdW0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGlucHV0Lmxlbmd0aCAtIDE7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBlcnJvclN1bSArPSBlcXVhdGlvbnNbaV0ucHJlZGljdFRhcmdldChpbnB1dFtpXSwgaW5wdXRbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kKCk7XG4gICAgICByZXR1cm4gZXJyb3JTdW0gLyBpbnB1dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncnVuTnVtYmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bk51bWJlcnMoaW5wdXQpIHtcbiAgICAgIGlmICghdGhpcy5pc1J1bm5hYmxlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb25zID0gbW9kZWwuZXF1YXRpb25zO1xuICAgICAgaWYgKHRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgaW5wdXQgPSBfbG9va3VwMi5kZWZhdWx0LnRvQXJyYXkodGhpcy5pbnB1dExvb2t1cCwgaW5wdXQsIHRoaXMuaW5wdXRMb29rdXBMZW5ndGgpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGVxdWF0aW9ucy5sZW5ndGggPD0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmluZEVxdWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdE91dHB1dCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGFzdE91dHB1dCA9IGVxdWF0aW9uc1tpXS5ydW5JbnB1dChbaW5wdXRbaV1dKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kKCk7XG4gICAgICByZXR1cm4gbGFzdE91dHB1dC53ZWlnaHRzWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZvcmVjYXN0TnVtYmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmVjYXN0TnVtYmVycyhpbnB1dCwgY291bnQpIHtcbiAgICAgIGlmICghdGhpcy5pc1J1bm5hYmxlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb25zID0gbW9kZWwuZXF1YXRpb25zO1xuICAgICAgdmFyIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCArIGNvdW50O1xuICAgICAgd2hpbGUgKGVxdWF0aW9ucy5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmluZEVxdWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdE91dHB1dCA9IHZvaWQgMDtcbiAgICAgIHZhciBlcXVhdGlvbkluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGFzdE91dHB1dCA9IGVxdWF0aW9uc1tlcXVhdGlvbkluZGV4KytdLnJ1bklucHV0KFtpbnB1dFtpXV0pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtsYXN0T3V0cHV0LndlaWdodHNbMF1dO1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYXggPSBjb3VudCAtIDE7IF9pIDwgbWF4OyBfaSsrKSB7XG4gICAgICAgIGxhc3RPdXRwdXQgPSBlcXVhdGlvbnNbZXF1YXRpb25JbmRleCsrXS5ydW5JbnB1dChsYXN0T3V0cHV0LndlaWdodHMpO1xuICAgICAgICByZXN1bHQucHVzaChsYXN0T3V0cHV0LndlaWdodHNbMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncnVuT2JqZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuT2JqZWN0KGlucHV0KSB7XG4gICAgICBpZiAodGhpcy5pbnB1dExvb2t1cCA9PT0gdGhpcy5vdXRwdXRMb29rdXApIHtcbiAgICAgICAgdmFyIGlucHV0QXJyYXkgPSBfbG9va3VwMi5kZWZhdWx0LnRvQXJyYXlTaG9ydCh0aGlzLmlucHV0TG9va3VwLCBpbnB1dCk7XG4gICAgICAgIHJldHVybiBfbG9va3VwMi5kZWZhdWx0LnRvT2JqZWN0UGFydGlhbCh0aGlzLm91dHB1dExvb2t1cCwgdGhpcy5mb3JlY2FzdE51bWJlcnMoaW5wdXRBcnJheSwgdGhpcy5vdXRwdXRMb29rdXBMZW5ndGggLSBpbnB1dEFycmF5Lmxlbmd0aCksIGlucHV0QXJyYXkubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfbG9va3VwMi5kZWZhdWx0LnRvT2JqZWN0KHRoaXMub3V0cHV0TG9va3VwLCB0aGlzLmZvcmVjYXN0TnVtYmVycyhfbG9va3VwMi5kZWZhdWx0LnRvQXJyYXkodGhpcy5pbnB1dExvb2t1cCwgaW5wdXQsIHRoaXMuaW5wdXRMb29rdXBMZW5ndGgpLCB0aGlzLm91dHB1dExvb2t1cExlbmd0aCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZvcmVjYXN0T2JqZWN0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmVjYXN0T2JqZWN0cyhpbnB1dCwgY291bnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpbnB1dCA9IGlucHV0Lm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9sb29rdXAyLmRlZmF1bHQudG9BcnJheShfdGhpczIub3V0cHV0TG9va3VwLCB2YWx1ZSwgX3RoaXMyLm91dHB1dExvb2t1cExlbmd0aCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmZvcmVjYXN0QXJyYXlzKGlucHV0LCBjb3VudCkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX2xvb2t1cDIuZGVmYXVsdC50b09iamVjdChfdGhpczIub3V0cHV0TG9va3VwLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0cmFpbklucHV0T3V0cHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW5JbnB1dE91dHB1dChvYmplY3QpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgaW5wdXQgPSBvYmplY3QuaW5wdXQ7XG4gICAgICB2YXIgb3V0cHV0ID0gb2JqZWN0Lm91dHB1dDtcbiAgICAgIHZhciB0b3RhbFNpemUgPSBpbnB1dC5sZW5ndGggKyBvdXRwdXQubGVuZ3RoO1xuICAgICAgdmFyIGVxdWF0aW9ucyA9IG1vZGVsLmVxdWF0aW9ucztcbiAgICAgIHdoaWxlIChlcXVhdGlvbnMubGVuZ3RoIDwgdG90YWxTaXplKSB7XG4gICAgICAgIHRoaXMuYmluZEVxdWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JTdW0gPSAwO1xuICAgICAgdmFyIGVxdWF0aW9uSW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgaW5wdXRJbmRleCA9IDAsIG1heCA9IGlucHV0Lmxlbmd0aCAtIDE7IGlucHV0SW5kZXggPCBtYXg7IGlucHV0SW5kZXgrKykge1xuICAgICAgICBlcnJvclN1bSArPSBlcXVhdGlvbnNbZXF1YXRpb25JbmRleCsrXS5wcmVkaWN0VGFyZ2V0KGlucHV0W2lucHV0SW5kZXhdLCBpbnB1dFtpbnB1dEluZGV4ICsgMV0pO1xuICAgICAgfVxuICAgICAgZXJyb3JTdW0gKz0gZXF1YXRpb25zW2VxdWF0aW9uSW5kZXgrK10ucHJlZGljdFRhcmdldChpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSwgb3V0cHV0WzBdKTtcbiAgICAgIGZvciAodmFyIG91dHB1dEluZGV4ID0gMCwgX21heCA9IG91dHB1dC5sZW5ndGggLSAxOyBvdXRwdXRJbmRleCA8IF9tYXg7IG91dHB1dEluZGV4KyspIHtcbiAgICAgICAgZXJyb3JTdW0gKz0gZXF1YXRpb25zW2VxdWF0aW9uSW5kZXgrK10ucHJlZGljdFRhcmdldChvdXRwdXRbb3V0cHV0SW5kZXhdLCBvdXRwdXRbb3V0cHV0SW5kZXggKyAxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCgpO1xuICAgICAgcmV0dXJuIGVycm9yU3VtIC8gdG90YWxTaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyYWluQXJyYXlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW5BcnJheXMoaW5wdXQpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb25zID0gbW9kZWwuZXF1YXRpb25zO1xuICAgICAgd2hpbGUgKGVxdWF0aW9ucy5sZW5ndGggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5iaW5kRXF1YXRpb24oKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvclN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gaW5wdXQubGVuZ3RoIC0gMTsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIGVycm9yU3VtICs9IGVxdWF0aW9uc1tpXS5wcmVkaWN0VGFyZ2V0KGlucHV0W2ldLCBpbnB1dFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIHJldHVybiBlcnJvclN1bSAvIGlucHV0Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdydW5BcnJheXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5BcnJheXMoaW5wdXQpIHtcbiAgICAgIGlmICghdGhpcy5pc1J1bm5hYmxlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb25zID0gbW9kZWwuZXF1YXRpb25zO1xuICAgICAgd2hpbGUgKGVxdWF0aW9ucy5sZW5ndGggPD0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmluZEVxdWF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pbnB1dExvb2t1cCkge1xuICAgICAgICBpbnB1dCA9IF9sb29rdXAyLmRlZmF1bHQudG9BcnJheXModGhpcy5pbnB1dExvb2t1cCwgaW5wdXQsIHRoaXMuaW5wdXRMb29rdXBMZW5ndGgpO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RPdXRwdXQgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRNYXRyaXggPSBlcXVhdGlvbnNbaV0ucnVuSW5wdXQoaW5wdXRbaV0pO1xuICAgICAgICBsYXN0T3V0cHV0ID0gb3V0cHV0TWF0cml4LndlaWdodHM7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCgpO1xuICAgICAgaWYgKHRoaXMub3V0cHV0TG9va3VwKSB7XG4gICAgICAgIHJldHVybiBfbG9va3VwMi5kZWZhdWx0LnRvT2JqZWN0KHRoaXMub3V0cHV0TG9va3VwLCBsYXN0T3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0T3V0cHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZvcmVjYXN0QXJyYXlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yZWNhc3RBcnJheXMoaW5wdXQsIGNvdW50KSB7XG4gICAgICBpZiAoIXRoaXMuaXNSdW5uYWJsZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIGVxdWF0aW9ucyA9IG1vZGVsLmVxdWF0aW9ucztcbiAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGggKyBjb3VudDtcbiAgICAgIHdoaWxlIChlcXVhdGlvbnMubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmJpbmRFcXVhdGlvbigpO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RPdXRwdXQgPSB2b2lkIDA7XG4gICAgICB2YXIgZXF1YXRpb25JbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxhc3RPdXRwdXQgPSBlcXVhdGlvbnNbZXF1YXRpb25JbmRleCsrXS5ydW5JbnB1dChpbnB1dFtpXSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW2xhc3RPdXRwdXQud2VpZ2h0c107XG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBtYXggPSBjb3VudCAtIDE7IF9pMiA8IG1heDsgX2kyKyspIHtcbiAgICAgICAgbGFzdE91dHB1dCA9IGVxdWF0aW9uc1tlcXVhdGlvbkluZGV4KytdLnJ1bklucHV0KGxhc3RPdXRwdXQud2VpZ2h0cyk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxhc3RPdXRwdXQud2VpZ2h0cy5zbGljZSgwKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICB0aGlzLm1vZGVsLmVxdWF0aW9uc1t0aGlzLm1vZGVsLmVxdWF0aW9ucy5sZW5ndGggLSAxXS5ydW5JbnB1dChuZXcgRmxvYXQzMkFycmF5KHRoaXMub3V0cHV0U2l6ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZm9ybWF0RGF0YScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdERhdGEoZGF0YSkge1xuICAgICAgdmFyIGRhdGFTaGFwZSA9IF9sb29rdXAyLmRlZmF1bHQuZGF0YVNoYXBlKGRhdGEpLmpvaW4oJywnKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHN3aXRjaCAoZGF0YVNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRTaXplICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRTaXplIG11c3QgYmUgMSBmb3IgdGhpcyBkYXRhIHNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFNpemUgIT09IDEpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRTaXplIG11c3QgYmUgMSBmb3IgdGhpcyBkYXRhIHNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChGbG9hdDMyQXJyYXkuZnJvbShbZGF0YVtpXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LGFycmF5LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRTaXplID09PSAxICYmIHRoaXMub3V0cHV0U2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBkYXRhLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgoMCwgX2Nhc3QuYXJyYXlUb0Zsb2F0MzJBcnJheXMpKGRhdGFbX2kzXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dFNpemUgIT09IGRhdGFbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRTaXplIG11c3QgbWF0Y2ggZGF0YSBpbnB1dCBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRTaXplICE9PSBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dFNpemUgbXVzdCBtYXRjaCBkYXRhIGlucHV0IHNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGRhdGEubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChGbG9hdDMyQXJyYXkuZnJvbShkYXRhW19pNF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSAhPT0gMSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0U2l6ZSBtdXN0IGJlIDEgZm9yIHRoaXMgZGF0YSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRTaXplICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0U2l6ZSBtdXN0IGJlIDEgZm9yIHRoaXMgZGF0YSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlID0gbmV3IF9sb29rdXBUYWJsZTMuZGVmYXVsdChkYXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5pbnB1dExvb2t1cCA9IHRoaXMub3V0cHV0TG9va3VwID0gbG9va3VwVGFibGUudGFibGU7XG4gICAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IGxvb2t1cFRhYmxlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGRhdGEubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCgoMCwgX2Nhc3Qub2JqZWN0VG9GbG9hdDMyQXJyYXlzKShkYXRhW19pNV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSxkYXR1bSxhcnJheSxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSAhPT0gMSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0U2l6ZSBtdXN0IGJlIDEgZm9yIHRoaXMgZGF0YSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRTaXplICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0U2l6ZSBtdXN0IGJlIDEgZm9yIHRoaXMgZGF0YSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkYXRhLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgICAgICAgdmFyIGRhdHVtID0gZGF0YVtfaTZdO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgwLCBfY2FzdC5hcnJheVRvRmxvYXQzMkFycmF5cykoZGF0dW0uaW5wdXQpLFxuICAgICAgICAgICAgICAgIG91dHB1dDogKDAsIF9jYXN0LmFycmF5VG9GbG9hdDMyQXJyYXlzKShkYXR1bS5vdXRwdXQpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSAhPT0gMSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0U2l6ZSBtdXN0IGJlIDEgZm9yIHRoaXMgZGF0YSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRTaXplICE9PSAxKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0U2l6ZSBtdXN0IGJlIDEgZm9yIHRoaXMgZGF0YSBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0TG9va3VwID0gbmV3IF9sb29rdXBUYWJsZTMuZGVmYXVsdChkYXRhLCAnaW5wdXQnKTtcbiAgICAgICAgICAgICAgdGhpcy5pbnB1dExvb2t1cCA9IGlucHV0TG9va3VwLnRhYmxlO1xuICAgICAgICAgICAgICB0aGlzLmlucHV0TG9va3VwTGVuZ3RoID0gaW5wdXRMb29rdXAubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm91dHB1dExvb2t1cCkge1xuICAgICAgICAgICAgICB2YXIgb3V0cHV0TG9va3VwID0gbmV3IF9sb29rdXBUYWJsZTMuZGVmYXVsdChkYXRhLCAnb3V0cHV0Jyk7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwID0gb3V0cHV0TG9va3VwLnRhYmxlO1xuICAgICAgICAgICAgICB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IG91dHB1dExvb2t1cC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBkYXRhLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgICAgICAgICAgdmFyIF9kYXR1bSA9IGRhdGFbX2k3XTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiAoMCwgX2Nhc3Qub2JqZWN0VG9GbG9hdDMyQXJyYXlzKShfZGF0dW0uaW5wdXQpLFxuICAgICAgICAgICAgICAgIG91dHB1dDogKDAsIF9jYXN0Lm9iamVjdFRvRmxvYXQzMkFycmF5cykoX2RhdHVtLm91dHB1dClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXksYXJyYXksYXJyYXksbnVtYmVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBkYXRhLmxlbmd0aDsgX2k4KyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goKDAsIF9jYXN0LmFycmF5c1RvRmxvYXQzMkFycmF5cykoZGF0YVtfaThdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXksYXJyYXksb2JqZWN0LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0TG9va3VwKSB7XG4gICAgICAgICAgICAgIHZhciBfbG9va3VwVGFibGUgPSBuZXcgX2xvb2t1cFRhYmxlMy5kZWZhdWx0KGRhdGEpO1xuICAgICAgICAgICAgICB0aGlzLmlucHV0TG9va3VwID0gdGhpcy5vdXRwdXRMb29rdXAgPSBfbG9va3VwVGFibGUudGFibGU7XG4gICAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IF9sb29rdXBUYWJsZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBkYXRhLmxlbmd0aDsgX2k5KyspIHtcbiAgICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtfaTldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCgoMCwgX2Nhc3Qub2JqZWN0VG9GbG9hdDMyQXJyYXkpKGRhdGFbX2k5XVtqXSwgdGhpcy5pbnB1dExvb2t1cCwgdGhpcy5pbnB1dExvb2t1cExlbmd0aCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSxkYXR1bSxhcnJheSxhcnJheSxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSA9PT0gMSAmJiB0aGlzLm91dHB1dFNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBkYXRhLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kYXR1bTIgPSBkYXRhW19pMTBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBGbG9hdDMyQXJyYXkuZnJvbShfZGF0dW0yLmlucHV0KSxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogRmxvYXQzMkFycmF5LmZyb20oX2RhdHVtMi5vdXRwdXQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSAhPT0gZGF0YVswXS5pbnB1dFswXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0U2l6ZSBtdXN0IG1hdGNoIGRhdGEgaW5wdXQgc2l6ZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFNpemUgIT09IGRhdGFbMF0ub3V0cHV0WzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0U2l6ZSBtdXN0IG1hdGNoIGRhdGEgb3V0cHV0IHNpemUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IGRhdGEubGVuZ3RoOyBfaTExKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RhdHVtMyA9IGRhdGFbX2kxMV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgwLCBfY2FzdC5hcnJheXNUb0Zsb2F0MzJBcnJheXMpKF9kYXR1bTMuaW5wdXQpLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoMCwgX2Nhc3QuYXJyYXlzVG9GbG9hdDMyQXJyYXlzKShfZGF0dW0zLm91dHB1dClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLGFycmF5LG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dExvb2t1cCkge1xuICAgICAgICAgICAgICB2YXIgX2lucHV0TG9va3VwID0gbmV3IF9hcnJheUxvb2t1cFRhYmxlMi5kZWZhdWx0KGRhdGEsICdpbnB1dCcpO1xuICAgICAgICAgICAgICB0aGlzLmlucHV0TG9va3VwID0gX2lucHV0TG9va3VwLnRhYmxlO1xuICAgICAgICAgICAgICB0aGlzLmlucHV0TG9va3VwTGVuZ3RoID0gX2lucHV0TG9va3VwLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRwdXRMb29rdXApIHtcbiAgICAgICAgICAgICAgdmFyIF9vdXRwdXRMb29rdXAgPSBuZXcgX2FycmF5TG9va3VwVGFibGUyLmRlZmF1bHQoZGF0YSwgJ291dHB1dCcpO1xuICAgICAgICAgICAgICB0aGlzLm91dHB1dExvb2t1cCA9IF9vdXRwdXRMb29rdXAudGFibGU7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwTGVuZ3RoID0gX291dHB1dExvb2t1cC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IGRhdGEubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9kYXR1bTQgPSBkYXRhW19pMTJdO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgwLCBfY2FzdC5vYmplY3RzVG9GbG9hdDMyQXJyYXlzKShfZGF0dW00LmlucHV0LCB0aGlzLmlucHV0TG9va3VwLCB0aGlzLmlucHV0TG9va3VwTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgwLCBfY2FzdC5vYmplY3RzVG9GbG9hdDMyQXJyYXlzKShfZGF0dW00Lm91dHB1dCwgdGhpcy5vdXRwdXRMb29rdXAsIHRoaXMub3V0cHV0TG9va3VwTGVuZ3RoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBkYXRhIHNoYXBlIG9yIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHJldHVybnMge1xuICAgICAqICB7XG4gICAgICogICAgZXJyb3I6IG51bWJlcixcbiAgICAgKiAgICBtaXNjbGFzc2VzOiBBcnJheVxuICAgICAqICB9XG4gICAgICogfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChkYXRhKSB7XG4gICAgICB2YXIgZm9ybWF0dGVkRGF0YSA9IHRoaXMuZm9ybWF0RGF0YShkYXRhKTtcbiAgICAgIC8vIGZvciBjbGFzc2lmaWNhdGlvbiBwcm9ibGVtc1xuICAgICAgdmFyIG1pc2NsYXNzZXMgPSBbXTtcbiAgICAgIC8vIHJ1biBlYWNoIHBhdHRlcm4gdGhyb3VnaCB0aGUgdHJhaW5lZCBuZXR3b3JrIGFuZCBjb2xsZWN0XG4gICAgICAvLyBlcnJvciBhbmQgbWlzY2xhc3NpZmljYXRpb24gc3RhdGlzdGljc1xuICAgICAgdmFyIGVycm9yU3VtID0gMDtcbiAgICAgIHZhciBkYXRhU2hhcGUgPSBfbG9va3VwMi5kZWZhdWx0LmRhdGFTaGFwZShkYXRhKS5qb2luKCcsJyk7XG4gICAgICBzd2l0Y2ggKGRhdGFTaGFwZSkge1xuICAgICAgICBjYXNlICdhcnJheSxhcnJheSxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0U2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlZERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSBmb3JtYXR0ZWREYXRhW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLnJ1bihpbnB1dC5zcGxpY2UoMCwgaW5wdXQubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBpbnB1dFtpbnB1dC5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB0YXJnZXQgLSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTVNFID0gZXJyb3IgKiBlcnJvcjtcbiAgICAgICAgICAgICAgICBlcnJvclN1bSArPSBlcnJvck1TRTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzQWJzID0gTWF0aC5hYnMoZXJyb3JNU0UpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnNBYnMgPiB0aGlzLnRyYWluT3B0cy5lcnJvclRocmVzaCkge1xuICAgICAgICAgICAgICAgICAgdmFyIG1pc2NsYXNzID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obWlzY2xhc3MsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IG91dHB1dFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtaXNjbGFzc2VzLnB1c2gobWlzY2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBkYXRhIHNoYXBlIG9yIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LGFycmF5LGFycmF5LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCBmb3JtYXR0ZWREYXRhLmxlbmd0aDsgX2kxMysrKSB7XG4gICAgICAgICAgICAgIHZhciBfaW5wdXQgPSBmb3JtYXR0ZWREYXRhW19pMTNdO1xuICAgICAgICAgICAgICB2YXIgX291dHB1dCA9IHRoaXMucnVuKF9pbnB1dC5zcGxpY2UoMCwgX2lucHV0Lmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgICAgdmFyIF90YXJnZXQgPSBfaW5wdXRbX2lucHV0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gMDtcbiAgICAgICAgICAgICAgdmFyIGVycm9yQ291bnQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9vdXRwdXQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvdW50Kys7XG4gICAgICAgICAgICAgICAgdmFyIF9lcnJvciA9IF90YXJnZXRbal0gLSBfb3V0cHV0W2pdO1xuICAgICAgICAgICAgICAgIC8vIG1zZVxuICAgICAgICAgICAgICAgIGVycm9ycyArPSBfZXJyb3IgKiBfZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXJyb3JTdW0gKz0gZXJyb3JzIC8gZXJyb3JDb3VudDtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvcnNBYnMgPSBNYXRoLmFicyhlcnJvcnMpO1xuICAgICAgICAgICAgICBpZiAoX2Vycm9yc0FicyA+IHRoaXMudHJhaW5PcHRzLmVycm9yVGhyZXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9taXNjbGFzcyA9IGRhdGFbX2kxM107XG4gICAgICAgICAgICAgICAgbWlzY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfbWlzY2xhc3MsXG4gICAgICAgICAgICAgICAgICBhY3R1YWw6IF9vdXRwdXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSxvYmplY3QsbnVtYmVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IGZvcm1hdHRlZERhdGEubGVuZ3RoOyBfaTE0KyspIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnB1dDIgPSBmb3JtYXR0ZWREYXRhW19pMTRdO1xuICAgICAgICAgICAgICB2YXIgX291dHB1dDIgPSB0aGlzLnJ1bihfbG9va3VwMi5kZWZhdWx0LnRvT2JqZWN0UGFydGlhbCh0aGlzLm91dHB1dExvb2t1cCwgX2lucHV0MiwgMCwgX2lucHV0Mi5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgIHZhciBfdGFyZ2V0MiA9IF9pbnB1dDJbX2lucHV0Mi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvcnMgPSAwO1xuICAgICAgICAgICAgICB2YXIgcCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgZm9yIChwIGluIF9vdXRwdXQyKSB7fVxuICAgICAgICAgICAgICB2YXIgX2Vycm9yMiA9IF90YXJnZXQyW19pMTRdIC0gX291dHB1dDJbcF07XG4gICAgICAgICAgICAgIC8vIG1zZVxuICAgICAgICAgICAgICBfZXJyb3JzICs9IF9lcnJvcjIgKiBfZXJyb3IyO1xuICAgICAgICAgICAgICBlcnJvclN1bSArPSBfZXJyb3JzO1xuICAgICAgICAgICAgICB2YXIgX2Vycm9yc0FiczIgPSBNYXRoLmFicyhfZXJyb3JzKTtcbiAgICAgICAgICAgICAgaWYgKF9lcnJvcnNBYnMyID4gdGhpcy50cmFpbk9wdHMuZXJyb3JUaHJlc2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgX21pc2NsYXNzMiA9IGRhdGFbX2kxNF07XG4gICAgICAgICAgICAgICAgbWlzY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfbWlzY2xhc3MyLFxuICAgICAgICAgICAgICAgICAgYWN0dWFsOiBfb3V0cHV0MlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LGFycmF5LG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMTUgPSAwOyBfaTE1IDwgZm9ybWF0dGVkRGF0YS5sZW5ndGg7IF9pMTUrKykge1xuICAgICAgICAgICAgICB2YXIgX2lucHV0MyA9IGZvcm1hdHRlZERhdGFbX2kxNV07XG4gICAgICAgICAgICAgIHZhciBfb3V0cHV0MyA9IHRoaXMucnVuKF9pbnB1dDMuc2xpY2UoMCwgX2lucHV0My5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgIHZhciBfdGFyZ2V0MyA9IGRhdGFbX2kxNV1bX2lucHV0My5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvcnMyID0gMDtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvckNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX3AgaW4gX291dHB1dDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2Vycm9yMyA9IF90YXJnZXQzW19wXSAtIF9vdXRwdXQzW19wXTtcbiAgICAgICAgICAgICAgICAvLyBtc2VcbiAgICAgICAgICAgICAgICBfZXJyb3JzMiArPSBfZXJyb3IzICogX2Vycm9yMztcbiAgICAgICAgICAgICAgICBfZXJyb3JDb3VudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVycm9yU3VtICs9IF9lcnJvcnMyIC8gX2Vycm9yQ291bnQ7XG4gICAgICAgICAgICAgIHZhciBfZXJyb3JzQWJzMyA9IE1hdGguYWJzKF9lcnJvcnMyKTtcbiAgICAgICAgICAgICAgaWYgKF9lcnJvcnNBYnMzID4gdGhpcy50cmFpbk9wdHMuZXJyb3JUaHJlc2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgX21pc2NsYXNzMyA9IGRhdGFbX2kxNV07XG4gICAgICAgICAgICAgICAgbWlzY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfbWlzY2xhc3MzLFxuICAgICAgICAgICAgICAgICAgYWN0dWFsOiBfb3V0cHV0M1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLGFycmF5LG51bWJlcic6XG4gICAgICAgIGNhc2UgJ2FycmF5LGRhdHVtLG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMTYgPSAwOyBfaTE2IDwgZm9ybWF0dGVkRGF0YS5sZW5ndGg7IF9pMTYrKykge1xuICAgICAgICAgICAgICB2YXIgZGF0dW0gPSBmb3JtYXR0ZWREYXRhW19pMTZdO1xuICAgICAgICAgICAgICB2YXIgX291dHB1dDQgPSB0aGlzLmZvcmVjYXN0KGRhdHVtLmlucHV0LCBkYXR1bS5vdXRwdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvcnMzID0gMDtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvckNvdW50MiA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBfb3V0cHV0NC5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2Vycm9yNCA9IGRhdHVtLm91dHB1dFtfal1bMF0gLSBfb3V0cHV0NFtfal07XG4gICAgICAgICAgICAgICAgX2Vycm9yczMgKz0gX2Vycm9yNCAqIF9lcnJvcjQ7XG4gICAgICAgICAgICAgICAgX2Vycm9yQ291bnQyKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlcnJvclN1bSArPSBfZXJyb3JzMyAvIF9lcnJvckNvdW50MjtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvcnNBYnM0ID0gTWF0aC5hYnMoX2Vycm9yczMpO1xuICAgICAgICAgICAgICBpZiAoX2Vycm9yc0FiczQgPiB0aGlzLnRyYWluT3B0cy5lcnJvclRocmVzaCkge1xuICAgICAgICAgICAgICAgIHZhciBfbWlzY2xhc3M0ID0gZGF0YVtfaTE2XTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKF9taXNjbGFzczQsIHtcbiAgICAgICAgICAgICAgICAgIGFjdHVhbDogdGhpcy5vdXRwdXRMb29rdXAgPyBfbG9va3VwMi5kZWZhdWx0LnRvT2JqZWN0KHRoaXMub3V0cHV0TG9va3VwLCBfb3V0cHV0NCkgOiBfb3V0cHV0NFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1pc2NsYXNzZXMucHVzaChfbWlzY2xhc3M0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSxkYXR1bSxhcnJheSxhcnJheSxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pMTcgPSAwOyBfaTE3IDwgZm9ybWF0dGVkRGF0YS5sZW5ndGg7IF9pMTcrKykge1xuICAgICAgICAgICAgICB2YXIgX2RhdHVtNSA9IGZvcm1hdHRlZERhdGFbX2kxN107XG4gICAgICAgICAgICAgIHZhciBfb3V0cHV0NSA9IHRoaXMuZm9yZWNhc3QoX2RhdHVtNS5pbnB1dCwgX2RhdHVtNS5vdXRwdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdmFyIF9lcnJvcnM0ID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgX291dHB1dDUubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgX291dHB1dDVbX2oyXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIF9lcnJvcjUgPSBfZGF0dW01Lm91dHB1dFtfajJdW2tdIC0gX291dHB1dDVbX2oyXVtrXTtcbiAgICAgICAgICAgICAgICAgIF9lcnJvcnM0ICs9IF9lcnJvcjUgKiBfZXJyb3I1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVycm9yU3VtICs9IF9lcnJvcnM0O1xuICAgICAgICAgICAgICB2YXIgX2Vycm9yc0FiczUgPSBNYXRoLmFicyhfZXJyb3JzNCk7XG4gICAgICAgICAgICAgIGlmIChfZXJyb3JzQWJzNSA+IHRoaXMudHJhaW5PcHRzLmVycm9yVGhyZXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9taXNjbGFzczUgPSBkYXRhW19pMTddO1xuICAgICAgICAgICAgICAgIG1pc2NsYXNzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogX21pc2NsYXNzNS5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogX21pc2NsYXNzNS5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICBhY3R1YWw6IF9vdXRwdXQ1XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXksZGF0dW0sYXJyYXksb2JqZWN0LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kxOCA9IDA7IF9pMTggPCBmb3JtYXR0ZWREYXRhLmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgICAgICAgIHZhciBfZGF0dW02ID0gZm9ybWF0dGVkRGF0YVtfaTE4XTtcbiAgICAgICAgICAgICAgdmFyIF9vdXRwdXQ2ID0gdGhpcy5mb3JlY2FzdChfZGF0dW02LmlucHV0LCBfZGF0dW02Lm91dHB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICB2YXIgX2Vycm9yczUgPSAwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBfb3V0cHV0Ni5sZW5ndGg7IF9qMysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX3AyIGluIF9vdXRwdXQ2W19qM10pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfZXJyb3I2ID0gZGF0YVtfaTE4XS5vdXRwdXRbX2ozXVtfcDJdIC0gX291dHB1dDZbX2ozXVtfcDJdO1xuICAgICAgICAgICAgICAgICAgX2Vycm9yczUgKz0gX2Vycm9yNiAqIF9lcnJvcjY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZXJyb3JTdW0gKz0gX2Vycm9yczU7XG4gICAgICAgICAgICAgIHZhciBfZXJyb3JzQWJzNiA9IE1hdGguYWJzKF9lcnJvcnM1KTtcbiAgICAgICAgICAgICAgaWYgKF9lcnJvcnNBYnM2ID4gdGhpcy50cmFpbk9wdHMuZXJyb3JUaHJlc2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgX21pc2NsYXNzNiA9IGRhdGFbX2kxOF07XG4gICAgICAgICAgICAgICAgbWlzY2xhc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBfbWlzY2xhc3M2LmlucHV0LFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiBfbWlzY2xhc3M2Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgIGFjdHVhbDogX291dHB1dDZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBkYXRhIHNoYXBlIG9yIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGVycm9yU3VtIC8gZm9ybWF0dGVkRGF0YS5sZW5ndGgsXG4gICAgICAgIG1pc2NsYXNzZXM6IG1pc2NsYXNzZXMsXG4gICAgICAgIHRvdGFsOiBmb3JtYXR0ZWREYXRhLmxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb3JtYXQodmFsdWUpIHtcbiAgICAgIHZhciBkYXRhU2hhcGUgPSBfbG9va3VwMi5kZWZhdWx0LmRhdGFTaGFwZSh2YWx1ZSkuam9pbignLCcpO1xuICAgICAgc3dpdGNoIChkYXRhU2hhcGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXksYXJyYXksbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZGF0dW0sYXJyYXksYXJyYXksbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYXJyYXksbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZGF0dW0sYXJyYXksbnVtYmVyJzpcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ2RhdHVtLG9iamVjdCxudW1iZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXAgPSBfbG9va3VwMi5kZWZhdWx0LmFkZEtleXModmFsdWUuaW5wdXQsIHRoaXMuaW5wdXRMb29rdXApO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRMb29rdXApIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnB1dExvb2t1cExlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuaW5wdXRMb29rdXApLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwID0gX2xvb2t1cDIuZGVmYXVsdC5hZGRLZXlzKHZhbHVlLm91dHB1dCwgdGhpcy5vdXRwdXRMb29rdXApO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0TG9va3VwKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwTGVuZ3RoID0gT2JqZWN0LmtleXModGhpcy5vdXRwdXRMb29rdXApLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnb2JqZWN0LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbnB1dExvb2t1cCA9IHRoaXMub3V0cHV0TG9va3VwID0gX2xvb2t1cDIuZGVmYXVsdC5hZGRLZXlzKHZhbHVlLCB0aGlzLmlucHV0TG9va3VwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0TG9va3VwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuaW5wdXRMb29rdXApLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXksb2JqZWN0LG51bWJlcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLmlucHV0TG9va3VwID0gdGhpcy5vdXRwdXRMb29rdXAgPSBfbG9va3VwMi5kZWZhdWx0LmFkZEtleXModmFsdWVbaV0sIHRoaXMuaW5wdXRMb29rdXApO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dExvb2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuaW5wdXRMb29rdXApLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkYXR1bSxhcnJheSxvYmplY3QsbnVtYmVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTE5ID0gMDsgX2kxOSA8IHZhbHVlLmlucHV0Lmxlbmd0aDsgX2kxOSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXAgPSBfbG9va3VwMi5kZWZhdWx0LmFkZEtleXModmFsdWUuaW5wdXRbX2kxOV0sIHRoaXMuaW5wdXRMb29rdXApO1xuICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dExvb2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSBPYmplY3Qua2V5cyh0aGlzLmlucHV0TG9va3VwKS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9pMjAgPSAwOyBfaTIwIDwgdmFsdWUub3V0cHV0Lmxlbmd0aDsgX2kyMCsrKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0TG9va3VwID0gX2xvb2t1cDIuZGVmYXVsdC5hZGRLZXlzKHZhbHVlLm91dHB1dFtfaTIwXSwgdGhpcy5vdXRwdXRMb29rdXApO1xuICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRMb29rdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMub3V0cHV0TG9va3VwKS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBkYXRhIHNoYXBlIG9yIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHM7XG4gICAgICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICB9XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgb3B0aW9uc1twXSA9IHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBoaWRkZW5MYXllcnM6IG1vZGVsLmhpZGRlbkxheWVycy5tYXAoZnVuY3Rpb24gKGhpZGRlbkxheWVyKSB7XG4gICAgICAgICAgdmFyIGxheWVycyA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIF9wMyBpbiBoaWRkZW5MYXllcikge1xuICAgICAgICAgICAgbGF5ZXJzW19wM10gPSBoaWRkZW5MYXllcltfcDNdLnRvSlNPTigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgICAgICB9KSxcbiAgICAgICAgb3V0cHV0Q29ubmVjdG9yOiB0aGlzLm1vZGVsLm91dHB1dENvbm5lY3Rvci50b0pTT04oKSxcbiAgICAgICAgb3V0cHV0OiB0aGlzLm1vZGVsLm91dHB1dC50b0pTT04oKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHM7XG4gICAgICB2YXIgb3B0aW9ucyA9IGpzb24ub3B0aW9ucztcbiAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgICAgdGhpcy5oaWRkZW5MYXllcnMgPSBudWxsO1xuICAgICAgdmFyIGFsbE1hdHJpY2VzID0gW107XG4gICAgICB2YXIgaGlkZGVuTGF5ZXJzID0gW107XG5cbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIGhpZGRlblNpemVzXG4gICAgICAoanNvbi5oaWRkZW5MYXllcnMgfHwganNvbi5oaWRkZW5TaXplcykuZm9yRWFjaChmdW5jdGlvbiAoaGlkZGVuTGF5ZXIpIHtcbiAgICAgICAgdmFyIGxheWVycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGhpZGRlbkxheWVyKSB7XG4gICAgICAgICAgbGF5ZXJzW3BdID0gX21hdHJpeDIuZGVmYXVsdC5mcm9tSlNPTihoaWRkZW5MYXllcltwXSk7XG4gICAgICAgICAgYWxsTWF0cmljZXMucHVzaChsYXllcnNbcF0pO1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkxheWVycy5wdXNoKGxheWVycyk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIG91dHB1dENvbm5lY3RvciA9IF9tYXRyaXgyLmRlZmF1bHQuZnJvbUpTT04oanNvbi5vdXRwdXRDb25uZWN0b3IpO1xuICAgICAgYWxsTWF0cmljZXMucHVzaChvdXRwdXRDb25uZWN0b3IpO1xuICAgICAgdmFyIG91dHB1dCA9IF9tYXRyaXgyLmRlZmF1bHQuZnJvbUpTT04oanNvbi5vdXRwdXQpO1xuICAgICAgYWxsTWF0cmljZXMucHVzaChvdXRwdXQpO1xuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuU2l6ZXMpIHtcbiAgICAgICAgdGhpcy5oaWRkZW5MYXllcnMgPSBvcHRpb25zLmhpZGRlblNpemVzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgICBoaWRkZW5MYXllcnM6IGhpZGRlbkxheWVycyxcbiAgICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICAgIGFsbE1hdHJpY2VzOiBhbGxNYXRyaWNlcyxcbiAgICAgICAgb3V0cHV0Q29ubmVjdG9yOiBvdXRwdXRDb25uZWN0b3IsXG4gICAgICAgIGVxdWF0aW9uczogW10sXG4gICAgICAgIGVxdWF0aW9uQ29ubmVjdGlvbnM6IFtdXG4gICAgICB9O1xuICAgICAgdGhpcy5pbml0aWFsTGF5ZXJJbnB1dHMgPSB0aGlzLmhpZGRlbkxheWVycy5tYXAoZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfbWF0cml4Mi5kZWZhdWx0KHNpemUsIDEpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJpbmRFcXVhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b0Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9GdW5jdGlvbigpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb25zID0gdGhpcy5tb2RlbC5lcXVhdGlvbnM7XG4gICAgICB2YXIgaW5wdXRTaXplID0gdGhpcy5pbnB1dFNpemU7XG4gICAgICB2YXIgaW5wdXRMb29rdXAgPSB0aGlzLmlucHV0TG9va3VwO1xuICAgICAgdmFyIGlucHV0TG9va3VwTGVuZ3RoID0gdGhpcy5pbnB1dExvb2t1cExlbmd0aDtcbiAgICAgIHZhciBvdXRwdXRMb29rdXAgPSB0aGlzLm91dHB1dExvb2t1cDtcbiAgICAgIHZhciBvdXRwdXRMb29rdXBMZW5ndGggPSB0aGlzLm91dHB1dExvb2t1cExlbmd0aDtcbiAgICAgIHZhciBlcXVhdGlvbiA9IGVxdWF0aW9uc1sxXTtcbiAgICAgIHZhciBzdGF0ZXMgPSBlcXVhdGlvbi5zdGF0ZXM7XG4gICAgICB2YXIganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuXG4gICAgICBmdW5jdGlvbiBtYXRyaXhPcmlnaW4obSwgc3RhdGVJbmRleCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gc3RhdGVzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVzW2ldO1xuXG4gICAgICAgICAgaWYgKGkgPT09IHN0YXRlSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBqID0gcHJldmlvdXNDb25uZWN0aW9uSW5kZXgobSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG0pIHtcbiAgICAgICAgICAgICAgY2FzZSBzdGF0ZS5sZWZ0OlxuICAgICAgICAgICAgICAgIGlmIChqID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAndHlwZW9mIHByZXZTdGF0ZXNbJyArIGogKyAnXSA9PT0gXFwnb2JqZWN0XFwnID8gcHJldlN0YXRlc1snICsgaiArICddLnByb2R1Y3QgOiBuZXcgTWF0cml4KCcgKyBtLnJvd3MgKyAnLCAnICsgbS5jb2x1bW5zICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBzdGF0ZS5yaWdodDpcbiAgICAgICAgICAgICAgICBpZiAoaiA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ3R5cGVvZiBwcmV2U3RhdGVzWycgKyBqICsgJ10gPT09IFxcJ29iamVjdFxcJyA/IHByZXZTdGF0ZXNbJyArIGogKyAnXS5wcm9kdWN0IDogbmV3IE1hdHJpeCgnICsgbS5yb3dzICsgJywgJyArIG0uY29sdW1ucyArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2Ugc3RhdGUucHJvZHVjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25ldyBNYXRyaXgoJyArIG0ucm93cyArICcsICcgKyBtLmNvbHVtbnMgKyAnKSc7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ3Vua25vd24gc3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobSA9PT0gc3RhdGUucHJvZHVjdCkgcmV0dXJuICdzdGF0ZXNbJyArIGkgKyAnXS5wcm9kdWN0JztcbiAgICAgICAgICBpZiAobSA9PT0gc3RhdGUucmlnaHQpIHJldHVybiAnc3RhdGVzWycgKyBpICsgJ10ucmlnaHQnO1xuICAgICAgICAgIGlmIChtID09PSBzdGF0ZS5sZWZ0KSByZXR1cm4gJ3N0YXRlc1snICsgaSArICddLmxlZnQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByZXZpb3VzQ29ubmVjdGlvbkluZGV4KG0pIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBtb2RlbC5lcXVhdGlvbkNvbm5lY3Rpb25zWzBdO1xuICAgICAgICB2YXIgc3RhdGVzID0gZXF1YXRpb25zWzBdLnN0YXRlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgIGlmIChzdGF0ZXNbaV0ucHJvZHVjdCA9PT0gbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLmluZGV4T2YobSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1hdHJpeFRvU3RyaW5nKG0sIHN0YXRlSW5kZXgpIHtcbiAgICAgICAgaWYgKCFtIHx8ICFtLnJvd3MgfHwgIW0uY29sdW1ucykgcmV0dXJuICdudWxsJztcbiAgICAgICAgaWYgKG0gPT09IG1vZGVsLm91dHB1dENvbm5lY3RvcikgcmV0dXJuICdqc29uLm91dHB1dENvbm5lY3Rvcic7XG4gICAgICAgIGlmIChtID09PSBtb2RlbC5vdXRwdXQpIHJldHVybiAnanNvbi5vdXRwdXQnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBtb2RlbC5oaWRkZW5MYXllcnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICB2YXIgaGlkZGVuTGF5ZXIgPSBtb2RlbC5oaWRkZW5MYXllcnNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBoaWRkZW5MYXllcikge1xuICAgICAgICAgICAgaWYgKCFoaWRkZW5MYXllci5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaGlkZGVuTGF5ZXJbcF0gIT09IG0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuICdqc29uLmhpZGRlbkxheWVyc1snICsgaSArICddLicgKyBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRyaXhPcmlnaW4obSwgc3RhdGVJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdElucHV0RGF0YSgpIHtcbiAgICAgICAgaWYgKCFpbnB1dExvb2t1cCkgcmV0dXJuICcnO1xuICAgICAgICBpZiAoaW5wdXRTaXplID09PSAxKSB7XG4gICAgICAgICAgaWYgKGlucHV0TG9va3VwID09PSBvdXRwdXRMb29rdXApIHtcbiAgICAgICAgICAgIHJldHVybiAnZnVuY3Rpb24gbG9va3VwSW5wdXQoaW5wdXQpIHtcXG4gICAgICAgICAgICB2YXIgdGFibGUgPSAnICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRMb29rdXApICsgJztcXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiB0YWJsZSkge1xcbiAgICAgICAgICAgICAgaWYgKCFpbnB1dC5oYXNPd25Qcm9wZXJ0eShwKSkgYnJlYWs7XFxuICAgICAgICAgICAgICByZXN1bHQucHVzaChGbG9hdDMyQXJyYXkuZnJvbShbaW5wdXRbcF1dKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICAgIH0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uIGxvb2t1cElucHV0KGlucHV0KSB7XFxuICAgICAgICAgIHZhciB0YWJsZSA9ICcgKyBKU09OLnN0cmluZ2lmeShpbnB1dExvb2t1cCkgKyAnO1xcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICAgIGZvciAodmFyIHAgaW4gdGFibGUpIHtcXG4gICAgICAgICAgICByZXN1bHQucHVzaChGbG9hdDMyQXJyYXkuZnJvbShbaW5wdXRbcF1dKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24gbG9va3VwSW5wdXQocmF3SW5wdXRzKSB7XFxuICAgICAgICB2YXIgdGFibGUgPSAnICsgSlNPTi5zdHJpbmdpZnkoaW5wdXRMb29rdXApICsgJztcXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3SW5wdXRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciByYXdJbnB1dCA9IHJhd0lucHV0c1tpXTtcXG4gICAgICAgICAgdmFyIGlucHV0ID0gbmV3IEZsb2F0MzJBcnJheSgnICsgaW5wdXRMb29rdXBMZW5ndGggKyAnKTtcXG4gICAgICAgICAgZm9yICh2YXIgcCBpbiB0YWJsZSkge1xcbiAgICAgICAgICAgIGlucHV0W3RhYmxlW3BdXSA9IHJhd0lucHV0Lmhhc093blByb3BlcnR5KHApID8gcmF3SW5wdXRbcF0gOiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJlc3VsdC5wdXNoKGlucHV0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfSc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZvcm1hdE91dHB1dERhdGEoKSB7XG4gICAgICAgIGlmICghb3V0cHV0TG9va3VwKSByZXR1cm4gJyc7XG4gICAgICAgIGlmIChpbnB1dFNpemUgPT09IDEpIHtcbiAgICAgICAgICBpZiAoaW5wdXRMb29rdXAgPT09IG91dHB1dExvb2t1cCkge1xuICAgICAgICAgICAgcmV0dXJuICdmdW5jdGlvbiBsb29rdXBPdXRwdXRQYXJ0aWFsKG91dHB1dCwgaW5wdXQpIHtcXG4gICAgICAgICAgICB2YXIgdGFibGUgPSAnICsgSlNPTi5zdHJpbmdpZnkob3V0cHV0TG9va3VwKSArICc7XFxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGlucHV0Lmxlbmd0aDtcXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XFxuICAgICAgICAgICAgdmFyIGkgPSAwO1xcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gdGFibGUpIHtcXG4gICAgICAgICAgICAgIGlmIChpKysgPCBvZmZzZXQpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgcmVzdWx0W3BdID0gb3V0cHV0W3RhYmxlW3BdIC0gb2Zmc2V0XVswXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgICAgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAnZnVuY3Rpb24gbG9va3VwT3V0cHV0KG91dHB1dCkge1xcbiAgICAgICAgICB2YXIgdGFibGUgPSAnICsgSlNPTi5zdHJpbmdpZnkob3V0cHV0TG9va3VwKSArICc7XFxuICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcXG4gICAgICAgICAgZm9yICh2YXIgcCBpbiB0YWJsZSkge1xcbiAgICAgICAgICAgIHJlc3VsdFtwXSA9IG91dHB1dFt0YWJsZVtwXV1bMF07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgIH0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24gbG9va3VwT3V0cHV0KG91dHB1dCkge1xcbiAgICAgICAgdmFyIHRhYmxlID0gJyArIEpTT04uc3RyaW5naWZ5KG91dHB1dExvb2t1cCkgKyAnO1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xcbiAgICAgICAgZm9yICh2YXIgcCBpbiB0YWJsZSkge1xcbiAgICAgICAgICByZXN1bHRbcF0gPSBvdXRwdXRbdGFibGVbcF1dO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9JztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9Jbm5lcihmblN0cmluZykge1xuICAgICAgICAvLyBjcnVkZSwgYnV0IHNob3VsZCBiZSBzdWZmaWNpZW50IGZvciBub3dcbiAgICAgICAgLy8gZnVuY3Rpb24oKSB7IGJvZHkgfVxuICAgICAgICBmblN0cmluZyA9IGZuU3RyaW5nLnRvU3RyaW5nKCkuc3BsaXQoJ3snKTtcbiAgICAgICAgZm5TdHJpbmcuc2hpZnQoKTtcbiAgICAgICAgLy8gYm9keSB9XG4gICAgICAgIGZuU3RyaW5nID0gZm5TdHJpbmcuam9pbigneycpO1xuICAgICAgICBmblN0cmluZyA9IGZuU3RyaW5nLnNwbGl0KCd9Jyk7XG4gICAgICAgIGZuU3RyaW5nLnBvcCgpO1xuICAgICAgICAvLyBib2R5XG5cbiAgICAgICAgcmV0dXJuIGZuU3RyaW5nLmpvaW4oJ30nKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAgICAgICAnKS5yZXBsYWNlKCdwcm9kdWN0LndlaWdodHMgPSBfaW5wdXQud2VpZ2h0cyA9IF90aGlzLmlucHV0VmFsdWU7JywgaW5wdXRMb29rdXAgJiYgaW5wdXRTaXplID09PSAxID8gJ3Byb2R1Y3Qud2VpZ2h0cyA9IF9pIDwgaW5wdXQubGVuZ3RoID8gaW5wdXRbX2ldOiBwcmV2U3RhdGVzW3ByZXZTdGF0ZXMubGVuZ3RoIC0gMV0ucHJvZHVjdC53ZWlnaHRzOycgOiBpbnB1dFNpemUgPT09IDEgPyAncHJvZHVjdC53ZWlnaHRzID0gW2lucHV0W19pXV07JyA6ICdwcm9kdWN0LndlaWdodHMgPSBpbnB1dFtfaV07JykucmVwbGFjZSgncHJvZHVjdC5kZWx0YXNbaV0gPSAwOycsICcnKS5yZXBsYWNlKCdwcm9kdWN0LmRlbHRhc1tjb2x1bW5dID0gMDsnLCAnJykucmVwbGFjZSgnbGVmdC5kZWx0YXNbbGVmdEluZGV4XSA9IDA7JywgJycpLnJlcGxhY2UoJ3JpZ2h0LmRlbHRhc1tyaWdodEluZGV4XSA9IDA7JywgJycpLnJlcGxhY2UoJ3Byb2R1Y3QuZGVsdGFzID0gbGVmdC5kZWx0YXMuc2xpY2UoMCk7JywgJycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaWxlTmFtZShmbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdzcmMvcmVjdXJyZW50L21hdHJpeC8nICsgZm5OYW1lLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAnLScgKyB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KSArICcuanMnO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGVzUmF3ID0gW107XG4gICAgICB2YXIgdXNlZEZ1bmN0aW9uTmFtZXMgPSB7fTtcbiAgICAgIHZhciBpbm5lckZ1bmN0aW9uc1N3aXRjaCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgIHN0YXRlc1Jhdy5wdXNoKCdzdGF0ZXNbJyArIGkgKyAnXSA9IHtcXG4gICAgICBuYW1lOiBcXCcnICsgc3RhdGUuZm9yd2FyZEZuLm5hbWUgKyAnXFwnLFxcbiAgICAgIGxlZnQ6ICcgKyBtYXRyaXhUb1N0cmluZyhzdGF0ZS5sZWZ0LCBpKSArICcsXFxuICAgICAgcmlnaHQ6ICcgKyBtYXRyaXhUb1N0cmluZyhzdGF0ZS5yaWdodCwgaSkgKyAnLFxcbiAgICAgIHByb2R1Y3Q6ICcgKyBtYXRyaXhUb1N0cmluZyhzdGF0ZS5wcm9kdWN0LCBpKSArICdcXG4gICAgfScpO1xuXG4gICAgICAgIHZhciBmbk5hbWUgPSBzdGF0ZS5mb3J3YXJkRm4ubmFtZTtcbiAgICAgICAgaWYgKCF1c2VkRnVuY3Rpb25OYW1lc1tmbk5hbWVdKSB7XG4gICAgICAgICAgdXNlZEZ1bmN0aW9uTmFtZXNbZm5OYW1lXSA9IHRydWU7XG4gICAgICAgICAgaW5uZXJGdW5jdGlvbnNTd2l0Y2gucHVzaCgnICAgICAgICBjYXNlIFxcJycgKyBmbk5hbWUgKyAnXFwnOicgKyAoZm5OYW1lICE9PSAnZm9yd2FyZEZuJyA/ICcgLy9jb21waWxlZCBmcm9tICcgKyBmaWxlTmFtZShmbk5hbWUpIDogJycpICsgJ1xcbiAgICAgICAgICAnICsgdG9Jbm5lcihzdGF0ZS5mb3J3YXJkRm4udG9TdHJpbmcoKSkgKyAnXFxuICAgICAgICAgIGJyZWFrOycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmb3JjZUZvcmVjYXN0ID0gdGhpcy5pbnB1dFNpemUgPT09IDEgJiYgdGhpcy5vdXRwdXRMb29rdXA7XG4gICAgICB2YXIgc3JjID0gJ1xcbiAgdmFyIGlucHV0ID0gJyArICh0aGlzLmlucHV0TG9va3VwID8gJ2xvb2t1cElucHV0KHJhd0lucHV0KScgOiAncmF3SW5wdXQnKSArICc7XFxuICB2YXIganNvbiA9ICcgKyBqc29uU3RyaW5nICsgJztcXG4gIHZhciBvdXRwdXQgPSBbXTtcXG4gIHZhciBzdGF0ZXMgPSBbXTtcXG4gIHZhciBwcmV2U3RhdGVzO1xcbiAgdmFyIHN0YXRlO1xcbiAgdmFyIG1heCA9ICcgKyAoZm9yY2VGb3JlY2FzdCA/IGlucHV0TG9va3VwID09PSBvdXRwdXRMb29rdXAgPyBpbnB1dExvb2t1cExlbmd0aCA6ICdpbnB1dC5sZW5ndGggKyAnICsgKG91dHB1dExvb2t1cExlbmd0aCAtIDEpIDogJ2lucHV0Lmxlbmd0aCcpICsgJztcXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBtYXg7IF9pKyspIHtcXG4gICAgcHJldlN0YXRlcyA9IHN0YXRlcztcXG4gICAgc3RhdGVzID0gW107XFxuICAgICcgKyBzdGF0ZXNSYXcuam9pbignO1xcbiAgICAnKSArICc7XFxuICAgIGZvciAodmFyIHN0YXRlSW5kZXggPSAwLCBzdGF0ZU1heCA9ICcgKyBzdGF0ZXNSYXcubGVuZ3RoICsgJzsgc3RhdGVJbmRleCA8IHN0YXRlTWF4OyBzdGF0ZUluZGV4KyspIHtcXG4gICAgICBzdGF0ZSA9IHN0YXRlc1tzdGF0ZUluZGV4XTtcXG4gICAgICB2YXIgcHJvZHVjdCA9IHN0YXRlLnByb2R1Y3Q7XFxuICAgICAgdmFyIGxlZnQgPSBzdGF0ZS5sZWZ0O1xcbiAgICAgIHZhciByaWdodCA9IHN0YXRlLnJpZ2h0O1xcbiAgICAgIFxcbiAgICAgIHN3aXRjaCAoc3RhdGUubmFtZSkge1xcbicgKyBpbm5lckZ1bmN0aW9uc1N3aXRjaC5qb2luKCdcXG4nKSArICdcXG4gICAgICB9XFxuICAgIH1cXG4gICAgJyArIChpbnB1dFNpemUgPT09IDEgJiYgaW5wdXRMb29rdXAgPyAnaWYgKF9pID49IGlucHV0Lmxlbmd0aCAtIDEpIHsgb3V0cHV0LnB1c2goc3RhdGUucHJvZHVjdC53ZWlnaHRzKTsgfScgOiAnb3V0cHV0ID0gc3RhdGUucHJvZHVjdC53ZWlnaHRzOycpICsgJ1xcbiAgfVxcbiAgJyArIChvdXRwdXRMb29rdXAgPyBvdXRwdXRMb29rdXAgPT09IGlucHV0TG9va3VwID8gJ3JldHVybiBsb29rdXBPdXRwdXRQYXJ0aWFsKG91dHB1dCwgaW5wdXQpJyA6ICdyZXR1cm4gbG9va3VwT3V0cHV0KG91dHB1dCknIDogaW5wdXRTaXplID09PSAxID8gJ3JldHVybiBvdXRwdXRbMF0nIDogJ3JldHVybiBvdXRwdXQnKSArICc7XFxuICAnICsgZm9ybWF0SW5wdXREYXRhKCkgKyAnXFxuICAnICsgZm9ybWF0T3V0cHV0RGF0YSgpICsgJ1xcbiAgXFxuICBmdW5jdGlvbiBNYXRyaXgocm93cywgY29sdW1ucykge1xcbiAgICB0aGlzLnJvd3MgPSByb3dzO1xcbiAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xcbiAgICB0aGlzLndlaWdodHMgPSB6ZXJvcyhyb3dzICogY29sdW1ucyk7XFxuICB9XFxuICAnICsgX3plcm9zMi5kZWZhdWx0LnRvU3RyaW5nKCkgKyAnXFxuICAnICsgX3NvZnRtYXgyLmRlZmF1bHQudG9TdHJpbmcoKS5yZXBsYWNlKCdfMi5kZWZhdWx0JywgJ01hdHJpeCcpICsgJ1xcbiAgJyArIF9yYW5kb20ucmFuZG9tRi50b1N0cmluZygpICsgJ1xcbiAgJyArIF9zYW1wbGVJMi5kZWZhdWx0LnRvU3RyaW5nKCkgKyAnXFxuICAnICsgX21heEkyLmRlZmF1bHQudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Jhd0lucHV0Jywgc3JjKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUk5OVGltZVN0ZXA7XG59KF9ybm4yLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSTk5UaW1lU3RlcDtcblxuXG5STk5UaW1lU3RlcC5kZWZhdWx0cyA9IHtcbiAgaW5wdXRTaXplOiAxLFxuICBoaWRkZW5MYXllcnM6IFsyMF0sXG4gIG91dHB1dFNpemU6IDEsXG4gIGxlYXJuaW5nUmF0ZTogX3JubjIuZGVmYXVsdC5kZWZhdWx0cy5sZWFybmluZ1JhdGUsXG4gIGRlY2F5UmF0ZTogX3JubjIuZGVmYXVsdC5kZWZhdWx0cy5kZWNheVJhdGUsXG4gIHNtb290aEVwczogX3JubjIuZGVmYXVsdC5kZWZhdWx0cy5zbW9vdGhFcHMsXG4gIHJlZ2M6IF9ybm4yLmRlZmF1bHQuZGVmYXVsdHMucmVnYyxcbiAgY2xpcHZhbDogX3JubjIuZGVmYXVsdC5kZWZhdWx0cy5jbGlwdmFsXG59O1xuXG5STk5UaW1lU3RlcC50cmFpbkRlZmF1bHRzID0gX3JubjIuZGVmYXVsdC50cmFpbkRlZmF1bHRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm5uLXRpbWUtc3RlcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0cml4ID0gcmVxdWlyZSgnLi9tYXRyaXgnKTtcblxudmFyIF9tYXRyaXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0cml4KTtcblxudmFyIF9yYW5kb21NYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeC9yYW5kb20tbWF0cml4Jyk7XG5cbnZhciBfcmFuZG9tTWF0cml4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhbmRvbU1hdHJpeCk7XG5cbnZhciBfZXF1YXRpb24gPSByZXF1aXJlKCcuL21hdHJpeC9lcXVhdGlvbicpO1xuXG52YXIgX2VxdWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VxdWF0aW9uKTtcblxudmFyIF9zYW1wbGVJID0gcmVxdWlyZSgnLi9tYXRyaXgvc2FtcGxlLWknKTtcblxudmFyIF9zYW1wbGVJMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NhbXBsZUkpO1xuXG52YXIgX21heEkgPSByZXF1aXJlKCcuL21hdHJpeC9tYXgtaScpO1xuXG52YXIgX21heEkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF4SSk7XG5cbnZhciBfc29mdG1heCA9IHJlcXVpcmUoJy4vbWF0cml4L3NvZnRtYXgnKTtcblxudmFyIF9zb2Z0bWF4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvZnRtYXgpO1xuXG52YXIgX2NvcHkgPSByZXF1aXJlKCcuL21hdHJpeC9jb3B5Jyk7XG5cbnZhciBfY29weTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3B5KTtcblxudmFyIF9yYW5kb20gPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvcmFuZG9tJyk7XG5cbnZhciBfemVyb3MgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvemVyb3MnKTtcblxudmFyIF96ZXJvczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF96ZXJvcyk7XG5cbnZhciBfZGF0YUZvcm1hdHRlciA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9kYXRhLWZvcm1hdHRlcicpO1xuXG52YXIgX2RhdGFGb3JtYXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGF0YUZvcm1hdHRlcik7XG5cbnZhciBfbmV1cmFsTmV0d29yayA9IHJlcXVpcmUoJy4uL25ldXJhbC1uZXR3b3JrJyk7XG5cbnZhciBfbmV1cmFsTmV0d29yazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uZXVyYWxOZXR3b3JrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJOTiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUk5OKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSTk4pO1xuXG4gICAgdmFyIGRlZmF1bHRzID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cztcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMudHJhaW5PcHRzID0ge307XG4gICAgdGhpcy51cGRhdGVUcmFpbmluZ09wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25zdHJ1Y3Rvci50cmFpbkRlZmF1bHRzLCBvcHRpb25zKSk7XG5cbiAgICB0aGlzLnN0ZXBDYWNoZSA9IHt9O1xuICAgIHRoaXMucnVucyA9IDA7XG4gICAgdGhpcy5yYXRpb0NsaXBwZWQgPSBudWxsO1xuICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIHRoaXMuaW5wdXRMb29rdXAgPSBudWxsO1xuICAgIHRoaXMuaW5wdXRMb29rdXBMZW5ndGggPSBudWxsO1xuICAgIHRoaXMub3V0cHV0TG9va3VwID0gbnVsbDtcbiAgICB0aGlzLm91dHB1dExvb2t1cExlbmd0aCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5qc29uKSB7XG4gICAgICB0aGlzLmZyb21KU09OKG9wdGlvbnMuanNvbik7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJOTiwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgIHRoaXMubW9kZWwgPSB7XG4gICAgICAgIGlucHV0OiBudWxsLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFtdLFxuICAgICAgICBvdXRwdXQ6IG51bGwsXG4gICAgICAgIGVxdWF0aW9uczogW10sXG4gICAgICAgIGFsbE1hdHJpY2VzOiBbXSxcbiAgICAgICAgZXF1YXRpb25Db25uZWN0aW9uczogW10sXG4gICAgICAgIG91dHB1dENvbm5lY3RvcjogbnVsbFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdHRlcikge1xuICAgICAgICB0aGlzLmlucHV0U2l6ZSA9IHRoaXMuaW5wdXRSYW5nZSA9IHRoaXMub3V0cHV0U2l6ZSA9IHRoaXMuZGF0YUZvcm1hdHRlci5jaGFyYWN0ZXJzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwTW9kZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVIaWRkZW5MYXllcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVIaWRkZW5MYXllcnMoKSB7XG4gICAgICAvLzAgaXMgZW5kLCBzbyBhZGQgMSB0byBvZmZzZXRcbiAgICAgIHRoaXMubW9kZWwuaGlkZGVuTGF5ZXJzLnB1c2godGhpcy5nZXRNb2RlbCh0aGlzLmhpZGRlbkxheWVyc1swXSwgdGhpcy5pbnB1dFNpemUpKTtcbiAgICAgIHZhciBwcmV2U2l6ZSA9IHRoaXMuaGlkZGVuTGF5ZXJzWzBdO1xuXG4gICAgICBmb3IgKHZhciBkID0gMTsgZCA8IHRoaXMuaGlkZGVuTGF5ZXJzLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgIC8vIGxvb3Agb3ZlciBkZXB0aHNcbiAgICAgICAgdmFyIGhpZGRlblNpemUgPSB0aGlzLmhpZGRlbkxheWVyc1tkXTtcbiAgICAgICAgdGhpcy5tb2RlbC5oaWRkZW5MYXllcnMucHVzaCh0aGlzLmdldE1vZGVsKGhpZGRlblNpemUsIHByZXZTaXplKSk7XG4gICAgICAgIHByZXZTaXplID0gaGlkZGVuU2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoaWRkZW5TaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHByZXZTaXplXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0TW9kZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlbChoaWRkZW5TaXplLCBwcmV2U2l6ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy93eGhcbiAgICAgICAgd2VpZ2h0OiBuZXcgX3JhbmRvbU1hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCBwcmV2U2l6ZSwgMC4wOCksXG4gICAgICAgIC8vd2hoXG4gICAgICAgIHRyYW5zaXRpb246IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KGhpZGRlblNpemUsIGhpZGRlblNpemUsIDAuMDgpLFxuICAgICAgICAvL2JoaFxuICAgICAgICBiaWFzOiBuZXcgX21hdHJpeDIuZGVmYXVsdChoaWRkZW5TaXplLCAxKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXF1YXRpb259IGVxdWF0aW9uXG4gICAgICogQHBhcmFtIHtNYXRyaXh9IGlucHV0TWF0cml4XG4gICAgICogQHBhcmFtIHtNYXRyaXh9IHByZXZpb3VzUmVzdWx0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhpZGRlbkxheWVyXG4gICAgICogQHJldHVybnMge01hdHJpeH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0RXF1YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFcXVhdGlvbihlcXVhdGlvbiwgaW5wdXRNYXRyaXgsIHByZXZpb3VzUmVzdWx0LCBoaWRkZW5MYXllcikge1xuICAgICAgdmFyIHJlbHUgPSBlcXVhdGlvbi5yZWx1LmJpbmQoZXF1YXRpb24pO1xuICAgICAgdmFyIGFkZCA9IGVxdWF0aW9uLmFkZC5iaW5kKGVxdWF0aW9uKTtcbiAgICAgIHZhciBtdWx0aXBseSA9IGVxdWF0aW9uLm11bHRpcGx5LmJpbmQoZXF1YXRpb24pO1xuXG4gICAgICByZXR1cm4gcmVsdShhZGQoYWRkKG11bHRpcGx5KGhpZGRlbkxheWVyLndlaWdodCwgaW5wdXRNYXRyaXgpLCBtdWx0aXBseShoaWRkZW5MYXllci50cmFuc2l0aW9uLCBwcmV2aW91c1Jlc3VsdCkpLCBoaWRkZW5MYXllci5iaWFzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlSW5wdXRNYXRyaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVJbnB1dE1hdHJpeCgpIHtcbiAgICAgIC8vMCBpcyBlbmQsIHNvIGFkZCAxIHRvIG9mZnNldFxuICAgICAgdGhpcy5tb2RlbC5pbnB1dCA9IG5ldyBfcmFuZG9tTWF0cml4Mi5kZWZhdWx0KHRoaXMuaW5wdXRSYW5nZSArIDEsIHRoaXMuaW5wdXRTaXplLCAwLjA4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVPdXRwdXRNYXRyaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVPdXRwdXRNYXRyaXgoKSB7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIG91dHB1dFNpemUgPSB0aGlzLm91dHB1dFNpemU7XG4gICAgICB2YXIgbGFzdEhpZGRlblNpemUgPSB0aGlzLmhpZGRlbkxheWVyc1t0aGlzLmhpZGRlbkxheWVycy5sZW5ndGggLSAxXTtcblxuICAgICAgLy8wIGlzIGVuZCwgc28gYWRkIDEgdG8gb2Zmc2V0XG4gICAgICAvL3doZFxuICAgICAgbW9kZWwub3V0cHV0Q29ubmVjdG9yID0gbmV3IF9yYW5kb21NYXRyaXgyLmRlZmF1bHQob3V0cHV0U2l6ZSArIDEsIGxhc3RIaWRkZW5TaXplLCAwLjA4KTtcbiAgICAgIC8vMCBpcyBlbmQsIHNvIGFkZCAxIHRvIG9mZnNldFxuICAgICAgLy9iZFxuICAgICAgbW9kZWwub3V0cHV0ID0gbmV3IF9tYXRyaXgyLmRlZmF1bHQob3V0cHV0U2l6ZSArIDEsIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JpbmRFcXVhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFcXVhdGlvbigpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb24gPSBuZXcgX2VxdWF0aW9uMi5kZWZhdWx0KCk7XG4gICAgICB2YXIgb3V0cHV0cyA9IFtdO1xuICAgICAgdmFyIGVxdWF0aW9uQ29ubmVjdGlvbiA9IG1vZGVsLmVxdWF0aW9uQ29ubmVjdGlvbnMubGVuZ3RoID4gMCA/IG1vZGVsLmVxdWF0aW9uQ29ubmVjdGlvbnNbbW9kZWwuZXF1YXRpb25Db25uZWN0aW9ucy5sZW5ndGggLSAxXSA6IHRoaXMuaW5pdGlhbExheWVySW5wdXRzO1xuXG4gICAgICAvLyAwIGluZGV4XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpcy5nZXRFcXVhdGlvbihlcXVhdGlvbiwgZXF1YXRpb24uaW5wdXRNYXRyaXhUb1Jvdyhtb2RlbC5pbnB1dCksIGVxdWF0aW9uQ29ubmVjdGlvblswXSwgbW9kZWwuaGlkZGVuTGF5ZXJzWzBdKTtcbiAgICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICAgICAgLy8gMSsgaW5kaWNlc1xuICAgICAgZm9yICh2YXIgaSA9IDEsIG1heCA9IHRoaXMuaGlkZGVuTGF5ZXJzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIG91dHB1dCA9IHRoaXMuZ2V0RXF1YXRpb24oZXF1YXRpb24sIG91dHB1dCwgZXF1YXRpb25Db25uZWN0aW9uW2ldLCBtb2RlbC5oaWRkZW5MYXllcnNbaV0pO1xuICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwuZXF1YXRpb25Db25uZWN0aW9ucy5wdXNoKG91dHB1dHMpO1xuICAgICAgZXF1YXRpb24uYWRkKGVxdWF0aW9uLm11bHRpcGx5KG1vZGVsLm91dHB1dENvbm5lY3Rvciwgb3V0cHV0KSwgbW9kZWwub3V0cHV0KTtcbiAgICAgIG1vZGVsLmVxdWF0aW9ucy5wdXNoKGVxdWF0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtYXBNb2RlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcE1vZGVsKCkge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgIHZhciBoaWRkZW5MYXllcnMgPSBtb2RlbC5oaWRkZW5MYXllcnM7XG4gICAgICB2YXIgYWxsTWF0cmljZXMgPSBtb2RlbC5hbGxNYXRyaWNlcztcbiAgICAgIHRoaXMuaW5pdGlhbExheWVySW5wdXRzID0gdGhpcy5oaWRkZW5MYXllcnMubWFwKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgX21hdHJpeDIuZGVmYXVsdChzaXplLCAxKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmNyZWF0ZUlucHV0TWF0cml4KCk7XG4gICAgICBpZiAoIW1vZGVsLmlucHV0KSB0aHJvdyBuZXcgRXJyb3IoJ25ldC5tb2RlbC5pbnB1dCBub3Qgc2V0Jyk7XG4gICAgICBhbGxNYXRyaWNlcy5wdXNoKG1vZGVsLmlucHV0KTtcblxuICAgICAgdGhpcy5jcmVhdGVIaWRkZW5MYXllcnMoKTtcbiAgICAgIGlmICghbW9kZWwuaGlkZGVuTGF5ZXJzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCduZXQuaGlkZGVuTGF5ZXJzIG5vdCBzZXQnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBoaWRkZW5MYXllcnMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgdmFyIGhpZGRlbk1hdHJpeCA9IGhpZGRlbkxheWVyc1tpXTtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gaGlkZGVuTWF0cml4KSB7XG4gICAgICAgICAgaWYgKCFoaWRkZW5NYXRyaXguaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSBjb250aW51ZTtcbiAgICAgICAgICBhbGxNYXRyaWNlcy5wdXNoKGhpZGRlbk1hdHJpeFtwcm9wZXJ0eV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3JlYXRlT3V0cHV0TWF0cml4KCk7XG4gICAgICBpZiAoIW1vZGVsLm91dHB1dENvbm5lY3RvcikgdGhyb3cgbmV3IEVycm9yKCduZXQubW9kZWwub3V0cHV0Q29ubmVjdG9yIG5vdCBzZXQnKTtcbiAgICAgIGlmICghbW9kZWwub3V0cHV0KSB0aHJvdyBuZXcgRXJyb3IoJ25ldC5tb2RlbC5vdXRwdXQgbm90IHNldCcpO1xuXG4gICAgICBhbGxNYXRyaWNlcy5wdXNoKG1vZGVsLm91dHB1dENvbm5lY3Rvcik7XG4gICAgICBhbGxNYXRyaWNlcy5wdXNoKG1vZGVsLm91dHB1dCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfHN0cmluZ1tdfHN0cmluZ30gaW5wdXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb2dFcnJvclJhdGVdXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHJhaW5QYXR0ZXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW5QYXR0ZXJuKGlucHV0LCBsb2dFcnJvclJhdGUpIHtcbiAgICAgIHZhciBlcnJvciA9IHRoaXMudHJhaW5JbnB1dChpbnB1dCk7XG4gICAgICB0aGlzLmJhY2twcm9wYWdhdGUoaW5wdXQpO1xuICAgICAgdGhpcy5hZGp1c3RXZWlnaHRzKCk7XG5cbiAgICAgIGlmIChsb2dFcnJvclJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0cmFpbklucHV0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhaW5JbnB1dChpbnB1dCkge1xuICAgICAgdGhpcy5ydW5zKys7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIG1heCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHZhciBsb2cycHBsID0gMDtcbiAgICAgIHZhciBlcXVhdGlvbiA9IHZvaWQgMDtcbiAgICAgIHdoaWxlIChtb2RlbC5lcXVhdGlvbnMubGVuZ3RoIDw9IGlucHV0Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgLy9sYXN0IGlzIHplcm9cbiAgICAgICAgdGhpcy5iaW5kRXF1YXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGlucHV0SW5kZXggPSAtMSwgaW5wdXRNYXggPSBpbnB1dC5sZW5ndGg7IGlucHV0SW5kZXggPCBpbnB1dE1heDsgaW5wdXRJbmRleCsrKSB7XG4gICAgICAgIC8vIHN0YXJ0IGFuZCBlbmQgdG9rZW5zIGFyZSB6ZXJvc1xuICAgICAgICB2YXIgZXF1YXRpb25JbmRleCA9IGlucHV0SW5kZXggKyAxO1xuICAgICAgICBlcXVhdGlvbiA9IG1vZGVsLmVxdWF0aW9uc1tlcXVhdGlvbkluZGV4XTtcblxuICAgICAgICB2YXIgc291cmNlID0gaW5wdXRJbmRleCA9PT0gLTEgPyAwIDogaW5wdXRbaW5wdXRJbmRleF0gKyAxOyAvLyBmaXJzdCBzdGVwOiBzdGFydCB3aXRoIFNUQVJUIHRva2VuXG4gICAgICAgIHZhciB0YXJnZXQgPSBpbnB1dEluZGV4ID09PSBtYXggLSAxID8gMCA6IGlucHV0W2lucHV0SW5kZXggKyAxXSArIDE7IC8vIGxhc3Qgc3RlcDogZW5kIHdpdGggRU5EIHRva2VuXG4gICAgICAgIGxvZzJwcGwgKz0gZXF1YXRpb24ucHJlZGljdFRhcmdldEluZGV4KHNvdXJjZSwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCBsb2cycHBsIC8gKG1heCAtIDEpKSAvIDEwMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBpbnB1dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdiYWNrcHJvcGFnYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmFja3Byb3BhZ2F0ZShpbnB1dCkge1xuICAgICAgdmFyIGkgPSBpbnB1dC5sZW5ndGg7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIGVxdWF0aW9ucyA9IG1vZGVsLmVxdWF0aW9ucztcbiAgICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgICBlcXVhdGlvbnNbaV0uYmFja3Byb3BhZ2F0ZUluZGV4KGlucHV0W2kgLSAxXSArIDEpO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBlcXVhdGlvbnNbMF0uYmFja3Byb3BhZ2F0ZUluZGV4KDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkanVzdFdlaWdodHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RXZWlnaHRzKCkge1xuICAgICAgdmFyIHJlZ2MgPSB0aGlzLnJlZ2MsXG4gICAgICAgICAgY2xpcHZhbCA9IHRoaXMuY2xpcHZhbCxcbiAgICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICAgICAgZGVjYXlSYXRlID0gdGhpcy5kZWNheVJhdGUsXG4gICAgICAgICAgc3RlcENhY2hlID0gdGhpcy5zdGVwQ2FjaGUsXG4gICAgICAgICAgc21vb3RoRXBzID0gdGhpcy5zbW9vdGhFcHMsXG4gICAgICAgICAgdHJhaW5PcHRzID0gdGhpcy50cmFpbk9wdHM7XG4gICAgICB2YXIgbGVhcm5pbmdSYXRlID0gdHJhaW5PcHRzLmxlYXJuaW5nUmF0ZTtcbiAgICAgIHZhciBhbGxNYXRyaWNlcyA9IG1vZGVsLmFsbE1hdHJpY2VzO1xuXG4gICAgICB2YXIgbnVtQ2xpcHBlZCA9IDA7XG4gICAgICB2YXIgbnVtVG90ID0gMDtcbiAgICAgIGZvciAodmFyIG1hdHJpeEluZGV4ID0gMDsgbWF0cml4SW5kZXggPCBhbGxNYXRyaWNlcy5sZW5ndGg7IG1hdHJpeEluZGV4KyspIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IGFsbE1hdHJpY2VzW21hdHJpeEluZGV4XTtcbiAgICAgICAgdmFyIHdlaWdodHMgPSBtYXRyaXgud2VpZ2h0cyxcbiAgICAgICAgICAgIGRlbHRhcyA9IG1hdHJpeC5kZWx0YXM7XG5cbiAgICAgICAgaWYgKCEobWF0cml4SW5kZXggaW4gc3RlcENhY2hlKSkge1xuICAgICAgICAgIHN0ZXBDYWNoZVttYXRyaXhJbmRleF0gPSAoMCwgX3plcm9zMi5kZWZhdWx0KShtYXRyaXgucm93cyAqIG1hdHJpeC5jb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FjaGUgPSBzdGVwQ2FjaGVbbWF0cml4SW5kZXhdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgciA9IGRlbHRhc1tpXTtcbiAgICAgICAgICB2YXIgdyA9IHdlaWdodHNbaV07XG4gICAgICAgICAgLy8gcm1zcHJvcCBhZGFwdGl2ZSBsZWFybmluZyByYXRlXG4gICAgICAgICAgY2FjaGVbaV0gPSBjYWNoZVtpXSAqIGRlY2F5UmF0ZSArICgxIC0gZGVjYXlSYXRlKSAqIHIgKiByO1xuICAgICAgICAgIC8vIGdyYWRpZW50IGNsaXBcbiAgICAgICAgICBpZiAociA+IGNsaXB2YWwpIHtcbiAgICAgICAgICAgIHIgPSBjbGlwdmFsO1xuICAgICAgICAgICAgbnVtQ2xpcHBlZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAociA8IC1jbGlwdmFsKSB7XG4gICAgICAgICAgICByID0gLWNsaXB2YWw7XG4gICAgICAgICAgICBudW1DbGlwcGVkKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bVRvdCsrO1xuICAgICAgICAgIC8vIHVwZGF0ZSAoYW5kIHJlZ3VsYXJpemUpXG4gICAgICAgICAgd2VpZ2h0c1tpXSA9IHcgKyAtbGVhcm5pbmdSYXRlICogciAvIE1hdGguc3FydChjYWNoZVtpXSArIHNtb290aEVwcykgLSByZWdjICogdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yYXRpb0NsaXBwZWQgPSBudW1DbGlwcGVkIC8gbnVtVG90O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdydW4nLFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW118Kn0gW3Jhd0lucHV0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2FtcGxlSV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGVtcGVyYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdmFyIHJhd0lucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgIHZhciBpc1NhbXBsZUkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHRlbXBlcmF0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuXG4gICAgICB2YXIgbWF4UHJlZGljdGlvbkxlbmd0aCA9IHRoaXMubWF4UHJlZGljdGlvbkxlbmd0aCArIHJhd0lucHV0Lmxlbmd0aCArICh0aGlzLmRhdGFGb3JtYXR0ZXIgPyB0aGlzLmRhdGFGb3JtYXR0ZXIuc3BlY2lhbEluZGV4ZXMubGVuZ3RoIDogMCk7XG4gICAgICBpZiAoIXRoaXMuaXNSdW5uYWJsZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLmZvcm1hdERhdGFJbihyYXdJbnB1dCk7XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSBpID09PSAwID8gMCA6IGkgPCBpbnB1dC5sZW5ndGggPyBpbnB1dFtpIC0gMV0gKyAxIDogb3V0cHV0W2kgLSAxXTtcbiAgICAgICAgd2hpbGUgKG1vZGVsLmVxdWF0aW9ucy5sZW5ndGggPD0gaSkge1xuICAgICAgICAgIHRoaXMuYmluZEVxdWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVxdWF0aW9uID0gbW9kZWwuZXF1YXRpb25zW2ldO1xuICAgICAgICAvLyBzYW1wbGUgcHJlZGljdGVkIGxldHRlclxuICAgICAgICB2YXIgb3V0cHV0TWF0cml4ID0gZXF1YXRpb24ucnVuSW5kZXgocHJldmlvdXNJbmRleCk7XG4gICAgICAgIHZhciBsb2dQcm9iYWJpbGl0aWVzID0gbmV3IF9tYXRyaXgyLmRlZmF1bHQobW9kZWwub3V0cHV0LnJvd3MsIG1vZGVsLm91dHB1dC5jb2x1bW5zKTtcbiAgICAgICAgKDAsIF9jb3B5Mi5kZWZhdWx0KShsb2dQcm9iYWJpbGl0aWVzLCBvdXRwdXRNYXRyaXgpO1xuICAgICAgICBpZiAodGVtcGVyYXR1cmUgIT09IDEgJiYgaXNTYW1wbGVJKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogc2NhbGUgbG9nIHByb2JhYmlsaXRpZXMgYnkgdGVtcGVyYXR1cmUgYW5kIHJlLW5vcm1hbGl6ZVxuICAgICAgICAgICAqIGlmIHRlbXBlcmF0dXJlIGlzIGhpZ2gsIGxvZ1Byb2JhYmlsaXRpZXMgd2lsbCBnbyB0b3dhcmRzIHplcm9cbiAgICAgICAgICAgKiBhbmQgdGhlIHNvZnRtYXggb3V0cHV0cyB3aWxsIGJlIG1vcmUgZGlmZnVzZS4gaWYgdGVtcGVyYXR1cmUgaXNcbiAgICAgICAgICAgKiB2ZXJ5IGxvdywgdGhlIHNvZnRtYXggb3V0cHV0cyB3aWxsIGJlIG1vcmUgcGVha3lcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbWF4ID0gbG9nUHJvYmFiaWxpdGllcy53ZWlnaHRzLmxlbmd0aDsgaiA8IG1heDsgaisrKSB7XG4gICAgICAgICAgICBsb2dQcm9iYWJpbGl0aWVzLndlaWdodHNbal0gLz0gdGVtcGVyYXR1cmU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb2JzID0gKDAsIF9zb2Z0bWF4Mi5kZWZhdWx0KShsb2dQcm9iYWJpbGl0aWVzKTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGlzU2FtcGxlSSA/ICgwLCBfc2FtcGxlSTIuZGVmYXVsdCkocHJvYnMpIDogKDAsIF9tYXhJMi5kZWZhdWx0KShwcm9icyk7XG5cbiAgICAgICAgaSsrO1xuICAgICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgLy8gRU5EIHRva2VuIHByZWRpY3RlZCwgYnJlYWsgb3V0XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gbWF4UHJlZGljdGlvbkxlbmd0aCkge1xuICAgICAgICAgIC8vIHNvbWV0aGluZyBpcyB3cm9uZ1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnB1c2gobmV4dEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB3ZSBzbGljZSB0aGUgaW5wdXQgbGVuZ3RoIGhlcmUsIG5vdCBiZWNhdXNlIG91dHB1dCBjb250YWlucyBpdCwgYnV0IGl0IHdpbGwgYmUgZXJyb25lb3VzIGFzIHdlIGFyZSBzZW5kaW5nIHRoZVxuICAgICAgICogbmV0d29yayB3aGF0IGlzIGNvbnRhaW5lZCBpbiBpbnB1dCwgc28gdGhlIGRhdGEgaXMgZXNzZW50aWFsbHkgZ3Vlc3NlZCBieSB0aGUgbmV0d29yayB3aGF0IGNvdWxkIGJlIG5leHQsIHRpbGwgaXRcbiAgICAgICAqIGxvY2tzIGluIG9uIGEgdmFsdWUuXG4gICAgICAgKiBLaW5kIG9mIGxpa2UgdGhpcywgdmFsdWVzIGFyZSBmcm9tIGlucHV0OlxuICAgICAgICogMCAtPiA0IChvciBpbiBFbmdsaXNoOiBcImJlZ2lubmluZyBvbiBpbnB1dFwiIC0+IFwiSSBoYXZlIG5vIGlkZWE/IEknbGwgZ3Vlc3Mgd2hhdCB0aGV5IHdhbnQgbmV4dCFcIilcbiAgICAgICAqIDIgLT4gMiAob2ggaG93IGludGVyZXN0aW5nLCBJJ3ZlIG5hcnJvd2VkIGRvd24gdmFsdWVzLi4uKVxuICAgICAgICogMSAtPiA5IChvaCBob3cgaW50ZXJlc3RpbmcsIEkndmUgbm93IGtub3cgd2hhdCB0aGUgdmFsdWVzIGFyZS4uLilcbiAgICAgICAqIHRoZW4gdGhlIG91dHB1dCBsb29rcyBsaWtlOiBbNCwgMiwgOSwuLi5dXG4gICAgICAgKiBzbyB3ZSB0aGVuIHJlbW92ZSB0aGUgZXJyb25lb3VzIGRhdGEgdG8gZ2V0IG91ciB0cnVlIG91dHB1dFxuICAgICAgICovXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXREYXRhT3V0KGlucHV0LCBvdXRwdXQuc2xpY2UoaW5wdXQubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAtIDE7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIFZlcmlmaWVzIG5ldHdvcmsgc2l6ZXMgYXJlIGluaXRpbGFpemVkXG4gICAgICogSWYgdGhleSBhcmUgbm90IGl0IHdpbGwgaW5pdGlhbGl6ZSB0aGVtIGJhc2VkIG9mZiB0aGUgZGF0YSBzZXQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZlcmlmeUlzSW5pdGlhbGl6ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlJc0luaXRpYWxpemVkKGRhdGEpIHtcbiAgICAgIGlmICghdGhpcy5tb2RlbCkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogICAgU3VwcG9ydHMgYWxsIGB0cmFpbkRlZmF1bHRzYCBwcm9wZXJ0aWVzXG4gICAgICogICAgYWxzbyBzdXBwb3J0czpcbiAgICAgKiAgICAgICBsZWFybmluZ1JhdGU6IChudW1iZXIpLFxuICAgICAqICAgICAgIG1vbWVudHVtOiAobnVtYmVyKSxcbiAgICAgKiAgICAgICBhY3RpdmF0aW9uOiAnc2lnbW9pZCcsICdyZWx1JywgJ2xlYWt5LXJlbHUnLCAndGFuaCdcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlVHJhaW5pbmdPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVHJhaW5pbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IudHJhaW5EZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudHJhaW5PcHRzW3BdID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSA/IG9wdGlvbnNbcF0gOiBfdGhpcy50cmFpbk9wdHNbcF07XG4gICAgICB9KTtcbiAgICAgIHRoaXMudmFsaWRhdGVUcmFpbmluZ09wdGlvbnModGhpcy50cmFpbk9wdHMpO1xuICAgICAgdGhpcy5zZXRMb2dNZXRob2Qob3B0aW9ucy5sb2cgfHwgdGhpcy50cmFpbk9wdHMubG9nKTtcbiAgICAgIHRoaXMuYWN0aXZhdGlvbiA9IG9wdGlvbnMuYWN0aXZhdGlvbiB8fCB0aGlzLmFjdGl2YXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndmFsaWRhdGVUcmFpbmluZ09wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVRyYWluaW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBfbmV1cmFsTmV0d29yazIuZGVmYXVsdC5wcm90b3R5cGUudmFsaWRhdGVUcmFpbmluZ09wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2dcbiAgICAgKiBpZiBhIG1ldGhvZCBpcyBwYXNzZWQgaW4gbWV0aG9kIGlzIHVzZWRcbiAgICAgKiBpZiBmYWxzZSBwYXNzZWQgaW4gbm90aGluZyBpcyBsb2dnZWRcbiAgICAgKiBAcmV0dXJucyBlcnJvclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRMb2dNZXRob2QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb2dNZXRob2QobG9nKSB7XG4gICAgICBpZiAodHlwZW9mIGxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnRyYWluT3B0cy5sb2cgPSBsb2c7XG4gICAgICB9IGVsc2UgaWYgKGxvZykge1xuICAgICAgICB0aGlzLnRyYWluT3B0cy5sb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhaW5PcHRzLmxvZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHsgZGF0YSwgc3RhdHVzLCBlbmRUaW1lIH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJlcFRyYWluaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcFRyYWluaW5nKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhaW5pbmdPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgZGF0YSA9IHRoaXMuZm9ybWF0RGF0YShkYXRhKTtcbiAgICAgIHZhciBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHRoaXMudHJhaW5PcHRzLnRpbWVvdXQ7XG5cbiAgICAgIHZhciBzdGF0dXMgPSB7XG4gICAgICAgIGVycm9yOiAxLFxuICAgICAgICBpdGVyYXRpb25zOiAwXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnZlcmlmeUlzSW5pdGlhbGl6ZWQoZGF0YSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICBlbmRUaW1lOiBlbmRUaW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxTdHJpbmdbXX0gZGF0YSBhbiBhcnJheSBvZiBvYmplY3RzOiBge2lucHV0OiAnc3RyaW5nJywgb3V0cHV0OiAnc3RyaW5nJ31gIG9yIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnMge3tlcnJvcjogbnVtYmVyLCBpdGVyYXRpb25zOiBudW1iZXJ9fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0cmFpbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWluKGRhdGEpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgdGhpcy50cmFpbk9wdHMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25zdHJ1Y3Rvci50cmFpbkRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuICAgICAgdmFyIGVycm9yVGhyZXNoID0gb3B0aW9ucy5lcnJvclRocmVzaDtcbiAgICAgIHZhciBsb2cgPSBvcHRpb25zLmxvZyA9PT0gdHJ1ZSA/IGNvbnNvbGUubG9nIDogb3B0aW9ucy5sb2c7XG4gICAgICB2YXIgbG9nUGVyaW9kID0gb3B0aW9ucy5sb2dQZXJpb2Q7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICAgICAgdmFyIGNhbGxiYWNrUGVyaW9kID0gb3B0aW9ucy5jYWxsYmFja1BlcmlvZDtcbiAgICAgIHZhciBlcnJvciA9IEluZmluaXR5O1xuICAgICAgdmFyIGkgPSB2b2lkIDA7XG5cbiAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KCdzZXR1cERhdGEnKSkge1xuICAgICAgICBkYXRhID0gdGhpcy5zZXR1cERhdGEoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmVyaWZ5SXNJbml0aWFsaXplZCgpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlcmF0aW9ucyAmJiBlcnJvciA+IGVycm9yVGhyZXNoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlcnIgPSB0aGlzLnRyYWluUGF0dGVybihkYXRhW2pdLCB0cnVlKTtcbiAgICAgICAgICBzdW0gKz0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gc3VtIC8gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGlzTmFOKGVycm9yKSkgdGhyb3cgbmV3IEVycm9yKCduZXR3b3JrIGVycm9yIHJhdGUgaXMgdW5leHBlY3RlZCBOYU4sIGNoZWNrIG5ldHdvcmsgY29uZmlndXJhdGlvbnMgYW5kIHRyeSBhZ2FpbicpO1xuICAgICAgICBpZiAobG9nICYmIGkgJSBsb2dQZXJpb2QgPT09IDApIHtcbiAgICAgICAgICBsb2coJ2l0ZXJhdGlvbnM6ICcgKyBpICsgJywgdHJhaW5pbmcgZXJyb3I6ICcgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIGkgJSBjYWxsYmFja1BlcmlvZCA9PT0gMCkge1xuICAgICAgICAgIGNhbGxiYWNrKHsgZXJyb3I6IGVycm9yLCBpdGVyYXRpb25zOiBpIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgaXRlcmF0aW9uczogaVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRGb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRGb3JtYXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCB5ZXQgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3RvSlNPTicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHM7XG4gICAgICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICB9XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgb3B0aW9uc1twXSA9IHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBpbnB1dDogbW9kZWwuaW5wdXQudG9KU09OKCksXG4gICAgICAgIGhpZGRlbkxheWVyczogbW9kZWwuaGlkZGVuTGF5ZXJzLm1hcChmdW5jdGlvbiAoaGlkZGVuTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgbGF5ZXJzID0ge307XG4gICAgICAgICAgZm9yICh2YXIgX3AgaW4gaGlkZGVuTGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyc1tfcF0gPSBoaWRkZW5MYXllcltfcF0udG9KU09OKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYXllcnM7XG4gICAgICAgIH0pLFxuICAgICAgICBvdXRwdXRDb25uZWN0b3I6IHRoaXMubW9kZWwub3V0cHV0Q29ubmVjdG9yLnRvSlNPTigpLFxuICAgICAgICBvdXRwdXQ6IHRoaXMubW9kZWwub3V0cHV0LnRvSlNPTigpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zyb21KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0cztcbiAgICAgIHZhciBvcHRpb25zID0ganNvbi5vcHRpb25zO1xuICAgICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgICB0aGlzLmhpZGRlbkxheWVycyA9IG51bGw7XG4gICAgICB2YXIgYWxsTWF0cmljZXMgPSBbXTtcbiAgICAgIHZhciBpbnB1dCA9IF9tYXRyaXgyLmRlZmF1bHQuZnJvbUpTT04oanNvbi5pbnB1dCk7XG4gICAgICBhbGxNYXRyaWNlcy5wdXNoKGlucHV0KTtcbiAgICAgIHZhciBoaWRkZW5MYXllcnMgPSBbXTtcblxuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3IgaGlkZGVuU2l6ZXNcbiAgICAgIChqc29uLmhpZGRlbkxheWVycyB8fCBqc29uLmhpZGRlblNpemVzKS5mb3JFYWNoKGZ1bmN0aW9uIChoaWRkZW5MYXllcikge1xuICAgICAgICB2YXIgbGF5ZXJzID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gaGlkZGVuTGF5ZXIpIHtcbiAgICAgICAgICBsYXllcnNbcF0gPSBfbWF0cml4Mi5kZWZhdWx0LmZyb21KU09OKGhpZGRlbkxheWVyW3BdKTtcbiAgICAgICAgICBhbGxNYXRyaWNlcy5wdXNoKGxheWVyc1twXSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuTGF5ZXJzLnB1c2gobGF5ZXJzKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgb3V0cHV0Q29ubmVjdG9yID0gX21hdHJpeDIuZGVmYXVsdC5mcm9tSlNPTihqc29uLm91dHB1dENvbm5lY3Rvcik7XG4gICAgICBhbGxNYXRyaWNlcy5wdXNoKG91dHB1dENvbm5lY3Rvcik7XG4gICAgICB2YXIgb3V0cHV0ID0gX21hdHJpeDIuZGVmYXVsdC5mcm9tSlNPTihqc29uLm91dHB1dCk7XG4gICAgICBhbGxNYXRyaWNlcy5wdXNoKG91dHB1dCk7XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAob3B0aW9ucy5oaWRkZW5TaXplcykge1xuICAgICAgICB0aGlzLmhpZGRlbkxheWVycyA9IG9wdGlvbnMuaGlkZGVuU2l6ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRhdGFGb3JtYXR0ZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhRm9ybWF0dGVyID0gX2RhdGFGb3JtYXR0ZXIyLmRlZmF1bHQuZnJvbUpTT04ob3B0aW9ucy5kYXRhRm9ybWF0dGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICBoaWRkZW5MYXllcnM6IGhpZGRlbkxheWVycyxcbiAgICAgICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgICAgIGFsbE1hdHJpY2VzOiBhbGxNYXRyaWNlcyxcbiAgICAgICAgb3V0cHV0Q29ubmVjdG9yOiBvdXRwdXRDb25uZWN0b3IsXG4gICAgICAgIGVxdWF0aW9uczogW10sXG4gICAgICAgIGVxdWF0aW9uQ29ubmVjdGlvbnM6IFtdXG4gICAgICB9O1xuICAgICAgdGhpcy5pbml0aWFsTGF5ZXJJbnB1dHMgPSB0aGlzLmhpZGRlbkxheWVycy5tYXAoZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfbWF0cml4Mi5kZWZhdWx0KHNpemUsIDEpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJpbmRFcXVhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b0Z1bmN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9GdW5jdGlvbigpIHtcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICB2YXIgZXF1YXRpb25zID0gdGhpcy5tb2RlbC5lcXVhdGlvbnM7XG4gICAgICB2YXIgZXF1YXRpb24gPSBlcXVhdGlvbnNbMV07XG4gICAgICB2YXIgc3RhdGVzID0gZXF1YXRpb24uc3RhdGVzO1xuICAgICAgdmFyIGpzb25TdHJpbmcgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcblxuICAgICAgZnVuY3Rpb24gbWF0cml4T3JpZ2luKG0sIHN0YXRlSW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tpXTtcblxuICAgICAgICAgIGlmIChpID09PSBzdGF0ZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaiA9IHByZXZpb3VzQ29ubmVjdGlvbkluZGV4KG0pO1xuICAgICAgICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgICAgICAgIGNhc2Ugc3RhdGUubGVmdDpcbiAgICAgICAgICAgICAgICBpZiAoaiA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gJ3R5cGVvZiBwcmV2U3RhdGVzWycgKyBqICsgJ10gPT09IFxcJ29iamVjdFxcJyA/IHByZXZTdGF0ZXNbJyArIGogKyAnXS5wcm9kdWN0IDogbmV3IE1hdHJpeCgnICsgbS5yb3dzICsgJywgJyArIG0uY29sdW1ucyArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2Ugc3RhdGUucmlnaHQ6XG4gICAgICAgICAgICAgICAgaWYgKGogPiAtMSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICd0eXBlb2YgcHJldlN0YXRlc1snICsgaiArICddID09PSBcXCdvYmplY3RcXCcgPyBwcmV2U3RhdGVzWycgKyBqICsgJ10ucHJvZHVjdCA6IG5ldyBNYXRyaXgoJyArIG0ucm93cyArICcsICcgKyBtLmNvbHVtbnMgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIHN0YXRlLnByb2R1Y3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduZXcgTWF0cml4KCcgKyBtLnJvd3MgKyAnLCAnICsgbS5jb2x1bW5zICsgJyknO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCd1bmtub3duIHN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG0gPT09IHN0YXRlLnByb2R1Y3QpIHJldHVybiAnc3RhdGVzWycgKyBpICsgJ10ucHJvZHVjdCc7XG4gICAgICAgICAgaWYgKG0gPT09IHN0YXRlLnJpZ2h0KSByZXR1cm4gJ3N0YXRlc1snICsgaSArICddLnJpZ2h0JztcbiAgICAgICAgICBpZiAobSA9PT0gc3RhdGUubGVmdCkgcmV0dXJuICdzdGF0ZXNbJyArIGkgKyAnXS5sZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcmV2aW91c0Nvbm5lY3Rpb25JbmRleChtKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gbW9kZWwuZXF1YXRpb25Db25uZWN0aW9uc1swXTtcbiAgICAgICAgdmFyIHN0YXRlcyA9IGVxdWF0aW9uc1swXS5zdGF0ZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICBpZiAoc3RhdGVzW2ldLnByb2R1Y3QgPT09IG0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5pbmRleE9mKG0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXRyaXhUb1N0cmluZyhtLCBzdGF0ZUluZGV4KSB7XG4gICAgICAgIGlmICghbSB8fCAhbS5yb3dzIHx8ICFtLmNvbHVtbnMpIHJldHVybiAnbnVsbCc7XG5cbiAgICAgICAgaWYgKG0gPT09IG1vZGVsLmlucHV0KSByZXR1cm4gJ2pzb24uaW5wdXQnO1xuICAgICAgICBpZiAobSA9PT0gbW9kZWwub3V0cHV0Q29ubmVjdG9yKSByZXR1cm4gJ2pzb24ub3V0cHV0Q29ubmVjdG9yJztcbiAgICAgICAgaWYgKG0gPT09IG1vZGVsLm91dHB1dCkgcmV0dXJuICdqc29uLm91dHB1dCc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IG1vZGVsLmhpZGRlbkxheWVycy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgIHZhciBoaWRkZW5MYXllciA9IG1vZGVsLmhpZGRlbkxheWVyc1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIGhpZGRlbkxheWVyKSB7XG4gICAgICAgICAgICBpZiAoIWhpZGRlbkxheWVyLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChoaWRkZW5MYXllcltwXSAhPT0gbSkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gJ2pzb24uaGlkZGVuTGF5ZXJzWycgKyBpICsgJ10uJyArIHA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdHJpeE9yaWdpbihtLCBzdGF0ZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdG9Jbm5lcihmblN0cmluZykge1xuICAgICAgICAvLyBjcnVkZSwgYnV0IHNob3VsZCBiZSBzdWZmaWNpZW50IGZvciBub3dcbiAgICAgICAgLy8gZnVuY3Rpb24oKSB7IGJvZHkgfVxuICAgICAgICBmblN0cmluZyA9IGZuU3RyaW5nLnRvU3RyaW5nKCkuc3BsaXQoJ3snKTtcbiAgICAgICAgZm5TdHJpbmcuc2hpZnQoKTtcbiAgICAgICAgLy8gYm9keSB9XG4gICAgICAgIGZuU3RyaW5nID0gZm5TdHJpbmcuam9pbigneycpO1xuICAgICAgICBmblN0cmluZyA9IGZuU3RyaW5nLnNwbGl0KCd9Jyk7XG4gICAgICAgIGZuU3RyaW5nLnBvcCgpO1xuICAgICAgICAvLyBib2R5XG4gICAgICAgIHJldHVybiBmblN0cmluZy5qb2luKCd9Jykuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgICAgICAgJykucmVwbGFjZSgncHJvZHVjdC5kZWx0YXNbaV0gPSAwOycsICcnKS5yZXBsYWNlKCdwcm9kdWN0LmRlbHRhc1tjb2x1bW5dID0gMDsnLCAnJykucmVwbGFjZSgnbGVmdC5kZWx0YXNbbGVmdEluZGV4XSA9IDA7JywgJycpLnJlcGxhY2UoJ3JpZ2h0LmRlbHRhc1tyaWdodEluZGV4XSA9IDA7JywgJycpLnJlcGxhY2UoJ3Byb2R1Y3QuZGVsdGFzID0gbGVmdC5kZWx0YXMuc2xpY2UoMCk7JywgJycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmaWxlTmFtZShmbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdzcmMvcmVjdXJyZW50L21hdHJpeC8nICsgZm5OYW1lLnJlcGxhY2UoL1tBLVpdL2csIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiAnLScgKyB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KSArICcuanMnO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGVzUmF3ID0gW107XG4gICAgICB2YXIgdXNlZEZ1bmN0aW9uTmFtZXMgPSB7fTtcbiAgICAgIHZhciBpbm5lckZ1bmN0aW9uc1N3aXRjaCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgIHN0YXRlc1Jhdy5wdXNoKCdzdGF0ZXNbJyArIGkgKyAnXSA9IHtcXG4gICAgICBuYW1lOiBcXCcnICsgc3RhdGUuZm9yd2FyZEZuLm5hbWUgKyAnXFwnLFxcbiAgICAgIGxlZnQ6ICcgKyBtYXRyaXhUb1N0cmluZyhzdGF0ZS5sZWZ0LCBpKSArICcsXFxuICAgICAgcmlnaHQ6ICcgKyBtYXRyaXhUb1N0cmluZyhzdGF0ZS5yaWdodCwgaSkgKyAnLFxcbiAgICAgIHByb2R1Y3Q6ICcgKyBtYXRyaXhUb1N0cmluZyhzdGF0ZS5wcm9kdWN0LCBpKSArICdcXG4gICAgfScpO1xuXG4gICAgICAgIHZhciBmbk5hbWUgPSBzdGF0ZS5mb3J3YXJkRm4ubmFtZTtcbiAgICAgICAgaWYgKCF1c2VkRnVuY3Rpb25OYW1lc1tmbk5hbWVdKSB7XG4gICAgICAgICAgdXNlZEZ1bmN0aW9uTmFtZXNbZm5OYW1lXSA9IHRydWU7XG4gICAgICAgICAgaW5uZXJGdW5jdGlvbnNTd2l0Y2gucHVzaCgnICAgICAgICBjYXNlIFxcJycgKyBmbk5hbWUgKyAnXFwnOiAvL2NvbXBpbGVkIGZyb20gJyArIGZpbGVOYW1lKGZuTmFtZSkgKyAnXFxuICAgICAgICAgICcgKyB0b0lubmVyKHN0YXRlLmZvcndhcmRGbi50b1N0cmluZygpKSArICdcXG4gICAgICAgICAgYnJlYWs7Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNyYyA9ICdcXG4gIGlmICh0eXBlb2YgcmF3SW5wdXQgPT09IFxcJ3VuZGVmaW5lZFxcJykgcmF3SW5wdXQgPSBbXTtcXG4gIGlmICh0eXBlb2YgaXNTYW1wbGVJID09PSBcXCd1bmRlZmluZWRcXCcpIGlzU2FtcGxlSSA9IGZhbHNlO1xcbiAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSA9PT0gXFwndW5kZWZpbmVkXFwnKSB0ZW1wZXJhdHVyZSA9IDE7XFxuICAnICsgKHRoaXMuZGF0YUZvcm1hdHRlciA/IHRoaXMuZGF0YUZvcm1hdHRlci50b0Z1bmN0aW9uU3RyaW5nKCkgOiAnJykgKyAnXFxuICBcXG4gIHZhciBpbnB1dCA9ICcgKyAodGhpcy5kYXRhRm9ybWF0dGVyICYmIHR5cGVvZiB0aGlzLmZvcm1hdERhdGFJbiA9PT0gJ2Z1bmN0aW9uJyA/ICdmb3JtYXREYXRhSW4ocmF3SW5wdXQpJyA6ICdyYXdJbnB1dCcpICsgJztcXG4gIHZhciBqc29uID0gJyArIGpzb25TdHJpbmcgKyAnO1xcbiAgdmFyIG1heFByZWRpY3Rpb25MZW5ndGggPSBpbnB1dC5sZW5ndGggKyAnICsgdGhpcy5tYXhQcmVkaWN0aW9uTGVuZ3RoICsgJztcXG4gIHZhciBfaSA9IDA7XFxuICB2YXIgb3V0cHV0ID0gW107XFxuICB2YXIgc3RhdGVzID0gW107XFxuICB2YXIgcHJldlN0YXRlcztcXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHZhciBwcmV2aW91c0luZGV4ID0gKF9pID09PSAwXFxuICAgICAgICA/IDBcXG4gICAgICAgIDogX2kgPCBpbnB1dC5sZW5ndGhcXG4gICAgICAgICAgPyBpbnB1dFtfaSAtIDFdICsgMVxcbiAgICAgICAgICA6IG91dHB1dFtfaSAtIDFdKVxcbiAgICAgICAgICA7XFxuICAgIHZhciByb3dQbHVja0luZGV4ID0gcHJldmlvdXNJbmRleDtcXG4gICAgdmFyIHN0YXRlO1xcbiAgICBwcmV2U3RhdGVzID0gc3RhdGVzO1xcbiAgICBzdGF0ZXMgPSBbXTtcXG4gICAgJyArIHN0YXRlc1Jhdy5qb2luKCc7XFxuICAgICcpICsgJztcXG4gICAgZm9yICh2YXIgc3RhdGVJbmRleCA9IDAsIHN0YXRlTWF4ID0gJyArIHN0YXRlc1Jhdy5sZW5ndGggKyAnOyBzdGF0ZUluZGV4IDwgc3RhdGVNYXg7IHN0YXRlSW5kZXgrKykge1xcbiAgICAgIHN0YXRlID0gc3RhdGVzW3N0YXRlSW5kZXhdO1xcbiAgICAgIHZhciBwcm9kdWN0ID0gc3RhdGUucHJvZHVjdDtcXG4gICAgICB2YXIgbGVmdCA9IHN0YXRlLmxlZnQ7XFxuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUucmlnaHQ7XFxuICAgICAgXFxuICAgICAgc3dpdGNoIChzdGF0ZS5uYW1lKSB7XFxuJyArIGlubmVyRnVuY3Rpb25zU3dpdGNoLmpvaW4oJ1xcbicpICsgJ1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIGxvZ1Byb2JhYmlsaXRpZXMgPSBzdGF0ZS5wcm9kdWN0O1xcbiAgICBpZiAodGVtcGVyYXR1cmUgIT09IDEgJiYgaXNTYW1wbGVJKSB7XFxuICAgICAgZm9yICh2YXIgcSA9IDAsIG5xID0gbG9nUHJvYmFiaWxpdGllcy53ZWlnaHRzLmxlbmd0aDsgcSA8IG5xOyBxKyspIHtcXG4gICAgICAgIGxvZ1Byb2JhYmlsaXRpZXMud2VpZ2h0c1txXSAvPSB0ZW1wZXJhdHVyZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHByb2JzID0gc29mdG1heChsb2dQcm9iYWJpbGl0aWVzKTtcXG4gICAgdmFyIG5leHRJbmRleCA9IGlzU2FtcGxlSSA/IHNhbXBsZUkocHJvYnMpIDogbWF4SShwcm9icyk7XFxuICAgIFxcbiAgICBfaSsrO1xcbiAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgaWYgKF9pID49IG1heFByZWRpY3Rpb25MZW5ndGgpIHtcXG4gICAgICBicmVhaztcXG4gICAgfVxcblxcbiAgICBvdXRwdXQucHVzaChuZXh0SW5kZXgpO1xcbiAgfVxcbiAgJyArICh0aGlzLmRhdGFGb3JtYXR0ZXIgJiYgdHlwZW9mIHRoaXMuZm9ybWF0RGF0YU91dCA9PT0gJ2Z1bmN0aW9uJyA/ICdyZXR1cm4gZm9ybWF0RGF0YU91dChpbnB1dCwgb3V0cHV0LnNsaWNlKGlucHV0Lmxlbmd0aCkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAtIDE7IH0pKScgOiAncmV0dXJuIG91dHB1dC5zbGljZShpbnB1dC5sZW5ndGgpLm1hcChmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgLSAxOyB9KScpICsgJztcXG4gIGZ1bmN0aW9uIE1hdHJpeChyb3dzLCBjb2x1bW5zKSB7XFxuICAgIHRoaXMucm93cyA9IHJvd3M7XFxuICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnM7XFxuICAgIHRoaXMud2VpZ2h0cyA9IHplcm9zKHJvd3MgKiBjb2x1bW5zKTtcXG4gIH1cXG4gICcgKyAodGhpcy5kYXRhRm9ybWF0dGVyICYmIHR5cGVvZiB0aGlzLmZvcm1hdERhdGFJbiA9PT0gJ2Z1bmN0aW9uJyA/ICdmdW5jdGlvbiBmb3JtYXREYXRhSW4oaW5wdXQsIG91dHB1dCkgeyAnICsgdG9Jbm5lcih0aGlzLmZvcm1hdERhdGFJbi50b1N0cmluZygpKS5yZXBsYWNlKC90aGlzWy5dZGF0YUZvcm1hdHRlcltcXG5cXHNdK1suXS9nLCAnJykucmVwbGFjZSgvdGhpc1suXWRhdGFGb3JtYXR0ZXJbLl0vZywgJycpLnJlcGxhY2UoL3RoaXNbLl1kYXRhRm9ybWF0dGVyL2csICd0cnVlJykgKyAnIH0nIDogJycpICsgJ1xcbiAgJyArICh0aGlzLmRhdGFGb3JtYXR0ZXIgIT09IG51bGwgJiYgdHlwZW9mIHRoaXMuZm9ybWF0RGF0YU91dCA9PT0gJ2Z1bmN0aW9uJyA/ICdmdW5jdGlvbiBmb3JtYXREYXRhT3V0KGlucHV0LCBvdXRwdXQpIHsgJyArIHRvSW5uZXIodGhpcy5mb3JtYXREYXRhT3V0LnRvU3RyaW5nKCkpLnJlcGxhY2UoL3RoaXNbLl1kYXRhRm9ybWF0dGVyW1xcblxcc10rWy5dL2csICcnKS5yZXBsYWNlKC90aGlzWy5dZGF0YUZvcm1hdHRlclsuXS9nLCAnJykucmVwbGFjZSgvdGhpc1suXWRhdGFGb3JtYXR0ZXIvZywgJ3RydWUnKSArICcgfScgOiAnJykgKyAnXFxuICAnICsgX3plcm9zMi5kZWZhdWx0LnRvU3RyaW5nKCkgKyAnXFxuICAnICsgX3NvZnRtYXgyLmRlZmF1bHQudG9TdHJpbmcoKS5yZXBsYWNlKCdfMi5kZWZhdWx0JywgJ01hdHJpeCcpICsgJ1xcbiAgJyArIF9yYW5kb20ucmFuZG9tRi50b1N0cmluZygpICsgJ1xcbiAgJyArIF9zYW1wbGVJMi5kZWZhdWx0LnRvU3RyaW5nKCkgKyAnXFxuICAnICsgX21heEkyLmRlZmF1bHQudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Jhd0lucHV0JywgJ2lzU2FtcGxlSScsICd0ZW1wZXJhdHVyZScsIHNyYyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaXNSdW5uYWJsZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5tb2RlbC5lcXVhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGVxdWF0aW9ucyBib3VuZCwgZGlkIHlvdSBydW4gdHJhaW4oKT8nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUk5OO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSTk47XG5cblxuUk5OLmRlZmF1bHRzID0ge1xuICBpbnB1dFNpemU6IDIwLFxuICBpbnB1dFJhbmdlOiAyMCxcbiAgaGlkZGVuTGF5ZXJzOiBbMjAsIDIwXSxcbiAgb3V0cHV0U2l6ZTogMjAsXG4gIGRlY2F5UmF0ZTogMC45OTksXG4gIHNtb290aEVwczogMWUtOCxcbiAgcmVnYzogMC4wMDAwMDEsXG4gIGNsaXB2YWw6IDUsXG4gIG1heFByZWRpY3Rpb25MZW5ndGg6IDEwMCxcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7KltdfSBkYXRhXG4gICAqIEByZXR1cm5zIHtOdW1iZXJbXX1cbiAgICovXG4gIHNldHVwRGF0YTogZnVuY3Rpb24gc2V0dXBEYXRhKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnICYmICFBcnJheS5pc0FycmF5KGRhdGFbMF0pICYmICghZGF0YVswXS5oYXNPd25Qcm9wZXJ0eSgnaW5wdXQnKSB8fCAhZGF0YVswXS5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0JykpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAodHlwZW9mIGRhdGFbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoZGF0YVswXSkpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhRm9ybWF0dGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGRhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YUZvcm1hdHRlciA9IG5ldyBfZGF0YUZvcm1hdHRlcjIuZGVmYXVsdCh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYXggPSBkYXRhLmxlbmd0aDsgX2kgPCBtYXg7IF9pKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5mb3JtYXREYXRhSW4oZGF0YVtfaV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmRhdGFGb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZGF0YS5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2goZGF0YVtfaTJdLmlucHV0KTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhW19pMl0ub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFGb3JtYXR0ZXIgPSBfZGF0YUZvcm1hdHRlcjIuZGVmYXVsdC5mcm9tQXJyYXlJbnB1dE91dHB1dCh2YWx1ZXMpO1xuICAgICAgICB0aGlzLmRhdGFGb3JtYXR0ZXIuYWRkVW5yZWNvZ25pemVkKCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTMgPSAwLCBfbWF4ID0gZGF0YS5sZW5ndGg7IF9pMyA8IF9tYXg7IF9pMysrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZm9ybWF0RGF0YUluKGRhdGFbX2kzXS5pbnB1dCwgZGF0YVtfaTNdLm91dHB1dCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqW119IGlucHV0XG4gICAqIEBwYXJhbSB7KltdfSBvdXRwdXRcbiAgICogQHJldHVybnMge051bWJlcltdfVxuICAgKi9cbiAgZm9ybWF0RGF0YUluOiBmdW5jdGlvbiBmb3JtYXREYXRhSW4oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgaWYgKHRoaXMuZGF0YUZvcm1hdHRlcikge1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdHRlci5pbmRleFRhYmxlLmhhc093blByb3BlcnR5KCdzdG9wLWlucHV0JykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZvcm1hdHRlci50b0luZGV4ZXNJbnB1dE91dHB1dChpbnB1dCwgb3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGb3JtYXR0ZXIudG9JbmRleGVzKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xuICB9LFxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaW5wdXRcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gb3V0cHV0XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgZm9ybWF0RGF0YU91dDogZnVuY3Rpb24gZm9ybWF0RGF0YU91dChpbnB1dCwgb3V0cHV0KSB7XG4gICAgaWYgKHRoaXMuZGF0YUZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YUZvcm1hdHRlci50b0NoYXJhY3RlcnMob3V0cHV0KS5qb2luKCcnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcbiAgZGF0YUZvcm1hdHRlcjogbnVsbFxufTtcblxuUk5OLnRyYWluRGVmYXVsdHMgPSB7XG4gIGl0ZXJhdGlvbnM6IDIwMDAwLFxuICBlcnJvclRocmVzaDogMC4wMDUsXG4gIGxvZzogZmFsc2UsXG4gIGxvZ1BlcmlvZDogMTAsXG4gIGxlYXJuaW5nUmF0ZTogMC4wMSxcbiAgY2FsbGJhY2s6IG51bGwsXG4gIGNhbGxiYWNrUGVyaW9kOiAxMFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJubi5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKlxuICogQHBhcmFtIG9wdHNcbiAqIEByZXR1cm5zIHtUcmFpblN0cmVhbX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVHJhaW5TdHJlYW0gPSBmdW5jdGlvbiAoX1dyaXRhYmxlKSB7XG4gIF9pbmhlcml0cyhUcmFpblN0cmVhbSwgX1dyaXRhYmxlKTtcblxuICBmdW5jdGlvbiBUcmFpblN0cmVhbShvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWluU3RyZWFtKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUcmFpblN0cmVhbS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRyYWluU3RyZWFtKSkuY2FsbCh0aGlzLCB7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSkpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyByZXF1aXJlIHRoZSBuZXVyYWxOZXR3b3JrXG4gICAgaWYgKCFvcHRpb25zLm5ldXJhbE5ldHdvcmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbmV1cmFsIG5ldHdvcmsgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgbmV1cmFsTmV0d29yayA9IF9vcHRpb25zLm5ldXJhbE5ldHdvcms7XG5cbiAgICBfdGhpcy5uZXVyYWxOZXR3b3JrID0gbmV1cmFsTmV0d29yaztcbiAgICBfdGhpcy5kYXRhRm9ybWF0RGV0ZXJtaW5lZCA9IGZhbHNlO1xuICAgIF90aGlzLmkgPSAwOyAvLyBrZWVwIHRyYWNrIG9mIGludGVybmFsIGl0ZXJhdGlvbnNcbiAgICBfdGhpcy5zaXplID0gMDtcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgX3RoaXMuc3VtID0gMDtcbiAgICBfdGhpcy5mbG9vZENhbGxiYWNrID0gb3B0aW9ucy5mbG9vZENhbGxiYWNrO1xuICAgIF90aGlzLmRvbmVUcmFpbmluZ0NhbGxiYWNrID0gb3B0aW9ucy5kb25lVHJhaW5pbmdDYWxsYmFjaztcblxuICAgIC8vIGluaGVyaXQgdHJhaW5PcHRzIHNldHRpbmdzIGZyb20gbmV1cmFsTmV0d29ya1xuICAgIG5ldXJhbE5ldHdvcmsudXBkYXRlVHJhaW5pbmdPcHRpb25zKG9wdGlvbnMpO1xuICAgIHZhciB0cmFpbk9wdHMgPSBuZXVyYWxOZXR3b3JrLnRyYWluT3B0cztcblxuICAgIF90aGlzLml0ZXJhdGlvbnMgPSB0cmFpbk9wdHMuaXRlcmF0aW9ucztcbiAgICBfdGhpcy5lcnJvclRocmVzaCA9IHRyYWluT3B0cy5lcnJvclRocmVzaDtcbiAgICBfdGhpcy5sb2cgPSB0cmFpbk9wdHMubG9nO1xuICAgIF90aGlzLmxvZ1BlcmlvZCA9IHRyYWluT3B0cy5sb2dQZXJpb2Q7XG4gICAgX3RoaXMuY2FsbGJhY2tQZXJpb2QgPSB0cmFpbk9wdHMuY2FsbGJhY2tQZXJpb2Q7XG4gICAgX3RoaXMuY2FsbGJhY2sgPSB0cmFpbk9wdHMuY2FsbGJhY2s7XG5cbiAgICBfdGhpcy5vbignZmluaXNoJywgX3RoaXMuZmluaXNoU3RyZWFtSXRlcmF0aW9uLmJpbmQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVHJhaW5TdHJlYW0sIFt7XG4gICAga2V5OiAnZW5kSW5wdXRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kSW5wdXRzKCkge1xuICAgICAgdGhpcy53cml0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX3dyaXRlIGV4cGVjdHMgZGF0YSB0byBiZSBpbiB0aGUgZm9ybSBvZiBhIGRhdHVtLiBpZS4ge2lucHV0OiB7YTogMSBiOiAwfSwgb3V0cHV0OiB7ejogMH19XG4gICAgICogQHBhcmFtIGNodW5rXG4gICAgICogQHBhcmFtIGVuY1xuICAgICAqIEBwYXJhbSBuZXh0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX3dyaXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dyaXRlKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgICAgIGlmICghY2h1bmspIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBlbmQgb2Ygb25lIGl0ZXJhdGlvbiBvZiB0aGUgc3RyZWFtXG4gICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5kYXRhRm9ybWF0RGV0ZXJtaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgdGhpcy5uZXVyYWxOZXR3b3JrLmFkZEZvcm1hdChjaHVuayk7XG4gICAgICAgIHRoaXMuZmlyc3REYXR1bSA9IHRoaXMuZmlyc3REYXR1bSB8fCBjaHVuaztcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb3VudCsrO1xuXG4gICAgICB2YXIgZGF0YSA9IHRoaXMubmV1cmFsTmV0d29yay5mb3JtYXREYXRhKGNodW5rKTtcbiAgICAgIHRoaXMuc3VtICs9IHRoaXMubmV1cmFsTmV0d29yay50cmFpblBhdHRlcm4oZGF0YVswXSwgdHJ1ZSk7XG5cbiAgICAgIC8vIHRlbGwgdGhlIFJlYWRhYmxlIFN0cmVhbSB0aGF0IHdlIGFyZSByZWFkeSBmb3IgbW9yZSBkYXRhXG4gICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZmluaXNoU3RyZWFtSXRlcmF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluaXNoU3RyZWFtSXRlcmF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdERldGVybWluZWQgJiYgdGhpcy5zaXplICE9PSB0aGlzLmNvdW50KSB7XG4gICAgICAgIHRoaXMubG9nKCdUaGlzIGl0ZXJhdGlvblxcJ3MgZGF0YSBsZW5ndGggd2FzIGRpZmZlcmVudCBmcm9tIHRoZSBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmRhdGFGb3JtYXREZXRlcm1pbmVkKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5uZXVyYWxOZXR3b3JrLmZvcm1hdERhdGEodGhpcy5maXJzdERhdHVtKTtcbiAgICAgICAgdGhpcy5uZXVyYWxOZXR3b3JrLnZlcmlmeUlzSW5pdGlhbGl6ZWQoZGF0YSk7XG4gICAgICAgIHRoaXMuZGF0YUZvcm1hdERldGVybWluZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mbG9vZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5mbG9vZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnN1bSAvIHRoaXMuc2l6ZTtcblxuICAgICAgaWYgKHRoaXMubG9nICYmIHRoaXMuaSAlIHRoaXMubG9nUGVyaW9kID09PSAwKSB7XG4gICAgICAgIHRoaXMubG9nKCdpdGVyYXRpb25zOiAnICsgdGhpcy5pICsgJywgdHJhaW5pbmcgZXJyb3I6ICcgKyBlcnJvcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYWxsYmFjayAmJiB0aGlzLmkgJSB0aGlzLmNhbGxiYWNrUGVyaW9kID09PSAwKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICBpdGVyYXRpb25zOiB0aGlzLmlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3VtID0gMDtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgLy8gdXBkYXRlIHRoZSBpdGVyYXRpb25zXG4gICAgICB0aGlzLmkrKztcblxuICAgICAgLy8gZG8gYSBjaGVjayBoZXJlIHRvIHNlZSBpZiB3ZSBuZWVkIHRoZSBzdHJlYW0gYWdhaW5cbiAgICAgIGlmICh0aGlzLmkgPCB0aGlzLml0ZXJhdGlvbnMgJiYgZXJyb3IgPiB0aGlzLmVycm9yVGhyZXNoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mbG9vZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvb2RDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb25lIHRyYWluaW5nXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kb25lVHJhaW5pbmdDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRvbmVUcmFpbmluZ0NhbGxiYWNrKHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IHRoaXMuaVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYWluU3RyZWFtO1xufShfc3RyZWFtLldyaXRhYmxlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhaW5TdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFpbi1zdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBcnJheUxvb2t1cFRhYmxlO1xuZnVuY3Rpb24gQXJyYXlMb29rdXBUYWJsZShkYXRhLCBwcm9wKSB7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5wcm9wID0gcHJvcDtcbiAgdmFyIHRhYmxlID0gdGhpcy50YWJsZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0dW0gPSBkYXRhW2ldO1xuICAgIHZhciBpbnB1dCA9IGRhdHVtW3Byb3BdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5wdXQubGVuZ3RoOyBqKyspIHtcbiAgICAgIGZvciAodmFyIHAgaW4gaW5wdXRbal0pIHtcbiAgICAgICAgaWYgKHRhYmxlLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcbiAgICAgICAgdGFibGVbcF0gPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LWxvb2t1cC10YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXJyYXlzVG9GbG9hdDMyQXJyYXlzID0gYXJyYXlzVG9GbG9hdDMyQXJyYXlzO1xuZXhwb3J0cy5hcnJheVRvRmxvYXQzMkFycmF5cyA9IGFycmF5VG9GbG9hdDMyQXJyYXlzO1xuZXhwb3J0cy5hcnJheVRvRmxvYXQzMkFycmF5ID0gYXJyYXlUb0Zsb2F0MzJBcnJheTtcbmV4cG9ydHMub2JqZWN0c1RvRmxvYXQzMkFycmF5cyA9IG9iamVjdHNUb0Zsb2F0MzJBcnJheXM7XG5leHBvcnRzLm9iamVjdFRvRmxvYXQzMkFycmF5cyA9IG9iamVjdFRvRmxvYXQzMkFycmF5cztcbmV4cG9ydHMub2JqZWN0VG9GbG9hdDMyQXJyYXkgPSBvYmplY3RUb0Zsb2F0MzJBcnJheTtcbmZ1bmN0aW9uIGFycmF5c1RvRmxvYXQzMkFycmF5cyhhcnJheXMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKEZsb2F0MzJBcnJheS5mcm9tKGFycmF5c1tpXSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhcnJheVRvRmxvYXQzMkFycmF5cyhhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQucHVzaChGbG9hdDMyQXJyYXkuZnJvbShbYXJyYXlbaV1dKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFycmF5VG9GbG9hdDMyQXJyYXkoYXJyYXkpIHtcbiAgcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycmF5KTtcbn1cbmZ1bmN0aW9uIG9iamVjdHNUb0Zsb2F0MzJBcnJheXMob2JqZWN0cywgdGFibGUsIGxlbmd0aCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgb2JqZWN0ID0gb2JqZWN0c1tpXTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIHJlc3VsdFt0YWJsZVtwXV0gPSBvYmplY3RbcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuZnVuY3Rpb24gb2JqZWN0VG9GbG9hdDMyQXJyYXlzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2goRmxvYXQzMkFycmF5LmZyb20oW29iamVjdFtwXV0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb2JqZWN0VG9GbG9hdDMyQXJyYXkob2JqZWN0LCB0YWJsZSwgbGVuZ3RoKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgcmVzdWx0W3RhYmxlW3BdXSA9IG9iamVjdFtwXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmdbXXxOdW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0gbWF4VGhyZXNob2xkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGFGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFGb3JtYXR0ZXIodmFsdWVzKSB7XG4gICAgdmFyIG1heFRocmVzaG9sZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhRm9ybWF0dGVyKTtcblxuICAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgLy8gZ28gb3ZlciBhbGwgY2hhcmFjdGVycyBhbmQga2VlcCB0cmFjayBvZiBhbGwgdW5pcXVlIG9uZXMgc2VlblxuICAgIC8vIGNvdW50IHVwIGFsbCBjaGFyYWN0ZXJzXG4gICAgdGhpcy5pbmRleFRhYmxlID0ge307XG4gICAgdGhpcy5jaGFyYWN0ZXJUYWJsZSA9IHt9O1xuICAgIHRoaXMuY2hhcmFjdGVycyA9IFtdO1xuICAgIHRoaXMuc3BlY2lhbEluZGV4ZXMgPSBbXTtcbiAgICB0aGlzLmJ1aWxkQ2hhcmFjdGVyc0Zyb21JdGVyYWJsZSh2YWx1ZXMpO1xuICAgIHRoaXMuYnVpbGRUYWJsZXMobWF4VGhyZXNob2xkKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhRm9ybWF0dGVyLCBbe1xuICAgIGtleTogJ2J1aWxkQ2hhcmFjdGVyc0Zyb21JdGVyYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkQ2hhcmFjdGVyc0Zyb21JdGVyYWJsZSh2YWx1ZXMpIHtcbiAgICAgIHZhciB0ZW1wQ2hhcmFjdGVyc1RhYmxlID0ge307XG4gICAgICBmb3IgKHZhciBkYXRhRm9ybWF0dGVySW5kZXggPSAwLCBkYXRhRm9ybWF0dGVyTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDsgZGF0YUZvcm1hdHRlckluZGV4IDwgZGF0YUZvcm1hdHRlckxlbmd0aDsgZGF0YUZvcm1hdHRlckluZGV4KyspIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlcnMgPSB2YWx1ZXNbZGF0YUZvcm1hdHRlckluZGV4XTtcblxuICAgICAgICBpZiAoY2hhcmFjdGVycy5oYXNPd25Qcm9wZXJ0eSgnbGVuZ3RoJykpIHtcbiAgICAgICAgICBmb3IgKHZhciBjaGFyYWN0ZXJJbmRleCA9IDAsIGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDsgY2hhcmFjdGVySW5kZXggPCBjaGFyYWN0ZXJzTGVuZ3RoOyBjaGFyYWN0ZXJJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gY2hhcmFjdGVyc1tjaGFyYWN0ZXJJbmRleF07XG4gICAgICAgICAgICBpZiAodGVtcENoYXJhY3RlcnNUYWJsZS5oYXNPd25Qcm9wZXJ0eShjaGFyYWN0ZXIpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRlbXBDaGFyYWN0ZXJzVGFibGVbY2hhcmFjdGVyXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNoYXJhY3RlcnMucHVzaChjaGFyYWN0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NoYXJhY3RlciA9IHZhbHVlc1tkYXRhRm9ybWF0dGVySW5kZXhdO1xuICAgICAgICAgIGlmICh0ZW1wQ2hhcmFjdGVyc1RhYmxlLmhhc093blByb3BlcnR5KF9jaGFyYWN0ZXIpKSBjb250aW51ZTtcbiAgICAgICAgICB0ZW1wQ2hhcmFjdGVyc1RhYmxlW2RhdGFGb3JtYXR0ZXJJbmRleF0gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY2hhcmFjdGVycy5wdXNoKF9jaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYnVpbGRUYWJsZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZFRhYmxlcyhtYXhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIGZpbHRlciBieSBjb3VudCB0aHJlc2hvbGQgYW5kIGNyZWF0ZSBwb2ludGVyc1xuICAgICAgdmFyIGNoYXJhY3RlcnNMZW5ndGggPSB0aGlzLmNoYXJhY3RlcnMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgY2hhcmFjdGVySW5kZXggPSAwOyBjaGFyYWN0ZXJJbmRleCA8IGNoYXJhY3RlcnNMZW5ndGg7IGNoYXJhY3RlckluZGV4KyspIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRoaXMuY2hhcmFjdGVyc1tjaGFyYWN0ZXJJbmRleF07XG4gICAgICAgIGlmIChjaGFyYWN0ZXJJbmRleCA+PSBtYXhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBhZGQgY2hhcmFjdGVyIHRvIGRhdGFGb3JtYXR0ZXJcbiAgICAgICAgICB0aGlzLmluZGV4VGFibGVbY2hhcmFjdGVyXSA9IGNoYXJhY3RlckluZGV4O1xuICAgICAgICAgIHRoaXMuY2hhcmFjdGVyVGFibGVbY2hhcmFjdGVySW5kZXhdID0gY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9JbmRleGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9JbmRleGVzKHZhbHVlKSB7XG4gICAgICB2YXIgbWF4VGhyZXNob2xkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgaW5kZXhUYWJsZSA9IHRoaXMuaW5kZXhUYWJsZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHZhbHVlLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyYWN0ZXIgPSB2YWx1ZVtpXTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhUYWJsZVtjaGFyYWN0ZXJdO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChpbmRleFRhYmxlWyd1bnJlY29nbml6ZWQnXSkge1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleFRhYmxlWyd1bnJlY29nbml6ZWQnXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgY2hhcmFjdGVyIFwiJyArIGNoYXJhY3RlciArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPCBtYXhUaHJlc2hvbGQpIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9JbmRleGVzSW5wdXRPdXRwdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0luZGV4ZXNJbnB1dE91dHB1dCh2YWx1ZTEpIHtcbiAgICAgIHZhciB2YWx1ZTIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgbWF4VGhyZXNob2xkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZTEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudG9JbmRleGVzKHZhbHVlMS5zcGxpdCgnJykuY29uY2F0KFsnc3RvcC1pbnB1dCcsICdzdGFydC1vdXRwdXQnXSksIG1heFRocmVzaG9sZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnRvSW5kZXhlcyh2YWx1ZTEuY29uY2F0KFsnc3RvcC1pbnB1dCcsICdzdGFydC1vdXRwdXQnXSksIG1heFRocmVzaG9sZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZTIgPT09IG51bGwpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCh0aGlzLnRvSW5kZXhlcyh2YWx1ZTIuc3BsaXQoJycpLCBtYXhUaHJlc2hvbGQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHRoaXMudG9JbmRleGVzKHZhbHVlMiwgbWF4VGhyZXNob2xkKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9DaGFyYWN0ZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9DaGFyYWN0ZXJzKGluZGljZXMpIHtcbiAgICAgIHZhciBtYXhUaHJlc2hvbGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBjaGFyYWN0ZXJUYWJsZSA9IHRoaXMuY2hhcmFjdGVyVGFibGU7XG4gICAgICB2YXIgaW5kZXhUYWJsZSA9IHRoaXMuaW5kZXhUYWJsZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgICAgaWYgKGluZGV4IDwgbWF4VGhyZXNob2xkKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGNoYXJhY3RlciA9IGNoYXJhY3RlclRhYmxlW2luZGV4XTtcbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGluZGV4VGFibGVbJ3VucmVjb2duaXplZCddKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXJUYWJsZVtpbmRleFRhYmxlWyd1bnJlY29nbml6ZWQnXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIGluZGV4IFwiJyArIGluZGV4ICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKGluZGljZXMsIG1heFRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9DaGFyYWN0ZXJzKGluZGljZXMsIG1heFRocmVzaG9sZCkuam9pbignJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYWRkSW5wdXRPdXRwdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbnB1dE91dHB1dCgpIHtcbiAgICAgIHRoaXMuYWRkU3BlY2lhbCgnc3RvcC1pbnB1dCcpO1xuICAgICAgdGhpcy5hZGRTcGVjaWFsKCdzdGFydC1vdXRwdXQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRVbnJlY29nbml6ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVbnJlY29nbml6ZWQoKSB7XG4gICAgICB0aGlzLmFkZFNwZWNpYWwoJ3VucmVjb2duaXplZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZFNwZWNpYWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTcGVjaWFsKHNwZWNpYWwpIHtcbiAgICAgIHZhciBjaGFyYWN0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIHZhciBzcGVjaWFsSW5kZXggPSB0aGlzLmluZGV4VGFibGVbc3BlY2lhbF0gPSB0aGlzLmNoYXJhY3RlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5jaGFyYWN0ZXJUYWJsZVtzcGVjaWFsSW5kZXhdID0gY2hhcmFjdGVyO1xuICAgICAgdGhpcy5zcGVjaWFsSW5kZXhlcy5wdXNoKHRoaXMuY2hhcmFjdGVycy5sZW5ndGgpO1xuICAgICAgdGhpcy5jaGFyYWN0ZXJzLnB1c2goc3BlY2lhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY291bnRTcGVjaWFsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY291bnRTcGVjaWFsKG91dHB1dCkge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbEluZGV4ZXM7IGkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKGluZGV4ID0gb3V0cHV0LmluZGV4T2YodGhpcy5zcGVjaWFsSW5kZXhlc1tpXSwgaW5kZXgpID4gLTEpIHtcbiAgICAgICAgICBzdW0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b0Z1bmN0aW9uU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9GdW5jdGlvblN0cmluZygpIHtcbiAgICAgIHJldHVybiAnXFxudmFyIGNoYXJhY3RlclRhYmxlID0gJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuY2hhcmFjdGVyVGFibGUpICsgJztcXG52YXIgaW5kZXhUYWJsZSA9ICcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmluZGV4VGFibGUpICsgJztcXG52YXIgY2hhcmFjdGVycyA9ICcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmNoYXJhY3RlcnMpICsgJztcXG4nICsgdGhpcy50b0luZGV4ZXMudG9TdHJpbmcoKS5yZXBsYWNlKC8obGV0fHZhcikgaW5kZXhUYWJsZSA9IHRoaXNbLl1pbmRleFRhYmxlO1xcbi8sICcnKS5yZXBsYWNlKC90aGlzWy5dL2csICcnKSArICdcXG4nICsgdGhpcy50b0luZGV4ZXNJbnB1dE91dHB1dC50b1N0cmluZygpLnJlcGxhY2UoL3RoaXNbLl0vZywgJycpICsgJ1xcbicgKyB0aGlzLnRvQ2hhcmFjdGVycy50b1N0cmluZygpLnJlcGxhY2UoLyhsZXR8dmFyKSBjaGFyYWN0ZXJUYWJsZSA9IHRoaXNbLl1jaGFyYWN0ZXJUYWJsZTtcXG4vZywgJycpLnJlcGxhY2UoL3RoaXNbLl0vLCAnJykgKyAnXFxuJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2Zyb21BbGxQcmludGFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQWxsUHJpbnRhYmxlKG1heFRocmVzaG9sZCkge1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWydcXG4nXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDMyOyBpIDw9IDEyNjsgaSsrKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhRm9ybWF0dGVyKHZhbHVlcywgbWF4VGhyZXNob2xkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tQWxsUHJpbnRhYmxlSW5wdXRPdXRwdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQWxsUHJpbnRhYmxlSW5wdXRPdXRwdXQobWF4VGhyZXNob2xkKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbJ1xcbiddO1xuXG4gICAgICB2YXIgZGF0YUZvcm1hdHRlciA9IERhdGFGb3JtYXR0ZXIuZnJvbUFsbFByaW50YWJsZShtYXhUaHJlc2hvbGQsIHZhbHVlcyk7XG4gICAgICBkYXRhRm9ybWF0dGVyLmFkZElucHV0T3V0cHV0KCk7XG4gICAgICByZXR1cm4gZGF0YUZvcm1hdHRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tU3RyaW5nSW5wdXRPdXRwdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nSW5wdXRPdXRwdXQoc3RyaW5nLCBtYXhUaHJlc2hvbGQpIHtcbiAgICAgIHZhciBfU3RyaW5nJHByb3RvdHlwZTtcblxuICAgICAgdmFyIHZhbHVlcyA9IChfU3RyaW5nJHByb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGUpLmNvbmNhdC5hcHBseShfU3RyaW5nJHByb3RvdHlwZSwgX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBTZXQoc3RyaW5nKSkpO1xuICAgICAgdmFyIGRhdGFGb3JtYXR0ZXIgPSBuZXcgRGF0YUZvcm1hdHRlcih2YWx1ZXMsIG1heFRocmVzaG9sZCk7XG4gICAgICBkYXRhRm9ybWF0dGVyLmFkZElucHV0T3V0cHV0KCk7XG4gICAgICByZXR1cm4gZGF0YUZvcm1hdHRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tQXJyYXlJbnB1dE91dHB1dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheUlucHV0T3V0cHV0KGFycmF5LCBtYXhUaHJlc2hvbGQpIHtcbiAgICAgIHZhciBkYXRhRm9ybWF0dGVyID0gbmV3IERhdGFGb3JtYXR0ZXIoYXJyYXkuZmlsdGVyKGZ1bmN0aW9uICh2LCBpLCBhKSB7XG4gICAgICAgIHJldHVybiBhLmluZGV4T2YodikgPT09IGk7XG4gICAgICB9KS5zb3J0KCksIG1heFRocmVzaG9sZCk7XG4gICAgICBkYXRhRm9ybWF0dGVyLmFkZElucHV0T3V0cHV0KCk7XG4gICAgICByZXR1cm4gZGF0YUZvcm1hdHRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcsIG1heFRocmVzaG9sZCkge1xuICAgICAgdmFyIF9TdHJpbmckcHJvdG90eXBlMjtcblxuICAgICAgdmFyIHZhbHVlcyA9IChfU3RyaW5nJHByb3RvdHlwZTIgPSBTdHJpbmcucHJvdG90eXBlKS5jb25jYXQuYXBwbHkoX1N0cmluZyRwcm90b3R5cGUyLCBfdG9Db25zdW1hYmxlQXJyYXkobmV3IFNldChzdHJpbmcpKSk7XG4gICAgICByZXR1cm4gbmV3IERhdGFGb3JtYXR0ZXIodmFsdWVzLCBtYXhUaHJlc2hvbGQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Zyb21KU09OJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgdmFyIGRhdGFGb3JtYXR0ZXIgPSBuZXcgRGF0YUZvcm1hdHRlcigpO1xuICAgICAgZGF0YUZvcm1hdHRlci5pbmRleFRhYmxlID0ganNvbi5pbmRleFRhYmxlO1xuICAgICAgZGF0YUZvcm1hdHRlci5jaGFyYWN0ZXJUYWJsZSA9IGpzb24uY2hhcmFjdGVyVGFibGU7XG4gICAgICBkYXRhRm9ybWF0dGVyLnZhbHVlcyA9IGpzb24udmFsdWVzO1xuICAgICAgZGF0YUZvcm1hdHRlci5jaGFyYWN0ZXJzID0ganNvbi5jaGFyYWN0ZXJzO1xuICAgICAgZGF0YUZvcm1hdHRlci5zcGVjaWFsSW5kZXhlcyA9IGpzb24uc3BlY2lhbEluZGV4ZXM7XG4gICAgICByZXR1cm4gZGF0YUZvcm1hdHRlcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YUZvcm1hdHRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUZvcm1hdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtZm9ybWF0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9va3VwVGFibGU7XG5mdW5jdGlvbiBMb29rdXBUYWJsZShkYXRhLCBwcm9wKSB7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgaWYgKHByb3ApIHtcbiAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgIHZhciB0YWJsZSA9IHRoaXMudGFibGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkYXR1bSA9IGRhdGFbaV07XG4gICAgICB2YXIgb2JqZWN0ID0gZGF0dW1bcHJvcF07XG4gICAgICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgICAgICBpZiAodGFibGUuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuICAgICAgICB0YWJsZVtwXSA9IHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXSkpIHtcbiAgICB2YXIgX3RhYmxlID0gdGhpcy50YWJsZSA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkYXRhLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGFycmF5ID0gZGF0YVtfaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBfb2JqZWN0ID0gYXJyYXlbal07XG4gICAgICAgIGZvciAodmFyIF9wIGluIF9vYmplY3QpIHtcbiAgICAgICAgICBpZiAoX3RhYmxlLmhhc093blByb3BlcnR5KF9wKSkgY29udGludWU7XG4gICAgICAgICAgX3RhYmxlW19wXSA9IHRoaXMubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90YWJsZTIgPSB0aGlzLnRhYmxlID0ge307XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZGF0YS5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX29iamVjdDIgPSBkYXRhW19pMl07XG4gICAgICBmb3IgKHZhciBfcDIgaW4gX29iamVjdDIpIHtcbiAgICAgICAgaWYgKF90YWJsZTIuaGFzT3duUHJvcGVydHkoX3AyKSkgY29udGludWU7XG4gICAgICAgIF90YWJsZTJbX3AyXSA9IHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9va3VwLXRhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1heDtcblxudmFyIF90b0FycmF5ID0gcmVxdWlyZSgnLi90by1hcnJheScpO1xuXG52YXIgX3RvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9BcnJheSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG1heCh2YWx1ZXMpIHtcbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsICgwLCBfdG9BcnJheTIuZGVmYXVsdCkodmFsdWVzKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtc2U7XG5mdW5jdGlvbiBtc2UoZXJyb3JzKSB7XG4gIC8vIG1lYW4gc3F1YXJlZCBlcnJvclxuICB2YXIgc3VtID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gKz0gZXJyb3JzW2ldICogZXJyb3JzW2ldO1xuICB9XG4gIHJldHVybiBzdW0gLyBlcnJvcnMubGVuZ3RoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG9uZXM7XG5mdW5jdGlvbiBvbmVzKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplKS5maWxsKDEpO1xuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSAxO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByYW5kb21XZWlnaHQ7XG5mdW5jdGlvbiByYW5kb21XZWlnaHQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpICogMC40IC0gMC4yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLXdlaWdodC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmFuZG9tRiA9IHJhbmRvbUY7XG5leHBvcnRzLnJhbmRvbUkgPSByYW5kb21JO1xuZXhwb3J0cy5yYW5kb21OID0gcmFuZG9tTjtcbmZ1bmN0aW9uIHJhbmRvbUYoYSwgYikge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhO1xufVxuXG5mdW5jdGlvbiByYW5kb21JKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tTihtdSwgc3RkKSB7XG4gIHJldHVybiBtdSArIGdhdXNzUmFuZG9tKCkgKiBzdGQ7XG59XG5cbi8vIFJhbmRvbSBudW1iZXJzIHV0aWxzXG5mdW5jdGlvbiBnYXVzc1JhbmRvbSgpIHtcbiAgaWYgKGdhdXNzUmFuZG9tLnJldHVyblYpIHtcbiAgICBnYXVzc1JhbmRvbS5yZXR1cm5WID0gZmFsc2U7XG4gICAgcmV0dXJuIGdhdXNzUmFuZG9tLnZWYWw7XG4gIH1cbiAgdmFyIHUgPSAyICogTWF0aC5yYW5kb20oKSAtIDE7XG4gIHZhciB2ID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxO1xuICB2YXIgciA9IHUgKiB1ICsgdiAqIHY7XG4gIGlmIChyID09IDAgfHwgciA+IDEpIHtcbiAgICByZXR1cm4gZ2F1c3NSYW5kb20oKTtcbiAgfVxuICB2YXIgYyA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gIGdhdXNzUmFuZG9tLnZWYWwgPSB2ICogYzsgLy8gY2FjaGUgdGhpc1xuICBnYXVzc1JhbmRvbS5yZXR1cm5WID0gdHJ1ZTtcbiAgcmV0dXJuIHUgKiBjO1xufVxuZ2F1c3NSYW5kb20ucmV0dXJuViA9IGZhbHNlO1xuZ2F1c3NSYW5kb20udlZhbCA9IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmFuZG9zO1xuXG52YXIgX3JhbmRvbVdlaWdodCA9IHJlcXVpcmUoJy4vcmFuZG9tLXdlaWdodCcpO1xuXG52YXIgX3JhbmRvbVdlaWdodDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYW5kb21XZWlnaHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiByYW5kb3Moc2l6ZSkge1xuICB2YXIgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGFycmF5W2ldID0gKDAsIF9yYW5kb21XZWlnaHQyLmRlZmF1bHQpKCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmFuZ2U7XG4vKipcbiAqXG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAoOyBzdGFydCA8IGVuZDsgc3RhcnQrKykge1xuICAgIHJlc3VsdC5wdXNoKHN0YXJ0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0FycmF5O1xuLyoqXG4gKlxuICogQHBhcmFtIHZhbHVlc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSBpbiBrZXlzKSB7XG4gICAgICByZXN1bHRbaV0gPSB2YWx1ZXNba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvLWFycmF5LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TVkc7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiB0b1NWRyhuZXR3b3JrLCBvcHRpb25zKSB7XG4gICAgLy9kZWZhdWx0IHZhbHVlc1xuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgICAgd2lkdGg6ICcwLjUnLFxuICAgICAgICAgICAgY29sb3I6ICdibGFjaydcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMTI4LCAwLCAwLjUpJyxcbiAgICAgICAgICAgIGxhYmVsOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBvdXRwdXRzOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTAwLCAxNDksIDIzNywgMC41KSdcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZGVuOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LCAxMjcsIDgwLCAwLjUpJ1xuICAgICAgICB9LFxuICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICByYWRpdXM6ICc4JyxcbiAgICAgICAgd2lkdGg6ICc0MDAnLFxuICAgICAgICBoZWlnaHQ6ICcyNTAnXG4gICAgfTtcblxuICAgIHZhciBzaXplID0gdHlwZW9mIG5ldHdvcmsuaW5wdXRTaXplID09ICdudW1iZXInICYmIHR5cGVvZiBuZXR3b3JrLm91dHB1dFNpemUgPT0gJ251bWJlcicgJiYgbmV0d29yay5pbnB1dFNpemUgPiAwICYmIG5ldHdvcmsub3V0cHV0U2l6ZSA+IDAgPyBbbmV0d29yay5pbnB1dFNpemVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobmV0d29yay5oaWRkZW5MYXllcnMpLCBbbmV0d29yay5vdXRwdXRTaXplXSkgOiBmYWxzZTtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5pbnB1dHMubGFiZWwgPSBvcHRpb25zLmlucHV0cy5sYWJlbC5sZW5ndGggPT0gbmV0d29yay5pbnB1dFNpemUgPyBvcHRpb25zLmlucHV0cy5sYWJlbCA6IGZhbHNlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIHZhciBzdmcgPSAnPHN2ZyAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHZlcnNpb249XCIxLjFcIiB3aWR0aD1cIicgKyBvcHRpb25zLndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyBvcHRpb25zLmhlaWdodCArICdcIj4nO1xuICAgICAgICB2YXIgc2ggPSBvcHRpb25zLndpZHRoIC8gc2l6ZS5sZW5ndGg7XG4gICAgICAgIHNpemUuZm9yRWFjaChmdW5jdGlvbiAobmV1cm9uc051LCBpKSB7XG4gICAgICAgICAgICB2YXIgc3YgPSBvcHRpb25zLmhlaWdodCAvIG5ldXJvbnNOdTtcbiAgICAgICAgICAgIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkobmV1cm9uc051KSkpLmZvckVhY2goZnVuY3Rpb24gKF8sIGopIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2ZyArPSAnPHJlY3QgeD1cIicgKyAoc2ggLyAyIC0gb3B0aW9ucy5yYWRpdXMpICsgJ1wiIHk9XCInICsgKHN2IC8gMiArIGogKiBzdiAtIG9wdGlvbnMucmFkaXVzKSArICdcIiB3aWR0aD1cIicgKyAyICogb3B0aW9ucy5yYWRpdXMgKyAnXCIgaGVpZ2h0PVwiJyArIDIgKiBvcHRpb25zLnJhZGl1cyArICdcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwiJyArIG9wdGlvbnMuaW5wdXRzLmNvbG9yICsgJ1wiIC8+JztcbiAgICAgICAgICAgICAgICAgICAgc3ZnICs9ICc8bGluZSB4MT1cIicgKyBzaCAvIDQgKyAnXCIgeTE9XCInICsgKHN2IC8gMiArIGogKiBzdikgKyAnXCIgeDI9XCInICsgKHNoIC8gMiAtIG9wdGlvbnMucmFkaXVzKSArICdcIiB5Mj1cIicgKyAoc3YgLyAyICsgaiAqIHN2KSArICdcIiBzdHlsZT1cInN0cm9rZTonICsgb3B0aW9ucy5saW5lLmNvbG9yICsgJztzdHJva2Utd2lkdGg6JyArIG9wdGlvbnMubGluZS53aWR0aCArICdcIiAvPic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlucHV0cy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnICs9ICc8dGV4dCB4PVwiJyArIHNoIC8gOCArICdcIiB5PVwiJyArIChzdiAvIDIgKyBqICogc3YgLSA1KSArICdcIiBmaWxsPVwiYmxhY2tcIiBmb250LXNpemU9IFwiJyArIG9wdGlvbnMuZm9udFNpemUgKyAnXCI+JyArIG9wdGlvbnMuaW5wdXRzLmxhYmVsW2pdICsgJzwvdGV4dD4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN2XzEgPSBvcHRpb25zLmhlaWdodCAvIHNpemVbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBzaXplLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2ZyArPSAnPGNpcmNsZSBjeD1cIicgKyAoc2ggLyAyICsgaSAqIHNoKSArICdcIiBjeT1cIicgKyAoc3YgLyAyICsgaiAqIHN2KSArICdcIiByPVwiJyArIG9wdGlvbnMucmFkaXVzICsgJ1wiIHN0cm9rZT1cImJsYWNrXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCInICsgb3B0aW9ucy5vdXRwdXRzLmNvbG9yICsgJ1wiIC8+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2ZyArPSAnPGxpbmUgeDE9XCInICsgKHNoIC8gMiArIGkgKiBzaCArIG9wdGlvbnMucmFkaXVzKSArICdcIiB5MT1cIicgKyAoc3YgLyAyICsgaiAqIHN2KSArICdcIiB4Mj1cIicgKyAoc2ggLyAyICsgaSAqIHNoICsgc2ggLyA0KSArICdcIiB5Mj1cIicgKyAoc3YgLyAyICsgaiAqIHN2KSArICdcIiBzdHlsZT1cInN0cm9rZTonICsgb3B0aW9ucy5saW5lLmNvbG9yICsgJztzdHJva2Utd2lkdGg6JyArIG9wdGlvbnMubGluZS53aWR0aCArICdcIiAvPic7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdmcgKz0gJzxjaXJjbGUgY3g9XCInICsgKHNoIC8gMiArIGkgKiBzaCkgKyAnXCIgY3k9XCInICsgKHN2IC8gMiArIGogKiBzdikgKyAnXCIgcj1cIicgKyBvcHRpb25zLnJhZGl1cyArICdcIiBzdHJva2U9XCJibGFja1wiIHN0cm9rZS13aWR0aD1cIjFcIiBmaWxsPVwiJyArIG9wdGlvbnMuaGlkZGVuLmNvbG9yICsgJ1wiIC8+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemVbaSAtIDFdOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2ZyArPSAnPGxpbmUgeDE9XCInICsgKHNoIC8gMiArIChpIC0gMSkgKiBzaCArIG9wdGlvbnMucmFkaXVzKSArICdcIiB5MT1cIicgKyAoc3ZfMSAvIDIgKyBrICogc3ZfMSkgKyAnXCIgeDI9XCInICsgKHNoIC8gMiArIGkgKiBzaCAtIG9wdGlvbnMucmFkaXVzKSArICdcIiB5Mj1cIicgKyAoc3YgLyAyICsgaiAqIHN2KSArICdcIiBzdHlsZT1cInN0cm9rZTonICsgb3B0aW9ucy5saW5lLmNvbG9yICsgJztzdHJva2Utd2lkdGg6JyArIG9wdGlvbnMubGluZS53aWR0aCArICdcIiAvPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN2ZyArPSAnPC9zdmc+JztcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tc3ZnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gemVyb3M7XG5mdW5jdGlvbiB6ZXJvcyhzaXplKSB7XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emVyb3MuanMubWFwIiwidmFyIENyb3NzVmFsaWRhdGUgPSByZXF1aXJlKCcuL2Rpc3QvY3Jvc3MtdmFsaWRhdGUnKS5kZWZhdWx0O1xudmFyIGxpa2VseSA9IHJlcXVpcmUoJy4vZGlzdC9saWtlbHknKS5kZWZhdWx0O1xudmFyIGxvb2t1cCA9IHJlcXVpcmUoJy4vZGlzdC9sb29rdXAnKS5kZWZhdWx0O1xudmFyIE5ldXJhbE5ldHdvcmsgPSByZXF1aXJlKCcuL2Rpc3QvbmV1cmFsLW5ldHdvcmsnKS5kZWZhdWx0O1xudmFyIE5ldXJhbE5ldHdvcmtHUFUgPSByZXF1aXJlKCcuL2Rpc3QvbmV1cmFsLW5ldHdvcmstZ3B1JykuZGVmYXVsdDtcbnZhciBUcmFpblN0cmVhbSA9IHJlcXVpcmUoJy4vZGlzdC90cmFpbi1zdHJlYW0nKS5kZWZhdWx0O1xudmFyIFJOTlRpbWVTdGVwID0gcmVxdWlyZSgnLi9kaXN0L3JlY3VycmVudC9ybm4tdGltZS1zdGVwJykuZGVmYXVsdDtcbnZhciBMU1RNVGltZVN0ZXAgPSByZXF1aXJlKCcuL2Rpc3QvcmVjdXJyZW50L2xzdG0tdGltZS1zdGVwJykuZGVmYXVsdDtcbnZhciBHUlVUaW1lU3RlcCA9IHJlcXVpcmUoJy4vZGlzdC9yZWN1cnJlbnQvZ3J1LXRpbWUtc3RlcCcpLmRlZmF1bHQ7XG52YXIgUk5OID0gcmVxdWlyZSgnLi9kaXN0L3JlY3VycmVudC9ybm4nKS5kZWZhdWx0O1xudmFyIExTVE0gPSByZXF1aXJlKCcuL2Rpc3QvcmVjdXJyZW50L2xzdG0nKS5kZWZhdWx0O1xudmFyIEdSVSA9IHJlcXVpcmUoJy4vZGlzdC9yZWN1cnJlbnQvZ3J1JykuZGVmYXVsdDtcbnZhciB1dGlsaXRpZXMgPSB7XG4gIG1heDogcmVxdWlyZSgnLi9kaXN0L3V0aWxpdGllcy9tYXgnKS5kZWZhdWx0LFxuICBtc2U6IHJlcXVpcmUoJy4vZGlzdC91dGlsaXRpZXMvbXNlJykuZGVmYXVsdCxcbiAgb25lczogcmVxdWlyZSgnLi9kaXN0L3V0aWxpdGllcy9vbmVzJykuZGVmYXVsdCxcbiAgcmFuZG9tOiByZXF1aXJlKCcuL2Rpc3QvdXRpbGl0aWVzL3JhbmRvbScpLmRlZmF1bHQsXG4gIHJhbmRvbVdlaWdodDogcmVxdWlyZSgnLi9kaXN0L3V0aWxpdGllcy9yYW5kb20td2VpZ2h0JykuZGVmYXVsdCxcbiAgcmFuZG9zOiByZXF1aXJlKCcuL2Rpc3QvdXRpbGl0aWVzL3JhbmRvcycpLmRlZmF1bHQsXG4gIHJhbmdlOiByZXF1aXJlKCcuL2Rpc3QvdXRpbGl0aWVzL3JhbmdlJykuZGVmYXVsdCxcbiAgdG9BcnJheTogcmVxdWlyZSgnLi9kaXN0L3V0aWxpdGllcy90by1hcnJheScpLmRlZmF1bHQsXG4gIERhdGFGb3JtYXR0ZXI6IHJlcXVpcmUoJy4vZGlzdC91dGlsaXRpZXMvZGF0YS1mb3JtYXR0ZXInKS5kZWZhdWx0LFxuICB6ZXJvczogcmVxdWlyZSgnLi9kaXN0L3V0aWxpdGllcy96ZXJvcycpLmRlZmF1bHQsXG4gIHRvU1ZHOiByZXF1aXJlKCcuL2Rpc3QvdXRpbGl0aWVzL3RvLXN2ZycpLmRlZmF1bHRcbn07XG5cbnZhciBicmFpbiA9IHtcbiAgQ3Jvc3NWYWxpZGF0ZTogQ3Jvc3NWYWxpZGF0ZSxcbiAgbGlrZWx5OiBsaWtlbHksXG4gIGxvb2t1cDogbG9va3VwLFxuICBOZXVyYWxOZXR3b3JrOiBOZXVyYWxOZXR3b3JrLFxuICBOZXVyYWxOZXR3b3JrR1BVOiBOZXVyYWxOZXR3b3JrR1BVLFxuICBUcmFpblN0cmVhbTogVHJhaW5TdHJlYW0sXG4gIHJlY3VycmVudDoge1xuICAgIFJOTlRpbWVTdGVwOiBSTk5UaW1lU3RlcCxcbiAgICBMU1RNVGltZVN0ZXA6IExTVE1UaW1lU3RlcCxcbiAgICBHUlVUaW1lU3RlcDogR1JVVGltZVN0ZXAsXG4gICAgUk5OOiBSTk4sXG4gICAgTFNUTTogTFNUTSxcbiAgICBHUlU6IEdSVSxcbiAgfSxcbiAgdXRpbGl0aWVzOiB1dGlsaXRpZXNcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuYnJhaW4gPSBicmFpbjtcbn1cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgc2VsZi5icmFpbiA9IGJyYWluO1xufVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnJhaW47XG59XG4iLCIoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzO1xuICAgIHZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cdHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXHR2YXIgaW50ZXJ2YWxQYXJzZXIgPSAvKFswLTlcXC5dKykobXN8c3xtfGgpPy87XG5cdHZhciByb290ID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuXHQvLyBMaWwgYml0IG9mIHVzZWZ1bCBwb2x5ZmlsbC4uLlxuXHRpZiAodHlwZW9mKEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cykgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0RnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzID0gZnVuY3Rpb24ocGFyZW50KSB7XG5cdFx0XHR0aGlzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG5cdFx0fTtcblx0fVxuXG5cdGlmICh0eXBlb2YoQXJyYXkucHJvdG90eXBlLnJlbW92ZU9uZSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0QXJyYXkucHJvdG90eXBlLnJlbW92ZU9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHdoYXQsIGEgPSBhcmd1bWVudHMsIEwgPSBhLmxlbmd0aCwgYXg7XG5cdFx0XHR3aGlsZSAoTCAmJiB0aGlzLmxlbmd0aCkge1xuXHRcdFx0XHR3aGF0ID0gYVstLUxdO1xuXHRcdFx0XHR3aGlsZSAoKGF4ID0gdGhpcy5pbmRleE9mKHdoYXQpKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zcGxpY2UoYXgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdyZWF0ZXN0Q29tbW9uRmFjdG9yKGludGVydmFscykge1xuXHRcdHZhciBzdW1PZk1vZHVsaSA9IDE7XG5cdFx0dmFyIGludGVydmFsID0gXy5taW4oaW50ZXJ2YWxzKTtcblx0XHR3aGlsZSAoc3VtT2ZNb2R1bGkgIT09IDApIHtcblx0XHRcdHN1bU9mTW9kdWxpID0gXy5yZWR1Y2UoaW50ZXJ2YWxzLCBmdW5jdGlvbihtZW1vLCBpKXsgcmV0dXJuIG1lbW8gKyAoaSAlIGludGVydmFsKTsgfSwgMCk7XG5cdFx0XHRpZiAoc3VtT2ZNb2R1bGkgIT09IDApIHtcblx0XHRcdFx0aW50ZXJ2YWwgLT0gMTA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbnRlcnZhbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlRXZlbnQoZSkge1xuXHRcdHZhciBpbnRlcnZhbEdyb3VwcyA9IGludGVydmFsUGFyc2VyLmV4ZWMoZSk7XG5cdFx0aWYgKCFpbnRlcnZhbEdyb3Vwcykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJIGRvblxcJ3QgdW5kZXJzdGFuZCB0aGF0IHBhcnRpY3VsYXIgaW50ZXJ2YWwnKTtcblx0XHR9XG5cdFx0dmFyIGludGVydmFsQW1vdW50ID0gK2ludGVydmFsR3JvdXBzWzFdO1xuXHRcdHZhciBpbnRlcnZhbFR5cGUgPSBpbnRlcnZhbEdyb3Vwc1syXSB8fCAnbXMnO1xuXHRcdGlmIChpbnRlcnZhbFR5cGUgPT09ICdzJykge1xuXHRcdFx0aW50ZXJ2YWxBbW91bnQgPSBpbnRlcnZhbEFtb3VudCAqIDEwMDA7XG5cdFx0fSBlbHNlIGlmIChpbnRlcnZhbFR5cGUgPT09ICdtJykge1xuXHRcdFx0aW50ZXJ2YWxBbW91bnQgPSBpbnRlcnZhbEFtb3VudCAqIDEwMDAgKiA2MDtcblx0XHR9IGVsc2UgaWYgKGludGVydmFsVHlwZSA9PT0gJ2gnKSB7XG5cdFx0XHRpbnRlcnZhbEFtb3VudCA9IGludGVydmFsQW1vdW50ICogMTAwMCAqIDYwICogNjA7XG5cdFx0fSBlbHNlIGlmICghIWludGVydmFsVHlwZSAmJiBpbnRlcnZhbFR5cGUgIT09ICdtcycpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IHNwZWNpZnkgaW50ZXJ2YWxzIG9mIG1zLCBzLCBtLCBvciBoJyk7XG5cdFx0fVxuXHRcdGlmIChpbnRlcnZhbEFtb3VudCA8IDEwIHx8IGludGVydmFsQW1vdW50ICUgMTAgIT09IDApIHtcblx0XHRcdC8vIFdlIG9ubHkgZGVhbCBpbiAxMCdzIG9mIG1pbGxpc2Vjb25kcyBmb3Igc2ltcGxpY2l0eVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuIG9ubHkgc3BlY2lmeSAxMHMgb2YgbWlsbGlzZWNvbmRzLCB0cnVzdCBtZSBvbiB0aGlzIG9uZScpO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0YW1vdW50OmludGVydmFsQW1vdW50LFxuXHRcdFx0dHlwZTppbnRlcnZhbFR5cGVcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gRXZlbnRlZExvb3AoKSB7XG5cdFx0dGhpcy5pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaW50ZXJ2YWxMZW5ndGggPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pbnRlcnZhbHNUb0VtaXQgPSB7fTtcblx0XHR0aGlzLmN1cnJlbnRUaWNrID0gMTtcblx0XHR0aGlzLm1heFRpY2tzID0gMDtcblx0XHR0aGlzLmxpc3RlbmluZ0ZvckZvY3VzID0gZmFsc2U7XG5cblx0XHQvLyBQcml2YXRlIG1ldGhvZFxuXHRcdHZhciBkZXRlcm1pbmVJbnRlcnZhbExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwb3RlbnRpYWxJbnRlcnZhbExlbmd0aCA9IGdyZWF0ZXN0Q29tbW9uRmFjdG9yKF8ua2V5cyh0aGlzLmludGVydmFsc1RvRW1pdCkpO1xuXHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHRoaXMuaW50ZXJ2YWxMZW5ndGgpIHtcblx0XHRcdFx0aWYgKHBvdGVudGlhbEludGVydmFsTGVuZ3RoICE9PSB0aGlzLmludGVydmFsTGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gTG9va3MgbGlrZSB3ZSBuZWVkIGEgbmV3IGludGVydmFsXG5cdFx0XHRcdFx0dGhpcy5pbnRlcnZhbExlbmd0aCA9IHBvdGVudGlhbEludGVydmFsTGVuZ3RoO1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmludGVydmFsTGVuZ3RoID0gcG90ZW50aWFsSW50ZXJ2YWxMZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWF4VGlja3MgPSBfLm1heChfLm1hcChfLmtleXModGhpcy5pbnRlcnZhbHNUb0VtaXQpLCBmdW5jdGlvbihhKSB7IHJldHVybiArYTsgfSkpIC8gdGhpcy5pbnRlcnZhbExlbmd0aDtcblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH0uYmluZCh0aGlzKTtcblxuXHRcdHRoaXMub24oJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlID09PSAncmVtb3ZlTGlzdGVuZXInIHx8IGUgPT09ICduZXdMaXN0ZW5lcicpIHJldHVybjsgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aGF0IG9uZVxuXHRcdFx0dmFyIGludGVydmFsSW5mbyA9IHBhcnNlRXZlbnQoZSk7XG5cdFx0XHR2YXIgaW50ZXJ2YWxBbW91bnQgPSBpbnRlcnZhbEluZm8uYW1vdW50O1xuXG5cdFx0XHR0aGlzLmludGVydmFsc1RvRW1pdFsraW50ZXJ2YWxBbW91bnRdID0gXy51bmlvbih0aGlzLmludGVydmFsc1RvRW1pdFsraW50ZXJ2YWxBbW91bnRdIHx8IFtdLCBbZV0pO1xuXHRcdFx0XG5cdFx0XHRpZiAoZGV0ZXJtaW5lSW50ZXJ2YWxMZW5ndGgoKSAmJiB0aGlzLmlzU3RhcnRlZCgpKSB7XG5cdFx0XHRcdHRoaXMuc3RvcCgpLnN0YXJ0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLm9uKCdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQodGhpcywgZSkgPiAwKSByZXR1cm47XG5cdFx0XHR2YXIgaW50ZXJ2YWxJbmZvID0gcGFyc2VFdmVudChlKTtcblx0XHRcdHZhciBpbnRlcnZhbEFtb3VudCA9IGludGVydmFsSW5mby5hbW91bnQ7XG5cblx0XHRcdHZhciByZW1vdmVkRXZlbnQgPSB0aGlzLmludGVydmFsc1RvRW1pdFsraW50ZXJ2YWxBbW91bnRdLnJlbW92ZU9uZShlKTtcblx0XHRcdGlmICh0aGlzLmludGVydmFsc1RvRW1pdFsraW50ZXJ2YWxBbW91bnRdLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5pbnRlcnZhbHNUb0VtaXRbK2ludGVydmFsQW1vdW50XTtcblx0XHRcdH1cblx0XHRcdGNvbnNvbGUubG9nKCdEZXRlcm1pbmluZyBpbnRlcnZhbCBsZW5ndGggYWZ0ZXIgcmVtb3ZhbCBvZicsIHJlbW92ZWRFdmVudCk7XG5cdFx0XHRkZXRlcm1pbmVJbnRlcnZhbExlbmd0aCgpO1xuXG5cdFx0XHRpZiAoZGV0ZXJtaW5lSW50ZXJ2YWxMZW5ndGgoKSAmJiB0aGlzLmlzU3RhcnRlZCgpKSB7XG5cdFx0XHRcdHRoaXMuc3RvcCgpLnN0YXJ0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRFdmVudGVkTG9vcC5pbmhlcml0cyhFdmVudEVtaXR0ZXIpO1xuXG5cdC8vIFB1YmxpYyBtZXRob2RzXG5cdEV2ZW50ZWRMb29wLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLmN1cnJlbnRUaWNrICogdGhpcy5pbnRlcnZhbExlbmd0aDtcblx0XHRfLmVhY2godGhpcy5pbnRlcnZhbHNUb0VtaXQsIGZ1bmN0aW9uIChldmVudHMsIGtleSkge1xuXHRcdFx0aWYgKG1pbGxpc2Vjb25kcyAlIGtleSA9PT0gMCkge1xuXHRcdFx0XHRfLmVhY2goZXZlbnRzLCBmdW5jdGlvbihlKSB7IHRoaXMuZW1pdChlLCBlLCBrZXkpOyB9LmJpbmQodGhpcykpO1xuXHRcdFx0fVxuXHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5jdXJyZW50VGljayArPSAxO1xuXHRcdGlmICh0aGlzLmN1cnJlbnRUaWNrID4gdGhpcy5tYXhUaWNrcykge1xuXHRcdFx0dGhpcy5jdXJyZW50VGljayA9IDE7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEV2ZW50ZWRMb29wLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuaW50ZXJ2YWxMZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IGhhdmVuXFwndCBzcGVjaWZpZWQgYW55IGludGVydmFsIGNhbGxiYWNrcy4gVXNlIEV2ZW50ZWRMb29wLm9uKFxcJzUwMG1zXFwnLCBmdW5jdGlvbiAoKSB7IC4uLiB9KSB0byBkbyBzbywgYW5kIHRoZW4geW91IGNhbiBzdGFydCcpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5pbnRlcnZhbElkKSB7XG5cdFx0XHRyZXR1cm4gY29uc29sZS5sb2coJ05vIG5lZWQgdG8gc3RhcnQgdGhlIGxvb3AgYWdhaW4sIGl0XFwncyBhbHJlYWR5IHN0YXJ0ZWQuJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodGhpcy50aWNrLmJpbmQodGhpcyksIHRoaXMuaW50ZXJ2YWxMZW5ndGgpO1xuXG5cdFx0aWYgKHJvb3QgJiYgIXRoaXMubGlzdGVuaW5nRm9yRm9jdXMgJiYgcm9vdC5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRyb290LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRcdHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRcdHRoaXMubGlzdGVuaW5nRm9yRm9jdXMgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRFdmVudGVkTG9vcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG5cdFx0dGhpcy5pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdEV2ZW50ZWRMb29wLnByb3RvdHlwZS5pc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5pbnRlcnZhbElkO1xuXHR9O1xuXG5cdEV2ZW50ZWRMb29wLnByb3RvdHlwZS5ldmVyeSA9IEV2ZW50ZWRMb29wLnByb3RvdHlwZS5vbjtcblxuICAgIC8vIEV4cG9ydCB0aGUgRXZlbnRlZExvb3Agb2JqZWN0IGZvciAqKk5vZGUuanMqKiBvciBvdGhlclxuICAgIC8vIGNvbW1vbmpzIHN5c3RlbXMuIE90aGVyd2lzZSwgYWRkIGl0IGFzIGEgZ2xvYmFsIG9iamVjdCB0byB0aGUgcm9vdFxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBFdmVudGVkTG9vcDtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLkV2ZW50ZWRMb29wID0gRXZlbnRlZExvb3A7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cuRXZlbnRlZExvb3AgPSBFdmVudGVkTG9vcDtcbiAgICB9XG59KS5jYWxsKHRoaXMpOyIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuNi4wXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXG4gIHZhciBicmVha2VyID0ge307XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlRm9yRWFjaCAgICAgID0gQXJyYXlQcm90by5mb3JFYWNoLFxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZVJlZHVjZSAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlLFxuICAgIG5hdGl2ZVJlZHVjZVJpZ2h0ICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXG4gICAgbmF0aXZlRXZlcnkgICAgICAgID0gQXJyYXlQcm90by5ldmVyeSxcbiAgICBuYXRpdmVTb21lICAgICAgICAgPSBBcnJheVByb3RvLnNvbWUsXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZUxhc3RJbmRleE9mICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2YsXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZDtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXG4gIC8vIGZvciBDbG9zdXJlIENvbXBpbGVyIFwiYWR2YW5jZWRcIiBtb2RlLlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjYuMCc7XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmb3JFYWNoYCBpZiBhdmFpbGFibGUuXG4gIHZhciBlYWNoID0gXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYG1hcGAgaWYgYXZhaWxhYmxlLlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSB2YWx1ZTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZVJpZ2h0ICYmIG9iai5yZWR1Y2VSaWdodCA9PT0gbmF0aXZlUmVkdWNlUmlnaHQpIHtcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGluZGV4ID0ga2V5cyA/IGtleXNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtpbmRleF07XG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgbWVtbywgb2JqW2luZGV4XSwgaW5kZXgsIGxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghaW5pdGlhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmaWx0ZXJgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xuICAgIGlmIChuYXRpdmVGaWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSByZXR1cm4gb2JqLmZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICB9LCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBfLmlkZW50aXR5KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkpIHJldHVybiBicmVha2VyO1xuICAgIH0pO1xuICAgIHJldHVybiAhIXJlc3VsdDtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHNvbWVgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IF8uaWRlbnRpdHkpO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKG5hdGl2ZVNvbWUgJiYgb2JqLnNvbWUgPT09IG5hdGl2ZVNvbWUpIHJldHVybiBvYmouc29tZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChyZXN1bHQgfHwgKHJlc3VsdCA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcyhhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgLy8gQ2FuJ3Qgb3B0aW1pemUgYXJyYXlzIG9mIGludGVnZXJzIGxvbmdlciB0aGFuIDY1LDUzNSBlbGVtZW50cy5cbiAgLy8gU2VlIFtXZWJLaXQgQnVnIDgwNzk3XShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODA3OTcpXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkoTWF0aCwgb2JqKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xuICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYW4gYXJyYXksIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmFuZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzaHVmZmxlZCA9IFtdO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xuICAgICAgc2h1ZmZsZWRbaW5kZXggLSAxXSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmIChvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBsb29rdXAgaXRlcmF0b3JzLlxuICB2YXIgbG9va3VwSXRlcmF0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xuICAgIF8uaGFzKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldLnB1c2godmFsdWUpIDogcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbbWlkXSkgPCB2YWx1ZSA/IGxvdyA9IG1pZCArIDEgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgaWYgKG4gPCAwKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGhcbiAgLy8gYF8ubWFwYC5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIGFycmF5Lmxlbmd0aCAtICgobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKlxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAobiA9PSBudWxsKSB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIG91dHB1dCkge1xuICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XG4gICAgfVxuICAgIGVhY2goaW5wdXQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgICBzaGFsbG93ID8gcHVzaC5hcHBseShvdXRwdXQsIHZhbHVlKSA6IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFNwbGl0IGFuIGFycmF5IGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBlYWNoKGFycmF5LCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAocHJlZGljYXRlKGVsZW0pID8gcGFzcyA6IGZhaWwpLnB1c2goZWxlbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0b3I7XG4gICAgICBpdGVyYXRvciA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWwgPSBpdGVyYXRvciA/IF8ubWFwKGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkgOiBhcnJheTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZWFjaChpbml0aWFsLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcbiAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShfLmZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmV2ZXJ5KHJlc3QsIGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBfLmNvbnRhaW5zKG90aGVyLCBpdGVtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpOyB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBfLm1heChfLnBsdWNrKGFyZ3VtZW50cywgJ2xlbmd0aCcpLmNvbmNhdCgwKSk7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRzW2ldID0gXy5wbHVjayhhcmd1bWVudHMsICcnICsgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwbHkgdXMgd2l0aCBpbmRleE9mIChJJ20gbG9va2luZyBhdCB5b3UsICoqTVNJRSoqKSxcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXG4gIC8vIGl0ZW0gaW4gYW4gYXJyYXksIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBpbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gKGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XG4gICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xuICAgIGlmIChuYXRpdmVMYXN0SW5kZXhPZiAmJiBhcnJheS5sYXN0SW5kZXhPZiA9PT0gbmF0aXZlTGFzdEluZGV4T2YpIHtcbiAgICAgIHJldHVybiBoYXNJbmRleCA/IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0sIGZyb20pIDogYXJyYXkubGFzdEluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIHZhciBpID0gKGhhc0luZGV4ID8gZnJvbSA6IGFycmF5Lmxlbmd0aCk7XG4gICAgd2hpbGUgKGktLSkgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IGFyZ3VtZW50c1syXSB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlKGlkeCA8IGxlbmd0aCkge1xuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XG4gICAgICBzdGFydCArPSBzdGVwO1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldXNhYmxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBwcm90b3R5cGUgc2V0dGluZy5cbiAgdmFyIGN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICB2YXIgYXJncyA9IGJvdW5kQXJncy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT09IF8pIGFyZ3NbaV0gPSBhcmd1bWVudHNbcG9zaXRpb24rK107XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW8gPSB7fTtcbiAgICBoYXNoZXIgfHwgKGhhc2hlciA9IF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfLmhhcyhtZW1vLCBrZXkpID8gbWVtb1trZXldIDogKG1lbW9ba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciByYW4gPSBmYWxzZSwgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgIHJhbiA9IHRydWU7XG4gICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmdW5jcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGZvciAodmFyIGkgPSBmdW5jcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSBjb3B5W2tleV0gPSBvYmpba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoQXJyYXlQcm90bywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSkgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBlYWNoKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcbiAgICAgICAgLy8gb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiBhICE9ICthID8gYiAhPSArYiA6IChhID09IDAgPyAxIC8gYSA9PSAxIC8gYiA6IGEgPT0gK2IpO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09ICtiO1xuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PSBiLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgICAgIGEubXVsdGlsaW5lID09IGIubXVsdGlsaW5lICYmXG4gICAgICAgICAgICAgICBhLmlnbm9yZUNhc2UgPT0gYi5pZ25vcmVDYXNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT0gYjtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgKGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcbiAgICB2YXIgc2l6ZSA9IDAsIHJlc3VsdCA9IHRydWU7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChfLmhhcyhhLCBrZXkpKSB7XG4gICAgICAgICAgLy8gQ291bnQgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXIuXG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAgICAgaWYgKF8uaGFzKGIsIGtleSkgJiYgIShzaXplLS0pKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSAhc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLlxuICBpZiAodHlwZW9mICgvLi8pICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRvcnMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqID09PSBhdHRycykgcmV0dXJuIHRydWU7IC8vYXZvaWQgY29tcGFyaW5nIGFuIG9iamVjdCB0byBpdHNlbGYuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlbnRpdHlNYXAgPSB7XG4gICAgZXNjYXBlOiB7XG4gICAgICAnJic6ICcmYW1wOycsXG4gICAgICAnPCc6ICcmbHQ7JyxcbiAgICAgICc+JzogJyZndDsnLFxuICAgICAgJ1wiJzogJyZxdW90OycsXG4gICAgICBcIidcIjogJyYjeDI3OydcbiAgICB9XG4gIH07XG4gIGVudGl0eU1hcC51bmVzY2FwZSA9IF8uaW52ZXJ0KGVudGl0eU1hcC5lc2NhcGUpO1xuXG4gIC8vIFJlZ2V4ZXMgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzIGxpc3RlZCBpbW1lZGlhdGVseSBhYm92ZS5cbiAgdmFyIGVudGl0eVJlZ2V4ZXMgPSB7XG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxuICAgIHVuZXNjYXBlOiBuZXcgUmVnRXhwKCcoJyArIF8ua2V5cyhlbnRpdHlNYXAudW5lc2NhcGUpLmpvaW4oJ3wnKSArICcpJywgJ2cnKVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgXy5lYWNoKFsnZXNjYXBlJywgJ3VuZXNjYXBlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gKCcnICsgc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSwgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdCc6ICAgICAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdHxcXHUyMDI4fFxcdTIwMjkvZztcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcmVuZGVyO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAgIC5yZXBsYWNlKGVzY2FwZXIsIGZ1bmN0aW9uKG1hdGNoKSB7IHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTsgfSk7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH1cbiAgICAgIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyBcInJldHVybiBfX3A7XFxuXCI7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChkYXRhKSByZXR1cm4gcmVuZGVyKGRhdGEsIF8pO1xuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonKSArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8ob2JqKS5jaGFpbigpO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PSAnc2hpZnQnIHx8IG5hbWUgPT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICBfLmV4dGVuZChfLnByb3RvdHlwZSwge1xuXG4gICAgLy8gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICAgIGNoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGdW5jdGlvbkJ1aWxkZXJCYXNlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlci1iYXNlJyk7XG52YXIgQ1BVRnVuY3Rpb25Ob2RlID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1ub2RlJyk7XG5cbi8qKlxuICogQGNsYXNzIENQVUZ1bmN0aW9uQnVpbGRlclxuICpcbiAqIEBleHRlbmRzIEZ1bmN0aW9uQnVpbGRlckJhc2VcbiAqXG4gKiBAZGVzYyBCdWlsZHMgZnVuY3Rpb25zIHRvIGV4ZWN1dGUgb24gQ1BVIGZyb20gSmF2YVNjcmlwdCBmdW5jdGlvbiBTdHJpbmdzXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfRnVuY3Rpb25CdWlsZGVyQmFzZSkge1xuICBfaW5oZXJpdHMoQ1BVRnVuY3Rpb25CdWlsZGVyLCBfRnVuY3Rpb25CdWlsZGVyQmFzZSk7XG5cbiAgZnVuY3Rpb24gQ1BVRnVuY3Rpb25CdWlsZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDUFVGdW5jdGlvbkJ1aWxkZXIpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENQVUZ1bmN0aW9uQnVpbGRlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENQVUZ1bmN0aW9uQnVpbGRlcikpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMuTm9kZSA9IENQVUZ1bmN0aW9uTm9kZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gQ1BVRnVuY3Rpb25CdWlsZGVyO1xufShGdW5jdGlvbkJ1aWxkZXJCYXNlKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJhc2VGdW5jdGlvbk5vZGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1ub2RlLWJhc2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbHMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQ1BVRnVuY3Rpb25Ob2RlXG4gKlxuICogQGV4dGVuZHMgQmFzZUZ1bmN0aW9uTm9kZSNcbiAqXG4gKiBAZGVzYyBbSU5URVJOQUxdIFJlcHJlc2VudHMgYSBzaW5nbGUgZnVuY3Rpb24sIGluc2lkZSBKU1xuICpcbiAqIDxwPlRoaXMgaGFuZGxlcyBhbGwgdGhlIHJhdyBzdGF0ZSwgY29udmVydGVkIHN0YXRlLCBldGMuIE9mIGEgc2luZ2xlIGZ1bmN0aW9uLjwvcD5cbiAqXG4gKiBAcHJvcCBmdW5jdGlvbk5hbWUgICAgICAgICAtIHtTdHJpbmd9ICAgICAgICBOYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHByb3AganNGdW5jdGlvbiAgICAgICAgICAgLSB7RnVuY3Rpb259ICAgVGhlIEpTIEZ1bmN0aW9uIHRoZSBub2RlIHJlcHJlc2VudHNcbiAqIEBwcm9wIGpzRnVuY3Rpb25TdHJpbmcgICAgIC0ge1N0cmluZ30gICAgICAgIGpzRnVuY3Rpb24udG9TdHJpbmcoKVxuICogQHByb3AgcGFyYW1OYW1lcyAgICAgICAgICAgLSB7U3RyaW5nW119ICBQYXJhbWV0ZXIgbmFtZXMgb2YgdGhlIGZ1bmN0aW9uXG4gKiBAcHJvcCBwYXJhbVR5cGVzICAgICAgICAgICAtIHtTdHJpbmdbXX0gIFNoYWRlciBsYW5kIHBhcmFtZXRlcnMgdHlwZSBhc3N1bXB0aW9uXG4gKiBAcHJvcCBpc1Jvb3RLZXJuZWwgICAgICAgICAtIHtCb29sZWFufSAgICAgICBTcGVjaWFsIGluZGljYXRvciwgZm9yIGtlcm5lbCBmdW5jdGlvblxuICogQHByb3Agd2ViZ2xGdW5jdGlvblN0cmluZyAgLSB7U3RyaW5nfSAgICAgICAgd2ViZ2wgY29udmVydGVkIGZ1bmN0aW9uIHN0cmluZ1xuICogQHByb3Agb3BlbmdsRnVuY3Rpb25TdHJpbmcgLSB7U3RyaW5nfSAgICAgICAgb3BlbmdsIGNvbnZlcnRlZCBmdW5jdGlvbiBzdHJpbmdcbiAqIEBwcm9wIGNhbGxlZEZ1bmN0aW9ucyAgICAgIC0ge1N0cmluZ1tdfSAgTGlzdCBvZiBhbGwgdGhlIGZ1bmN0aW9ucyBjYWxsZWRcbiAqIEBwcm9wIGluaXRWYXJpYWJsZXMgICAgICAgIC0ge1N0cmluZ1tdfSAgTGlzdCBvZiB2YXJpYWJsZXMgaW5pdGlhbGl6ZWQgaW4gdGhlIGZ1bmN0aW9uXG4gKiBAcHJvcCByZWFkVmFyaWFibGVzICAgICAgICAtIHtTdHJpbmdbXX0gIExpc3Qgb2YgdmFyaWFibGVzIHJlYWQgb3BlcmF0aW9ucyBvY2N1clxuICogQHByb3Agd3JpdGVWYXJpYWJsZXMgICAgICAgLSB7U3RyaW5nW119ICBMaXN0IG9mIHZhcmlhYmxlcyB3cml0ZSBvcGVyYXRpb25zIG9jY3VyXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfQmFzZUZ1bmN0aW9uTm9kZSkge1xuXHRfaW5oZXJpdHMoQ1BVRnVuY3Rpb25Ob2RlLCBfQmFzZUZ1bmN0aW9uTm9kZSk7XG5cblx0ZnVuY3Rpb24gQ1BVRnVuY3Rpb25Ob2RlKGZ1bmN0aW9uTmFtZSwganNGdW5jdGlvbiwgb3B0aW9ucykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDUFVGdW5jdGlvbk5vZGUpO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENQVUZ1bmN0aW9uTm9kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENQVUZ1bmN0aW9uTm9kZSkpLmNhbGwodGhpcywgZnVuY3Rpb25OYW1lLCBqc0Z1bmN0aW9uLCBvcHRpb25zKSk7XG5cblx0XHRfdGhpcy5wYXJhbVNpemVzID0gb3B0aW9ucyA/IG9wdGlvbnMucGFyYW1TaXplcyA6IFtdO1xuXHRcdF90aGlzLm1lbWJlclN0YXRlcyA9IFtdO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhDUFVGdW5jdGlvbk5vZGUsIFt7XG5cdFx0a2V5OiAncHVzaE1lbWJlclN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcHVzaE1lbWJlclN0YXRlKG5hbWUpIHtcblx0XHRcdHRoaXMubWVtYmVyU3RhdGVzLnB1c2gobmFtZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncG9wTWVtYmVyU3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwb3BNZW1iZXJTdGF0ZShuYW1lKSB7XG5cdFx0XHRpZiAodGhpcy5tZW1iZXJTdGF0ZSA9PT0gbmFtZSkge1xuXHRcdFx0XHR0aGlzLm1lbWJlclN0YXRlcy5wb3AoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBvcE1lbWJlclN0YXRlICcgKyBuYW1lICsgJyB3aGVuIGluICcgKyB0aGlzLm1lbWJlclN0YXRlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdnZW5lcmF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuXHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2codGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZ1bmN0aW9uU3RyaW5nQXJyYXkgPSB0aGlzLmFzdEdlbmVyaWModGhpcy5nZXRKc0FTVCgpLCBbXSk7XG5cdFx0XHR0aGlzLmZ1bmN0aW9uU3RyaW5nID0gdGhpcy5mdW5jdGlvblN0cmluZ0FycmF5LmpvaW4oJycpLnRyaW0oKTtcblx0XHRcdHJldHVybiB0aGlzLmZ1bmN0aW9uU3RyaW5nO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgZ2V0RnVuY3Rpb25Qcm90b3R5cGVTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgY29udmVydGVkIEpTIGZ1bmN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IGZ1bmN0aW9uIHN0cmluZywgcmVzdWx0IGlzIGNhY2hlZCB1bmRlciB0aGlzLmdldEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRGdW5jdGlvblByb3RvdHlwZVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nKCkge1xuXHRcdFx0aWYgKHRoaXMud2ViR2xGdW5jdGlvblByb3RvdHlwZVN0cmluZykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy53ZWJHbEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMud2ViR2xGdW5jdGlvblByb3RvdHlwZVN0cmluZyA9IHRoaXMuZ2VuZXJhdGUoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEZ1bmN0aW9uRGVjbGFyYXRpb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgdG8gaXRzICpuYW1lZCBmdW5jdGlvbiBkZWNsYXJhdGlvbipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RnVuY3Rpb25EZWNsYXJhdGlvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHRoaXMuYnVpbGRlci5hZGRGdW5jdGlvbihudWxsLCB1dGlscy5nZXRBc3RTdHJpbmcodGhpcy5qc0Z1bmN0aW9uU3RyaW5nLCBhc3QpKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RGdW5jdGlvblByb3RvdHlwZVxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciB0byBpdHMgKm5hbWVkIGZ1bmN0aW9uIHByb3RvdHlwZSpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RnVuY3Rpb25Qcm90b3R5cGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RGdW5jdGlvblByb3RvdHlwZShhc3QsIHJldEFycikge1xuXHRcdFx0Ly8gU2V0dXAgZnVuY3Rpb24gcmV0dXJuIHR5cGUgYW5kIG5hbWVcblx0XHRcdGlmICh0aGlzLmlzUm9vdEtlcm5lbCB8fCB0aGlzLmlzU3ViS2VybmVsKSB7XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHR9XG5cblx0XHRcdHJldEFyci5wdXNoKHRoaXMucmV0dXJuVHlwZSk7XG5cdFx0XHRyZXRBcnIucHVzaCgnICcpO1xuXHRcdFx0cmV0QXJyLnB1c2godGhpcy5mdW5jdGlvbk5hbWUpO1xuXHRcdFx0cmV0QXJyLnB1c2goJygnKTtcblxuXHRcdFx0Ly8gQXJndW1lbnRzIGhhbmRsaW5nXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFyYW1OYW1lcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnLCAnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXRBcnIucHVzaCgndXNlcl8nKTtcblx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5wYXJhbU5hbWVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0QXJyLnB1c2goJyk7XFxuJyk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RGdW5jdGlvbkV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgdG8gaXRzICpuYW1lZCBmdW5jdGlvbipcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RnVuY3Rpb25FeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0RnVuY3Rpb25FeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cblx0XHRcdC8vIFNldHVwIGZ1bmN0aW9uIHJldHVybiB0eXBlIGFuZCBuYW1lXG5cdFx0XHRpZiAoIXRoaXMuaXNSb290S2VybmVsKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdmdW5jdGlvbicpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnICcpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLmZ1bmN0aW9uTmFtZSk7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cblx0XHRcdFx0Ly8gQXJndW1lbnRzIGhhbmRsaW5nXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJhbU5hbWVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0dmFyIHBhcmFtTmFtZSA9IHRoaXMucGFyYW1OYW1lc1tpXTtcblxuXHRcdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCd1c2VyXycpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKHBhcmFtTmFtZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGdW5jdGlvbiBvcGVuaW5nXG5cdFx0XHRcdHJldEFyci5wdXNoKCcpIHtcXG4nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQm9keSBzdGF0ZW1lbnQgaXRlcmF0aW9uXG5cdFx0XHRmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXN0LmJvZHkuYm9keS5sZW5ndGg7ICsrX2kpIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5ib2R5LmJvZHlbX2ldLCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnXFxuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5pc1Jvb3RLZXJuZWwpIHtcblx0XHRcdFx0Ly8gRnVuY3Rpb24gY2xvc2luZ1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdFJldHVyblN0YXRlbWVudFxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciB0byAqcmV0dXJuKiBzdGF0ZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0UmV0dXJuU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0UmV0dXJuU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRpZiAodGhpcy5pc1Jvb3RLZXJuZWwpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ2tlcm5lbFJlc3VsdCA9ICcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzU3ViS2VybmVsKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKHRoaXMuZnVuY3Rpb25OYW1lICsgJ1Jlc3VsdCA9ICcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgncmV0dXJuICcgKyB0aGlzLmZ1bmN0aW9uTmFtZSArICdSZXN1bHQ7Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgncmV0dXJuICcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3Rocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG5cdFx0XHQvL1x0J05vbiBtYWluIGZ1bmN0aW9uIHJldHVybiwgaXMgbm90IHN1cHBvcnRlZCA6ICcrdGhpcy5jdXJyZW50RnVuY3Rpb25OYW1lc3BhY2UsXG5cdFx0XHQvL1x0YXN0XG5cdFx0XHQvLyk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RMaXRlcmFsXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpsaXRlcmFsIHZhbHVlKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RMaXRlcmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuXG5cdFx0XHQvLyBSZWplY3Qgbm9uIG51bWVyaWMgbGl0ZXJhbHNcblx0XHRcdGlmIChpc05hTihhc3QudmFsdWUpKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05vbi1udW1lcmljIGxpdGVyYWwgbm90IHN1cHBvcnRlZCA6ICcgKyBhc3QudmFsdWUsIGFzdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldEFyci5wdXNoKGFzdC52YWx1ZSk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RCaW5hcnlFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpiaW5hcnkqIGV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0QmluYXJ5RXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaChhc3Qub3BlcmF0b3IpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcblx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0SWRlbnRpZmllckV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKmlkZW50aWZpZXIqIGV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGlkdE5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdElkZW50aWZpZXJFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0SWRlbnRpZmllckV4cHJlc3Npb24oaWR0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSWRlbnRpZmllckV4cHJlc3Npb24gLSBub3QgYW4gSWRlbnRpZmllcicsIGlkdE5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSAnaW5wdXQtaW5kZXgteSc6XG5cdFx0XHRcdGNhc2UgJ2lucHV0LWluZGV4LXonOlxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoaWR0Tm9kZS5uYW1lKSB7XG5cdFx0XHRcdGNhc2UgJ2dwdV90aHJlYWRYJzpcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWSc6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3RocmVhZElkLnknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZ3B1X3RocmVhZFonOlxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCd0aHJlYWRJZC56Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2dwdV9vdXRwdXRYJzpcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndU91dHB1dERpbS54Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2dwdV9vdXRwdXRZJzpcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndU91dHB1dERpbS55Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2dwdV9vdXRwdXRaJzpcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndU91dHB1dERpbS56Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ0luZmluaXR5Jzpcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnSW5maW5pdHknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRpZiAodGhpcy5jb25zdGFudHMgJiYgdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWR0Tm9kZS5uYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2NvbnN0YW50c18nICsgaWR0Tm9kZS5uYW1lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHVzZXJQYXJhbU5hbWUgPSB0aGlzLmdldFVzZXJQYXJhbU5hbWUoaWR0Tm9kZS5uYW1lKTtcblx0XHRcdFx0XHRcdGlmICh1c2VyUGFyYW1OYW1lICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd1c2VyXycgKyB1c2VyUGFyYW1OYW1lKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd1c2VyXycgKyBpZHROb2RlLm5hbWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICh0aGlzLnN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgJ2lucHV0LWluZGV4LXknOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBzaXplID0gdGhpcy5wYXJhbVNpemVzW3RoaXMucGFyYW1OYW1lcy5pbmRleE9mKHRoaXMubWVtYmVyU3RhdGUpXTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcgKiAnICsgc2l6ZVswXSArICcpJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ2lucHV0LWluZGV4LXonOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBfc2l6ZSA9IHRoaXMucGFyYW1TaXplc1t0aGlzLnBhcmFtTmFtZXMuaW5kZXhPZih0aGlzLm1lbWJlclN0YXRlKV07XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnICogJyArIF9zaXplWzBdICogX3NpemVbMV0gKyAnKScpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0Rm9yU3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yZm9yICpmb3ItbG9vcCogZXhwcmVzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZm9yTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgcGFyc2VkIGNwdSBzdHJpbmdcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEZvclN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcblx0XHRcdGlmIChmb3JOb2RlLnR5cGUgIT09ICdGb3JTdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgZm9yIHN0YXRlbWVudCcsIGZvck5vZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZm9yTm9kZS50ZXN0ICYmIGZvck5vZGUudGVzdC50eXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbicpIHtcblx0XHRcdFx0aWYgKChmb3JOb2RlLnRlc3QucmlnaHQudHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8IGZvck5vZGUudGVzdC5yaWdodC50eXBlID09PSAnTGl0ZXJhbCcpICYmIGZvck5vZGUudGVzdC5vcGVyYXRvciA9PT0gJzwnICYmIHRoaXMuaXNJZGVudGlmaWVyQ29uc3RhbnQoZm9yTm9kZS50ZXN0LnJpZ2h0Lm5hbWUpID09PSBmYWxzZSkge1xuXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmxvb3BNYXhJdGVyYXRpb25zKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1dhcm5pbmc6IGxvb3BNYXhJdGVyYXRpb25zIGlzIG5vdCBzZXQhIFVzaW5nIGRlZmF1bHQgb2YgMTAwMCB3aGljaCBtYXkgcmVzdWx0IGluIHVuaW50ZW5kZWQgYmVoYXZpb3IuJyk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1NldCBsb29wTWF4SXRlcmF0aW9ucyBvciB1c2UgYSBmb3IgbG9vcCBvZiBmaXhlZCBsZW5ndGggdG8gc2lsZW5jZSB0aGlzIG1lc3NhZ2UuJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2ZvciAoJyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRpZiAocmV0QXJyW3JldEFyci5sZW5ndGggLSAxXSAhPT0gJzsnKSB7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goZm9yTm9kZS50ZXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnTE9PUF9NQVgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnVwZGF0ZSwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3tcXG4nKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnaWYgKCcpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnRlc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaChmb3JOb2RlLnRlc3Qub3BlcmF0b3IpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnRlc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJykge1xcbicpO1xuXHRcdFx0XHRcdGlmIChmb3JOb2RlLmJvZHkudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmb3JOb2RlLmJvZHkuYm9keS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LmJvZHlbaV0sIHJldEFycik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmJvZHksIHJldEFycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCd9IGVsc2Uge1xcbicpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGZvck5vZGUuaW5pdC5kZWNsYXJhdGlvbnMpIHtcblx0XHRcdFx0XHR2YXIgZGVjbGFyYXRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmb3JOb2RlLmluaXQuZGVjbGFyYXRpb25zKSk7XG5cdFx0XHRcdFx0dmFyIHVwZGF0ZUFyZ3VtZW50ID0gZm9yTm9kZS51cGRhdGUuYXJndW1lbnQ7XG5cdFx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGRlY2xhcmF0aW9ucykgfHwgZGVjbGFyYXRpb25zLmxlbmd0aCA8IDEpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHRoaXMuanNGdW5jdGlvblN0cmluZyk7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBJbmNvbXBhdGlibGUgZm9yIGxvb3AgZGVjbGFyYXRpb24nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBpbml0QXJndW1lbnQgPSBudWxsO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgX2kyKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW19pMl07XG5cdFx0XHRcdFx0XHRcdGlmIChkZWNsYXJhdGlvbi5pZC5uYW1lID09PSB1cGRhdGVBcmd1bWVudC5uYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5pdEFyZ3VtZW50ID0gZGVjbGFyYXRpb247XG5cdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb25zLnNwbGljZShfaTIsIDEpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd2YXIgJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGRlY2xhcmF0aW9uLCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2ZvciAobGV0ICcpO1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGluaXRBcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdmb3IgKCcpO1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUuaW5pdCwgcmV0QXJyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudXBkYXRlLCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUuYm9keSwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgZm9yIHN0YXRlbWVudCcsIGZvck5vZGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0V2hpbGVTdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKndoaWxlKiBsb29wXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3aGlsZU5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCBvcGVuY2xnbCBzdHJpbmdcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdFdoaWxlU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0V2hpbGVTdGF0ZW1lbnQod2hpbGVOb2RlLCByZXRBcnIpIHtcblx0XHRcdGlmICh3aGlsZU5vZGUudHlwZSAhPT0gJ1doaWxlU3RhdGVtZW50Jykge1xuXHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsIHdoaWxlTm9kZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldEFyci5wdXNoKCdmb3IgKGxldCBpID0gMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcblx0XHRcdHJldEFyci5wdXNoKCdpZiAoJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLmJvZHksIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnfSBlbHNlIHtcXG4nKTtcblx0XHRcdHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcblx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0V2hpbGVTdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKmRvIHdoaWxlKiBsb29wXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkb1doaWxlTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgcGFyc2VkIHdlYmdsIHN0cmluZ1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RG9XaGlsZVN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdERvV2hpbGVTdGF0ZW1lbnQoZG9XaGlsZU5vZGUsIHJldEFycikge1xuXHRcdFx0aWYgKGRvV2hpbGVOb2RlLnR5cGUgIT09ICdEb1doaWxlU3RhdGVtZW50Jykge1xuXHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRlbWVudCcsIGRvV2hpbGVOb2RlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0QXJyLnB1c2goJ2ZvciAobGV0IGkgPSAwOyBpIDwgTE9PUF9NQVg7IGkrKykgeycpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLmJvZHksIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnaWYgKCEnKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhkb1doaWxlTm9kZS50ZXN0LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJykge1xcbicpO1xuXHRcdFx0cmV0QXJyLnB1c2goJ2JyZWFrO1xcbicpO1xuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqQXNzaWdubWVudCogRXhwcmVzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXNzTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0QXNzaWdubWVudEV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3NOb2RlLCByZXRBcnIpIHtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaChhc3NOb2RlLm9wZXJhdG9yKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEVtcHR5U3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yIGFuICpFbXB0eSogU3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RW1wdHlTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RFbXB0eVN0YXRlbWVudChlTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHQvL3JldEFyci5wdXNoKCc7XFxuJyk7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0QmxvY2tTdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkJsb2NrKiBzdGF0ZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGJOb2RlIC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RCbG9ja1N0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEJsb2NrU3RhdGVtZW50KGJOb2RlLCByZXRBcnIpIHtcblx0XHRcdHJldEFyci5wdXNoKCd7XFxuJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJOb2RlLmJvZHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGJOb2RlLmJvZHlbaV0sIHJldEFycik7XG5cdFx0XHR9XG5cdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEV4cHJlc3Npb25TdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKmdlbmVyaWMgZXhwcmVzc2lvbiogc3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlc05vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEV4cHJlc3Npb25TdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RFeHByZXNzaW9uU3RhdGVtZW50KGVzTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZXNOb2RlLmV4cHJlc3Npb24sIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdFZhcmlhYmxlRGVjbGFyYXRpb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlZhcmlhYmxlIERlY2xhcmF0aW9uKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFyZGVjTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0VmFyaWFibGVEZWNsYXJhdGlvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFZhcmlhYmxlRGVjbGFyYXRpb24odmFyZGVjTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgndmFyICcpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YXJkZWNOb2RlLmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmRlY2xhcmF0aW9uc1t2YXJkZWNOb2RlLmRlY2xhcmF0aW9uc1tpXS5pZC5uYW1lXSA9ICd2YXInO1xuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnLCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh2YXJkZWNOb2RlLmRlY2xhcmF0aW9uc1tpXSwgcmV0QXJyKTtcblx0XHRcdH1cblx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0VmFyaWFibGVEZWNsYXJhdG9yXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpWYXJpYWJsZSBEZWNsYXJhdG9yKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXZhcmRlY05vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdFZhcmlhYmxlRGVjbGFyYXRvcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFZhcmlhYmxlRGVjbGFyYXRvcihpdmFyZGVjTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoaXZhcmRlY05vZGUuaWQsIHJldEFycik7XG5cdFx0XHRpZiAoaXZhcmRlY05vZGUuaW5pdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnPScpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoaXZhcmRlY05vZGUuaW5pdCwgcmV0QXJyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RJZlN0YXRlbWVudFxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqSWYqIFN0YXRlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gaWZOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RJZlN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdElmU3RhdGVtZW50KGlmTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnaWYgKCcpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS50ZXN0LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdGlmIChpZk5vZGUuY29uc2VxdWVudC50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuY29uc2VxdWVudCwgcmV0QXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcge1xcbicpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpZk5vZGUuYWx0ZXJuYXRlKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdlbHNlICcpO1xuXHRcdFx0XHRpZiAoaWZOb2RlLmFsdGVybmF0ZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJyB7XFxuJyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS5hbHRlcm5hdGUsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1xcbn1cXG4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEJyZWFrU3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpCcmVhayogU3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBick5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEJyZWFrU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0QnJlYWtTdGF0ZW1lbnQoYnJOb2RlLCByZXRBcnIpIHtcblx0XHRcdHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RDb250aW51ZVN0YXRlbWVudFxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqQ29udGludWUqIFN0YXRlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY3JOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RDb250aW51ZVN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdENvbnRpbnVlU3RhdGVtZW50KGNyTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnY29udGludWU7XFxuJyk7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0TG9naWNhbEV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkxvZ2ljYWwqIEV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGxvZ05vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdExvZ2ljYWxFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0TG9naWNhbEV4cHJlc3Npb24obG9nTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgnKCcpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGxvZ05vZGUubGVmdCwgcmV0QXJyKTtcblx0XHRcdHJldEFyci5wdXNoKGxvZ05vZGUub3BlcmF0b3IpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGxvZ05vZGUucmlnaHQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdFVwZGF0ZUV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlVwZGF0ZSogRXhwcmVzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdU5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdFVwZGF0ZUV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RVcGRhdGVFeHByZXNzaW9uKHVOb2RlLCByZXRBcnIpIHtcblx0XHRcdGlmICh1Tm9kZS5wcmVmaXgpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdFVuYXJ5RXhwcmVzc2lvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqVW5hcnkqIEV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHVOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RVbmFyeUV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RVbmFyeUV4cHJlc3Npb24odU5vZGUsIHJldEFycikge1xuXHRcdFx0aWYgKHVOb2RlLnByZWZpeCkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyh1Tm9kZS5hcmd1bWVudCwgcmV0QXJyKTtcblx0XHRcdFx0cmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0VGhpc0V4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlRoaXMqIGV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHROb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RUaGlzRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFRoaXNFeHByZXNzaW9uKHROb2RlLCByZXRBcnIpIHtcblx0XHRcdHJldEFyci5wdXNoKCdfdGhpcycpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdE1lbWJlckV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKk1lbWJlciogRXhwcmVzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbU5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdE1lbWJlckV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RNZW1iZXJFeHByZXNzaW9uKG1Ob2RlLCByZXRBcnIpIHtcblx0XHRcdGlmIChtTm9kZS5jb21wdXRlZCkge1xuXHRcdFx0XHRpZiAobU5vZGUub2JqZWN0LnR5cGUgPT09ICdJZGVudGlmaWVyJyB8fCBtTm9kZS5vYmplY3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIG1Ob2RlLm9iamVjdC5vYmplY3Qub2JqZWN0ICYmIG1Ob2RlLm9iamVjdC5vYmplY3Qub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicgJiYgbU5vZGUub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lID09PSAnY29uc3RhbnRzJykge1xuXHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdpZGVudGlmaWVyJyk7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdpZGVudGlmaWVyJyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdFx0XHRpZiAodGhpcy5pc0lucHV0KG1Ob2RlLm9iamVjdC5uYW1lKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLnByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCddJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKG1Ob2RlLm9iamVjdC5vYmplY3QpIHtcblx0XHRcdFx0XHRcdGlmIChtTm9kZS5vYmplY3Qub2JqZWN0Lm9iamVjdCAmJiB0aGlzLmlzSW5wdXQobU5vZGUub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wdXNoTWVtYmVyU3RhdGUobU5vZGUub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdpbnB1dC1pbmRleC16Jyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdHZhciBsYXN0ID0gcmV0QXJyLnBvcCgpO1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnICsgJyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ2lucHV0LWluZGV4LXonKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2lucHV0LWluZGV4Jyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5wcm9wZXJ0eSwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW5wdXQtaW5kZXgnKTtcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2gobGFzdCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucG9wTWVtYmVyU3RhdGUobU5vZGUub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXNJbnB1dChtTm9kZS5vYmplY3Qub2JqZWN0Lm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucHVzaE1lbWJlclN0YXRlKG1Ob2RlLm9iamVjdC5vYmplY3QubmFtZSk7XG5cdFx0XHRcdFx0XHRcdGlmICghdGhpcy5pc1N0YXRlKCdpbnB1dC1pbmRleC16JykpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnaW5wdXQtaW5kZXgteScpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdHZhciBfbGFzdCA9IHJldEFyci5wb3AoKTtcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJyArICcpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXRoaXMuaXNTdGF0ZSgnaW5wdXQtaW5kZXgteicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW5wdXQtaW5kZXgteScpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dmFyIGlzSW5wdXRJbmRleFogPSB0aGlzLmlzU3RhdGUoJ2lucHV0LWluZGV4LXonKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlzSW5wdXRJbmRleFopIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnaW5wdXQtaW5kZXgteScpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdpbnB1dC1pbmRleCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5wcm9wZXJ0eSwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0aWYgKGlzSW5wdXRJbmRleFopIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdpbnB1dC1pbmRleC15Jyk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW5wdXQtaW5kZXgnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaChfbGFzdCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucG9wTWVtYmVyU3RhdGUobU5vZGUub2JqZWN0Lm9iamVjdC5uYW1lKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdHZhciBfbGFzdDIgPSByZXRBcnIucG9wKCk7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCddWycpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKF9sYXN0Mik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHR2YXIgX2xhc3QzID0gcmV0QXJyLnBvcCgpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ11bJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaChfbGFzdDMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHVucm9sbGVkID0gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKG1Ob2RlKTtcblx0XHRcdFx0aWYgKG1Ob2RlLnByb3BlcnR5LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBtTm9kZS5jb21wdXRlZCkge1xuXHRcdFx0XHRcdHVucm9sbGVkID0gJ3VzZXJfJyArIHVucm9sbGVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHVucm9sbGVkLmluZGV4T2YoJ3RoaXMuY29uc3RhbnRzJykgPT09IDApIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgJ3RoaXMuY29uc3RhbnRzJyBmcm9tIGJlZ2lubmluZ1xuXHRcdFx0XHRcdHVucm9sbGVkID0gJ2NvbnN0YW50c18nICsgdW5yb2xsZWQuc3Vic3RyaW5nKDE1KTtcblx0XHRcdFx0fSBlbHNlIGlmICh1bnJvbGxlZC5pbmRleE9mKCd0aGlzJykgPT09IDApIHtcblx0XHRcdFx0XHQvLyBJdHMgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhZGQgJ18nIGJlZm9yZVxuXHRcdFx0XHRcdHVucm9sbGVkID0gJ18nICsgdW5yb2xsZWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcblx0XHRcdFx0XHRjYXNlICdpbnB1dC1pbmRleC15Jzpcblx0XHRcdFx0XHRjYXNlICdpbnB1dC1pbmRleC16Jzpcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKHVucm9sbGVkKSB7XG5cdFx0XHRcdFx0Y2FzZSAnX3RoaXMub3V0cHV0LngnOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMF0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnX3RoaXMub3V0cHV0LnknOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnX3RoaXMub3V0cHV0LnonOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMl0pO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGlmIChtTm9kZS5vYmplY3QgJiYgbU5vZGUub2JqZWN0Lm5hbWUgJiYgdGhpcy5kZWNsYXJhdGlvbnNbbU5vZGUub2JqZWN0Lm5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd1c2VyXycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godW5yb2xsZWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoICh0aGlzLnN0YXRlKSB7XG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQtaW5kZXgteSc6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBzaXplID0gdGhpcy5wYXJhbVNpemVzW3RoaXMucGFyYW1OYW1lcy5pbmRleE9mKHRoaXMubWVtYmVyU3RhdGUpXTtcblx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJyAqICcgKyBzaXplWzBdICsgJyknKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FzZSAnaW5wdXQtaW5kZXgteic6XG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHZhciBfc2l6ZTIgPSB0aGlzLnBhcmFtU2l6ZXNbdGhpcy5wYXJhbU5hbWVzLmluZGV4T2YodGhpcy5tZW1iZXJTdGF0ZSldO1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnICogJyArIF9zaXplMlswXSAqIF9zaXplMlsxXSArICcpJyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdFNlcXVlbmNlRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFNlcXVlbmNlRXhwcmVzc2lvbihzTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNOb2RlLmV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcsJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKHNOb2RlLmV4cHJlc3Npb25zLCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdENhbGxFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpjYWxsKiBleHByZXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zICB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RDYWxsRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoYXN0LmNhbGxlZSkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIGZ1bGwgZnVuY3Rpb24gY2FsbCwgdW5yb2xsZWRcblx0XHRcdFx0dmFyIGZ1bmNOYW1lID0gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5jYWxsZWUpO1xuXG5cdFx0XHRcdC8vIFJlZ2lzdGVyIHRoZSBmdW5jdGlvbiBpbnRvIHRoZSBjYWxsZWQgcmVnaXN0cnlcblx0XHRcdFx0aWYgKHRoaXMuY2FsbGVkRnVuY3Rpb25zLmluZGV4T2YoZnVuY05hbWUpIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGVkRnVuY3Rpb25zLnB1c2goZnVuY05hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnZnVuY05hbWUnKSkge1xuXHRcdFx0XHRcdHRoaXMuY2FsbGVkRnVuY3Rpb25zQXJndW1lbnRzW2Z1bmNOYW1lXSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGZ1bmN0aW9uQXJndW1lbnRzID0gW107XG5cdFx0XHRcdHRoaXMuY2FsbGVkRnVuY3Rpb25zQXJndW1lbnRzW2Z1bmNOYW1lXS5wdXNoKGZ1bmN0aW9uQXJndW1lbnRzKTtcblxuXHRcdFx0XHQvLyBDYWxsIHRoZSBmdW5jdGlvblxuXHRcdFx0XHRyZXRBcnIucHVzaChmdW5jTmFtZSk7XG5cblx0XHRcdFx0Ly8gT3BlbiBhcmd1bWVudHMgc3BhY2Vcblx0XHRcdFx0cmV0QXJyLnB1c2goJygnKTtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIHZhcnNcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhc3QuYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3VtZW50ID0gYXN0LmFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdFx0aWYgKGFyZ3VtZW50LnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuXHRcdFx0XHRcdFx0dmFyIHBhcmFtSW5kZXggPSB0aGlzLnBhcmFtTmFtZXMuaW5kZXhPZihhcmd1bWVudC5uYW1lKTtcblx0XHRcdFx0XHRcdGlmIChwYXJhbUluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbkFyZ3VtZW50cy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb25Bcmd1bWVudHMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogYXJndW1lbnQubmFtZSxcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiB0aGlzLnBhcmFtVHlwZXNbcGFyYW1JbmRleF1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZ1bmN0aW9uQXJndW1lbnRzLnB1c2gobnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2xvc2UgYXJndW1lbnRzIHNwYWNlXG5cdFx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cblx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFpbHVyZSwgdW5rbm93biBleHByZXNzaW9uXG5cdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdVbmtub3duIENhbGxFeHByZXNzaW9uJywgYXN0KTtcblxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEFycmF5RXhwcmVzc2lvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqQXJyYXkqIEV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyck5vZGUgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEFycmF5RXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEFycmF5RXhwcmVzc2lvbihhcnJOb2RlLCByZXRBcnIpIHtcblx0XHRcdHZhciBhcnJMZW4gPSBhcnJOb2RlLmVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdFx0cmV0QXJyLnB1c2goJ1snKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyTGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN1Yk5vZGUgPSBhcnJOb2RlLmVsZW1lbnRzW2ldO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoc3ViTm9kZSwgcmV0QXJyKTtcblx0XHRcdH1cblx0XHRcdHJldEFyci5wdXNoKCddJyk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cblx0XHRcdC8vIC8vIEZhaWx1cmUsIHVua25vd24gZXhwcmVzc2lvblxuXHRcdFx0Ly8gdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcblx0XHRcdC8vIFx0J1Vua25vd24gIEFycmF5RXhwcmVzc2lvbicsXG5cdFx0XHQvLyBcdGFyck5vZGVcblx0XHRcdC8vKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3REZWJ1Z2dlclN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdERlYnVnZ2VyU3RhdGVtZW50KGFyck5vZGUsIHJldEFycikge1xuXHRcdFx0cmV0QXJyLnB1c2goJ2RlYnVnZ2VyOycpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdtZW1iZXJTdGF0ZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tZW1iZXJTdGF0ZXNbdGhpcy5tZW1iZXJTdGF0ZXMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIENQVUZ1bmN0aW9uTm9kZTtcbn0oQmFzZUZ1bmN0aW9uTm9kZSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWxzJyk7XG52YXIga2VybmVsUnVuU2hvcnRjdXQgPSByZXF1aXJlKCcuLi9rZXJuZWwtcnVuLXNob3J0Y3V0Jyk7XG5cbmZ1bmN0aW9uIHJlbW92ZUZuTm9pc2UoZm4pIHtcbiAgaWYgKC9eZnVuY3Rpb24gLy50ZXN0KGZuKSkge1xuICAgIGZuID0gZm4uc3Vic3RyaW5nKDkpO1xuICB9XG4gIHJldHVybiBmbi5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2lzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjcHVLZXJuZWwsIG5hbWUpIHtcbiAgcmV0dXJuICcoKSA9PiB7XFxuICAgICcgKyBrZXJuZWxSdW5TaG9ydGN1dC50b1N0cmluZygpICsgJztcXG4gICAgY29uc3QgdXRpbHMgPSB7XFxuICAgICAgYWxsUHJvcGVydGllc09mOiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuYWxsUHJvcGVydGllc09mLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBjbG9uZTogJyArIHJlbW92ZU5vaXNlKHV0aWxzLmNsb25lLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBjaGVja091dHB1dDogJyArIHJlbW92ZU5vaXNlKHV0aWxzLmNoZWNrT3V0cHV0LnRvU3RyaW5nKCkpICsgJ1xcbiAgICB9O1xcbiAgICBjb25zdCBVdGlscyA9IHV0aWxzO1xcbiAgICBsZXQgSW5wdXQgPSBmdW5jdGlvbigpIHt9O1xcbiAgICBjbGFzcyAnICsgKG5hbWUgfHwgJ0tlcm5lbCcpICsgJyB7XFxuICAgICAgY29uc3RydWN0b3IoKSB7ICAgICAgICBcXG4gICAgICAgIHRoaXMuYXJndW1lbnRzTGVuZ3RoID0gMDtcXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XFxuICAgICAgICB0aGlzLl93ZWJHbCA9IG51bGw7XFxuICAgICAgICB0aGlzLmJ1aWx0ID0gZmFsc2U7XFxuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xcbiAgICAgICAgdGhpcy5wYXJhbU5hbWVzID0gJyArIEpTT04uc3RyaW5naWZ5KGNwdUtlcm5lbC5wYXJhbU5hbWVzKSArICc7XFxuICAgICAgICB0aGlzLnBhcmFtVHlwZXMgPSAnICsgSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLnBhcmFtVHlwZXMpICsgJztcXG4gICAgICAgIHRoaXMudGV4U2l6ZSA9ICcgKyBKU09OLnN0cmluZ2lmeShjcHVLZXJuZWwudGV4U2l6ZSkgKyAnO1xcbiAgICAgICAgdGhpcy5vdXRwdXQgPSAnICsgSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLm91dHB1dCkgKyAnO1xcbiAgICAgICAgdGhpcy5fa2VybmVsU3RyaW5nID0gYCcgKyBjcHVLZXJuZWwuX2tlcm5lbFN0cmluZyArICdgO1xcbiAgICAgICAgdGhpcy5vdXRwdXQgPSAnICsgSlNPTi5zdHJpbmdpZnkoY3B1S2VybmVsLm91dHB1dCkgKyAnO1xcblxcdFxcdCAgICB0aGlzLnJ1biA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICB0aGlzLnJ1biA9IG51bGw7XFxuICAgICAgICAgIHRoaXMuYnVpbGQoKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMucnVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9LmJpbmQodGhpcyk7XFxuICAgICAgICB0aGlzLnRocmVhZCA9IHtcXG4gICAgICAgICAgeDogMCxcXG4gICAgICAgICAgeTogMCxcXG4gICAgICAgICAgejogMFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgICAgc2V0Q2FudmFzKGNhbnZhcykgeyB0aGlzLl9jYW52YXMgPSBjYW52YXM7IHJldHVybiB0aGlzOyB9XFxuICAgICAgc2V0V2ViR2wod2ViR2wpIHsgdGhpcy5fd2ViR2wgPSB3ZWJHbDsgcmV0dXJuIHRoaXM7IH1cXG4gICAgICBzZXRJbnB1dChUeXBlKSB7IElucHV0ID0gVHlwZTsgfVxcbiAgICAgICcgKyByZW1vdmVGbk5vaXNlKGNwdUtlcm5lbC5idWlsZC50b1N0cmluZygpKSArICdcXG4gICAgICAnICsgcmVtb3ZlRm5Ob2lzZShjcHVLZXJuZWwuc2V0dXBQYXJhbXMudG9TdHJpbmcoKSkgKyAnXFxuICAgICAgJyArIHJlbW92ZUZuTm9pc2UoY3B1S2VybmVsLnNldHVwQ29uc3RhbnRzLnRvU3RyaW5nKCkpICsgJ1xcbiAgICAgIHJ1biAoKSB7ICcgKyBjcHVLZXJuZWwua2VybmVsU3RyaW5nICsgJyB9XFxuICAgICAgZ2V0S2VybmVsU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fa2VybmVsU3RyaW5nOyB9XFxuICAgICAgJyArIHJlbW92ZUZuTm9pc2UoY3B1S2VybmVsLnZhbGlkYXRlT3B0aW9ucy50b1N0cmluZygpKSArICdcXG4gICAgfTtcXG4gICAgcmV0dXJuIGtlcm5lbFJ1blNob3J0Y3V0KG5ldyBLZXJuZWwoKSk7XFxuICB9Oyc7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgS2VybmVsQmFzZSA9IHJlcXVpcmUoJy4uL2tlcm5lbC1iYXNlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWxzJyk7XG52YXIga2VybmVsU3RyaW5nID0gcmVxdWlyZSgnLi9rZXJuZWwtc3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9LZXJuZWxCYXNlKSB7XG5cdF9pbmhlcml0cyhDUFVLZXJuZWwsIF9LZXJuZWxCYXNlKTtcblxuXHQvKipcbiAgKiBAY29uc3RydWN0b3IgQ1BVS2VybmVsXG4gICpcbiAgKiBAZGVzYyBLZXJuZWwgSW1wbGVtZW50YXRpb24gZm9yIENQVS5cbiAgKlxuICAqIDxwPkluc3RhbnRpYXRlcyBwcm9wZXJ0aWVzIHRvIHRoZSBDUFUgS2VybmVsLjwvcD5cbiAgKlxuICAqIEBleHRlbmRzIEtlcm5lbEJhc2VcbiAgKlxuICAqIEBwcm9wIHtPYmplY3R9IHRocmVhZCAtIFRoZSB0aHJlYWQgZGltZW5zaW9ucywgeCwgeSBhbmQgelxuICAqIEBwcm9wIHtPYmplY3R9IG91dHB1dCAtIFRoZSBjYW52YXMgZGltZW5zaW9uc1xuICAqIEBwcm9wIHtPYmplY3R9IGZ1bmN0aW9uQnVpbGRlciAtIEZ1bmN0aW9uIEJ1aWxkZXIgaW5zdGFuY2UgYm91bmQgdG8gdGhpcyBLZXJuZWxcbiAgKiBAcHJvcCB7RnVuY3Rpb259IHJ1biAtIE1ldGhvZCB0byBydW4gdGhlIGtlcm5lbFxuICAqXG4gICovXG5cdGZ1bmN0aW9uIENQVUtlcm5lbChmblN0cmluZywgc2V0dGluZ3MpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ1BVS2VybmVsKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDUFVLZXJuZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDUFVLZXJuZWwpKS5jYWxsKHRoaXMsIGZuU3RyaW5nLCBzZXR0aW5ncykpO1xuXG5cdFx0X3RoaXMuX2ZuID0gbnVsbDtcblx0XHRfdGhpcy5ydW4gPSBudWxsO1xuXHRcdF90aGlzLl9jYW52YXNDdHggPSBudWxsO1xuXHRcdF90aGlzLl9pbWFnZURhdGEgPSBudWxsO1xuXHRcdF90aGlzLl9jb2xvckRhdGEgPSBudWxsO1xuXHRcdF90aGlzLl9rZXJuZWxTdHJpbmcgPSBudWxsO1xuXHRcdF90aGlzLnRocmVhZCA9IHtcblx0XHRcdHg6IDAsXG5cdFx0XHR5OiAwLFxuXHRcdFx0ejogMFxuXHRcdH07XG5cblx0XHRfdGhpcy5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnJ1biA9IG51bGw7XG5cdFx0XHR0aGlzLmJ1aWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ydW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LmJpbmQoX3RoaXMpO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIEBtZW1iZXJPZiBDUFVLZXJuZWwjXG4gICogQGZ1bmN0aW9uXG4gICogQG5hbWUgdmFsaWRhdGVPcHRpb25zXG4gICpcbiAgKiBAZGVzYyBWYWxpZGF0ZSBvcHRpb25zIHJlbGF0ZWQgdG8gQ1BVIEtlcm5lbCwgc3VjaCBhc1xuICAqIGRpbWVuc2lvbnMgc2l6ZSwgYW5kIGF1dG8gZGltZW5zaW9uIHN1cHBvcnQuXG4gICpcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhDUFVLZXJuZWwsIFt7XG5cdFx0a2V5OiAndmFsaWRhdGVPcHRpb25zJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKCkge1xuXHRcdFx0aWYgKCF0aGlzLm91dHB1dCB8fCB0aGlzLm91dHB1dC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcblx0XHRcdFx0XHR0aHJvdyAnQXV0byBkaW1lbnNpb25zIG9ubHkgc3VwcG9ydGVkIGZvciBrZXJuZWxzIHdpdGggb25seSBvbmUgaW5wdXQnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGFyZ1R5cGUgPSB1dGlscy5nZXRBcmd1bWVudFR5cGUoYXJndW1lbnRzWzBdKTtcblx0XHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdBcnJheScpIHtcblx0XHRcdFx0XHR0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ051bWJlclRleHR1cmUnIHx8IGFyZ1R5cGUgPT09ICdBcnJheVRleHR1cmUoNCknKSB7XG5cdFx0XHRcdFx0dGhpcy5vdXRwdXQgPSBhcmd1bWVudHNbMF0ub3V0cHV0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93ICdBdXRvIGRpbWVuc2lvbnMgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dXRpbHMuY2hlY2tPdXRwdXQodGhpcy5vdXRwdXQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQ1BVS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYnVpbGRcbiAgICpcbiAgICogQGRlc2MgQnVpbGRzIHRoZSBLZXJuZWwsIGJ5IGdlbmVyYXRpbmcgdGhlIGtlcm5lbFxuICAgKiBzdHJpbmcgdXNpbmcgdGhyZWFkIGRpbWVuc2lvbnMsIGFuZCBhcmd1bWVudHNcbiAgICogc3VwcGxpZWQgdG8gdGhlIGtlcm5lbC5cbiAgICpcbiAgICogPHA+SWYgdGhlIGdyYXBoaWNhbCBmbGFnIGlzIGVuYWJsZWQsIGNhbnZhcyBpcyB1c2VkLjwvcD5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2J1aWxkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG5cdFx0XHR0aGlzLnNldHVwQ29uc3RhbnRzKCk7XG5cdFx0XHR0aGlzLnNldHVwUGFyYW1zKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnZhbGlkYXRlT3B0aW9ucygpO1xuXHRcdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblx0XHRcdGlmIChjYW52YXMpIHtcblx0XHRcdFx0Ly8gaWYgbm9kZSBvciBjYW52YXMgaXMgbm90IGZvdW5kLCBkb24ndCBkaWVcblx0XHRcdFx0dGhpcy5fY2FudmFzQ3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGhyZWFkRGltID0gdGhpcy50aHJlYWREaW0gPSB1dGlscy5jbG9uZSh0aGlzLm91dHB1dCk7XG5cblx0XHRcdHdoaWxlICh0aHJlYWREaW0ubGVuZ3RoIDwgMykge1xuXHRcdFx0XHR0aHJlYWREaW0ucHVzaCgxKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG5cdFx0XHRcdHZhciBfY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdFx0XHRpZiAoIV9jYW52YXMpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vIGNhbnZhcyBhdmFpbGFibGUgZm9yIHVzaW5nIGdyYXBoaWNhbCBvdXRwdXQnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfY2FudmFzLndpZHRoID0gdGhyZWFkRGltWzBdO1xuXHRcdFx0XHRfY2FudmFzLmhlaWdodCA9IHRocmVhZERpbVsxXTtcblx0XHRcdFx0dGhpcy5faW1hZ2VEYXRhID0gdGhpcy5fY2FudmFzQ3R4LmNyZWF0ZUltYWdlRGF0YSh0aHJlYWREaW1bMF0sIHRocmVhZERpbVsxXSk7XG5cdFx0XHRcdHRoaXMuX2NvbG9yRGF0YSA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aHJlYWREaW1bMF0gKiB0aHJlYWREaW1bMV0gKiA0KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtlcm5lbFN0cmluZyA9IHRoaXMuZ2V0S2VybmVsU3RyaW5nKCk7XG5cblx0XHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdPcHRpb25zOicpO1xuXHRcdFx0XHRjb25zb2xlLmRpcih0aGlzKTtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0Z1bmN0aW9uIG91dHB1dDonKTtcblx0XHRcdFx0Y29uc29sZS5sb2coa2VybmVsU3RyaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5rZXJuZWxTdHJpbmcgPSBrZXJuZWxTdHJpbmc7XG5cdFx0XHR0aGlzLnJ1biA9IG5ldyBGdW5jdGlvbihbXSwga2VybmVsU3RyaW5nKS5iaW5kKHRoaXMpKCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnY29sb3InLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb2xvcihyLCBnLCBiLCBhKSB7XG5cdFx0XHRpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyID0gTWF0aC5mbG9vcihyICogMjU1KTtcblx0XHRcdGcgPSBNYXRoLmZsb29yKGcgKiAyNTUpO1xuXHRcdFx0YiA9IE1hdGguZmxvb3IoYiAqIDI1NSk7XG5cdFx0XHRhID0gTWF0aC5mbG9vcihhICogMjU1KTtcblxuXHRcdFx0dmFyIHdpZHRoID0gdGhpcy5vdXRwdXRbMF07XG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5vdXRwdXRbMV07XG5cblx0XHRcdHZhciB4ID0gdGhpcy50aHJlYWQueDtcblx0XHRcdHZhciB5ID0gaGVpZ2h0IC0gdGhpcy50aHJlYWQueSAtIDE7XG5cblx0XHRcdHZhciBpbmRleCA9IHggKyB5ICogd2lkdGg7XG5cblx0XHRcdHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAwXSA9IHI7XG5cdFx0XHR0aGlzLl9jb2xvckRhdGFbaW5kZXggKiA0ICsgMV0gPSBnO1xuXHRcdFx0dGhpcy5fY29sb3JEYXRhW2luZGV4ICogNCArIDJdID0gYjtcblx0XHRcdHRoaXMuX2NvbG9yRGF0YVtpbmRleCAqIDQgKyAzXSA9IGE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRLZXJuZWxTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgR2VuZXJhdGVzIGtlcm5lbCBzdHJpbmcgZm9yIHRoaXMga2VybmVsIHByb2dyYW0uXG4gICAqXG4gICAqIDxwPklmIHN1Yi1rZXJuZWxzIGFyZSBzdXBwbGllZCwgdGhleSBhcmUgYWxzbyBmYWN0b3JlZCBpbi5cbiAgICogVGhpcyBzdHJpbmcgY2FuIGJlIHNhdmVkIGJ5IGNhbGxpbmcgdGhlIGB0b1N0cmluZ2AgbWV0aG9kXG4gICAqIGFuZCB0aGVuIGNhbiBiZSByZXVzZWQgbGF0ZXIuPC9wPlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEtlcm5lbFN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEtlcm5lbFN0cmluZygpIHtcblx0XHRcdGlmICh0aGlzLl9rZXJuZWxTdHJpbmcgIT09IG51bGwpIHJldHVybiB0aGlzLl9rZXJuZWxTdHJpbmc7XG5cblx0XHRcdHZhciBidWlsZGVyID0gdGhpcy5mdW5jdGlvbkJ1aWxkZXI7XG5cblx0XHRcdC8vIFRocmVhZCBkaW0gZml4ICh0byBtYWtlIGNvbXBpbGFibGUpXG5cdFx0XHR2YXIgdGhyZWFkRGltID0gdGhpcy50aHJlYWREaW0gfHwgKHRoaXMudGhyZWFkRGltID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpKTtcblx0XHRcdHdoaWxlICh0aHJlYWREaW0ubGVuZ3RoIDwgMykge1xuXHRcdFx0XHR0aHJlYWREaW0ucHVzaCgxKTtcblx0XHRcdH1cblxuXHRcdFx0YnVpbGRlci5hZGRLZXJuZWwodGhpcy5mblN0cmluZywge1xuXHRcdFx0XHRwcm90b3R5cGVPbmx5OiBmYWxzZSxcblx0XHRcdFx0Y29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcblx0XHRcdFx0b3V0cHV0OiB0aHJlYWREaW0sXG5cdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRsb29wTWF4SXRlcmF0aW9uczogdGhpcy5sb29wTWF4SXRlcmF0aW9ucyxcblx0XHRcdFx0cGFyYW1OYW1lczogdGhpcy5wYXJhbU5hbWVzLFxuXHRcdFx0XHRwYXJhbVR5cGVzOiB0aGlzLnBhcmFtVHlwZXMsXG5cdFx0XHRcdHBhcmFtU2l6ZXM6IHRoaXMucGFyYW1TaXplcyxcblx0XHRcdFx0Y29uc3RhbnRUeXBlczogdGhpcy5jb25zdGFudFR5cGVzXG5cdFx0XHR9KTtcblxuXHRcdFx0YnVpbGRlci5hZGRGdW5jdGlvbnModGhpcy5mdW5jdGlvbnMsIHtcblx0XHRcdFx0Y29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcblx0XHRcdFx0b3V0cHV0OiB0aHJlYWREaW1cblx0XHRcdH0pO1xuXG5cdFx0XHRidWlsZGVyLmFkZE5hdGl2ZUZ1bmN0aW9ucyh0aGlzLm5hdGl2ZUZ1bmN0aW9ucyk7XG5cblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxzW2ldO1xuXHRcdFx0XHRcdGJ1aWxkZXIuYWRkU3ViS2VybmVsKHN1Yktlcm5lbCwge1xuXHRcdFx0XHRcdFx0cHJvdG90eXBlT25seTogZmFsc2UsXG5cdFx0XHRcdFx0XHRjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuXHRcdFx0XHRcdFx0b3V0cHV0OiB0aGlzLm91dHB1dCxcblx0XHRcdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRcdFx0bG9vcE1heEl0ZXJhdGlvbnM6IHRoaXMubG9vcE1heEl0ZXJhdGlvbnNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMucHVzaChzdWJLZXJuZWwubmFtZSArICdSZXN1bHQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzID0gW107XG5cdFx0XHRcdHZhciBfaSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIHAgaW4gdGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdHZhciBfc3ViS2VybmVsID0gdGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzW3BdO1xuXHRcdFx0XHRcdGJ1aWxkZXIuYWRkU3ViS2VybmVsKF9zdWJLZXJuZWwpO1xuXHRcdFx0XHRcdHRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcy5wdXNoKF9zdWJLZXJuZWwubmFtZSArICdSZXN1bHQnKTtcblx0XHRcdFx0XHRfaSsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwcm90b3R5cGVzID0gYnVpbGRlci5nZXRQcm90b3R5cGVzKCdrZXJuZWwnKTtcblx0XHRcdHZhciBrZXJuZWwgPSBudWxsO1xuXHRcdFx0aWYgKHByb3RvdHlwZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRwcm90b3R5cGVzID0gcHJvdG90eXBlcy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRcdFx0aWYgKC9eZnVuY3Rpb24vLnRlc3QoZm4pKSByZXR1cm4gZm47XG5cdFx0XHRcdFx0a2VybmVsID0gZm47XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtlcm5lbCA9IHByb3RvdHlwZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdHZhciBrZXJuZWxTdHJpbmcgPSB0aGlzLl9rZXJuZWxTdHJpbmcgPSAnXFxuXFx0XFx0dmFyIExPT1BfTUFYID0gJyArIHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSArICdcXG5cXHRcXHR2YXIgY29uc3RhbnRzID0gdGhpcy5jb25zdGFudHM7XFxuXFx0XFx0dmFyIF90aGlzID0gdGhpcztcXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgnICsgdGhpcy5wYXJhbU5hbWVzLm1hcChmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG5cdFx0XHRcdHJldHVybiAndXNlcl8nICsgcGFyYW1OYW1lO1xuXHRcdFx0fSkuam9pbignLCAnKSArICcpIHtcXG4gICAgICAnICsgdGhpcy5fcHJvY2Vzc0NvbnN0YW50cygpICsgJ1xcbiAgICAgICcgKyB0aGlzLl9wcm9jZXNzUGFyYW1zKCkgKyAnXFxuICAgICAgJyArIHRoaXMuX2tlcm5lbExvb3Aoa2VybmVsKSArICdcXG4gICAgICBpZiAodGhpcy5ncmFwaGljYWwpIHtcXG4gICAgICAgIHRoaXMuX2ltYWdlRGF0YS5kYXRhLnNldCh0aGlzLl9jb2xvckRhdGEpO1xcbiAgICAgICAgdGhpcy5fY2FudmFzQ3R4LnB1dEltYWdlRGF0YSh0aGlzLl9pbWFnZURhdGEsIDAsIDApO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICAnICsgdGhpcy5fa2VybmVsT3V0cHV0KCkgKyAnXFxuICAgICAgJyArIChwcm90b3R5cGVzLmxlbmd0aCA+IDAgPyBwcm90b3R5cGVzLmpvaW4oJ1xcbicpIDogJycpICsgJ1xcbiAgICB9LmJpbmQodGhpcyk7Jztcblx0XHRcdHJldHVybiBrZXJuZWxTdHJpbmc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSAqcHJlLWNvbXBpbGVkKiBLZXJuZWwgYXMgYSBKUyBPYmplY3QgU3RyaW5nLCB0aGF0IGNhbiBiZSByZXVzZWQuXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd0b1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdFx0cmV0dXJuIGtlcm5lbFN0cmluZyh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldExvb3BNYXhTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgR2V0IHRoZSBtYXhpbXVtIGxvb3Agc2l6ZSBTdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldExvb3BNYXhTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0TG9vcE1heFN0cmluZygpIHtcblx0XHRcdHJldHVybiB0aGlzLmxvb3BNYXhJdGVyYXRpb25zID8gJyAnICsgcGFyc2VJbnQodGhpcy5sb29wTWF4SXRlcmF0aW9ucykgKyAnO1xcbicgOiAnIDEwMDA7XFxuJztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfcHJvY2Vzc0NvbnN0YW50cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzQ29uc3RhbnRzKCkge1xuXHRcdFx0aWYgKCF0aGlzLmNvbnN0YW50cykgcmV0dXJuICcnO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHRmb3IgKHZhciBwIGluIHRoaXMuY29uc3RhbnRzKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5jb25zdGFudFR5cGVzW3BdO1xuXHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgdmFyIGNvbnN0YW50c18nICsgcCArICcgPSB0aGlzLl9pbWFnZVRvMkRBcnJheSh0aGlzLmNvbnN0YW50cy4nICsgcCArICcpJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICB2YXIgY29uc3RhbnRzXycgKyBwICsgJyA9IHRoaXMuX2ltYWdlVG8zREFycmF5KHRoaXMuY29uc3RhbnRzLicgKyBwICsgJyknKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCcgIHZhciBjb25zdGFudHNfJyArIHAgKyAnID0gdGhpcy5jb25zdGFudHMuJyArIHAgKyAnLnZhbHVlJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgdmFyIGNvbnN0YW50c18nICsgcCArICcgPSB0aGlzLmNvbnN0YW50cy4nICsgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQuam9pbignXFxuJyk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3Byb2Nlc3NQYXJhbXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc1BhcmFtcygpIHtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJhbVR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHN3aXRjaCAodGhpcy5wYXJhbVR5cGVzW2ldKSB7XG5cdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlJzpcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCcgIHVzZXJfJyArIHRoaXMucGFyYW1OYW1lc1tpXSArICcgPSB0aGlzLl9pbWFnZVRvMkRBcnJheSh1c2VyXycgKyB0aGlzLnBhcmFtTmFtZXNbaV0gKyAnKScpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgdXNlcl8nICsgdGhpcy5wYXJhbU5hbWVzW2ldICsgJyA9IHRoaXMuX2ltYWdlVG8zREFycmF5KHVzZXJfJyArIHRoaXMucGFyYW1OYW1lc1tpXSArICcpJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdJbnB1dCc6XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICB1c2VyXycgKyB0aGlzLnBhcmFtTmFtZXNbaV0gKyAnID0gdXNlcl8nICsgdGhpcy5wYXJhbU5hbWVzW2ldICsgJy52YWx1ZScpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQuam9pbignO1xcbicpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19pbWFnZVRvMkRBcnJheScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9pbWFnZVRvMkRBcnJheShpbWFnZSkge1xuXHRcdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblx0XHRcdGlmIChjYW52YXMud2lkdGggPCBpbWFnZS53aWR0aCkge1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdH1cblx0XHRcdGlmIChjYW52YXMuaGVpZ2h0IDwgaW1hZ2UuaGVpZ2h0KSB7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY2FudmFzQ3R4O1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cdFx0XHR2YXIgcGl4ZWxzRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkuZGF0YTtcblx0XHRcdHZhciBpbWFnZUFycmF5ID0gbmV3IEFycmF5KGltYWdlLmhlaWdodCk7XG5cdFx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdFx0Zm9yICh2YXIgeSA9IGltYWdlLmhlaWdodCAtIDE7IHkgPj0gMDsgeS0tKSB7XG5cdFx0XHRcdGltYWdlQXJyYXlbeV0gPSBuZXcgQXJyYXkoaW1hZ2Uud2lkdGgpO1xuXHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGltYWdlLndpZHRoOyB4KyspIHtcblx0XHRcdFx0XHR2YXIgciA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7XG5cdFx0XHRcdFx0dmFyIGcgPSBwaXhlbHNEYXRhW2luZGV4KytdIC8gMjU1O1xuXHRcdFx0XHRcdHZhciBiID0gcGl4ZWxzRGF0YVtpbmRleCsrXSAvIDI1NTtcblx0XHRcdFx0XHR2YXIgYSA9IHBpeGVsc0RhdGFbaW5kZXgrK10gLyAyNTU7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IFtyLCBnLCBiLCBhXTtcblx0XHRcdFx0XHRyZXN1bHQuciA9IHI7XG5cdFx0XHRcdFx0cmVzdWx0LmcgPSBnO1xuXHRcdFx0XHRcdHJlc3VsdC5iID0gYjtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IGE7XG5cdFx0XHRcdFx0aW1hZ2VBcnJheVt5XVt4XSA9IHJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGltYWdlQXJyYXk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2ltYWdlVG8zREFycmF5Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2ltYWdlVG8zREFycmF5KGltYWdlcykge1xuXHRcdFx0dmFyIGltYWdlc0FycmF5ID0gbmV3IEFycmF5KGltYWdlcy5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aW1hZ2VzQXJyYXlbaV0gPSB0aGlzLl9pbWFnZVRvMkRBcnJheShpbWFnZXNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGltYWdlc0FycmF5O1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19rZXJuZWxMb29wJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2tlcm5lbExvb3Aoa2VybmVsU3RyaW5nKSB7XG5cdFx0XHRzd2l0Y2ggKHRoaXMub3V0cHV0Lmxlbmd0aCkge1xuXHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2tlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2tlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpO1xuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2tlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgc2l6ZSBrZXJuZWwnKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfa2VybmVsMURMb29wJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2tlcm5lbDFETG9vcChrZXJuZWxTdHJpbmcpIHtcblx0XHRcdHZhciB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcblx0XHRcdHJldHVybiAnXFxuICAgIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KCcgKyB0aHJlYWREaW1bMF0gKyAnKTtcXG4gICAgJyArIHRoaXMuX21hcFN1Yktlcm5lbHMoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuICd2YXIgcmVzdWx0XycgKyBuYW1lICsgJyA9IG5ldyBGbG9hdDMyQXJyYXkoJyArIHRocmVhZERpbVswXSArICcpO1xcbic7XG5cdFx0XHR9KS5qb2luKCcnKSArICdcXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCAnICsgdGhyZWFkRGltWzBdICsgJzsgeCsrKSB7XFxuICAgICAgdGhpcy50aHJlYWQueCA9IHg7XFxuICAgICAgdGhpcy50aHJlYWQueSA9IDA7XFxuICAgICAgdGhpcy50aHJlYWQueiA9IDA7XFxuICAgICAgdmFyIGtlcm5lbFJlc3VsdDtcXG4gICAgICAnICsga2VybmVsU3RyaW5nICsgJ1xcbiAgICAgIHJlc3VsdFt4XSA9IGtlcm5lbFJlc3VsdDtcXG4gICAgICAnICsgdGhpcy5fbWFwU3ViS2VybmVscyhmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gJ3Jlc3VsdF8nICsgbmFtZSArICdbeF0gPSAnICsgbmFtZSArICc7XFxuJztcblx0XHRcdH0pLmpvaW4oJycpICsgJ1xcbiAgICB9Jztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfa2VybmVsMkRMb29wJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2tlcm5lbDJETG9vcChrZXJuZWxTdHJpbmcpIHtcblx0XHRcdHZhciB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcblx0XHRcdHJldHVybiAnXFxuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoJyArIHRocmVhZERpbVsxXSArICcpO1xcbiAgICAnICsgdGhpcy5fbWFwU3ViS2VybmVscyhmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gJ3ZhciByZXN1bHRfJyArIG5hbWUgKyAnID0gbmV3IEFycmF5KCcgKyB0aHJlYWREaW1bMV0gKyAnKTtcXG4nO1xuXHRcdFx0fSkuam9pbignJykgKyAnXFxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgJyArIHRocmVhZERpbVsxXSArICc7IHkrKykge1xcbiAgICAgIHRoaXMudGhyZWFkLnogPSAwO1xcbiAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xcbiAgICAgIHZhciByZXN1bHRYID0gcmVzdWx0W3ldID0gbmV3IEZsb2F0MzJBcnJheSgnICsgdGhyZWFkRGltWzBdICsgJyk7XFxuICAgICAgJyArIHRoaXMuX21hcFN1Yktlcm5lbHMoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuICd2YXIgcmVzdWx0XycgKyBuYW1lICsgJ1ggPSByZXN1bHRfJyArIG5hbWUgKyAnW3ldID0gbmV3IEZsb2F0MzJBcnJheSgnICsgdGhyZWFkRGltWzBdICsgJyk7XFxuJztcblx0XHRcdH0pLmpvaW4oJycpICsgJ1xcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgJyArIHRocmVhZERpbVswXSArICc7IHgrKykge1xcbiAgICAgIFxcdHRoaXMudGhyZWFkLnggPSB4O1xcbiAgICAgICAgdmFyIGtlcm5lbFJlc3VsdDtcXG4gICAgICAgICcgKyBrZXJuZWxTdHJpbmcgKyAnXFxuICAgICAgICByZXN1bHRYW3hdID0ga2VybmVsUmVzdWx0O1xcbiAgICAgICAgJyArIHRoaXMuX21hcFN1Yktlcm5lbHMoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuICdyZXN1bHRfJyArIG5hbWUgKyAnWFt4XSA9ICcgKyBuYW1lICsgJztcXG4nO1xuXHRcdFx0fSkuam9pbignJykgKyAnXFxuICAgICAgfVxcbiAgICB9Jztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfa2VybmVsM0RMb29wJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2tlcm5lbDNETG9vcChrZXJuZWxTdHJpbmcpIHtcblx0XHRcdHZhciB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcblx0XHRcdHJldHVybiAnXFxuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoJyArIHRocmVhZERpbVsyXSArICcpO1xcbiAgICAnICsgdGhpcy5fbWFwU3ViS2VybmVscyhmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gJ3ZhciByZXN1bHRfJyArIG5hbWUgKyAnID0gbmV3IEFycmF5KCcgKyB0aHJlYWREaW1bMl0gKyAnKTtcXG4nO1xuXHRcdFx0fSkuam9pbignJykgKyAnXFxuICAgIGZvciAodmFyIHogPSAwOyB6IDwgJyArIHRocmVhZERpbVsyXSArICc7IHorKykge1xcbiAgICAgIHRoaXMudGhyZWFkLnogPSB6O1xcbiAgICAgIHZhciByZXN1bHRZID0gcmVzdWx0W3pdID0gbmV3IEFycmF5KCcgKyB0aHJlYWREaW1bMV0gKyAnKTtcXG4gICAgICAnICsgdGhpcy5fbWFwU3ViS2VybmVscyhmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gJ3ZhciByZXN1bHRfJyArIG5hbWUgKyAnWSA9IHJlc3VsdF8nICsgbmFtZSArICdbel0gPSBuZXcgQXJyYXkoJyArIHRocmVhZERpbVsxXSArICcpO1xcbic7XG5cdFx0XHR9KS5qb2luKCcnKSArICdcXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8ICcgKyB0aHJlYWREaW1bMV0gKyAnOyB5KyspIHtcXG4gICAgICAgIHRoaXMudGhyZWFkLnkgPSB5O1xcbiAgICAgICAgdmFyIHJlc3VsdFggPSByZXN1bHRZW3ldID0gbmV3IEZsb2F0MzJBcnJheSgnICsgdGhyZWFkRGltWzBdICsgJyk7XFxuICAgICAgICAnICsgdGhpcy5fbWFwU3ViS2VybmVscyhmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gJ3ZhciByZXN1bHRfJyArIG5hbWUgKyAnWCA9IHJlc3VsdF8nICsgbmFtZSArICdZW3ldID0gbmV3IEZsb2F0MzJBcnJheSgnICsgdGhyZWFkRGltWzBdICsgJyk7XFxuJztcblx0XHRcdH0pLmpvaW4oJycpICsgJ1xcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCAnICsgdGhyZWFkRGltWzBdICsgJzsgeCsrKSB7XFxuICAgICAgICBcXHR0aGlzLnRocmVhZC54ID0geDtcXG4gICAgICAgICAgdmFyIGtlcm5lbFJlc3VsdDtcXG4gICAgICAgICAgJyArIGtlcm5lbFN0cmluZyArICdcXG4gICAgICAgICAgcmVzdWx0WFt4XSA9IGtlcm5lbFJlc3VsdDtcXG4gICAgICAgICAgJyArIHRoaXMuX21hcFN1Yktlcm5lbHMoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuICdyZXN1bHRfJyArIG5hbWUgKyAnWFt4XSA9ICcgKyBuYW1lICsgJztcXG4nO1xuXHRcdFx0fSkuam9pbignJykgKyAnXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9Jztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfa2VybmVsT3V0cHV0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2tlcm5lbE91dHB1dCgpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHRpZiAoIXRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcykge1xuXHRcdFx0XHRyZXR1cm4gJ3JldHVybiByZXN1bHQ7Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiAncmV0dXJuIHtcXG4gICAgICByZXN1bHQ6IHJlc3VsdCxcXG4gICAgICAnICsgT2JqZWN0LmtleXModGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzIHx8IHRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcykubWFwKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG5cdFx0XHRcdHJldHVybiBuYW1lICsgJzogcmVzdWx0XycgKyBfdGhpczIuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lc1tpXTtcblx0XHRcdH0pLmpvaW4oJyxcXG4nKSArICdcXG4gICAgfTsnO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ19tYXBTdWJLZXJuZWxzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX21hcFN1Yktlcm5lbHMoZm4pIHtcblx0XHRcdHJldHVybiB0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMgPT09IG51bGwgPyBbJyddIDogdGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzLm1hcChmbik7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIENQVUtlcm5lbDtcbn0oS2VybmVsQmFzZSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbHMnKTtcbnZhciBSdW5uZXJCYXNlID0gcmVxdWlyZSgnLi4vcnVubmVyLWJhc2UnKTtcbnZhciBDUFVLZXJuZWwgPSByZXF1aXJlKCcuL2tlcm5lbCcpO1xudmFyIENQVUZ1bmN0aW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tYnVpbGRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfUnVubmVyQmFzZSkge1xuXHRfaW5oZXJpdHMoQ1BVUnVubmVyLCBfUnVubmVyQmFzZSk7XG5cblx0LyoqXG4gICogQGNvbnN0cnVjdG9yIENQVVJ1bm5lclxuICAqXG4gICogQGRlc2MgSW5zdGFudGlhdGVzIGEgUnVubmVyIGluc3RhbmNlIGZvciB0aGUga2VybmVsLlxuICAqIFxuICAqIEBleHRlbmRzIFJ1bm5lckJhc2VcbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyAtIFNldHRpbmdzIHRvIGluc3RhbnRpYXRlIHByb3BlcnRpZXMgaW4gUnVubmVyQmFzZSwgd2l0aCBnaXZlbiB2YWx1ZXNcbiAgKlxuICAqL1xuXG5cdGZ1bmN0aW9uIENQVVJ1bm5lcihzZXR0aW5ncykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDUFVSdW5uZXIpO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENQVVJ1bm5lci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENQVVJ1bm5lcikpLmNhbGwodGhpcywgbmV3IENQVUZ1bmN0aW9uQnVpbGRlcigpLCBzZXR0aW5ncykpO1xuXG5cdFx0X3RoaXMuS2VybmVsID0gQ1BVS2VybmVsO1xuXHRcdF90aGlzLmtlcm5lbCA9IG51bGw7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogQG1lbWJlck9mIENQVVJ1bm5lciNcbiAgKiBAZnVuY3Rpb25cbiAgKiBAbmFtZSBnZXRNb2RlKClcbiAgKlxuICAqIFJldHVybiB0aGUgY3VycmVudCBtb2RlIGluIHdoaWNoIGdwdS5qcyBpcyBleGVjdXRpbmcuXG4gICogXG4gICogQHJldHVybnMge1N0cmluZ30gVGhlIGN1cnJlbnQgbW9kZTsgXCJjcHVcIi5cbiAgKlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKENQVVJ1bm5lciwgW3tcblx0XHRrZXk6ICdnZXRNb2RlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kZSgpIHtcblx0XHRcdHJldHVybiAnY3B1Jztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gQ1BVUnVubmVyO1xufShSdW5uZXJCYXNlKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuICAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvbkJ1aWxkZXJCYXNlXG4gICpcbiAgKiBAZGVzYyBUaGlzIGhhbmRsZXMgYWxsIHRoZSByYXcgc3RhdGUsIGNvbnZlcnRlZCBzdGF0ZSwgZXRjLiBvZiBhIHNpbmdsZSBmdW5jdGlvbi5cbiAgKiBbSU5URVJOQUxdIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbk5vZGVzLlxuICAqIFxuICAqIEBwcm9wIHtPYmplY3R9IG5vZGVNYXAgLSBPYmplY3QgbWFwLCB3aGVyZSBub2RlTWFwW2Z1bmN0aW9uXSA9IG5ldyBGdW5jdGlvbk5vZGU7XG4gICogQHByb3Age09iamVjdH0gZ3B1IC0gVGhlIGN1cnJlbnQgZ3B1IGluc3RhbmNlIGJvdW5kIHRvIHRoaXMgYnVpbGRlclxuICAqIEBwcm9wIHtPYmplY3R9IHJvb3RLZXJuZWwgLSBUaGUgcm9vdCBrZXJuZWwgb2JqZWN0LCBjb250YWlucyB0aGUgcGFyYW1OYW1lcywgZGltZW5zaW9ucyBldGMuXG4gICogXG4gICovXG5cdGZ1bmN0aW9uIEZ1bmN0aW9uQnVpbGRlckJhc2UoZ3B1KSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bmN0aW9uQnVpbGRlckJhc2UpO1xuXG5cdFx0dGhpcy5ub2RlTWFwID0ge307XG5cdFx0dGhpcy5uYXRpdmVGdW5jdGlvbnMgPSB7fTtcblx0XHR0aGlzLmdwdSA9IGdwdTtcblx0XHR0aGlzLnJvb3RLZXJuZWwgPSBudWxsO1xuXHRcdHRoaXMuTm9kZSA9IG51bGw7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoRnVuY3Rpb25CdWlsZGVyQmFzZSwgW3tcblx0XHRrZXk6ICdhZGROYXRpdmVGdW5jdGlvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgZ2xzbEZ1bmN0aW9uU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdID0gZ2xzbEZ1bmN0aW9uU3RyaW5nO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25CdWlsZGVyQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFkZEZ1bmN0aW9uXG4gICAqXG4gICAqIEBkZXNjIEluc3RhbnRpYXRlcyBhIEZ1bmN0aW9uTm9kZSwgYW5kIGFkZCBpdCB0byB0aGUgbm9kZU1hcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25OYW1lIC0gRnVuY3Rpb24gbmFtZSB0byBhc3N1bWUsIGlmIGl0cyBudWxsLCBpdCBhdHRlbXB0cyB0byBleHRyYWN0IGZyb20gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpzRnVuY3Rpb24gLSBKUyBGdW5jdGlvbiB0byBkbyBjb252ZXJzaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZEZ1bmN0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBqc0Z1bmN0aW9uLCBvcHRpb25zKSB7XG5cdFx0XHR0aGlzLmFkZEZ1bmN0aW9uTm9kZShuZXcgdGhpcy5Ob2RlKGZ1bmN0aW9uTmFtZSwganNGdW5jdGlvbiwgb3B0aW9ucykuc2V0QnVpbGRlcih0aGlzKSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYWRkRnVuY3Rpb25zJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkRnVuY3Rpb25zKGZ1bmN0aW9ucywgb3B0aW9ucykge1xuXHRcdFx0aWYgKGZ1bmN0aW9ucykge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShmdW5jdGlvbnMpKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHRoaXMuYWRkRnVuY3Rpb24obnVsbCwgZnVuY3Rpb25zW2ldLCBvcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgcCBpbiBmdW5jdGlvbnMpIHtcblx0XHRcdFx0XHRcdHRoaXMuYWRkRnVuY3Rpb24ocCwgZnVuY3Rpb25zW3BdLCBvcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhZGROYXRpdmVGdW5jdGlvbnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGROYXRpdmVGdW5jdGlvbnMobmF0aXZlRnVuY3Rpb25zKSB7XG5cdFx0XHRmb3IgKHZhciBmdW5jdGlvbk5hbWUgaW4gbmF0aXZlRnVuY3Rpb25zKSB7XG5cdFx0XHRcdGlmICghbmF0aXZlRnVuY3Rpb25zLmhhc093blByb3BlcnR5KGZ1bmN0aW9uTmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0XHR0aGlzLmFkZE5hdGl2ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgbmF0aXZlRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25CdWlsZGVyQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFkZEZ1bmN0aW9uTm9kZVxuICAgKlxuICAgKiBAZGVzYyBBZGQgdGhlIGZ1bmN0aW9uIG5vZGUgZGlyZWN0bHlcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbk5vZGV9IGluTm9kZSAtIGZ1bmN0aW9uTm9kZSB0byBhZGRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZEZ1bmN0aW9uTm9kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZEZ1bmN0aW9uTm9kZShpbk5vZGUpIHtcblx0XHRcdHRoaXMubm9kZU1hcFtpbk5vZGUuZnVuY3Rpb25OYW1lXSA9IGluTm9kZTtcblx0XHRcdGlmIChpbk5vZGUuaXNSb290S2VybmVsKSB7XG5cdFx0XHRcdHRoaXMucm9vdEtlcm5lbCA9IGluTm9kZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uQnVpbGRlckJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSB0cmFjZUZ1bmN0aW9uQ2FsbHNcbiAgICpcbiAgICogQGRlc2MgVHJhY2UgYWxsIHRoZSBkZXBlbmRpbmcgZnVuY3Rpb25zIGJlaW5nIGNhbGxlZCwgZnJvbSBhIHNpbmdsZSBmdW5jdGlvblxuICAgKlxuICAgKiBUaGlzIGFsbG93IGZvciAndW5uZWVkZWQnIGZ1bmN0aW9ucyB0byBiZSBhdXRvbWF0aWNhbGx5IG9wdGltaXplZCBvdXQuXG4gICAqIE5vdGUgdGhhdCB0aGUgMC1pbmRleCwgaXMgdGhlIHN0YXJ0aW5nIGZ1bmN0aW9uIHRyYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25OYW1lIC0gRnVuY3Rpb24gbmFtZSB0byB0cmFjZSBmcm9tLCBkZWZhdWx0IHRvICdrZXJuZWwnXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IHJldExpc3QgLSBSZXR1cm5pbmcgbGlzdCBvZiBmdW5jdGlvbiBuYW1lcyB0aGF0IGlzIHRyYWNlZC4gSW5jbHVkaW5nIGl0c2VsZi5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJlbnRdIC0gUGFyZW50IG5vZGVcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ1tdfSAgUmV0dXJuaW5nIGxpc3Qgb2YgZnVuY3Rpb24gbmFtZXMgdGhhdCBpcyB0cmFjZWQuIEluY2x1ZGluZyBpdHNlbGYuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd0cmFjZUZ1bmN0aW9uQ2FsbHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB0cmFjZUZ1bmN0aW9uQ2FsbHMoZnVuY3Rpb25OYW1lLCByZXRMaXN0LCBwYXJlbnQpIHtcblx0XHRcdGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZSB8fCAna2VybmVsJztcblx0XHRcdHJldExpc3QgPSByZXRMaXN0IHx8IFtdO1xuXG5cdFx0XHR2YXIgZk5vZGUgPSB0aGlzLm5vZGVNYXBbZnVuY3Rpb25OYW1lXTtcblx0XHRcdGlmIChmTm9kZSkge1xuXHRcdFx0XHQvLyBDaGVjayBpZiBmdW5jdGlvbiBhbHJlYWR5IGV4aXN0c1xuXHRcdFx0XHR2YXIgZnVuY3Rpb25JbmRleCA9IHJldExpc3QuaW5kZXhPZihmdW5jdGlvbk5hbWUpO1xuXHRcdFx0XHRpZiAoZnVuY3Rpb25JbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRyZXRMaXN0LnB1c2goZnVuY3Rpb25OYW1lKTtcblx0XHRcdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdFx0XHRmTm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZOb2RlLmdldEZ1bmN0aW9uU3RyaW5nKCk7IC8vZW5zdXJlIEpTIHRyYWNlIGlzIGRvbmVcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZOb2RlLmNhbGxlZEZ1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0dGhpcy50cmFjZUZ1bmN0aW9uQ2FsbHMoZk5vZGUuY2FsbGVkRnVuY3Rpb25zW2ldLCByZXRMaXN0LCBmTm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qKlxuICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3B1anMvZ3B1LmpzL2lzc3Vlcy8yMDdcbiAgICAgICogaWYgZGVwZW5kZW50IGZ1bmN0aW9uIGlzIGFscmVhZHkgaW4gdGhlIGxpc3QsIGJlY2F1c2UgYSBmdW5jdGlvbiBkZXBlbmRzIG9uIGl0LCBhbmQgYmVjYXVzZSBpdCBoYXNcbiAgICAgICogYWxyZWFkeSBiZWVuIHRyYWNlZCwgd2Uga25vdyB0aGF0IHdlIG11c3QgbW92ZSB0aGUgZGVwZW5kZW50IGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHRoZSByZXRMaXN0LlxuICAgICAgKiAqL1xuXHRcdFx0XHRcdHZhciBkZXBlbmRhbnRGdW5jdGlvbk5hbWUgPSByZXRMaXN0LnNwbGljZShmdW5jdGlvbkluZGV4LCAxKVswXTtcblx0XHRcdFx0XHRyZXRMaXN0LnB1c2goZGVwZW5kYW50RnVuY3Rpb25OYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5uYXRpdmVGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXSkge1xuXHRcdFx0XHRpZiAocmV0TGlzdC5pbmRleE9mKGZ1bmN0aW9uTmFtZSkgPj0gMCkge1xuXHRcdFx0XHRcdC8vIERvZXMgbm90aGluZyBpZiBhbHJlYWR5IHRyYWNlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldExpc3QucHVzaChmdW5jdGlvbk5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXRMaXN0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25CdWlsZGVyQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFkZEtlcm5lbFxuICAgKlxuICAgKiBAZGVzYyBBZGQgYSBuZXcga2VybmVsIHRvIHRoaXMgaW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZuU3RyaW5nIC0gS2VybmVsIGZ1bmN0aW9uIGFzIGEgU3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU2V0dGluZ3Mgb2JqZWN0IHRvIHNldCBjb25zdGFudHMsIGRlYnVnIG1vZGUsIGV0Yy5cbiAgICpcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIGluc2VydGVkIGtlcm5lbCBhcyBhIEtlcm5lbCBOb2RlXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhZGRLZXJuZWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRLZXJuZWwoZm5TdHJpbmcsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBrZXJuZWxOb2RlID0gbmV3IHRoaXMuTm9kZSgna2VybmVsJywgZm5TdHJpbmcsIG9wdGlvbnMpO1xuXHRcdFx0a2VybmVsTm9kZS5zZXRCdWlsZGVyKHRoaXMpO1xuXHRcdFx0a2VybmVsTm9kZS5pc1Jvb3RLZXJuZWwgPSB0cnVlO1xuXHRcdFx0dGhpcy5hZGRGdW5jdGlvbk5vZGUoa2VybmVsTm9kZSk7XG5cdFx0XHRyZXR1cm4ga2VybmVsTm9kZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uQnVpbGRlckJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhZGRTdWJLZXJuZWxcbiAgICpcbiAgICogQGRlc2MgQWRkIGEgbmV3IHN1Yi1rZXJuZWwgdG8gdGhlIGN1cnJlbnQga2VybmVsIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpzRnVuY3Rpb24gLSBTdWIta2VybmVsIGZ1bmN0aW9uIChKYXZhU2NyaXB0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFNldHRpbmdzIG9iamVjdCB0byBzZXQgY29uc3RhbnRzLCBkZWJ1ZyBtb2RlLCBldGMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbnNlcnRlZCBzdWIta2VybmVsIGFzIGEgS2VybmVsIE5vZGVcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZFN1Yktlcm5lbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFN1Yktlcm5lbChqc0Z1bmN0aW9uLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIga2VybmVsTm9kZSA9IG5ldyB0aGlzLk5vZGUobnVsbCwganNGdW5jdGlvbiwgb3B0aW9ucyk7XG5cdFx0XHRrZXJuZWxOb2RlLnNldEJ1aWxkZXIodGhpcyk7XG5cdFx0XHRrZXJuZWxOb2RlLmlzU3ViS2VybmVsID0gdHJ1ZTtcblx0XHRcdHRoaXMuYWRkRnVuY3Rpb25Ob2RlKGtlcm5lbE5vZGUpO1xuXHRcdFx0cmV0dXJuIGtlcm5lbE5vZGU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBDUFVGdW5jdGlvbkJ1aWxkZXIjXG4gICAqIEBuYW1lIGdldFByb3RvdHlwZVN0cmluZ1xuICAgKiBAZnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2MgUmV0dXJuIHRoZSBzdHJpbmcgZm9yIGEgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bmN0aW9uTmFtZSAtIEZ1bmN0aW9uIG5hbWUgdG8gdHJhY2UgZnJvbS4gSWYgbnVsbCwgaXQgcmV0dXJucyB0aGUgV0hPTEUgYnVpbGRlciBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZnVsbCBzdHJpbmcsIG9mIGFsbCB0aGUgdmFyaW91cyBmdW5jdGlvbnMuIFRyYWNlIG9wdGltaXplZCBpZiBmdW5jdGlvbk5hbWUgZ2l2ZW5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFByb3RvdHlwZVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFByb3RvdHlwZVN0cmluZyhmdW5jdGlvbk5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFByb3RvdHlwZXMoZnVuY3Rpb25OYW1lKS5qb2luKCdcXG4nKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIENQVUZ1bmN0aW9uQnVpbGRlciNcbiAgICogQG5hbWUgZ2V0UHJvdG90eXBlU3RyaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKlxuICAgKiBAZGVzYyBSZXR1cm4gdGhlIHN0cmluZyBmb3IgYSBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2Z1bmN0aW9uTmFtZV0gLSBGdW5jdGlvbiBuYW1lIHRvIHRyYWNlIGZyb20uIElmIG51bGwsIGl0IHJldHVybnMgdGhlIFdIT0xFIGJ1aWxkZXIgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgZnVsbCBzdHJpbmcsIG9mIGFsbCB0aGUgdmFyaW91cyBmdW5jdGlvbnMuIFRyYWNlIG9wdGltaXplZCBpZiBmdW5jdGlvbk5hbWUgZ2l2ZW5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFByb3RvdHlwZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVzKGZ1bmN0aW9uTmFtZSkge1xuXHRcdFx0dGhpcy5yb290S2VybmVsLmdlbmVyYXRlKCk7XG5cdFx0XHRpZiAoZnVuY3Rpb25OYW1lKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyh0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUsIFtdKS5yZXZlcnNlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UHJvdG90eXBlc0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMubm9kZU1hcCkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25CdWlsZGVyQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzXG4gICAqXG4gICAqIEBkZXNjIEdldCBzdHJpbmcgZnJvbSBmdW5jdGlvbiBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBmdW5jdGlvbkxpc3QgLSBMaXN0IG9mIGZ1bmN0aW9uIHRvIGJ1aWxkIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nLCBvZiBhbGwgdGhlIHZhcmlvdXMgZnVuY3Rpb25zLiBUcmFjZSBvcHRpbWl6ZWQgaWYgZnVuY3Rpb25OYW1lIGdpdmVuXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKGZ1bmN0aW9uTGlzdCkge1xuXHRcdFx0dmFyIHJldCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbkxpc3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBbZnVuY3Rpb25MaXN0W2ldXTtcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHRyZXQucHVzaCh0aGlzLm5vZGVNYXBbZnVuY3Rpb25MaXN0W2ldXS5nZXRGdW5jdGlvblN0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldC5qb2luKCdcXG4nKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uQnVpbGRlckJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRQcm90b3R5cGVTdHJpbmdGcm9tRnVuY3Rpb25OYW1lc1xuICAgKlxuICAgKiBAZGVzYyBSZXR1cm4gc3RyaW5nIG9mIGFsbCBmdW5jdGlvbnMgY29udmVydGVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGZ1bmN0aW9uTGlzdCAtIExpc3Qgb2YgZnVuY3Rpb24gbmFtZXMgdG8gYnVpbGQgdGhlIHN0cmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHQgLSBTZXR0aW5ncyBvYmplY3QgcGFzc2VkIHRvIGZ1bmN0aW9uTm9kZS4gU2VlIGZ1bmN0aW9uTm9kZSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFByb3RvdHlwZXMgb2YgYWxsIGZ1bmN0aW9ucyBjb252ZXJ0ZWRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QsIG9wdCkge1xuXHRcdFx0dmFyIHJldCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbkxpc3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTGlzdFtpXTtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBbZnVuY3Rpb25OYW1lXTtcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHRyZXQucHVzaChub2RlLmdldEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nKG9wdCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMubmF0aXZlRnVuY3Rpb25zW2Z1bmN0aW9uTmFtZV0pIHtcblx0XHRcdFx0XHRyZXQucHVzaCh0aGlzLm5hdGl2ZUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uQnVpbGRlckJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRQcm90b3R5cGVTdHJpbmdGcm9tRnVuY3Rpb25OYW1lc1xuICAgKlxuICAgKiBAZGVzYyBSZXR1cm4gc3RyaW5nIG9mIGFsbCBmdW5jdGlvbnMgY29udmVydGVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGZ1bmN0aW9uTGlzdCAtIExpc3Qgb2YgZnVuY3Rpb24gbmFtZXMgdG8gYnVpbGQgdGhlIHN0cmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIFNldHRpbmdzIG9iamVjdCBwYXNzZWQgdG8gZnVuY3Rpb25Ob2RlLiBTZWUgZnVuY3Rpb25Ob2RlIGZvciBtb3JlIGRldGFpbHMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFByb3RvdHlwZSBzdHJpbmcgb2YgYWxsIGZ1bmN0aW9ucyBjb252ZXJ0ZWRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFByb3RvdHlwZVN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvdG90eXBlU3RyaW5nRnJvbUZ1bmN0aW9uTmFtZXMoZnVuY3Rpb25MaXN0LCBvcHQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFByb3RvdHlwZXNGcm9tRnVuY3Rpb25OYW1lcyhmdW5jdGlvbkxpc3QsIG9wdCkudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uQnVpbGRlckJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRTdHJpbmdcbiAgICpcbiAgICogR2V0IHN0cmluZyBmb3IgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bmN0aW9uTmFtZSAtIEZ1bmN0aW9uIG5hbWUgdG8gdHJhY2UgZnJvbS4gSWYgbnVsbCwgaXQgcmV0dXJucyB0aGUgV0hPTEUgYnVpbGRlciBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nLCBvZiBhbGwgdGhlIHZhcmlvdXMgZnVuY3Rpb25zLiBUcmFjZSBvcHRpbWl6ZWQgaWYgZnVuY3Rpb25OYW1lIGdpdmVuXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJpbmcoZnVuY3Rpb25OYW1lLCBvcHQpIHtcblx0XHRcdGlmIChvcHQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvcHQgPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZ1bmN0aW9uTmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRTdHJpbmdGcm9tRnVuY3Rpb25OYW1lcyh0aGlzLnRyYWNlRnVuY3Rpb25DYWxscyhmdW5jdGlvbk5hbWUsIFtdLCBvcHQpLnJldmVyc2UoKSwgb3B0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmdldFN0cmluZ0Zyb21GdW5jdGlvbk5hbWVzKE9iamVjdC5rZXlzKHRoaXMubm9kZU1hcCksIG9wdCk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEZ1bmN0aW9uQnVpbGRlckJhc2U7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbHMnKTtcbnZhciBhY29ybiA9IHJlcXVpcmUoJ2Fjb3JuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuICAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvbk5vZGVCYXNlXG4gICogXG4gICogQGRlc2MgUmVwcmVzZW50cyBhIHNpbmdsZSBmdW5jdGlvbiwgaW5zaWRlIEpTLCB3ZWJHTCwgb3Igb3BlbkdMLlxuICAqIFxuICAqIDxwPlRoaXMgaGFuZGxlcyBhbGwgdGhlIHJhdyBzdGF0ZSwgY29udmVydGVkIHN0YXRlLCBldGMuIE9mIGEgc2luZ2xlIGZ1bmN0aW9uLjwvcD5cbiAgKiBcbiAgKiBAcHJvcCB7U3RyaW5nfSBmdW5jdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBmdW5jdGlvblxuICAqIEBwcm9wIHtGdW5jdGlvbn0ganNGdW5jdGlvbiAtIFRoZSBKUyBGdW5jdGlvbiB0aGUgbm9kZSByZXByZXNlbnRzXG4gICogQHByb3Age1N0cmluZ30ganNGdW5jdGlvblN0cmluZyAtIGpzRnVuY3Rpb24udG9TdHJpbmcoKVxuICAqIEBwcm9wIHtTdHJpbmdbXX0gcGFyYW1OYW1lcyAtIFBhcmFtZXRlciBuYW1lcyBvZiB0aGUgZnVuY3Rpb25cbiAgKiBAcHJvcCB7U3RyaW5nW119IHBhcmFtVHlwZXMgLSBTaGFkZXIgbGFuZCBwYXJhbWV0ZXJzIHR5cGUgYXNzdW1wdGlvblxuICAqIEBwcm9wIHtCb29sZWFufSBpc1Jvb3RLZXJuZWwgLSBTcGVjaWFsIGluZGljYXRvciwgZm9yIGtlcm5lbCBmdW5jdGlvblxuICAqIEBwcm9wIHtTdHJpbmd9IHdlYmdsRnVuY3Rpb25TdHJpbmcgLSB3ZWJnbCBjb252ZXJ0ZWQgZnVuY3Rpb24gc3RyaW5nXG4gICogQHByb3Age1N0cmluZ30gb3BlbmdsRnVuY3Rpb25TdHJpbmcgLSBvcGVuZ2wgY29udmVydGVkIGZ1bmN0aW9uIHN0cmluZ1xuICAqIEBwcm9wIHtTdHJpbmdbXX0gY2FsbGVkRnVuY3Rpb25zIC0gTGlzdCBvZiBhbGwgdGhlIGZ1bmN0aW9ucyBjYWxsZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25OYW1lIC0gRnVuY3Rpb24gbmFtZSB0byBhc3N1bWUsIGlmIGl0cyBudWxsLCBpdCBhdHRlbXB0cyB0byBleHRyYWN0IGZyb20gdGhlIGZ1bmN0aW9uXG4gICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGpzRnVuY3Rpb24gLSBKUyBGdW5jdGlvbiB0byBkbyBjb252ZXJzaW9uXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgKlxuICAqL1xuXHRmdW5jdGlvbiBCYXNlRnVuY3Rpb25Ob2RlKGZ1bmN0aW9uTmFtZSwganNGdW5jdGlvbiwgb3B0aW9ucykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlRnVuY3Rpb25Ob2RlKTtcblxuXHRcdHRoaXMuY2FsbGVkRnVuY3Rpb25zID0gW107XG5cdFx0dGhpcy5jYWxsZWRGdW5jdGlvbnNBcmd1bWVudHMgPSB7fTtcblx0XHR0aGlzLmJ1aWxkZXIgPSBudWxsO1xuXHRcdHRoaXMuaXNSb290S2VybmVsID0gZmFsc2U7XG5cdFx0dGhpcy5pc1N1Yktlcm5lbCA9IGZhbHNlO1xuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHR0aGlzLmRlYnVnID0gbnVsbDtcblx0XHR0aGlzLnByb3RvdHlwZU9ubHkgPSBudWxsO1xuXHRcdHRoaXMuY29uc3RhbnRzID0gbnVsbDtcblx0XHR0aGlzLm91dHB1dCA9IG51bGw7XG5cdFx0dGhpcy5kZWNsYXJhdGlvbnMgPSB7fTtcblx0XHR0aGlzLnN0YXRlcyA9IFtdO1xuXHRcdHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBudWxsO1xuXG5cdFx0dmFyIHBhcmFtVHlwZXMgPSB2b2lkIDA7XG5cdFx0dmFyIHJldHVyblR5cGUgPSB2b2lkIDA7XG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdkZWJ1ZycpKSB7XG5cdFx0XHRcdHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZU9ubHknKSkge1xuXHRcdFx0XHR0aGlzLnByb3RvdHlwZU9ubHkgPSBvcHRpb25zLnByb3RvdHlwZU9ubHk7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RhbnRzJykpIHtcblx0XHRcdFx0dGhpcy5jb25zdGFudHMgPSBvcHRpb25zLmNvbnN0YW50cztcblx0XHRcdH1cblx0XHRcdGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdvdXRwdXQnKSkge1xuXHRcdFx0XHR0aGlzLm91dHB1dCA9IG9wdGlvbnMub3V0cHV0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2xvb3BNYXhJdGVyYXRpb25zJykpIHtcblx0XHRcdFx0dGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IG9wdGlvbnMubG9vcE1heEl0ZXJhdGlvbnM7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGFyYW1UeXBlcycpKSB7XG5cdFx0XHRcdHRoaXMucGFyYW1UeXBlcyA9IHBhcmFtVHlwZXMgPSBvcHRpb25zLnBhcmFtVHlwZXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29uc3RhbnRUeXBlcycpKSB7XG5cdFx0XHRcdHRoaXMuY29uc3RhbnRUeXBlcyA9IG9wdGlvbnMuY29uc3RhbnRUeXBlcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3JldHVyblR5cGUnKSkge1xuXHRcdFx0XHRyZXR1cm5UeXBlID0gb3B0aW9ucy5yZXR1cm5UeXBlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2ZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5JykpIHtcblx0XHRcdFx0dGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG9wdGlvbnMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3k7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBNaXNzaW5nIGpzRnVuY3Rpb24gb2JqZWN0IGV4Y2VwdGlvblxuXHRcdC8vXG5cdFx0aWYgKCFqc0Z1bmN0aW9uKSB7XG5cdFx0XHR0aHJvdyAnanNGdW5jdGlvbiwgcGFyYW1ldGVyIGlzIG1pc3NpbmcnO1xuXHRcdH1cblxuXHRcdC8vXG5cdFx0Ly8gU2V0dXAganNGdW5jdGlvbiBhbmQgaXRzIHN0cmluZyBwcm9wZXJ0eSArIHZhbGlkYXRlIHRoZW1cblx0XHQvL1xuXHRcdHRoaXMuanNGdW5jdGlvblN0cmluZyA9IGpzRnVuY3Rpb24udG9TdHJpbmcoKTtcblx0XHRpZiAoIXV0aWxzLmlzRnVuY3Rpb25TdHJpbmcodGhpcy5qc0Z1bmN0aW9uU3RyaW5nKSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignanNGdW5jdGlvbiwgdG8gc3RyaW5nIGNvbnZlcnNpb24gY2hlY2sgZmFpbGVkOiBub3QgYSBmdW5jdGlvbj8nLCB0aGlzLmpzRnVuY3Rpb25TdHJpbmcpO1xuXHRcdFx0dGhyb3cgJ2pzRnVuY3Rpb24sIHRvIHN0cmluZyBjb252ZXJzaW9uIGNoZWNrIGZhaWxlZDogbm90IGEgZnVuY3Rpb24/Jztcblx0XHR9XG5cblx0XHRpZiAoIXV0aWxzLmlzRnVuY3Rpb24oanNGdW5jdGlvbikpIHtcblx0XHRcdC8vdGhyb3cgJ2pzRnVuY3Rpb24sIGlzIG5vdCBhIHZhbGlkIEpTIEZ1bmN0aW9uJztcblx0XHRcdHRoaXMuanNGdW5jdGlvbiA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuanNGdW5jdGlvbiA9IGpzRnVuY3Rpb247XG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBTZXR1cCB0aGUgZnVuY3Rpb24gbmFtZSBwcm9wZXJ0eVxuXHRcdC8vXG5cdFx0dGhpcy5mdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUgfHwganNGdW5jdGlvbiAmJiBqc0Z1bmN0aW9uLm5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZyh0aGlzLmpzRnVuY3Rpb25TdHJpbmcpO1xuXG5cdFx0aWYgKCF0aGlzLmZ1bmN0aW9uTmFtZSkge1xuXHRcdFx0dGhyb3cgJ2pzRnVuY3Rpb24sIG1pc3NpbmcgbmFtZSBhcmd1bWVudCBvciB2YWx1ZSc7XG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBFeHRyYWN0IHBhcmFtZXRlciBuYW1lLCBhbmQgaXRzIGFyZ3VtZW50IHR5cGVzXG5cdFx0Ly9cblx0XHR0aGlzLnBhcmFtTmFtZXMgPSB1dGlscy5nZXRQYXJhbU5hbWVzRnJvbVN0cmluZyh0aGlzLmpzRnVuY3Rpb25TdHJpbmcpO1xuXHRcdGlmIChwYXJhbVR5cGVzKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXJhbVR5cGVzKSkge1xuXHRcdFx0XHRpZiAocGFyYW1UeXBlcy5sZW5ndGggIT09IHRoaXMucGFyYW1OYW1lcy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0aHJvdyAnSW52YWxpZCBhcmd1bWVudCB0eXBlIGFycmF5IGxlbmd0aCwgYWdhaW5zdCBmdW5jdGlvbiBsZW5ndGggLT4gKCcgKyBwYXJhbVR5cGVzLmxlbmd0aCArICcsJyArIHRoaXMucGFyYW1OYW1lcy5sZW5ndGggKyAnKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wYXJhbVR5cGVzID0gcGFyYW1UeXBlcztcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGVvZiBwYXJhbVR5cGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXJhbVR5cGVzKSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBwYXJhbVZhcmlhYmxlTmFtZXMgPSBPYmplY3Qua2V5cyhwYXJhbVR5cGVzKTtcblx0XHRcdFx0aWYgKHBhcmFtVHlwZXMuaGFzT3duUHJvcGVydHkoJ3JldHVybnMnKSkge1xuXHRcdFx0XHRcdHRoaXMucmV0dXJuVHlwZSA9IHBhcmFtVHlwZXMucmV0dXJucztcblx0XHRcdFx0XHRwYXJhbVZhcmlhYmxlTmFtZXMuc3BsaWNlKHBhcmFtVmFyaWFibGVOYW1lcy5pbmRleE9mKCdyZXR1cm5zJyksIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYXJhbVZhcmlhYmxlTmFtZXMubGVuZ3RoID4gMCAmJiBwYXJhbVZhcmlhYmxlTmFtZXMubGVuZ3RoICE9PSB0aGlzLnBhcmFtTmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGhyb3cgJ0ludmFsaWQgYXJndW1lbnQgdHlwZSBhcnJheSBsZW5ndGgsIGFnYWluc3QgZnVuY3Rpb24gbGVuZ3RoIC0+ICgnICsgcGFyYW1WYXJpYWJsZU5hbWVzLmxlbmd0aCArICcsJyArIHRoaXMucGFyYW1OYW1lcy5sZW5ndGggKyAnKSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJhbVR5cGVzID0gdGhpcy5wYXJhbU5hbWVzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0XHRpZiAocGFyYW1UeXBlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJhbVR5cGVzW2tleV07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wYXJhbVR5cGVzID0gW107XG5cdFx0fVxuXG5cdFx0Ly9cblx0XHQvLyBSZXR1cm4gdHlwZSBoYW5kbGluZ1xuXHRcdC8vXG5cdFx0aWYgKCF0aGlzLnJldHVyblR5cGUpIHtcblx0XHRcdHRoaXMucmV0dXJuVHlwZSA9IHJldHVyblR5cGUgfHwgJ051bWJlcic7XG5cdFx0fVxuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKEJhc2VGdW5jdGlvbk5vZGUsIFt7XG5cdFx0a2V5OiAnaXNJZGVudGlmaWVyQ29uc3RhbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0lkZW50aWZpZXJDb25zdGFudChwYXJhbU5hbWUpIHtcblx0XHRcdGlmICghdGhpcy5jb25zdGFudHMpIHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShwYXJhbU5hbWUpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2lzSW5wdXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0lucHV0KHBhcmFtTmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyYW1UeXBlc1t0aGlzLnBhcmFtTmFtZXMuaW5kZXhPZihwYXJhbU5hbWUpXSA9PT0gJ0lucHV0Jztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzZXRCdWlsZGVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0QnVpbGRlcihidWlsZGVyKSB7XG5cdFx0XHR0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncHVzaFN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlKSB7XG5cdFx0XHR0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdwb3BTdGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHBvcFN0YXRlKHN0YXRlKSB7XG5cdFx0XHRpZiAodGhpcy5zdGF0ZSAhPT0gc3RhdGUpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcG9wU3RhdGUgJyArIHN0YXRlICsgJyB3aGVuIGluICcgKyB0aGlzLnN0YXRlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc3RhdGVzLnBvcCgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2lzU3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc1N0YXRlKHN0YXRlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZSA9PT0gc3RhdGU7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0SnNGdW5jdGlvbicsXG5cblx0XHQvKipcbiAgICogXG4gICAqIENvcmUgRnVuY3Rpb25zXG4gICAqIFxuICAgKi9cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25Ob2RlQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGdldEpTRnVuY3Rpb25cbiAgICpcbiAgICogQGRlc2MgR2V0cyBhbmQgcmV0dXJuIHRoZSBzdG9yZWQgSlMgRnVuY3Rpb24uXG4gICAqIE5vdGU6IHRoYXQgdGhpcyBpbnRlcm5hbGx5IGV2YWwgdGhlIGZ1bmN0aW9uLCBpZiBvbmx5IHRoZSBzdHJpbmcgd2FzIHByb3ZpZGVkIG9uIGNvbnN0cnVjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBmdW5jdGlvbiBvYmplY3RcbiAgICpcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEpzRnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5qc0Z1bmN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmpzRnVuY3Rpb247XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmpzRnVuY3Rpb25TdHJpbmcpIHtcblx0XHRcdFx0dGhpcy5qc0Z1bmN0aW9uID0gZXZhbCh0aGlzLmpzRnVuY3Rpb25TdHJpbmcpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5qc0Z1bmN0aW9uO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyAnTWlzc2luZyBqc0Z1bmN0aW9uLCBhbmQganNGdW5jdGlvblN0cmluZyBwYXJhbWV0ZXInO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25Ob2RlQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGxcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgYmluYXJ5IGV4cHJlc3Npb24uXG4gICAqXG4gICAqIDxwPlV0aWxpdHkgZnVuY3Rpb24gZm9yIGFzdENhbGxFeHByZXNzaW9uLjwvcD5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBmdW5jdGlvbiBuYW1lc3BhY2UgY2FsbCwgdW5yb2xsZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdCkge1xuXHRcdFx0aWYgKGFzdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdFx0cmV0dXJuIGFzdC5uYW1lO1xuXHRcdFx0fSBlbHNlIGlmIChhc3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuXHRcdFx0XHRyZXR1cm4gJ3RoaXMnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuXHRcdFx0XHRpZiAoYXN0Lm9iamVjdCAmJiBhc3QucHJvcGVydHkpIHtcblx0XHRcdFx0XHQvL2JhYmVsIHNuaWZmaW5nXG5cdFx0XHRcdFx0aWYgKGFzdC5vYmplY3QuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBhc3Qub2JqZWN0Lm5hbWVbMF0gPT09ICdfJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QucHJvcGVydHkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0Lm9iamVjdCkgKyAnLicgKyB0aGlzLmFzdE1lbWJlckV4cHJlc3Npb25VbnJvbGwoYXN0LnByb3BlcnR5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL2JhYmVsIHNuaWZmaW5nXG5cdFx0XHRpZiAoYXN0Lmhhc093blByb3BlcnR5KCdleHByZXNzaW9ucycpKSB7XG5cdFx0XHRcdHZhciBmaXJzdEV4cHJlc3Npb24gPSBhc3QuZXhwcmVzc2lvbnNbMF07XG5cdFx0XHRcdGlmIChmaXJzdEV4cHJlc3Npb24udHlwZSA9PT0gJ0xpdGVyYWwnICYmIGZpcnN0RXhwcmVzc2lvbi52YWx1ZSA9PT0gMCAmJiBhc3QuZXhwcmVzc2lvbnMubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChhc3QuZXhwcmVzc2lvbnNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhaWx1cmUsIHVua25vd24gZXhwcmVzc2lvblxuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBDYWxsRXhwcmVzc2lvbl91bnJvbGwnLCBhc3QpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgRnVuY3Rpb25Ob2RlQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGdldEpzQVNUXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgY2xhc3MgZnVuY3Rpb24gSlMsIGFuZCByZXR1cm5zIGl0cyBBYnN0cmFjdCBTeW50YXggVHJlZSBvYmplY3QuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGNvbnZlcnQgdG8gc2hhZGVyIGNvZGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtpblBhcnNlcl0gLSBQYXJzZXIgdG8gdXNlLCBhc3N1bWVzIGluIHNjb3BlICdwYXJzZXInIGlmIG51bGwgb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmdW5jdGlvbiBBU1QgT2JqZWN0LCBub3RlIHRoYXQgcmVzdWx0IGlzIGNhY2hlZCB1bmRlciB0aGlzLmpzRnVuY3Rpb25BU1Q7XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRKc0FTVCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEpzQVNUKGluUGFyc2VyKSB7XG5cdFx0XHRpZiAodGhpcy5qc0Z1bmN0aW9uQVNUKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmpzRnVuY3Rpb25BU1Q7XG5cdFx0XHR9XG5cblx0XHRcdGluUGFyc2VyID0gaW5QYXJzZXIgfHwgYWNvcm47XG5cdFx0XHRpZiAoaW5QYXJzZXIgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgJ01pc3NpbmcgSlMgdG8gQVNUIHBhcnNlcic7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhc3QgPSBpblBhcnNlci5wYXJzZSgndmFyICcgKyB0aGlzLmZ1bmN0aW9uTmFtZSArICcgPSAnICsgdGhpcy5qc0Z1bmN0aW9uU3RyaW5nICsgJzsnLCB7XG5cdFx0XHRcdGxvY2F0aW9uczogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoYXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93ICdGYWlsZWQgdG8gcGFyc2UgSlMgY29kZSc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRha2Ugb3V0IHRoZSBmdW5jdGlvbiBvYmplY3QsIG91dHNpZGUgdGhlIHZhciBkZWNsYXJhdGlvbnNcblx0XHRcdHZhciBmdW5jQVNUID0gYXN0LmJvZHlbMF0uZGVjbGFyYXRpb25zWzBdLmluaXQ7XG5cdFx0XHR0aGlzLmpzRnVuY3Rpb25BU1QgPSBmdW5jQVNUO1xuXG5cdFx0XHRyZXR1cm4gZnVuY0FTVDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uTm9kZUJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRGdW5jdGlvblN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgd2ViZ2wgc2hhZGVyIGZ1bmN0aW9uIGVxdWl2YWxlbnQgb2YgdGhlIEpTIGZ1bmN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHdlYmdsIGZ1bmN0aW9uIHN0cmluZywgcmVzdWx0IGlzIGNhY2hlZCB1bmRlciB0aGlzLndlYkdsRnVuY3Rpb25TdHJpbmdcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEZ1bmN0aW9uU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0RnVuY3Rpb25TdHJpbmcoKSB7XG5cdFx0XHR0aGlzLmdlbmVyYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvblN0cmluZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uTm9kZUJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXRGdW5jdGlvblN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBTZXQgdGhlIGZ1bmN0aW9uU3RyaW5nIHZhbHVlLCBvdmVyd3JpdGluZyBpdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY3Rpb25TdHJpbmcgLSBTaGFkZXIgY29kZSBzdHJpbmcsIHJlcHJlc2VudGluZyB0aGUgZnVuY3Rpb25cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEZ1bmN0aW9uU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0RnVuY3Rpb25TdHJpbmcoZnVuY3Rpb25TdHJpbmcpIHtcblx0XHRcdHRoaXMuZnVuY3Rpb25TdHJpbmcgPSBmdW5jdGlvblN0cmluZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uTm9kZUJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRQYXJhbVR5cGVcbiAgICpcbiAgICogQGRlc2MgUmV0dXJuIHRoZSB0eXBlIG9mIHBhcmFtZXRlciBzZW50IHRvIHN1Yktlcm5lbC9LZXJuZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbU5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gVHlwZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXJhbVR5cGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJhbVR5cGUocGFyYW1OYW1lKSB7XG5cdFx0XHR2YXIgcGFyYW1JbmRleCA9IHRoaXMucGFyYW1OYW1lcy5pbmRleE9mKHBhcmFtTmFtZSk7XG5cdFx0XHRpZiAocGFyYW1JbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0aWYgKHRoaXMuZGVjbGFyYXRpb25zLmhhc093blByb3BlcnR5KHBhcmFtTmFtZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnNbcGFyYW1OYW1lXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gJ051bWJlcic7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghdGhpcy5wYXJlbnQpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wYXJhbVR5cGVzW3BhcmFtSW5kZXhdKSByZXR1cm4gdGhpcy5wYXJhbVR5cGVzW3BhcmFtSW5kZXhdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLnBhcmFtVHlwZXNbcGFyYW1JbmRleF0pIHJldHVybiB0aGlzLnBhcmFtVHlwZXNbcGFyYW1JbmRleF07XG5cdFx0XHRcdFx0dmFyIGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRzID0gdGhpcy5wYXJlbnQuY2FsbGVkRnVuY3Rpb25zQXJndW1lbnRzW3RoaXMuZnVuY3Rpb25OYW1lXTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgY2FsbGVkRnVuY3Rpb25Bcmd1bWVudCA9IGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRbcGFyYW1JbmRleF0gIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMucGFyYW1UeXBlc1twYXJhbUluZGV4XSA9IGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRbcGFyYW1JbmRleF0udHlwZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAnTnVtYmVyJztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdnZXRDb25zdGFudFR5cGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRDb25zdGFudFR5cGUoY29uc3RhbnROYW1lKSB7XG5cdFx0XHRpZiAodGhpcy5jb25zdGFudFR5cGVzW2NvbnN0YW50TmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RhbnRUeXBlc1tjb25zdGFudE5hbWVdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBGdW5jdGlvbk5vZGVCYXNlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgZ2V0VXNlclBhcmFtTmFtZVxuICAgKlxuICAgKiBAZGVzYyBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlICp1c2VyIHBhcmFtZXRlciooc3ViS2VybmVsIHBhcmFtZXRlcikgY29ycmVzcG9uZGluZyBcbiAgICogdG8gdGhlIHBhcmFtZXRlciBzdXBwbGllZCB0byB0aGUga2VybmVsXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbU5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRVc2VyUGFyYW1OYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VXNlclBhcmFtTmFtZShwYXJhbU5hbWUpIHtcblx0XHRcdHZhciBwYXJhbUluZGV4ID0gdGhpcy5wYXJhbU5hbWVzLmluZGV4T2YocGFyYW1OYW1lKTtcblx0XHRcdGlmIChwYXJhbUluZGV4ID09PSAtMSkgcmV0dXJuIG51bGw7XG5cdFx0XHRpZiAoIXRoaXMucGFyZW50IHx8ICF0aGlzLmlzU3ViS2VybmVsKSByZXR1cm4gbnVsbDtcblx0XHRcdHZhciBjYWxsZWRGdW5jdGlvbkFyZ3VtZW50cyA9IHRoaXMucGFyZW50LmNhbGxlZEZ1bmN0aW9uc0FyZ3VtZW50c1t0aGlzLmZ1bmN0aW9uTmFtZV07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjYWxsZWRGdW5jdGlvbkFyZ3VtZW50ID0gY2FsbGVkRnVuY3Rpb25Bcmd1bWVudHNbaV07XG5cdFx0XHRcdHZhciBwYXJhbSA9IGNhbGxlZEZ1bmN0aW9uQXJndW1lbnRbcGFyYW1JbmRleF07XG5cdFx0XHRcdGlmIChwYXJhbSAhPT0gbnVsbCAmJiBwYXJhbS50eXBlICE9PSAnSW50ZWdlcicpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyYW0ubmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZ2VuZXJhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZShvcHRpb25zKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlIG5vdCBkZWZpbmVkIG9uIEJhc2VGdW5jdGlvbk5vZGUnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEZ1bmN0aW9uTm9kZUJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RHZW5lcmljXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yIGdlbmVyaWNhbGx5IHRvIGl0cyByZXNwZWN0aXZlIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCBzdHJpbmcgYXJyYXlcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEdlbmVyaWMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RHZW5lcmljKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoYXN0ID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ05VTEwgYXN0JywgYXN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdFtpXSwgcmV0QXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN3aXRjaCAoYXN0LnR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ0Z1bmN0aW9uRXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RGdW5jdGlvbkV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ1JldHVyblN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ0xpdGVyYWwnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0TGl0ZXJhbChhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RCaW5hcnlFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRjYXNlICdJZGVudGlmaWVyJzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdElkZW50aWZpZXJFeHByZXNzaW9uKGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RBc3NpZ25tZW50RXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RFeHByZXNzaW9uU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRjYXNlICdFbXB0eVN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RFbXB0eVN0YXRlbWVudChhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0QmxvY2tTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ0lmU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdElmU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRjYXNlICdCcmVha1N0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RCcmVha1N0YXRlbWVudChhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnQ29udGludWVTdGF0ZW1lbnQnOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0Q29udGludWVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ0ZvclN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RGb3JTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRjYXNlICdEb1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdERvV2hpbGVTdGF0ZW1lbnQoYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0VmFyaWFibGVEZWNsYXJhdGlvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnVmFyaWFibGVEZWNsYXJhdG9yJzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdFZhcmlhYmxlRGVjbGFyYXRvcihhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0VGhpc0V4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ1NlcXVlbmNlRXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RTZXF1ZW5jZUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RVbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0VXBkYXRlRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnTG9naWNhbEV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0TG9naWNhbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ01lbWJlckV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvbihhc3QsIHJldEFycik7XG5cdFx0XHRcdFx0Y2FzZSAnQ2FsbEV4cHJlc3Npb24nOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXN0Q2FsbEV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hc3RBcnJheUV4cHJlc3Npb24oYXN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFzdERlYnVnZ2VyU3RhdGVtZW50KGFzdCwgcmV0QXJyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ1Vua25vd24gYXN0IHR5cGUgOiAnICsgYXN0LnR5cGUsIGFzdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0RXJyb3JPdXRwdXRcbiAgICogQGlnbm9yZVxuICAgKiBAZGVzYyBUbyB0aHJvdyB0aGUgQVNUIGVycm9yLCB3aXRoIGl0cyBsb2NhdGlvbi5cbiAgICpcbiAgICogQHRvZG8gYWRkIGxvY2F0aW9uIHN1cHBvcnQgZnByIHRoZSBBU1QgZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIC0gdGhlIGVycm9yIG1lc3NhZ2Ugb3V0cHV0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB3aGVyZSB0aGUgZXJyb3IgaXNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEVycm9yT3V0cHV0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0RXJyb3JPdXRwdXQoZXJyb3IsIGFzdCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcih1dGlscy5nZXRBc3RTdHJpbmcodGhpcy5qc0Z1bmN0aW9uU3RyaW5nLCBhc3QpKTtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IsIGFzdCwgdGhpcyk7XG5cdFx0XHRyZXR1cm4gZXJyb3I7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RGVidWdnZXJTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3REZWJ1Z2dlclN0YXRlbWVudChhcnJOb2RlLCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RnVuY3Rpb25EZWNsYXJhdGlvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEZ1bmN0aW9uRGVjbGFyYXRpb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RnVuY3Rpb25FeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0RnVuY3Rpb25FeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdFJldHVyblN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFJldHVyblN0YXRlbWVudChhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RMaXRlcmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0TGl0ZXJhbChhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RCaW5hcnlFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0QmluYXJ5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RJZGVudGlmaWVyRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdEFzc2lnbm1lbnRFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RXhwcmVzc2lvblN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEV4cHJlc3Npb25TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RW1wdHlTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RFbXB0eVN0YXRlbWVudChhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RCbG9ja1N0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEJsb2NrU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdElmU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0SWZTdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0QnJlYWtTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RCcmVha1N0YXRlbWVudChhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RDb250aW51ZVN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdENvbnRpbnVlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdEZvclN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEZvclN0YXRlbWVudChhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RXaGlsZVN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFdoaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdERvV2hpbGVTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3REb1doaWxlU3RhdGVtZW50KGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdFZhcmlhYmxlRGVjbGFyYXRpb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RWYXJpYWJsZURlY2xhcmF0aW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdFZhcmlhYmxlRGVjbGFyYXRvcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFZhcmlhYmxlRGVjbGFyYXRvcihhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RUaGlzRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFRoaXNFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdFNlcXVlbmNlRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFNlcXVlbmNlRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RVbmFyeUV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RVbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0VXBkYXRlRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFVwZGF0ZUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0TG9naWNhbEV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RMb2dpY2FsRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RNZW1iZXJFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0TWVtYmVyRXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RDYWxsRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FzdEFycmF5RXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEFycmF5RXhwcmVzc2lvbihhc3QsIHJldEFycikge1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGlnbm9yZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgcHVzaFBhcmFtZXRlclxuICAgKlxuICAgKiBAZGVzYyBbSU5URVJOQUxdIHB1c2hlcyBhIGZuIHBhcmFtZXRlciBvbnRvIHJldEFyciBhbmQgJ2Nhc3RzJyB0byBpbnQgaWYgbmVjZXNzYXJ5XG4gICAqICBpLmUuIGRlYWwgd2l0aCBmb3JjZS1pbnQtcGFyYW1ldGVyIHN0YXRlXG4gICAqIFx0XHRcdFxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbWV0ZXIgLSB0aGUgcGFyYW1ldGVyIG5hbWUgIFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncHVzaFBhcmFtZXRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHB1c2hQYXJhbWV0ZXIocmV0QXJyLCBwYXJhbWV0ZXIpIHtcblx0XHRcdGlmICh0aGlzLmlzU3RhdGUoJ2luLWdldC1jYWxsLXBhcmFtZXRlcnMnKSkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnaW50KCcgKyBwYXJhbWV0ZXIgKyAnKScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0QXJyLnB1c2gocGFyYW1ldGVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzdGF0ZScsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZXMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEJhc2VGdW5jdGlvbk5vZGU7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWxzJyk7XG52YXIgSW5wdXQgPSByZXF1aXJlKCcuLi9jb3JlL2lucHV0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuICAqIEBjb25zdHJ1Y3RvciBLZXJuZWxCYXNlXG4gICogXG4gICogQGRlc2MgSW1wbGVtZW50cyB0aGUgYmFzZSBjbGFzcyBmb3IgS2VybmVscywgYW5kIGlzIHVzZWQgYXMgYSBcbiAgKiBwYXJlbnQgY2xhc3MgZm9yIGFsbCBLZXJuZWwgaW1wbGVtZW50YXRpb25zLlxuICAqXG4gICogVGhpcyBjb250YWlucyB0aGUgYmFzaWMgbWV0aG9kcyBuZWVkZWQgYnkgYWxsIEtlcm5lbCBpbXBsZW1lbnRhdGlvbnMsIFxuICAqIGxpa2Ugc2V0RGltZW5zaW9ucywgYWRkU3ViS2VybmVsLCBldGMuXG4gICogXG4gICogQHByb3Age0FycmF5fSBwYXJhbU5hbWVzIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVycyBvZiB0aGUga2VybmVsIGZ1bmN0aW9uXG4gICogQHByb3Age1N0cmluZ30gZm5TdHJpbmcgLSBLZXJuZWwgZnVuY3Rpb24gYXMgYSBTdHJpbmdcbiAgKiBAcHJvcCB7QXJyYXl9IGRpbWVuc2lvbnMgLSBEaW1lbnNpb25zIG9mIHRoZSBrZXJuZWwgZnVuY3Rpb24sIHRoaXMudGhyZWFkLngsIGV0Yy5cbiAgKiBAcHJvcCB7Qm9vbGVhbn0gZGVidWcgLSBUb2dnbGUgZGVidWcgbW9kZVxuICAqIEBwcm9wIHtTdHJpbmd9IGdyYXBoaWNhbCAtIFRvZ2dsZSBncmFwaGljYWwgbW9kZVxuICAqIEBwcm9wIHtudW1iZXJ9IGxvb3BNYXhJdGVyYXRpb25zIC0gTWF4aW11bSBudW1iZXIgb2YgbG9vcCBpdGVyYXRpb25zXG4gICogQHByb3Age09iamVjdH0gY29uc3RhbnRzIC0gR2xvYmFsIGNvbnN0YW50c1xuICAqIEBwcm9wIHtBcnJheX0gc3ViS2VybmVscyAtIFN1YiBrZXJuZWxzIGJvdW5kIHRvIHRoaXMga2VybmVsIGluc3RhbmNlXG4gICogQHByb3Age09iamVjdH0gc3ViS2VybmVsUHJvcGVydGllcyAtIFN1YiBrZXJuZWxzIGJvdW5kIHRvIHRoaXMga2VybmVsIGluc3RhbmNlIGFzIGtleS92YWx1ZSBwYWlyc1xuICAqIEBwcm9wIHtBcnJheX0gc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcyAtIE5hbWVzIG9mIHRoZSB2YXJpYWJsZXMgb3V0cHV0dGVkIGJ5IHRoZSBzdWJrZXJsc1xuICAqIEBwcm9wIHtCb29sZWFufSBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAtIGZpeCBpc3N1ZXMgd2l0aCBzb21lIGdyYXBoaWNzIGNhcmRzIG5vdCByZXR1cm5pbmcgd2hvbGUgbnVtYmVycyB3aGVuIGRpdmlkaW5nIGJ5IGZhY3RvcnMgb2YgM1xuICAqXG4gICovXG5cdGZ1bmN0aW9uIEtlcm5lbEJhc2UoZm5TdHJpbmcsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtlcm5lbEJhc2UpO1xuXG5cdFx0dGhpcy5wYXJhbU5hbWVzID0gdXRpbHMuZ2V0UGFyYW1OYW1lc0Zyb21TdHJpbmcoZm5TdHJpbmcpO1xuXHRcdHRoaXMuZm5TdHJpbmcgPSBmblN0cmluZztcblx0XHR0aGlzLm91dHB1dCA9IG51bGw7XG5cdFx0dGhpcy5kZWJ1ZyA9IGZhbHNlO1xuXHRcdHRoaXMuZ3JhcGhpY2FsID0gZmFsc2U7XG5cdFx0dGhpcy5sb29wTWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0dGhpcy5jb25zdGFudHMgPSBudWxsO1xuXHRcdHRoaXMud3JhcGFyb3VuZCA9IG51bGw7XG5cdFx0dGhpcy5oYXJkY29kZUNvbnN0YW50cyA9IG51bGw7XG5cdFx0dGhpcy5vdXRwdXRUb1RleHR1cmUgPSBudWxsO1xuXHRcdHRoaXMub3V0cHV0SW1tdXRhYmxlID0gbnVsbDtcblx0XHR0aGlzLnRleFNpemUgPSBudWxsO1xuXHRcdHRoaXMuX2NhbnZhcyA9IG51bGw7XG5cdFx0dGhpcy5fd2ViR2wgPSBudWxsO1xuXHRcdHRoaXMudGhyZWFkRGltID0gbnVsbDtcblx0XHR0aGlzLmZsb2F0VGV4dHVyZXMgPSBudWxsO1xuXHRcdHRoaXMuZmxvYXRPdXRwdXQgPSBudWxsO1xuXHRcdHRoaXMuZmxvYXRPdXRwdXRGb3JjZSA9IG51bGw7XG5cdFx0dGhpcy5hZGRGdW5jdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5mdW5jdGlvbnMgPSBudWxsO1xuXHRcdHRoaXMubmF0aXZlRnVuY3Rpb25zID0gbnVsbDtcblx0XHR0aGlzLnN1Yktlcm5lbHMgPSBudWxsO1xuXHRcdHRoaXMuc3ViS2VybmVsUHJvcGVydGllcyA9IG51bGw7XG5cdFx0dGhpcy5zdWJLZXJuZWxOYW1lcyA9IG51bGw7XG5cdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzID0gbnVsbDtcblx0XHR0aGlzLmZ1bmN0aW9uQnVpbGRlciA9IG51bGw7XG5cdFx0dGhpcy5wYXJhbVR5cGVzID0gbnVsbDtcblx0XHR0aGlzLnBhcmFtU2l6ZXMgPSBudWxsO1xuXHRcdHRoaXMuY29uc3RhbnRUeXBlcyA9IG51bGw7XG5cdFx0dGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IG51bGw7XG5cblx0XHRmb3IgKHZhciBwIGluIHNldHRpbmdzKSB7XG5cdFx0XHRpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KHApIHx8ICF0aGlzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcblx0XHRcdHRoaXNbcF0gPSBzZXR0aW5nc1twXTtcblx0XHR9XG5cdFx0aWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdjYW52YXMnKSkge1xuXHRcdFx0dGhpcy5fY2FudmFzID0gc2V0dGluZ3MuY2FudmFzO1xuXHRcdH1cblx0XHRpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3dlYkdsJykpIHtcblx0XHRcdHRoaXMuX3dlYkdsID0gc2V0dGluZ3Mud2ViR2w7XG5cdFx0fVxuXHRcdGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnb3V0cHV0JykpIHtcblx0XHRcdHRoaXMuc2V0T3V0cHV0KHNldHRpbmdzLm91dHB1dCk7IC8vIEZsYXR0ZW4gb3V0cHV0IG9iamVjdFxuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fY2FudmFzKSB0aGlzLl9jYW52YXMgPSB1dGlscy5pbml0Q2FudmFzKCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoS2VybmVsQmFzZSwgW3tcblx0XHRrZXk6ICdidWlsZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJ1aWxkKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdcImJ1aWxkXCIgbm90IGRlZmluZWQgb24gQmFzZScpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgS2VybmVsQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHNldHVwUGFyYW1zXG4gICAqXG4gICAqIEBkZXNjIFNldHVwIHRoZSBwYXJhbWV0ZXIgdHlwZXMgZm9yIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHN1cHBsaWVkIHRvIHRoZSBLZXJuZWwgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtJQXJndW1lbnRzfSBhcmdzIC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0dXBQYXJhbXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXR1cFBhcmFtcyhhcmdzKSB7XG5cdFx0XHR0aGlzLnBhcmFtVHlwZXMgPSBbXTtcblx0XHRcdHRoaXMucGFyYW1TaXplcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBhcmcgPSBhcmdzW2ldO1xuXG5cdFx0XHRcdHRoaXMucGFyYW1UeXBlcy5wdXNoKHV0aWxzLmdldEFyZ3VtZW50VHlwZShhcmcpKTtcblx0XHRcdFx0dGhpcy5wYXJhbVNpemVzLnB1c2goYXJnLmNvbnN0cnVjdG9yID09PSBJbnB1dCA/IGFyZy5zaXplIDogbnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0dXBDb25zdGFudHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXR1cENvbnN0YW50cygpIHtcblx0XHRcdHRoaXMuY29uc3RhbnRUeXBlcyA9IHt9O1xuXHRcdFx0aWYgKHRoaXMuY29uc3RhbnRzKSB7XG5cdFx0XHRcdGZvciAodmFyIHAgaW4gdGhpcy5jb25zdGFudHMpIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN0YW50VHlwZXNbcF0gPSB1dGlscy5nZXRBcmd1bWVudFR5cGUodGhpcy5jb25zdGFudHNbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0RnVuY3Rpb25zJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0RnVuY3Rpb25zKGZ1bmN0aW9ucykge1xuXHRcdFx0dGhpcy5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXRPdXRwdXRcbiAgICpcbiAgICogQGRlc2MgU2V0IGRpbWVuc2lvbnMgb2YgdGhlIGtlcm5lbCBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb3V0cHV0IC0gVGhlIG91dHB1dCBhcnJheSB0byBzZXQgdGhlIGtlcm5lbCBvdXRwdXQgc2l6ZSB0b1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0T3V0cHV0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0T3V0cHV0KG91dHB1dCkge1xuXHRcdFx0aWYgKG91dHB1dC5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG5cdFx0XHRcdGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3knKSkge1xuXHRcdFx0XHRcdGlmIChvdXRwdXQuaGFzT3duUHJvcGVydHkoJ3onKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5vdXRwdXQgPSBbb3V0cHV0LngsIG91dHB1dC55LCBvdXRwdXQuel07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMub3V0cHV0ID0gW291dHB1dC54LCBvdXRwdXQueV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMub3V0cHV0ID0gW291dHB1dC54XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXREZWJ1Z1xuICAgKlxuICAgKiBAZGVzYyBUb2dnbGUgZGVidWcgbW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYWcgLSB0cnVlIHRvIGVuYWJsZSBkZWJ1Z1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0RGVidWcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXREZWJ1ZyhmbGFnKSB7XG5cdFx0XHR0aGlzLmRlYnVnID0gZmxhZztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgS2VybmVsQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHNldEdyYXBoaWNhbFxuICAgKlxuICAgKiBAZGVzYyBUb2dnbGUgZ3JhcGhpY2FsIG91dHB1dCBtb2RlXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmxhZyAtIHRydWUgdG8gZW5hYmxlIGdyYXBoaWNhbCBvdXRwdXRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEdyYXBoaWNhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldEdyYXBoaWNhbChmbGFnKSB7XG5cdFx0XHR0aGlzLmdyYXBoaWNhbCA9IGZsYWc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXRMb29wTWF4SXRlcmF0aW9uc1xuICAgKlxuICAgKiBAZGVzYyBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGxvb3AgaXRlcmF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gaXRlcmF0aW9ucyBjb3VudFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0TG9vcE1heEl0ZXJhdGlvbnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRMb29wTWF4SXRlcmF0aW9ucyhtYXgpIHtcblx0XHRcdHRoaXMubG9vcE1heEl0ZXJhdGlvbnMgPSBtYXg7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXRGaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuICAgKlxuICAgKiBAZGVzYyBGaXggZGl2aXNpb24gYnkgZmFjdG9yIG9mIDMgRlAgYWNjdXJhY3kgYnVnXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4IC0gc2hvdWxkIGZpeCBcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0Rml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3koZml4KSB7XG5cdFx0XHR0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gZml4O1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBLZXJuZWxCYXNlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgc2V0Q29uc3RhbnRzXG4gICAqIEBkZXNjIFNldCBDb25zdGFudHNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldENvbnN0YW50cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldENvbnN0YW50cyhjb25zdGFudHMpIHtcblx0XHRcdHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0V3JhcGFyb3VuZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFdyYXBhcm91bmQoZmxhZykge1xuXHRcdFx0Y29uc29sZS53YXJuKCdXcmFwYXJvdW5kIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBhbmQgdW5kb2N1bWVudGVkLicpO1xuXHRcdFx0dGhpcy53cmFwYXJvdW5kID0gZmxhZztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3NldEhhcmRjb2RlQ29uc3RhbnRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0SGFyZGNvZGVDb25zdGFudHMoZmxhZykge1xuXHRcdFx0dGhpcy5oYXJkY29kZUNvbnN0YW50cyA9IGZsYWc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzZXRPdXRwdXRUb1RleHR1cmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRPdXRwdXRUb1RleHR1cmUoZmxhZykge1xuXHRcdFx0dGhpcy5vdXRwdXRUb1RleHR1cmUgPSBmbGFnO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0T3V0cHV0SW1tdXRhYmxlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0T3V0cHV0SW1tdXRhYmxlKGZsYWcpIHtcblx0XHRcdHRoaXMub3V0cHV0SW1tdXRhYmxlID0gZmxhZztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgS2VybmVsQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHNldEZsb2F0VGV4dHVyZXNcbiAgICpcbiAgICogQGRlc2MgVG9nZ2xlIHRleHR1cmUgb3V0cHV0IG1vZGVcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBmbGFnIC0gdHJ1ZSB0byBlbmFibGUgZmxvYXRUZXh0dXJlc1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0RmxvYXRUZXh0dXJlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldEZsb2F0VGV4dHVyZXMoZmxhZykge1xuXHRcdFx0dGhpcy5mbG9hdFRleHR1cmVzID0gZmxhZztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgS2VybmVsQmFzZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHNldEZsb2F0T3V0cHV0XG4gICAqXG4gICAqIEBkZXNjIFRvZ2dsZSBvdXRwdXQgbW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZsYWcgLSB0cnVlIHRvIGVuYWJsZSBmbG9hdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0RmxvYXRPdXRwdXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRGbG9hdE91dHB1dChmbGFnKSB7XG5cdFx0XHR0aGlzLmZsb2F0T3V0cHV0ID0gZmxhZztcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3NldEZsb2F0T3V0cHV0Rm9yY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRGbG9hdE91dHB1dEZvcmNlKGZsYWcpIHtcblx0XHRcdHRoaXMuZmxvYXRPdXRwdXRGb3JjZSA9IGZsYWc7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXRDYW52YXNcbiAgICpcbiAgICogQGRlc2MgQmluZCB0aGUgY2FudmFzIHRvIGtlcm5lbFxuICAgKiBcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhcyAtIENhbnZhcyB0byBiaW5kXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRDYW52YXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRDYW52YXMoY2FudmFzKSB7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBjYW52YXM7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBzZXRDYW52YXNcbiAgICpcbiAgICogQGRlc2MgQmluZCB0aGUgd2ViR0wgaW5zdGFuY2UgdG8ga2VybmVsXG4gICAqIFxuICAgKiBAcGFyYW0ge0NhbnZhc30gd2ViR0wgLSB3ZWJHTCBpbnN0YW5jZSB0byBiaW5kXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRXZWJHbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFdlYkdsKHdlYkdsKSB7XG5cdFx0XHR0aGlzLl93ZWJHbCA9IHdlYkdsO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBLZXJuZWxCYXNlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgZ2V0Q2FudmFzKClcbiAgICpcbiAgICogQGRlc2MgUmV0dXJucyB0aGUgY3VycmVudCBjYW52YXMgaW5zdGFuY2UgYm91bmQgdG8gdGhlIGtlcm5lbFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Q2FudmFzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FudmFzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRXZWJHbCgpXG4gICAqXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIGN1cnJlbnQgd2ViR2wgaW5zdGFuY2UgYm91bmQgdG8gdGhlIGtlcm5lbFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0V2ViR2wnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRXZWJHbCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl93ZWJHbDtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICd2YWxpZGF0ZU9wdGlvbnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRlT3B0aW9ucyBub3QgZGVmaW5lZCcpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2V4ZWMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBleGVjKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZXhlY3V0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2V4ZWN1dGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlKCkge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdFx0Ly9cblx0XHRcdC8vIFByZXBhcmUgdGhlIHJlcXVpcmVkIG9iamVjdHNcblx0XHRcdC8vXG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbYXJndW1lbnRzWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cblx0XHRcdC8vXG5cdFx0XHQvLyBTZXR1cCBhbmQgcmV0dXJuIHRoZSBwcm9taXNlLCBhbmQgZXhlY3V0ZSB0aGUgZnVuY3Rpb24sIGluIHN5bmNocm9ub3VzIG1vZGVcblx0XHRcdC8vXG5cdFx0XHRyZXR1cm4gdXRpbHMubmV3UHJvbWlzZShmdW5jdGlvbiAoYWNjZXB0LCByZWplY3QpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhY2NlcHQoX3RoaXMucnVuLmFwcGx5KF90aGlzLCBhcmdzKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIEVycm9yIDogdGhyb3cgcmVqZWN0aW9uXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRyZWplY3QoZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKiBcbiAgICogQG1lbWJlck9mIEtlcm5lbEJhc2UjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhZGRTdWJLZXJuZWxcbiAgICpcbiAgICogQGRlc2MgQWRkIGEgc3ViIGtlcm5lbCB0byB0aGUgcm9vdCBrZXJuZWwgaW5zdGFuY2UuXG4gICAqIFRoaXMgaXMgd2hhdCBgY3JlYXRlS2VybmVsTWFwYCB1c2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm5TdHJpbmcgLSBmdW5jdGlvbiAoYXMgYSBTdHJpbmcpIG9mIHRoZSBzdWJLZXJuZWwgdG8gYWRkXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhZGRTdWJLZXJuZWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRTdWJLZXJuZWwoZm5TdHJpbmcpIHtcblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbHMgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxzID0gW107XG5cdFx0XHRcdHRoaXMuc3ViS2VybmVsTmFtZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHRoaXMuc3ViS2VybmVscy5wdXNoKGZuU3RyaW5nKTtcblx0XHRcdHRoaXMuc3ViS2VybmVsTmFtZXMucHVzaCh1dGlscy5nZXRGdW5jdGlvbk5hbWVGcm9tU3RyaW5nKGZuU3RyaW5nKSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKiogXG4gICAqIEBtZW1iZXJPZiBLZXJuZWxCYXNlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYWRkU3ViS2VybmVsUHJvcGVydHlcbiAgICpcbiAgICogQGRlc2MgQWRkIGEgc3ViIGtlcm5lbCB0byB0aGUgcm9vdCBrZXJuZWwgaW5zdGFuY2UsIGluZGV4ZWQgYnkgYSBwcm9wZXJ0eSBuYW1lXG4gICAqIFRoaXMgaXMgd2hhdCBgY3JlYXRlS2VybmVsTWFwYCB1c2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSBzdWJLZXJuZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZuU3RyaW5nIC0gZnVuY3Rpb24gKGFzIGEgU3RyaW5nKSBvZiB0aGUgc3ViS2VybmVsIHRvIGFkZFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYWRkU3ViS2VybmVsUHJvcGVydHknLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRTdWJLZXJuZWxQcm9wZXJ0eShwcm9wZXJ0eSwgZm5TdHJpbmcpIHtcblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzID0ge307XG5cdFx0XHRcdHRoaXMuc3ViS2VybmVsTmFtZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IGFkZCBzdWIga2VybmVsICcgKyBwcm9wZXJ0eSArICcsIGFscmVhZHkgZGVmaW5lZCcpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzW3Byb3BlcnR5XSA9IGZuU3RyaW5nO1xuXHRcdFx0dGhpcy5zdWJLZXJuZWxOYW1lcy5wdXNoKHV0aWxzLmdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoZm5TdHJpbmcpKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FkZE5hdGl2ZUZ1bmN0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgc291cmNlKSB7XG5cdFx0XHR0aGlzLmZ1bmN0aW9uQnVpbGRlci5hZGROYXRpdmVGdW5jdGlvbihuYW1lLCBzb3VyY2UpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKlxuICAgKiBEZXN0cm95cyBhbGwgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtlcm5lbFxuICAgKlxuICAgKiBAbmFtZSBkZXN0cm95XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgS2VybmVsQmFzZSNcbiAgICpcbiAgICogKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZUNhbnZhc1JlZmVyZW5jZXMgcmVtdmUgYW55IGFzc29jaWF0ZWQgY2FudmFzIHJlZmVyZW5jZXM/XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkZXN0cm95Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHt9XG5cdH1dKTtcblxuXHRyZXR1cm4gS2VybmVsQmFzZTtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBrZXJuZWxSdW5TaG9ydGN1dChrZXJuZWwpIHtcblx0dmFyIHNob3J0Y3V0ID0gZnVuY3Rpb24gc2hvcnRjdXQoKSB7XG5cdFx0cmV0dXJuIGtlcm5lbC5ydW4uYXBwbHkoa2VybmVsLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdHV0aWxzLmFsbFByb3BlcnRpZXNPZihrZXJuZWwpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGlmIChrZXlbMF0gPT09ICdfJyAmJiBrZXlbMV0gPT09ICdfJykgcmV0dXJuO1xuXHRcdGlmICh0eXBlb2Yga2VybmVsW2tleV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmIChrZXkuc3Vic3RyaW5nKDAsIDMpID09PSAnYWRkJyB8fCBrZXkuc3Vic3RyaW5nKDAsIDMpID09PSAnc2V0Jykge1xuXHRcdFx0XHRzaG9ydGN1dFtrZXldID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGtlcm5lbFtrZXldLmFwcGx5KGtlcm5lbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRyZXR1cm4gc2hvcnRjdXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzaG9ydGN1dFtrZXldID0ga2VybmVsW2tleV0uYmluZChrZXJuZWwpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaG9ydGN1dC5fX2RlZmluZUdldHRlcl9fKGtleSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4ga2VybmVsW2tleV07XG5cdFx0XHR9KTtcblx0XHRcdHNob3J0Y3V0Ll9fZGVmaW5lU2V0dGVyX18oa2V5LCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0a2VybmVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0c2hvcnRjdXQua2VybmVsID0ga2VybmVsO1xuXG5cdHJldHVybiBzaG9ydGN1dDtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWxzJyk7XG52YXIga2VybmVsUnVuU2hvcnRjdXQgPSByZXF1aXJlKCcuL2tlcm5lbC1ydW4tc2hvcnRjdXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG4gICogQGNvbnN0cnVjdG9yIEJhc2VSdW5uZXJcbiAgKlxuICAqIEBkZXNjIFJlcHJlc2VudHMgdGhlICdwcml2YXRlL3Byb3RlY3RlZCcgbmFtZXNwYWNlIG9mIHRoZSBHUFUgY2xhc3NcbiAgKlxuICAqIDxwPkkga25vdyBAcHJpdmF0ZSBtYWtlcyBtb3JlIHNlbnNlLCBidXQgc2luY2UgdGhlIGRvY3VtZW50YXRpb24gZW5naW5lIHN0YXRlIGlzIHVuZGV0aXJtaW5lZC5cbiAgKiAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHVqcy9ncHUuanMvaXNzdWVzLzE5IHJlZ2FyZGluZyBkb2N1bWVudGF0aW9uIGVuZ2luZSBpc3N1ZSlcbiAgKiBGaWxlIGlzb2xhdGlvbiBpcyBjdXJyZW50bHkgdGhlIGJlc3Qgd2F5IHRvIGdvLiA8L3A+XG4gICpcbiAgKiAqYmFzZS5qcyogaW50ZXJuYWwgZnVuY3Rpb25zIG5hbWVzcGFjZSA8YnI+XG4gICogKmdwdS5qcyogUFVCTElDIGZ1bmN0aW9uIG5hbWVzcGFjZSA8YnI+XG4gICpcbiAgKiBAcHJvcCB7T2JqZWN0fSBzZXR0aW5ncyAtIFNldHRpbmdzIG9iamVjdCB1c2VkIHRvIHNldCBEaW1lbnNpb25zLCBldGMuXG4gICogQHByb3Age1N0cmluZ30ga2VybmVsIC0gQ3VycmVudCBrZXJuZWwgaW5zdGFuY2VcbiAgKiBAcHJvcCB7T2JqZWN0fSBjYW52YXMgLSBDYW52YXMgaW5zdGFuY2UgYXR0YWNoZWQgdG8gdGhlIGtlcm5lbFxuICAqIEBwcm9wIHtPYmplY3R9IHdlYkdsIC0gV2ViR2wgaW5zdGFuY2UgYXR0YWNoZWQgdG8gdGhlIGtlcm5lbFxuICAqIEBwcm9wIHtGdW5jdGlvbn0gZm4gLSBLZXJuZWwgZnVuY3Rpb24gdG8gcnVuXG4gICogQHByb3Age09iamVjdH0gZnVuY3Rpb25CdWlsZGVyIC0gRnVuY3Rpb25CdWlsZGVyIGluc3RhbmNlXG4gICogQHByb3Age1N0cmluZ30gZm5TdHJpbmcgLSBLZXJuZWwgZnVuY3Rpb24gKGFzIGEgU3RyaW5nKVxuICAqIEBwcm9wIHtTdHJpbmd9IGVuZGlhbm5lc3MgLSBlbmRpYW4gaW5mb3JtYXRpb24gbGlrZSBMaXR0bGUtZW5kaWFuLCBCaWctZW5kaWFuLlxuICAqXG4gICovXG5cblx0ZnVuY3Rpb24gQmFzZVJ1bm5lcihmdW5jdGlvbkJ1aWxkZXIsIHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VSdW5uZXIpO1xuXG5cdFx0c2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcblx0XHR0aGlzLmtlcm5lbCA9IHNldHRpbmdzLmtlcm5lbDtcblx0XHR0aGlzLmNhbnZhcyA9IHNldHRpbmdzLmNhbnZhcztcblx0XHR0aGlzLndlYkdsID0gc2V0dGluZ3Mud2ViR2w7XG5cdFx0dGhpcy5mbiA9IG51bGw7XG5cdFx0dGhpcy5mdW5jdGlvbkJ1aWxkZXIgPSBmdW5jdGlvbkJ1aWxkZXI7XG5cdFx0dGhpcy5mblN0cmluZyA9IG51bGw7XG5cdFx0dGhpcy5lbmRpYW5uZXNzID0gdXRpbHMuc3lzdGVtRW5kaWFubmVzcygpO1xuXHR9XG5cblx0LyoqXG4gICogQG1lbWJlck9mIEJhc2VSdW5uZXIjXG4gICogQGZ1bmN0aW9uXG4gICogQG5hbWUgdGV4dHVyZVRvQXJyYXlcbiAgKlxuICAqIEBkZXNjIENvbnZlcnRzIHRoZSBwcm92aWRlZCBUZXh0dXJlIGluc3RhbmNlIHRvIGEgSmF2YVNjcmlwdCBBcnJheVxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IHRleHR1cmUgLSBUZXh0dXJlIE9iamVjdFxuICAqXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoQmFzZVJ1bm5lciwgW3tcblx0XHRrZXk6ICd0ZXh0dXJlVG9BcnJheScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHRleHR1cmVUb0FycmF5KHRleHR1cmUpIHtcblx0XHRcdHZhciBjb3B5ID0gdGhpcy5jcmVhdGVLZXJuZWwoZnVuY3Rpb24gKHgpIHtcblx0XHRcdFx0cmV0dXJuIHhbdGhpcy50aHJlYWQuel1bdGhpcy50aHJlYWQueV1bdGhpcy50aHJlYWQueF07XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGNvcHkodGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBCYXNlUnVubmVyI1xuICAgKiBAZnVuY3Rpb25cbiAgICpcbiAgICogQG5hbWUgZGVsZXRlVGV4dHVyZVxuICAgKlxuICAgKiBAZGVzYyBEZWxldGVzIHRoZSBwcm92aWRlZCBUZXh0dXJlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0dXJlIC0gVGV4dHVyZSBPYmplY3RcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2RlbGV0ZVRleHR1cmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkZWxldGVUZXh0dXJlKHRleHR1cmUpIHtcblx0XHRcdHRoaXMud2ViR2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLnRleHR1cmUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQmFzZVJ1bm5lciNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGJ1aWxkUHJvbWlzZUtlcm5lbFxuICAgKlxuICAgKiBAZGVzYyBHZXQgYW5kIHJldHVybnMgdGhlIEFTWU5DSFJPTk9VUyBleGVjdXRvciwgb2YgYSBjbGFzcyBhbmQga2VybmVsXG4gICAqIFRoaXMgcmV0dXJucyBhIFByb21pc2Ugb2JqZWN0IGZyb20gYW4gYXJndW1lbnQgc2V0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gY3VycmVudCBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2J1aWxkUHJvbWlzZUtlcm5lbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJ1aWxkUHJvbWlzZUtlcm5lbCgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2dldE1vZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdcIm1vZGVcIiBub3QgaW1wbGVtZW50ZWQgb24gQmFzZVJ1bm5lcicpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgQmFzZVJ1bm5lciNcbiAgICogQGZ1bmN0aW9uXG4gICAqXG4gICAqIEBuYW1lIGJ1aWxkS2VybmVsXG4gICAqXG4gICAqIEBkZXNjIEdldCBhbmQgcmV0dXJucyB0aGUgU3luY2hyb25vdXMgZXhlY3V0b3IsIG9mIGEgY2xhc3MgYW5kIGtlcm5lbFxuICAgKiBXaGljaCByZXR1cm5zIHRoZSByZXN1bHQgZGlyZWN0bHkgYWZ0ZXIgcGFzc2luZyB0aGUgYXJndW1lbnRzLlxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYnVpbGRLZXJuZWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBidWlsZEtlcm5lbChmbiwgc2V0dGluZ3MpIHtcblx0XHRcdHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MgfHwge30pO1xuXHRcdFx0dmFyIGZuU3RyaW5nID0gZm4udG9TdHJpbmcoKTtcblx0XHRcdGlmICghc2V0dGluZ3MuZnVuY3Rpb25CdWlsZGVyKSB7XG5cdFx0XHRcdHNldHRpbmdzLmZ1bmN0aW9uQnVpbGRlciA9IHRoaXMuZnVuY3Rpb25CdWlsZGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXNldHRpbmdzLmNhbnZhcykge1xuXHRcdFx0XHRzZXR0aW5ncy5jYW52YXMgPSB0aGlzLmNhbnZhcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFzZXR0aW5ncy53ZWJHbCkge1xuXHRcdFx0XHRzZXR0aW5ncy53ZWJHbCA9IHRoaXMud2ViZ2w7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBrZXJuZWxSdW5TaG9ydGN1dChuZXcgdGhpcy5LZXJuZWwoZm5TdHJpbmcsIHNldHRpbmdzKSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEJhc2VSdW5uZXI7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBGdW5jdGlvbkJ1aWxkZXJCYXNlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb24tYnVpbGRlci1iYXNlJyk7XG52YXIgV2ViR0xGdW5jdGlvbk5vZGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR0xGdW5jdGlvbkJ1aWxkZXJcbiAqXG4gKiBAZXh0ZW5kcyBGdW5jdGlvbkJ1aWxkZXJCYXNlXG4gKlxuICogQGRlc2MgQnVpbGRzIHdlYkdsIGZ1bmN0aW9ucyAoc2hhZGVycykgZnJvbSBKYXZhU2NyaXB0IGZ1bmN0aW9uIFN0cmluZ3NcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9GdW5jdGlvbkJ1aWxkZXJCYXNlKSB7XG5cdF9pbmhlcml0cyhXZWJHTEZ1bmN0aW9uQnVpbGRlciwgX0Z1bmN0aW9uQnVpbGRlckJhc2UpO1xuXG5cdGZ1bmN0aW9uIFdlYkdMRnVuY3Rpb25CdWlsZGVyKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTEZ1bmN0aW9uQnVpbGRlcik7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViR0xGdW5jdGlvbkJ1aWxkZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihXZWJHTEZ1bmN0aW9uQnVpbGRlcikpLmNhbGwodGhpcykpO1xuXG5cdFx0X3RoaXMuTm9kZSA9IFdlYkdMRnVuY3Rpb25Ob2RlO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vXG5cdC8vICBQb2x5ZmlsbCBzdHVmZlxuXHQvL1xuXHQvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8vIFJvdW5kIGZ1bmN0aW9uIHVzZWQgaW4gcG9seWZpbGxcblxuXG5cdF9jcmVhdGVDbGFzcyhXZWJHTEZ1bmN0aW9uQnVpbGRlciwgW3tcblx0XHRrZXk6ICdwb2x5ZmlsbFN0YW5kYXJkRnVuY3Rpb25zJyxcblxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBGdW5jdGlvbkJ1aWxkZXJCYXNlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgcG9seWZpbGxTdGFuZGFyZEZ1bmN0aW9uc1xuICAgKlxuICAgKiBAZGVzYyBQb2x5ZmlsbCBpbiB0aGUgbWlzc2luZyBNYXRoIGZ1bmN0aW9ucyAocm91bmQpXG4gICAqXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBwb2x5ZmlsbFN0YW5kYXJkRnVuY3Rpb25zKCkge1xuXHRcdFx0dGhpcy5hZGRGdW5jdGlvbigncm91bmQnLCBfcm91bmQpO1xuXHRcdH1cblx0fV0sIFt7XG5cdFx0a2V5OiAncm91bmQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByb3VuZChhKSB7XG5cdFx0XHRyZXR1cm4gX3JvdW5kKGEpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBXZWJHTEZ1bmN0aW9uQnVpbGRlcjtcbn0oRnVuY3Rpb25CdWlsZGVyQmFzZSk7XG5cbmZ1bmN0aW9uIF9yb3VuZChhKSB7XG5cdHJldHVybiBNYXRoLmZsb29yKGEgKyAwLjUpO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRnVuY3Rpb25Ob2RlQmFzZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9uLW5vZGUtYmFzZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlscycpO1xuLy8gQ2xvc3VyZSBjYXB0dXJlIGZvciB0aGUgYXN0IGZ1bmN0aW9uLCBwcmV2ZW50IGNvbGxpc2lvbiB3aXRoIGV4aXN0aW5nIEFTVCBmdW5jdGlvbnNcbi8vIFRoZSBwcmVmaXhlcyB0byB1c2VcbnZhciBqc01hdGhQcmVmaXggPSAnTWF0aC4nO1xudmFyIGxvY2FsUHJlZml4ID0gJ3RoaXMuJztcbnZhciBjb25zdGFudHNQcmVmaXggPSAndGhpcy5jb25zdGFudHMuJztcblxudmFyIERFQ09ERTMyX0VOQ09ERTMyID0gL2RlY29kZTMyXFwoXFxzK2VuY29kZTMyXFwoL2c7XG52YXIgRU5DT0RFMzJfREVDT0RFMzIgPSAvZW5jb2RlMzJcXChcXHMrZGVjb2RlMzJcXCgvZztcblxuLy8gdGhlc2UgZGVidWdzIHdlcmUgaHVnZWx5IHVzZWZ1bGwuLi5cbi8vIFRPRE86IG9wdGltaXNlIG91dCAtIHdlYnBhY2svYmFiZWwgb3B0aW9ucz8gbWF5YmUgc29tZSBnZW5lcmljIGxvZ2dpbmcgc3VwcG9ydCBpbiBjb3JlL3V0aWxzP1xuLy8gY29uc3QgZGVidWdMb2cgPSBjb25zb2xlLmxvZ1xudmFyIGRlYnVnTG9nID0gZnVuY3Rpb24gZGVidWdMb2coKSB7fTtcbi8qKlxuICogQGNsYXNzIFdlYkdMRnVuY3Rpb25Ob2RlXG4gKlxuICogQGRlc2MgW0lOVEVSTkFMXSBUYWtlcyBpbiBhIGZ1bmN0aW9uIG5vZGUsIGFuZCBkb2VzIGFsbCB0aGUgQVNUIHZvb2RvbyByZXF1aXJlZCB0byBnZW5lcmF0ZSBpdHMgcmVzcGVjdGl2ZSB3ZWJHTCBjb2RlLlxuICpcbiAqIEBleHRlbmRzIEZ1bmN0aW9uTm9kZUJhc2VcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uTm9kZX0gaW5Ob2RlIC0gVGhlIGZ1bmN0aW9uIG5vZGUgb2JqZWN0XG4gKlxuICogQHJldHVybnMgdGhlIGNvbnZlcnRlZCB3ZWJHTCBmdW5jdGlvbiBzdHJpbmdcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9GdW5jdGlvbk5vZGVCYXNlKSB7XG5cdF9pbmhlcml0cyhXZWJHTEZ1bmN0aW9uTm9kZSwgX0Z1bmN0aW9uTm9kZUJhc2UpO1xuXG5cdGZ1bmN0aW9uIFdlYkdMRnVuY3Rpb25Ob2RlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTEZ1bmN0aW9uTm9kZSk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFdlYkdMRnVuY3Rpb25Ob2RlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViR0xGdW5jdGlvbk5vZGUpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhXZWJHTEZ1bmN0aW9uTm9kZSwgW3tcblx0XHRrZXk6ICdnZW5lcmF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuXHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0ZGVidWdMb2codGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5wcm90b3R5cGVPbmx5KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uUHJvdG90eXBlKHRoaXMuZ2V0SnNBU1QoKSwgW10pLmpvaW4oJycpLnRyaW0oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZnVuY3Rpb25TdHJpbmdBcnJheSA9IHRoaXMuYXN0R2VuZXJpYyh0aGlzLmdldEpzQVNUKCksIFtdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnVuY3Rpb25TdHJpbmcgPSB3ZWJHbFJlZ2V4T3B0aW1pemUodGhpcy5mdW5jdGlvblN0cmluZ0FycmF5LmpvaW4oJycpLnRyaW0oKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvblN0cmluZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0RnVuY3Rpb25EZWNsYXJhdGlvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciB0byBpdHMgKm5hbWVkIGZ1bmN0aW9uIGRlY2xhcmF0aW9uKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RGdW5jdGlvbkRlY2xhcmF0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0RnVuY3Rpb25EZWNsYXJhdGlvbihhc3QsIHJldEFycikge1xuXHRcdFx0dGhpcy5idWlsZGVyLmFkZEZ1bmN0aW9uKG51bGwsIHV0aWxzLmdldEFzdFN0cmluZyh0aGlzLmpzRnVuY3Rpb25TdHJpbmcsIGFzdCkpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0RnVuY3Rpb25Qcm90b3R5cGVcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciB0byBpdHMgKm5hbWVkIGZ1bmN0aW9uIHByb3RvdHlwZSpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0RnVuY3Rpb25Qcm90b3R5cGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RGdW5jdGlvblByb3RvdHlwZShhc3QsIHJldEFycikge1xuXHRcdFx0Ly8gU2V0dXAgZnVuY3Rpb24gcmV0dXJuIHR5cGUgYW5kIG5hbWVcblx0XHRcdGlmICh0aGlzLmlzUm9vdEtlcm5lbCB8fCB0aGlzLmlzU3ViS2VybmVsKSB7XG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXR1cm5UeXBlID0gdGhpcy5yZXR1cm5UeXBlO1xuXHRcdFx0dmFyIHR5cGUgPSB0eXBlTWFwW3JldHVyblR5cGVdO1xuXHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcigndW5rbm93biB0eXBlICcgKyByZXR1cm5UeXBlKTtcblx0XHRcdH1cblx0XHRcdHJldEFyci5wdXNoKHR5cGUpO1xuXHRcdFx0cmV0QXJyLnB1c2goJyAnKTtcblx0XHRcdHJldEFyci5wdXNoKHRoaXMuZnVuY3Rpb25OYW1lKTtcblx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cblx0XHRcdC8vIEFyZ3VtZW50cyBoYW5kbGluZ1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcmFtTmFtZXMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXRBcnIucHVzaCh0aGlzLnBhcmFtVHlwZXNbaV0pO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnICcpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgndXNlcl8nKTtcblx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5wYXJhbU5hbWVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0QXJyLnB1c2goJyk7XFxuJyk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEZ1bmN0aW9uRXhwcmVzc2lvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciB0byBpdHMgKm5hbWVkIGZ1bmN0aW9uKlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RGdW5jdGlvbkV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RGdW5jdGlvbkV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblxuXHRcdFx0Ly8gU2V0dXAgZnVuY3Rpb24gcmV0dXJuIHR5cGUgYW5kIG5hbWVcblx0XHRcdGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgndm9pZCcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJldHVyblR5cGUgPSB0aGlzLnJldHVyblR5cGU7XG5cdFx0XHRcdHZhciB0eXBlID0gdHlwZU1hcFtyZXR1cm5UeXBlXTtcblx0XHRcdFx0aWYgKCF0eXBlKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGUgJyArIHJldHVyblR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldEFyci5wdXNoKHR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goJyAnKTtcblx0XHRcdHJldEFyci5wdXNoKHRoaXMuZnVuY3Rpb25OYW1lKTtcblx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cblx0XHRcdGlmICghdGhpcy5pc1Jvb3RLZXJuZWwpIHtcblx0XHRcdFx0Ly8gQXJndW1lbnRzIGhhbmRsaW5nXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJhbU5hbWVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0dmFyIHBhcmFtTmFtZSA9IHRoaXMucGFyYW1OYW1lc1tpXTtcblxuXHRcdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBwYXJhbVR5cGUgPSB0aGlzLmdldFBhcmFtVHlwZShwYXJhbU5hbWUpO1xuXHRcdFx0XHRcdHZhciBfdHlwZSA9IHR5cGVNYXBbcGFyYW1UeXBlXTtcblx0XHRcdFx0XHRpZiAoIV90eXBlKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gdHlwZSAnICsgcGFyYW1UeXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goX3R5cGUpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcgJyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VzZXJfJyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2gocGFyYW1OYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGdW5jdGlvbiBvcGVuaW5nXG5cdFx0XHRyZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cblx0XHRcdC8vIEJvZHkgc3RhdGVtZW50IGl0ZXJhdGlvblxuXHRcdFx0Zm9yICh2YXIgX2kgPSAwOyBfaSA8IGFzdC5ib2R5LmJvZHkubGVuZ3RoOyArK19pKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYm9keS5ib2R5W19pXSwgcmV0QXJyKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ1xcbicpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGdW5jdGlvbiBjbG9zaW5nXG5cdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0UmV0dXJuU3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yIHRvICpyZXR1cm4qIHN0YXRlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXN0IC0gdGhlIEFTVCBvYmplY3QgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RSZXR1cm5TdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RSZXR1cm5TdGF0ZW1lbnQoYXN0LCByZXRBcnIpIHtcblx0XHRcdGlmICh0aGlzLmlzUm9vdEtlcm5lbCkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgna2VybmVsUmVzdWx0ID0gJyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdyZXR1cm47Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXNTdWJLZXJuZWwpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5mdW5jdGlvbk5hbWUgKyAnUmVzdWx0ID0gJyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdyZXR1cm4gJyArIHRoaXMuZnVuY3Rpb25OYW1lICsgJ1Jlc3VsdDsnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCdyZXR1cm4gJyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vdGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dChcblx0XHRcdC8vXHQnTm9uIG1haW4gZnVuY3Rpb24gcmV0dXJuLCBpcyBub3Qgc3VwcG9ydGVkIDogJyt0aGlzLmN1cnJlbnRGdW5jdGlvbk5hbWVzcGFjZSxcblx0XHRcdC8vXHRhc3Rcblx0XHRcdC8vKTtcblxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0TGl0ZXJhbFxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqbGl0ZXJhbCB2YWx1ZSpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0TGl0ZXJhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdExpdGVyYWwoYXN0LCByZXRBcnIpIHtcblxuXHRcdFx0Ly8gUmVqZWN0IG5vbiBudW1lcmljIGxpdGVyYWxzXG5cdFx0XHRpZiAoaXNOYU4oYXN0LnZhbHVlKSkge1xuXHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdOb24tbnVtZXJpYyBsaXRlcmFsIG5vdCBzdXBwb3J0ZWQgOiAnICsgYXN0LnZhbHVlLCBhc3QpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXNoIHRoZSBsaXRlcmFsIHZhbHVlIGFzIGEgZmxvYXQvaW50XG5cdFx0XHRyZXRBcnIucHVzaChhc3QudmFsdWUpO1xuXG5cdFx0XHR2YXIgaW5HZXRQYXJhbXMgPSB0aGlzLmlzU3RhdGUoJ2luLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdC8vIElmIGl0IHdhcyBhbiBpbnQsIG5vZGUgbWFkZSBhIGZsb2F0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKE51bWJlci5pc0ludGVnZXIoYXN0LnZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWluR2V0UGFyYW1zKSB7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJy4wJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaW5HZXRQYXJhbXMpIHtcblx0XHRcdFx0Ly8gb3IgY2FzdCB0byBhbiBpbnQgYXMgd2UgYXJlIGFkZHJlc3NpbmcgYW4gaW5wdXQgYXJyYXlcblx0XHRcdFx0cmV0QXJyLnBvcCgpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnaW50KCcpO1xuXHRcdFx0XHRyZXRBcnIucHVzaChhc3QudmFsdWUpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RCaW5hcnlFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpiaW5hcnkqIGV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0QmluYXJ5RXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEJpbmFyeUV4cHJlc3Npb24oYXN0LCByZXRBcnIpIHtcblx0XHRcdHZhciBpbkdldFBhcmFtcyA9IHRoaXMuaXNTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0aWYgKGluR2V0UGFyYW1zKSB7XG5cdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdub3QtaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnaW50Jyk7XG5cdFx0XHR9XG5cdFx0XHRyZXRBcnIucHVzaCgnKCcpO1xuXG5cdFx0XHRpZiAoYXN0Lm9wZXJhdG9yID09PSAnJScpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2goJ21vZCgnKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnLCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0fSBlbHNlIGlmIChhc3Qub3BlcmF0b3IgPT09ICc9PT0nKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QubGVmdCwgcmV0QXJyKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJz09Jyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3QucmlnaHQsIHJldEFycik7XG5cdFx0XHR9IGVsc2UgaWYgKGFzdC5vcGVyYXRvciA9PT0gJyE9PScpIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnIT0nKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5yaWdodCwgcmV0QXJyKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiBhc3Qub3BlcmF0b3IgPT09ICcvJykge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnZGl2X3dpdGhfaW50X2NoZWNrKCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaChhc3Qub3BlcmF0b3IpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXG5cdFx0XHRpZiAoaW5HZXRQYXJhbXMpIHtcblx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnbm90LWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0SWRlbnRpZmllckV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKmlkZW50aWZpZXIqIGV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGlkdE5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdElkZW50aWZpZXJFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0SWRlbnRpZmllckV4cHJlc3Npb24oaWR0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoaWR0Tm9kZS50eXBlICE9PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnSWRlbnRpZmllckV4cHJlc3Npb24gLSBub3QgYW4gSWRlbnRpZmllcicsIGlkdE5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZG8gd2UgbmVlZCB0byBjYXN0IGFkZHJlc3NpbmcgdmFsZXMgdG8gZmxvYXQ/XG5cdFx0XHR2YXIgY2FzdEZsb2F0ID0gIXRoaXMuaXNTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXG5cdFx0XHRzd2l0Y2ggKGlkdE5vZGUubmFtZSkge1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWCc6XG5cdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueCcpO1xuXHRcdFx0XHRcdGNhc3RGbG9hdCAmJiByZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWSc6XG5cdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueScpO1xuXHRcdFx0XHRcdGNhc3RGbG9hdCAmJiByZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWic6XG5cdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueicpO1xuXHRcdFx0XHRcdGNhc3RGbG9hdCAmJiByZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfb3V0cHV0WCc6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfb3V0cHV0WSc6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfb3V0cHV0Wic6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueicpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdJbmZpbml0eSc6XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ3NTQzMTI3LzEzMjQwMzlcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnMy40MDI4MjM0NjZlKzM4Jyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dmFyIHVzZXJQYXJhbU5hbWUgPSB0aGlzLmdldFVzZXJQYXJhbU5hbWUoaWR0Tm9kZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAodXNlclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wdXNoUGFyYW1ldGVyKHJldEFyciwgJ3VzZXJfJyArIHVzZXJQYXJhbU5hbWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hQYXJhbWV0ZXIocmV0QXJyLCAndXNlcl8nICsgaWR0Tm9kZS5uYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEZvclN0YXRlbWVudFxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvcmZvciAqZm9yLWxvb3AqIGV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGZvck5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCB3ZWJnbCBzdHJpbmdcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEZvclN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEZvclN0YXRlbWVudChmb3JOb2RlLCByZXRBcnIpIHtcblx0XHRcdGlmIChmb3JOb2RlLnR5cGUgIT09ICdGb3JTdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgZm9yIHN0YXRtZW50JywgZm9yTm9kZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmb3JOb2RlLnRlc3QgJiYgZm9yTm9kZS50ZXN0LnR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJykge1xuXHRcdFx0XHRpZiAoZm9yTm9kZS50ZXN0LnJpZ2h0LnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBmb3JOb2RlLnRlc3Qub3BlcmF0b3IgPT09ICc8JyAmJiB0aGlzLmlzSWRlbnRpZmllckNvbnN0YW50KGZvck5vZGUudGVzdC5yaWdodC5uYW1lKSA9PT0gZmFsc2UpIHtcblxuXHRcdFx0XHRcdGlmICghdGhpcy5sb29wTWF4SXRlcmF0aW9ucykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdXYXJuaW5nOiBsb29wTWF4SXRlcmF0aW9ucyBpcyBub3Qgc2V0ISBVc2luZyBkZWZhdWx0IG9mIDEwMDAgd2hpY2ggbWF5IHJlc3VsdCBpbiB1bmludGVuZGVkIGJlaGF2aW9yLicpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdTZXQgbG9vcE1heEl0ZXJhdGlvbnMgb3IgdXNlIGEgZm9yIGxvb3Agb2YgZml4ZWQgbGVuZ3RoIHRvIHNpbGVuY2UgdGhpcyBtZXNzYWdlLicpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdmb3IgKCcpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmluaXQsIHJldEFycik7XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdC5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKGZvck5vZGUudGVzdC5vcGVyYXRvcik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ0xPT1BfTUFYJyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJzsnKTtcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS51cGRhdGUsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblxuXHRcdFx0XHRcdHJldEFyci5wdXNoKCd7XFxuJyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2lmICgnKTtcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LmxlZnQsIHJldEFycik7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goZm9yTm9kZS50ZXN0Lm9wZXJhdG9yKTtcblx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS50ZXN0LnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcpIHtcXG4nKTtcblx0XHRcdFx0XHRpZiAoZm9yTm9kZS5ib2R5LnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZm9yTm9kZS5ib2R5LmJvZHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUuYm9keS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZm9yTm9kZS5ib2R5LCByZXRBcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXFxufSBlbHNlIHtcXG4nKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgZGVjbGFyYXRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShmb3JOb2RlLmluaXQuZGVjbGFyYXRpb25zKSk7XG5cdFx0XHRcdFx0dmFyIHVwZGF0ZUFyZ3VtZW50ID0gZm9yTm9kZS51cGRhdGUuYXJndW1lbnQ7XG5cdFx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGRlY2xhcmF0aW9ucykgfHwgZGVjbGFyYXRpb25zLmxlbmd0aCA8IDEpIHtcblx0XHRcdFx0XHRcdGRlYnVnTG9nKHRoaXMuanNGdW5jdGlvblN0cmluZyk7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBJbmNvbXBhdGlibGUgZm9yIGxvb3AgZGVjbGFyYXRpb24nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBpbml0QXJndW1lbnQgPSBudWxsO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgX2kyKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb25zW19pMl07XG5cdFx0XHRcdFx0XHRcdGlmIChkZWNsYXJhdGlvbi5pZC5uYW1lID09PSB1cGRhdGVBcmd1bWVudC5uYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5pdEFyZ3VtZW50ID0gZGVjbGFyYXRpb247XG5cdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb25zLnNwbGljZShfaTIsIDEpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdmbG9hdCAnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoZGVjbGFyYXRpb24sIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJzsnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnZm9yIChmbG9hdCAnKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpbml0QXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnZm9yICgnKTtcblx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmluaXQsIHJldEFycik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGZvck5vZGUudGVzdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLnVwZGF0ZSwgcmV0QXJyKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhmb3JOb2RlLmJvZHksIHJldEFycik7XG5cdFx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIGZvciBzdGF0ZW1lbnQnLCBmb3JOb2RlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0V2hpbGVTdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKndoaWxlKiBsb29wXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB3aGlsZU5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHBhcnNlZCB3ZWJnbCBzdHJpbmdcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdFdoaWxlU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0V2hpbGVTdGF0ZW1lbnQod2hpbGVOb2RlLCByZXRBcnIpIHtcblx0XHRcdGlmICh3aGlsZU5vZGUudHlwZSAhPT0gJ1doaWxlU3RhdGVtZW50Jykge1xuXHRcdFx0XHR0aHJvdyB0aGlzLmFzdEVycm9yT3V0cHV0KCdJbnZhbGlkIHdoaWxlIHN0YXRtZW50Jywgd2hpbGVOb2RlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0QXJyLnB1c2goJ2ZvciAoZmxvYXQgaSA9IDAuMDsgaSA8IExPT1BfTUFYOyBpKyspIHsnKTtcblx0XHRcdHJldEFyci5wdXNoKCdpZiAoJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMod2hpbGVOb2RlLmJvZHksIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnfSBlbHNlIHtcXG4nKTtcblx0XHRcdHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcblx0XHRcdHJldEFyci5wdXNoKCd9XFxuJyk7XG5cdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RXaGlsZVN0YXRlbWVudFxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqZG8gd2hpbGUqIGxvb3BcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRvV2hpbGVOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBwYXJzZWQgd2ViZ2wgc3RyaW5nXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3REb1doaWxlU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0RG9XaGlsZVN0YXRlbWVudChkb1doaWxlTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoZG9XaGlsZU5vZGUudHlwZSAhPT0gJ0RvV2hpbGVTdGF0ZW1lbnQnKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0ludmFsaWQgd2hpbGUgc3RhdG1lbnQnLCBkb1doaWxlTm9kZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldEFyci5wdXNoKCdmb3IgKGZsb2F0IGkgPSAwLjA7IGkgPCBMT09QX01BWDsgaSsrKSB7Jyk7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZG9XaGlsZU5vZGUuYm9keSwgcmV0QXJyKTtcblx0XHRcdHJldEFyci5wdXNoKCdpZiAoIScpO1xuXHRcdFx0dGhpcy5hc3RHZW5lcmljKGRvV2hpbGVOb2RlLnRlc3QsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnKSB7XFxuJyk7XG5cdFx0XHRyZXRBcnIucHVzaCgnYnJlYWs7XFxuJyk7XG5cdFx0XHRyZXRBcnIucHVzaCgnfVxcbicpO1xuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0QXNzaWdubWVudEV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKkFzc2lnbm1lbnQqIEV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzc05vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEFzc2lnbm1lbnRFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0QXNzaWdubWVudEV4cHJlc3Npb24oYXNzTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoYXNzTm9kZS5vcGVyYXRvciA9PT0gJyU9Jykge1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnPScpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnbW9kKCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5sZWZ0LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnLCcpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcblx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhhc3NOb2RlLmxlZnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKGFzc05vZGUub3BlcmF0b3IpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoYXNzTm9kZS5yaWdodCwgcmV0QXJyKTtcblx0XHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0RW1wdHlTdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgYW4gKkVtcHR5KiBTdGF0ZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RFbXB0eVN0YXRlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdEVtcHR5U3RhdGVtZW50KGVOb2RlLCByZXRBcnIpIHtcblx0XHRcdC8vcmV0QXJyLnB1c2goJztcXG4nKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEJsb2NrU3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpCbG9jayogc3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiTm9kZSAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0QmxvY2tTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RCbG9ja1N0YXRlbWVudChiTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgne1xcbicpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiTm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhiTm9kZS5ib2R5W2ldLCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0QXJyLnB1c2goJ31cXG4nKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEV4cHJlc3Npb25TdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKmdlbmVyaWMgZXhwcmVzc2lvbiogc3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlc05vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEV4cHJlc3Npb25TdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RFeHByZXNzaW9uU3RhdGVtZW50KGVzTm9kZSwgcmV0QXJyKSB7XG5cdFx0XHR0aGlzLmFzdEdlbmVyaWMoZXNOb2RlLmV4cHJlc3Npb24sIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaCgnOycpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0VmFyaWFibGVEZWNsYXJhdGlvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqVmFyaWFibGUgRGVjbGFyYXRpb24qXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJkZWNOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RWYXJpYWJsZURlY2xhcmF0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJkZWNOb2RlLCByZXRBcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFyZGVjTm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGRlY2xhcmF0aW9uID0gdmFyZGVjTm9kZS5kZWNsYXJhdGlvbnNbaV07XG5cdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcsJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJldERlY2xhcmF0aW9uID0gW107XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhkZWNsYXJhdGlvbiwgcmV0RGVjbGFyYXRpb24pO1xuXHRcdFx0XHR2YXIgZGVjbGFyYXRpb25UeXBlID0gJ051bWJlcic7XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0dmFyIGluaXQgPSBkZWNsYXJhdGlvbi5pbml0O1xuXHRcdFx0XHRcdGlmIChpbml0KSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5pdC5vYmplY3QpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluaXQub2JqZWN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBpbml0Lm9iamVjdC5vYmplY3QpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzLnRocmVhZC54LCB0aGlzLnRocmVhZC55LCB0aGlzLnRocmVhZC56XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluaXQub2JqZWN0Lm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nICYmIGluaXQub2JqZWN0LnByb3BlcnR5ICYmIChpbml0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lID09PSAndGhyZWFkJyB8fCBpbml0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lID09PSAnb3V0cHV0JykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlY2xhcmF0aW9uVHlwZSA9ICdJbnRlZ2VyJztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gcGFyYW1bXVxuXHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGluaXQub2JqZWN0Lm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIF90eXBlMiA9IHRoaXMuZ2V0UGFyYW1UeXBlKGluaXQub2JqZWN0Lm9iamVjdC5uYW1lKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb25UeXBlID0gdHlwZUxvb2t1cE1hcFtfdHlwZTJdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcGFyYW1bXVtdXG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmIChpbml0Lm9iamVjdC5vYmplY3Qub2JqZWN0ICYmIGluaXQub2JqZWN0Lm9iamVjdC5vYmplY3QudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIF90eXBlMyA9IHRoaXMuZ2V0UGFyYW1UeXBlKGluaXQub2JqZWN0Lm9iamVjdC5vYmplY3QubmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb25UeXBlID0gdHlwZUxvb2t1cE1hcFtfdHlwZTNdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMuY29uc3RhbnRzLnBhcmFtW11cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAoaW5pdC5vYmplY3Qub2JqZWN0Lm9iamVjdCAmJiBpbml0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdCAmJiBpbml0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nICYmIGluaXQub2JqZWN0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSA9PT0gJ2NvbnN0YW50cycpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBfdHlwZTQgPSB0aGlzLmdldENvbnN0YW50VHlwZShpbml0Lm9iamVjdC5vYmplY3QucHJvcGVydHkubmFtZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvblR5cGUgPSB0eXBlTG9va3VwTWFwW190eXBlNF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMuY29uc3RhbnRzLnBhcmFtW11bXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsc2UgaWYgKGluaXQub2JqZWN0Lm9iamVjdC5vYmplY3QgJiYgaW5pdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3QgJiYgaW5pdC5vYmplY3Qub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0ICYmIGluaXQub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0Lm9iamVjdC50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nICYmIGluaXQub2JqZWN0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUgPT09ICdjb25zdGFudHMnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBfdHlwZTUgPSB0aGlzLmdldENvbnN0YW50VHlwZShpbml0Lm9iamVjdC5vYmplY3Qub2JqZWN0LnByb3BlcnR5Lm5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvblR5cGUgPSB0eXBlTG9va3VwTWFwW190eXBlNV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFkZWNsYXJhdGlvblR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gbG9va3VwIHR5cGUgJyArIHR5cGVMb29rdXBNYXApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5pdC5uYW1lICYmIHRoaXMuZGVjbGFyYXRpb25zW2luaXQubmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvblR5cGUgPSB0aGlzLmRlY2xhcmF0aW9uc1tpbml0Lm5hbWVdO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gJ0FycmF5RXhwcmVzc2lvbicpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvblR5cGUgPSAnQXJyYXkoJyArIGluaXQuZWxlbWVudHMubGVuZ3RoICsgJyknO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGluaXQudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBub2RlID0gdGhpcy5idWlsZGVyLm5vZGVNYXBbaW5pdC5jYWxsZWUubmFtZV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5vZGUgJiYgbm9kZS5yZXR1cm5UeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWNsYXJhdGlvblR5cGUgPSBub2RlLnJldHVyblR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0eXBlID0gdHlwZU1hcFtkZWNsYXJhdGlvblR5cGVdO1xuXHRcdFx0XHRcdGlmICghdHlwZSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0eXBlICcgKyBkZWNsYXJhdGlvblR5cGUgKyAnIG5vdCBoYW5kbGVkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldEFyci5wdXNoKHR5cGUgKyAnICcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZGVjbGFyYXRpb25zW2RlY2xhcmF0aW9uLmlkLm5hbWVdID0gZGVjbGFyYXRpb25UeXBlO1xuXHRcdFx0XHRyZXRBcnIucHVzaC5hcHBseShyZXRBcnIsIHJldERlY2xhcmF0aW9uKTtcblx0XHRcdH1cblx0XHRcdHJldEFyci5wdXNoKCc7Jyk7XG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xGdW5jdGlvbk5vZGUjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBhc3RWYXJpYWJsZURlY2xhcmF0b3JcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlZhcmlhYmxlIERlY2xhcmF0b3IqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdmFyZGVjTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0VmFyaWFibGVEZWNsYXJhdG9yJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0VmFyaWFibGVEZWNsYXJhdG9yKGl2YXJkZWNOb2RlLCByZXRBcnIpIHtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpdmFyZGVjTm9kZS5pZCwgcmV0QXJyKTtcblx0XHRcdGlmIChpdmFyZGVjTm9kZS5pbml0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKCc9Jyk7XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpdmFyZGVjTm9kZS5pbml0LCByZXRBcnIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0SWZTdGF0ZW1lbnRcbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKklmKiBTdGF0ZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGlmTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0SWZTdGF0ZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RJZlN0YXRlbWVudChpZk5vZGUsIHJldEFycikge1xuXHRcdFx0cmV0QXJyLnB1c2goJ2lmICgnKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUudGVzdCwgcmV0QXJyKTtcblx0XHRcdHJldEFyci5wdXNoKCcpJyk7XG5cdFx0XHRpZiAoaWZOb2RlLmNvbnNlcXVlbnQudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMoaWZOb2RlLmNvbnNlcXVlbnQsIHJldEFycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnIHtcXG4nKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGlmTm9kZS5jb25zZXF1ZW50LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnXFxufVxcbicpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaWZOb2RlLmFsdGVybmF0ZSkge1xuXHRcdFx0XHRyZXRBcnIucHVzaCgnZWxzZSAnKTtcblx0XHRcdFx0aWYgKGlmTm9kZS5hbHRlcm5hdGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcge1xcbicpO1xuXHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhpZk5vZGUuYWx0ZXJuYXRlLCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCdcXG59XFxuJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEJyZWFrU3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpCcmVhayogU3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBick5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdEJyZWFrU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0QnJlYWtTdGF0ZW1lbnQoYnJOb2RlLCByZXRBcnIpIHtcblx0XHRcdHJldEFyci5wdXNoKCdicmVhaztcXG4nKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdENvbnRpbnVlU3RhdGVtZW50XG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpDb250aW51ZSogU3RhdGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjck5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdENvbnRpbnVlU3RhdGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0Q29udGludWVTdGF0ZW1lbnQoY3JOb2RlLCByZXRBcnIpIHtcblx0XHRcdHJldEFyci5wdXNoKCdjb250aW51ZTtcXG4nKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdExvZ2ljYWxFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpMb2dpY2FsKiBFeHByZXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2dOb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RMb2dpY2FsRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdExvZ2ljYWxFeHByZXNzaW9uKGxvZ05vZGUsIHJldEFycikge1xuXHRcdFx0cmV0QXJyLnB1c2goJygnKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLmxlZnQsIHJldEFycik7XG5cdFx0XHRyZXRBcnIucHVzaChsb2dOb2RlLm9wZXJhdG9yKTtcblx0XHRcdHRoaXMuYXN0R2VuZXJpYyhsb2dOb2RlLnJpZ2h0LCByZXRBcnIpO1xuXHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdFVwZGF0ZUV4cHJlc3Npb25cbiAgICpcbiAgICogQGRlc2MgUGFyc2VzIHRoZSBhYnN0cmFjdCBzeW50YXggdHJlZSBmb3IgKlVwZGF0ZSogRXhwcmVzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdU5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdFVwZGF0ZUV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RVcGRhdGVFeHByZXNzaW9uKHVOb2RlLCByZXRBcnIpIHtcblx0XHRcdGlmICh1Tm9kZS5wcmVmaXgpIHtcblx0XHRcdFx0cmV0QXJyLnB1c2godU5vZGUub3BlcmF0b3IpO1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFzdEdlbmVyaWModU5vZGUuYXJndW1lbnQsIHJldEFycik7XG5cdFx0XHRcdHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0VW5hcnlFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpVbmFyeSogRXhwcmVzc2lvblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdU5vZGUgLSBBbiBhc3QgTm9kZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFwcGVuZCByZXRBcnJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FzdFVuYXJ5RXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdFVuYXJ5RXhwcmVzc2lvbih1Tm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRpZiAodU5vZGUucHJlZml4KSB7XG5cdFx0XHRcdHJldEFyci5wdXNoKHVOb2RlLm9wZXJhdG9yKTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKHVOb2RlLmFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRyZXRBcnIucHVzaCh1Tm9kZS5vcGVyYXRvcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdFRoaXNFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpUaGlzKiBleHByZXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0Tm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0VGhpc0V4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RUaGlzRXhwcmVzc2lvbih0Tm9kZSwgcmV0QXJyKSB7XG5cdFx0XHRyZXRBcnIucHVzaCgndGhpcycpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMRnVuY3Rpb25Ob2RlI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgYXN0TWVtYmVyRXhwcmVzc2lvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqTWVtYmVyKiBFeHByZXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtTm9kZSAtIEFuIGFzdCBOb2RlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0TWVtYmVyRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdE1lbWJlckV4cHJlc3Npb24obU5vZGUsIHJldEFycikge1xuXHRcdFx0ZGVidWdMb2coXCJbaW5dIGFzdE1lbWJlckV4cHJlc3Npb24gXCIgKyBtTm9kZS5vYmplY3QudHlwZSk7XG5cdFx0XHRpZiAobU5vZGUuY29tcHV0ZWQpIHtcblx0XHRcdFx0aWYgKG1Ob2RlLm9iamVjdC50eXBlID09PSAnSWRlbnRpZmllcicgfHwgbU5vZGUub2JqZWN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJlxuXHRcdFx0XHQvLyBtTm9kZS5vYmplY3Qub2JqZWN0ICYmXG5cdFx0XHRcdG1Ob2RlLm9iamVjdC5vYmplY3Qub2JqZWN0ICYmIG1Ob2RlLm9iamVjdC5vYmplY3Qub2JqZWN0LnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicgJiYgbU5vZGUub2JqZWN0Lm9iamVjdC5wcm9wZXJ0eS5uYW1lID09PSAnY29uc3RhbnRzJykge1xuXHRcdFx0XHRcdC8vIFdvcmtpbmcgbG9nZ2VyXG5cdFx0XHRcdFx0dmFyIHJlcU5hbWUgPSBtTm9kZS5vYmplY3QubmFtZTtcblx0XHRcdFx0XHR2YXIgZnVuY05hbWUgPSB0aGlzLmZ1bmN0aW9uTmFtZSB8fCAna2VybmVsJztcblx0XHRcdFx0XHR2YXIgYXNzdW1lTm90VGV4dHVyZSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gUG9zc2libHkgYW4gYXJyYXkgcmVxdWVzdCAtIGhhbmRsZSBpdCBhcyBzdWNoXG5cdFx0XHRcdFx0aWYgKHRoaXMucGFyYW1OYW1lcykge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCA9IHRoaXMucGFyYW1OYW1lcy5pbmRleE9mKHJlcU5hbWUpO1xuXHRcdFx0XHRcdFx0aWYgKGlkeCA+PSAwICYmIHRoaXMucGFyYW1UeXBlc1tpZHhdID09PSAnTnVtYmVyJykge1xuXHRcdFx0XHRcdFx0XHRhc3N1bWVOb3RUZXh0dXJlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVidWdMb2coXCItIGFzdE1lbWJlckV4cHJlc3Npb24gXCIgKyByZXFOYW1lICsgXCIgXCIgKyBmdW5jTmFtZSk7XG5cdFx0XHRcdFx0aWYgKGFzc3VtZU5vdFRleHR1cmUpIHtcblx0XHRcdFx0XHRcdC8vIEdldCBmcm9tIGFycmF5XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1tpbnQoJyk7XG5cdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKV0nKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGlzSW5HZXRQYXJhbXMgPSB0aGlzLmlzU3RhdGUoJ2luLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRcdHZhciBtdWx0aU1lbWJlckV4cHJlc3Npb24gPSB0aGlzLmlzU3RhdGUoJ211bHRpLW1lbWJlci1leHByZXNzaW9uJyk7XG5cdFx0XHRcdFx0XHRpZiAobXVsdGlNZW1iZXJFeHByZXNzaW9uKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ211bHRpLW1lbWJlci1leHByZXNzaW9uJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnbm90LWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblxuXHRcdFx0XHRcdFx0Ly8gVGhpcyBub3JtYWxseSByZWZlcnMgdG8gdGhlIGdsb2JhbCByZWFkIG9ubHkgaW5wdXQgdmFyc1xuXHRcdFx0XHRcdFx0dmFyIHZhcmlhYmxlVHlwZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAobU5vZGUub2JqZWN0Lm5hbWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuZGVjbGFyYXRpb25zW21Ob2RlLm9iamVjdC5uYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhcmlhYmxlVHlwZSA9IHRoaXMuZGVjbGFyYXRpb25zW21Ob2RlLm9iamVjdC5uYW1lXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR2YXJpYWJsZVR5cGUgPSB0aGlzLmdldFBhcmFtVHlwZShtTm9kZS5vYmplY3QubmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobU5vZGUub2JqZWN0ICYmIG1Ob2RlLm9iamVjdC5vYmplY3QgJiYgbU5vZGUub2JqZWN0Lm9iamVjdC5vYmplY3QgJiYgbU5vZGUub2JqZWN0Lm9iamVjdC5vYmplY3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJykge1xuXHRcdFx0XHRcdFx0XHR2YXJpYWJsZVR5cGUgPSB0aGlzLmdldENvbnN0YW50VHlwZShtTm9kZS5vYmplY3QucHJvcGVydHkubmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHZhcmlhYmxlVHlwZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdBcnJheSgyKSc6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ0FycmF5KDMpJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnQXJyYXkoNCknOlxuXHRcdFx0XHRcdFx0XHRcdC8vIEdldCBmcm9tIGxvY2FsIHZlYzRcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdbJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2gobU5vZGUucHJvcGVydHkucmF3KTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnXScpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChtdWx0aU1lbWJlckV4cHJlc3Npb24pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ25vdC1pbi1nZXQtY2FsbC1wYXJhbWV0ZXJzJyk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG5cdFx0XHRcdFx0XHRcdFx0Ly8gR2V0IGZyb20gaW1hZ2Vcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnZ2V0SW1hZ2UzRCgnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcsIGl2ZWMyKCcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1NpemVbMF0sJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnU2l6ZVsxXSksIGl2ZWMzKCcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ0RpbVswXSwnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdEaW1bMV0sJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnRGltWzJdJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJyksICcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ25vdC1pbi1nZXQtY2FsbC1wYXJhbWV0ZXJzJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wdXNoU3RhdGUoJ2luLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUucHJvcGVydHksIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFtdWx0aU1lbWJlckV4cHJlc3Npb24pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMucG9wU3RhdGUoJ2luLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlJzpcblx0XHRcdFx0XHRcdFx0XHQvLyBHZXQgZnJvbSBpbWFnZVxuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdnZXRJbWFnZTJEKCcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgaXZlYzIoJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnU2l6ZVswXSwnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdTaXplWzFdKSwgaXZlYzMoJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnRGltWzBdLCcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ0RpbVsxXSwnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdEaW1bMl0nKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKSwgJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnbm90LWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5wcm9wZXJ0eSwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIW11bHRpTWVtYmVyRXhwcmVzc2lvbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdC8vIEdldCBmcm9tIHRleHR1cmVcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNJbkdldFBhcmFtcykge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2ludCgnKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2dldCgnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCcsIGl2ZWMyKCcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ1NpemVbMF0sJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnU2l6ZVsxXSksIGl2ZWMzKCcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ0RpbVswXSwnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzdEdlbmVyaWMobU5vZGUub2JqZWN0LCByZXRBcnIpO1xuXHRcdFx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCdEaW1bMV0sJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnRGltWzJdJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJyksICcpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5vYmplY3QsIHJldEFycik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJ0JpdFJhdGlvJyk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0QXJyLnB1c2goJywgJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnbm90LWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhtTm9kZS5wcm9wZXJ0eSwgcmV0QXJyKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIW11bHRpTWVtYmVyRXhwcmVzc2lvbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpc0luR2V0UGFyYW1zKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRkZWJ1Z0xvZyhcIi0gYXN0TWVtYmVyRXhwcmVzc2lvbiBvYmo6XCIsIG1Ob2RlLm9iamVjdCk7XG5cdFx0XHRcdFx0dmFyIHN0YXRlU3RhY2tEZXB0aCA9IHRoaXMuc3RhdGVzLmxlbmd0aDtcblx0XHRcdFx0XHR2YXIgc3RhcnRlZEluR2V0UGFyYW1zU3RhdGUgPSB0aGlzLmlzU3RhdGUoJ2luLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRpZiAoIXN0YXJ0ZWRJbkdldFBhcmFtc1N0YXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hTdGF0ZSgnbXVsdGktbWVtYmVyLWV4cHJlc3Npb24nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLm9iamVjdCwgcmV0QXJyKTtcblx0XHRcdFx0XHRpZiAodGhpcy5pc1N0YXRlKCdtdWx0aS1tZW1iZXItZXhwcmVzc2lvbicpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdtdWx0aS1tZW1iZXItZXhwcmVzc2lvbicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgY2hhbmdlZEdldFBhcmFtc1N0YXRlID0gIXN0YXJ0ZWRJbkdldFBhcmFtc1N0YXRlICYmIHRoaXMuaXNTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRcdHZhciBsYXN0ID0gcmV0QXJyLnBvcCgpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcsJyk7XG5cdFx0XHRcdFx0ZGVidWdMb2coXCItIGFzdE1lbWJlckV4cHJlc3Npb24gcHJvcDpcIiwgbU5vZGUucHJvcGVydHkpO1xuXHRcdFx0XHRcdHZhciBzaG91bGRQb3BQYXJhbVN0YXRlID0gdGhpcy5pc1N0YXRlKCdzaG91bGQtcG9wLWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHRpZiAoc2hvdWxkUG9wUGFyYW1TdGF0ZSkge1xuXHRcdFx0XHRcdFx0Ly8gZ28gYmFjayB0byBpbi1nZXQtY2FsbC1wYXJhbWV0ZXJzIHN0YXRlXG5cdFx0XHRcdFx0XHR0aGlzLnBvcFN0YXRlKCdzaG91bGQtcG9wLWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKG1Ob2RlLnByb3BlcnR5LCByZXRBcnIpO1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKGxhc3QpO1xuXG5cdFx0XHRcdFx0aWYgKGNoYW5nZWRHZXRQYXJhbXNTdGF0ZSkge1xuXHRcdFx0XHRcdFx0Ly8gY2FsbGluZyBtZW1iZXJFeHByZXNzaW9uIHNob3VsZCBwb3AuLi5cblx0XHRcdFx0XHRcdHRoaXMucHVzaFN0YXRlKCdzaG91bGQtcG9wLWluLWdldC1jYWxsLXBhcmFtZXRlcnMnKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNob3VsZFBvcFBhcmFtU3RhdGUpIHtcblx0XHRcdFx0XHRcdC8vIGRvIHRoZSBwb3BwaW5nIVxuXHRcdFx0XHRcdFx0dGhpcy5wb3BTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBVbnJvbGwgdGhlIG1lbWJlciBleHByZXNzaW9uXG5cdFx0XHRcdHZhciB1bnJvbGxlZCA9IHRoaXMuYXN0TWVtYmVyRXhwcmVzc2lvblVucm9sbChtTm9kZSk7XG5cdFx0XHRcdHZhciB1bnJvbGxlZF9sYyA9IHVucm9sbGVkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGRlYnVnTG9nKFwiLSBhc3RNZW1iZXJFeHByZXNzaW9uIHVucm9sbGVkOlwiLCB1bnJvbGxlZCk7XG5cdFx0XHRcdC8vIEl0cyBhIGNvbnN0YW50LCByZW1vdmUgdGhpcy5jb25zdGFudHMuXG5cdFx0XHRcdGlmICh1bnJvbGxlZC5pbmRleE9mKGNvbnN0YW50c1ByZWZpeCkgPT09IDApIHtcblx0XHRcdFx0XHR1bnJvbGxlZCA9ICdjb25zdGFudHNfJyArIHVucm9sbGVkLnNsaWNlKGNvbnN0YW50c1ByZWZpeC5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZG8gd2UgbmVlZCB0byBjYXN0IGFkZHJlc3NpbmcgdmFsZXMgdG8gZmxvYXQ/XG5cdFx0XHRcdHZhciBjYXN0RmxvYXQgPSAhdGhpcy5pc1N0YXRlKCdpbi1nZXQtY2FsbC1wYXJhbWV0ZXJzJyk7XG5cblx0XHRcdFx0c3dpdGNoICh1bnJvbGxlZF9sYykge1xuXHRcdFx0XHRcdGNhc2UgJ3RoaXMudGhyZWFkLngnOlxuXHRcdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd0aHJlYWRJZC54Jyk7XG5cdFx0XHRcdFx0XHRjYXN0RmxvYXQgJiYgcmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RoaXMudGhyZWFkLnknOlxuXHRcdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd0aHJlYWRJZC55Jyk7XG5cdFx0XHRcdFx0XHRjYXN0RmxvYXQgJiYgcmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RoaXMudGhyZWFkLnonOlxuXHRcdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKCd0aHJlYWRJZC56Jyk7XG5cdFx0XHRcdFx0XHRjYXN0RmxvYXQgJiYgcmV0QXJyLnB1c2goJyknKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RoaXMub3V0cHV0LngnOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMF0gKyAnLjAnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RoaXMub3V0cHV0LnknOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMV0gKyAnLjAnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RoaXMub3V0cHV0LnonOlxuXHRcdFx0XHRcdFx0cmV0QXJyLnB1c2godGhpcy5vdXRwdXRbMl0gKyAnLjAnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRpZiAobU5vZGUub2JqZWN0ICYmIG1Ob2RlLm9iamVjdC5uYW1lICYmIHRoaXMuZGVjbGFyYXRpb25zW21Ob2RlLm9iamVjdC5uYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgndXNlcl8nKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldEFyci5wdXNoKHVucm9sbGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGVidWdMb2coXCJbb3V0XSBhc3RNZW1iZXJFeHByZXNzaW9uIFwiICsgbU5vZGUub2JqZWN0LnR5cGUpO1xuXHRcdFx0cmV0dXJuIHJldEFycjtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdhc3RTZXF1ZW5jZUV4cHJlc3Npb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3RTZXF1ZW5jZUV4cHJlc3Npb24oc05vZGUsIHJldEFycikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzTm9kZS5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgnLCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYXN0R2VuZXJpYyhzTm9kZS5leHByZXNzaW9ucywgcmV0QXJyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdENhbGxFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICpjYWxsKiBleHByZXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhc3QgLSB0aGUgQVNUIG9iamVjdCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0FycmF5fSByZXRBcnIgLSByZXR1cm4gYXJyYXkgc3RyaW5nXG4gICAqXG4gICAqIEByZXR1cm5zICB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RDYWxsRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdENhbGxFeHByZXNzaW9uKGFzdCwgcmV0QXJyKSB7XG5cdFx0XHRpZiAoYXN0LmNhbGxlZSkge1xuXHRcdFx0XHQvLyBHZXQgdGhlIGZ1bGwgZnVuY3Rpb24gY2FsbCwgdW5yb2xsZWRcblx0XHRcdFx0dmFyIGZ1bmNOYW1lID0gdGhpcy5hc3RNZW1iZXJFeHByZXNzaW9uVW5yb2xsKGFzdC5jYWxsZWUpO1xuXG5cdFx0XHRcdC8vIEl0cyBhIG1hdGggb3BlcmF0b3IsIHJlbW92ZSB0aGUgcHJlZml4XG5cdFx0XHRcdGlmIChmdW5jTmFtZS5pbmRleE9mKGpzTWF0aFByZWZpeCkgPT09IDApIHtcblx0XHRcdFx0XHRmdW5jTmFtZSA9IGZ1bmNOYW1lLnNsaWNlKGpzTWF0aFByZWZpeC5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSXRzIGEgbG9jYWwgZnVuY3Rpb24sIHJlbW92ZSB0aGlzXG5cdFx0XHRcdGlmIChmdW5jTmFtZS5pbmRleE9mKGxvY2FsUHJlZml4KSA9PT0gMCkge1xuXHRcdFx0XHRcdGZ1bmNOYW1lID0gZnVuY05hbWUuc2xpY2UobG9jYWxQcmVmaXgubGVuZ3RoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHRoaXMgaWYgZ3Jvd3MgdG8gbW9yZSB0aGFuIG9uZSwgbGV0cyB1c2UgYSBzd2l0Y2hcblx0XHRcdFx0aWYgKGZ1bmNOYW1lID09PSAnYXRhbjInKSB7XG5cdFx0XHRcdFx0ZnVuY05hbWUgPSAnYXRhbic7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWdpc3RlciB0aGUgZnVuY3Rpb24gaW50byB0aGUgY2FsbGVkIHJlZ2lzdHJ5XG5cdFx0XHRcdGlmICh0aGlzLmNhbGxlZEZ1bmN0aW9ucy5pbmRleE9mKGZ1bmNOYW1lKSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLmNhbGxlZEZ1bmN0aW9ucy5wdXNoKGZ1bmNOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ2Z1bmNOYW1lJykpIHtcblx0XHRcdFx0XHR0aGlzLmNhbGxlZEZ1bmN0aW9uc0FyZ3VtZW50c1tmdW5jTmFtZV0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmdW5jdGlvbkFyZ3VtZW50cyA9IFtdO1xuXHRcdFx0XHR0aGlzLmNhbGxlZEZ1bmN0aW9uc0FyZ3VtZW50c1tmdW5jTmFtZV0ucHVzaChmdW5jdGlvbkFyZ3VtZW50cyk7XG5cblx0XHRcdFx0Ly8gQ2FsbCB0aGUgZnVuY3Rpb25cblx0XHRcdFx0cmV0QXJyLnB1c2goZnVuY05hbWUpO1xuXG5cdFx0XHRcdC8vIE9wZW4gYXJndW1lbnRzIHNwYWNlXG5cdFx0XHRcdHJldEFyci5wdXNoKCcoJyk7XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSB2YXJzXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHZhciBhcmd1bWVudCA9IGFzdC5hcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0aWYgKGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXRBcnIucHVzaCgnLCAnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKGFyZ3VtZW50LCByZXRBcnIpO1xuXHRcdFx0XHRcdGlmIChhcmd1bWVudC50eXBlID09PSAnSWRlbnRpZmllcicpIHtcblx0XHRcdFx0XHRcdHZhciBwYXJhbUluZGV4ID0gdGhpcy5wYXJhbU5hbWVzLmluZGV4T2YoYXJndW1lbnQubmFtZSk7XG5cdFx0XHRcdFx0XHRpZiAocGFyYW1JbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb25Bcmd1bWVudHMucHVzaChudWxsKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZ1bmN0aW9uQXJndW1lbnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGFyZ3VtZW50Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogdGhpcy5wYXJhbVR5cGVzW3BhcmFtSW5kZXhdIHx8ICdOdW1iZXInXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmdW5jdGlvbkFyZ3VtZW50cy5wdXNoKG51bGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENsb3NlIGFyZ3VtZW50cyBzcGFjZVxuXHRcdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXG5cdFx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhaWx1cmUsIHVua25vd24gZXhwcmVzc2lvblxuXHRcdFx0dGhyb3cgdGhpcy5hc3RFcnJvck91dHB1dCgnVW5rbm93biBDYWxsRXhwcmVzc2lvbicsIGFzdCk7XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdEFycmF5RXhwcmVzc2lvblxuICAgKlxuICAgKiBAZGVzYyBQYXJzZXMgdGhlIGFic3RyYWN0IHN5bnRheCB0cmVlIGZvciAqQXJyYXkqIEV4cHJlc3Npb25cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFzdCAtIHRoZSBBU1Qgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJldEFyciAtIHJldHVybiBhcnJheSBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgYXBwZW5kIHJldEFyclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXN0QXJyYXlFeHByZXNzaW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXN0QXJyYXlFeHByZXNzaW9uKGFyck5vZGUsIHJldEFycikge1xuXHRcdFx0dmFyIGFyckxlbiA9IGFyck5vZGUuZWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0XHRyZXRBcnIucHVzaCgndmVjJyArIGFyckxlbiArICcoJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyckxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChpID4gMCkge1xuXHRcdFx0XHRcdHJldEFyci5wdXNoKCcsICcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdWJOb2RlID0gYXJyTm9kZS5lbGVtZW50c1tpXTtcblx0XHRcdFx0dGhpcy5hc3RHZW5lcmljKHN1Yk5vZGUsIHJldEFycik7XG5cdFx0XHR9XG5cdFx0XHRyZXRBcnIucHVzaCgnKScpO1xuXG5cdFx0XHRyZXR1cm4gcmV0QXJyO1xuXG5cdFx0XHQvLyAvLyBGYWlsdXJlLCB1bmtub3duIGV4cHJlc3Npb25cblx0XHRcdC8vIHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoXG5cdFx0XHQvLyBcdCdVbmtub3duICBBcnJheUV4cHJlc3Npb24nLFxuXHRcdFx0Ly8gXHRhcnJOb2RlXG5cdFx0XHQvLyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGdldEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIGNvbnZlcnRlZCB3ZWJnbCBzaGFkZXIgZnVuY3Rpb24gZXF1aXZhbGVudCBvZiB0aGUgSlMgZnVuY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gd2ViZ2wgZnVuY3Rpb24gc3RyaW5nLCByZXN1bHQgaXMgY2FjaGVkIHVuZGVyIHRoaXMuZ2V0RnVuY3Rpb25Qcm90b3R5cGVTdHJpbmdcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0RnVuY3Rpb25Qcm90b3R5cGVTdHJpbmcoKSB7XG5cdFx0XHRpZiAodGhpcy53ZWJHbEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLndlYkdsRnVuY3Rpb25Qcm90b3R5cGVTdHJpbmc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy53ZWJHbEZ1bmN0aW9uUHJvdG90eXBlU3RyaW5nID0gdGhpcy5nZW5lcmF0ZSgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2J1aWxkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYnVpbGQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRGdW5jdGlvblByb3RvdHlwZVN0cmluZygpLmxlbmd0aCA+IDA7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFdlYkdMRnVuY3Rpb25Ob2RlO1xufShGdW5jdGlvbk5vZGVCYXNlKTtcblxudmFyIHR5cGVNYXAgPSB7XG5cdCdBcnJheSc6ICdzYW1wbGVyMkQnLFxuXHQnQXJyYXkoMiknOiAndmVjMicsXG5cdCdBcnJheSgzKSc6ICd2ZWMzJyxcblx0J0FycmF5KDQpJzogJ3ZlYzQnLFxuXHQnQXJyYXkyRCc6ICdzYW1wbGVyMkQnLFxuXHQnQXJyYXkzRCc6ICdzYW1wbGVyMkQnLFxuXHQnRmxvYXQnOiAnZmxvYXQnLFxuXHQnSW5wdXQnOiAnc2FtcGxlcjJEJyxcblx0J0ludGVnZXInOiAnZmxvYXQnLFxuXHQnTnVtYmVyJzogJ2Zsb2F0Jyxcblx0J051bWJlclRleHR1cmUnOiAnc2FtcGxlcjJEJyxcblx0J0FycmF5VGV4dHVyZSg0KSc6ICdzYW1wbGVyMkQnXG59O1xuXG52YXIgdHlwZUxvb2t1cE1hcCA9IHtcblx0J0FycmF5JzogJ051bWJlcicsXG5cdCdBcnJheTJEJzogJ051bWJlcicsXG5cdCdBcnJheTNEJzogJ051bWJlcicsXG5cdCdIVE1MSW1hZ2UnOiAnQXJyYXkoNCknLFxuXHQnSFRNTEltYWdlQXJyYXknOiAnQXJyYXkoNCknLFxuXHQnTnVtYmVyVGV4dHVyZSc6ICdOdW1iZXInLFxuXHQnQXJyYXlUZXh0dXJlKDQpJzogJ0FycmF5KDQpJ1xufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKiBAZnVuY3Rpb25cbiAqIEBuYW1lIHdlYmdsX3JlZ2V4X29wdGltaXplXG4gKlxuICogQGRlc2MgW0lOVEVSTkFMXSBUYWtlcyB0aGUgbmVhciBmaW5hbCB3ZWJnbCBmdW5jdGlvbiBzdHJpbmcsIGFuZCBkbyByZWdleCBzZWFyY2ggYW5kIHJlcGxhY21lbnRzLlxuICogRm9yIHZvb2RvbyBvcHRpbWl6ZSBvdXQgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGRlY29kZTMyKGVuY29kZTMyKCA8YnI+XG4gKiAtIGVuY29kZTMyKGRlY29kZTMyKCA8YnI+XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGluU3RyIC0gVGhlIHdlYkdsIGZ1bmN0aW9uIFN0cmluZ1xuICpcbiAqL1xuZnVuY3Rpb24gd2ViR2xSZWdleE9wdGltaXplKGluU3RyKSB7XG5cdHJldHVybiBpblN0ci5yZXBsYWNlKERFQ09ERTMyX0VOQ09ERTMyLCAnKCgnKS5yZXBsYWNlKEVOQ09ERTMyX0RFQ09ERTMyLCAnKCgnKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbHMnKTtcbnZhciBrZXJuZWxSdW5TaG9ydGN1dCA9IHJlcXVpcmUoJy4uL2tlcm5lbC1ydW4tc2hvcnRjdXQnKTtcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvaW5wdXQnKTtcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi4vLi4vY29yZS90ZXh0dXJlJyk7XG5cbmZ1bmN0aW9uIHJlbW92ZUZuTm9pc2UoZm4pIHtcbiAgaWYgKC9eZnVuY3Rpb24gLy50ZXN0KGZuKSkge1xuICAgIGZuID0gZm4uc3Vic3RyaW5nKDkpO1xuICB9XG4gIHJldHVybiBmbi5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2lzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bX110eXBlb2YvZywgJ3R5cGVvZicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChncHVLZXJuZWwsIG5hbWUpIHtcbiAgcmV0dXJuICcoKSA9PiB7XFxuICAgICcgKyBrZXJuZWxSdW5TaG9ydGN1dC50b1N0cmluZygpICsgJztcXG4gICAgY29uc3QgdXRpbHMgPSB7XFxuICAgICAgYWxsUHJvcGVydGllc09mOiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuYWxsUHJvcGVydGllc09mLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBjbG9uZTogJyArIHJlbW92ZU5vaXNlKHV0aWxzLmNsb25lLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBzcGxpdEFycmF5OiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuc3BsaXRBcnJheS50b1N0cmluZygpKSArICcsXFxuICAgICAgZ2V0QXJndW1lbnRUeXBlOiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuZ2V0QXJndW1lbnRUeXBlLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBnZXREaW1lbnNpb25zOiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuZ2V0RGltZW5zaW9ucy50b1N0cmluZygpKSArICcsXFxuICAgICAgZGltVG9UZXhTaXplOiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuZGltVG9UZXhTaXplLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBmbGF0dGVuVG86ICcgKyByZW1vdmVOb2lzZSh1dGlscy5mbGF0dGVuVG8udG9TdHJpbmcoKSkgKyAnLFxcbiAgICAgIGZsYXR0ZW4yZEFycmF5VG86ICcgKyByZW1vdmVOb2lzZSh1dGlscy5mbGF0dGVuMmRBcnJheVRvLnRvU3RyaW5nKCkpICsgJyxcXG4gICAgICBmbGF0dGVuM2RBcnJheVRvOiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuZmxhdHRlbjNkQXJyYXlUby50b1N0cmluZygpKSArICcsXFxuICAgICAgc3lzdGVtRW5kaWFubmVzczogXFwnJyArIHJlbW92ZU5vaXNlKHV0aWxzLnN5c3RlbUVuZGlhbm5lc3MoKSkgKyAnXFwnLFxcbiAgICAgIGluaXRXZWJHbDogJyArIHJlbW92ZU5vaXNlKHV0aWxzLmluaXRXZWJHbC50b1N0cmluZygpKSArICcsXFxuICAgICAgaXNBcnJheTogJyArIHJlbW92ZU5vaXNlKHV0aWxzLmlzQXJyYXkudG9TdHJpbmcoKSkgKyAnLFxcbiAgICAgIGNoZWNrT3V0cHV0OiAnICsgcmVtb3ZlTm9pc2UodXRpbHMuY2hlY2tPdXRwdXQudG9TdHJpbmcoKSkgKyAnXFxuICAgIH07XFxuICAgIGNvbnN0IFV0aWxzID0gdXRpbHM7XFxuICAgIGNvbnN0IGNhbnZhc2VzID0gW107XFxuICAgIGNvbnN0IG1heFRleFNpemVzID0ge307XFxuICAgIGxldCBUZXh0dXJlID0gZnVuY3Rpb24oKSB7fTtcXG4gICAgbGV0IElucHV0ID0gZnVuY3Rpb24oKSB7fTsgXFxuICAgIGNsYXNzICcgKyAobmFtZSB8fCAnS2VybmVsJykgKyAnIHtcXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgIHRoaXMubWF4VGV4U2l6ZSA9IG51bGw7XFxuICAgICAgICB0aGlzLmFyZ3VtZW50c0xlbmd0aCA9IDA7XFxuICAgICAgICB0aGlzLmNvbnN0YW50c0xlbmd0aCA9IDA7XFxuICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xcbiAgICAgICAgdGhpcy5fd2ViR2wgPSBudWxsO1xcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcXG4gICAgICAgIHRoaXMub3V0cHV0VG9UZXh0dXJlID0gJyArIChncHVLZXJuZWwub3V0cHV0VG9UZXh0dXJlID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAnO1xcbiAgICAgICAgdGhpcy5wYXJhbU5hbWVzID0gJyArIEpTT04uc3RyaW5naWZ5KGdwdUtlcm5lbC5wYXJhbU5hbWVzKSArICc7XFxuICAgICAgICB0aGlzLnBhcmFtVHlwZXMgPSAnICsgSlNPTi5zdHJpbmdpZnkoZ3B1S2VybmVsLnBhcmFtVHlwZXMpICsgJztcXG4gICAgICAgIHRoaXMudGV4U2l6ZSA9ICcgKyBKU09OLnN0cmluZ2lmeShncHVLZXJuZWwudGV4U2l6ZSkgKyAnO1xcbiAgICAgICAgdGhpcy5vdXRwdXQgPSAnICsgSlNPTi5zdHJpbmdpZnkoZ3B1S2VybmVsLm91dHB1dCkgKyAnO1xcbiAgICAgICAgdGhpcy5jb21waWxlZEZyYWdTaGFkZXJTdHJpbmcgPSBgJyArIGdwdUtlcm5lbC5jb21waWxlZEZyYWdTaGFkZXJTdHJpbmcgKyAnYDtcXG5cXHRcXHQgICAgdGhpcy5jb21waWxlZFZlcnRTaGFkZXJTdHJpbmcgPSBgJyArIGdwdUtlcm5lbC5jb21waWxlZFZlcnRTaGFkZXJTdHJpbmcgKyAnYDtcXG5cXHRcXHQgICAgdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUgPSB7fTtcXG5cXHRcXHQgICAgdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcXG5cXHRcXHQgICAgdGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcyA9IG51bGw7XFxuXFx0XFx0ICAgIHRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcyA9IG51bGw7XFxuXFx0XFx0ICAgIHRoaXMudW5pZm9ybTFmQ2FjaGUgPSB7fTtcXG5cXHRcXHQgICAgdGhpcy51bmlmb3JtMWlDYWNoZSA9IHt9O1xcblxcdFxcdCAgICB0aGlzLnVuaWZvcm0yZkNhY2hlID0ge307XFxuXFx0XFx0ICAgIHRoaXMudW5pZm9ybTJmdkNhY2hlID0ge307XFxuXFx0XFx0ICAgIHRoaXMudW5pZm9ybTJpdkNhY2hlID0ge307XFxuXFx0XFx0ICAgIHRoaXMudW5pZm9ybTNmdkNhY2hlID0ge307XFxuXFx0XFx0ICAgIHRoaXMudW5pZm9ybTNpdkNhY2hlID0ge307XFxuICAgICAgfVxcbiAgICAgIF9nZXRGcmFnU2hhZGVyU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5jb21waWxlZEZyYWdTaGFkZXJTdHJpbmc7IH1cXG4gICAgICBfZ2V0VmVydFNoYWRlclN0cmluZygpIHsgcmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0U2hhZGVyU3RyaW5nOyB9XFxuICAgICAgdmFsaWRhdGVPcHRpb25zKCkge31cXG4gICAgICBzZXR1cFBhcmFtcygpIHt9XFxuICAgICAgc2V0dXBDb25zdGFudHMoKSB7fVxcbiAgICAgIHNldENhbnZhcyhjYW52YXMpIHsgdGhpcy5fY2FudmFzID0gY2FudmFzOyByZXR1cm4gdGhpczsgfVxcbiAgICAgIHNldFdlYkdsKHdlYkdsKSB7IHRoaXMuX3dlYkdsID0gd2ViR2w7IHJldHVybiB0aGlzOyB9XFxuICAgICAgc2V0VGV4dHVyZShUeXBlKSB7IFRleHR1cmUgPSBUeXBlOyB9XFxuICAgICAgc2V0SW5wdXQoVHlwZSkgeyBJbnB1dCA9IFR5cGU7IH1cXG4gICAgICAnICsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuZ2V0VW5pZm9ybUxvY2F0aW9uLnRvU3RyaW5nKCkpICsgJ1xcbiAgICAgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5idWlsZC50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5ydW4udG9TdHJpbmcoKSkgKyAnXFxuXFx0XFx0ICAnICsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuX2FkZEFyZ3VtZW50LnRvU3RyaW5nKCkpICsgJ1xcblxcdFxcdCAgJyArIHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLl9mb3JtYXRBcnJheVRyYW5zZmVyLnRvU3RyaW5nKCkpICsgJ1xcblxcdFxcdCAgJyArIHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLmdldEFyZ3VtZW50VGV4dHVyZS50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5nZXRUZXh0dXJlQ2FjaGUudG9TdHJpbmcoKSkgKyAnXFxuXFx0XFx0ICAnICsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuZ2V0T3V0cHV0VGV4dHVyZS50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5yZW5kZXJPdXRwdXQudG9TdHJpbmcoKSkgKyAnXFxuXFx0XFx0ICAnICsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwudXBkYXRlTWF4VGV4U2l6ZS50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5fc2V0dXBPdXRwdXRUZXh0dXJlLnRvU3RyaW5nKCkpICsgJ1xcblxcdFxcdCAgJyArIHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLmRldGFjaFRleHR1cmVDYWNoZS50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5zZXRVbmlmb3JtMWYudG9TdHJpbmcoKSkgKyAnXFxuXFx0XFx0ICAnICsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuc2V0VW5pZm9ybTFpLnRvU3RyaW5nKCkpICsgJ1xcblxcdFxcdCAgJyArIHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLnNldFVuaWZvcm0yZi50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5zZXRVbmlmb3JtMmZ2LnRvU3RyaW5nKCkpICsgJ1xcblxcdFxcdCAgJyArIHJlbW92ZUZuTm9pc2UoZ3B1S2VybmVsLnNldFVuaWZvcm0yaXYudG9TdHJpbmcoKSkgKyAnXFxuXFx0XFx0ICAnICsgcmVtb3ZlRm5Ob2lzZShncHVLZXJuZWwuc2V0VW5pZm9ybTNmdi50b1N0cmluZygpKSArICdcXG5cXHRcXHQgICcgKyByZW1vdmVGbk5vaXNlKGdwdUtlcm5lbC5zZXRVbmlmb3JtM2l2LnRvU3RyaW5nKCkpICsgJ1xcbiAgICB9O1xcbiAgICByZXR1cm4ga2VybmVsUnVuU2hvcnRjdXQobmV3IEtlcm5lbCgpKTtcXG4gIH07Jztcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEtlcm5lbEJhc2UgPSByZXF1aXJlKCcuLi9rZXJuZWwtYmFzZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlscycpO1xudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHR1cmUnKTtcbnZhciBmcmFnU2hhZGVyU3RyaW5nID0gcmVxdWlyZSgnLi9zaGFkZXItZnJhZycpO1xudmFyIHZlcnRTaGFkZXJTdHJpbmcgPSByZXF1aXJlKCcuL3NoYWRlci12ZXJ0Jyk7XG52YXIga2VybmVsU3RyaW5nID0gcmVxdWlyZSgnLi9rZXJuZWwtc3RyaW5nJyk7XG52YXIgY2FudmFzZXMgPSBbXTtcbnZhciBtYXhUZXhTaXplcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfS2VybmVsQmFzZSkge1xuXHRfaW5oZXJpdHMoV2ViR0xLZXJuZWwsIF9LZXJuZWxCYXNlKTtcblxuXHRfY3JlYXRlQ2xhc3MoV2ViR0xLZXJuZWwsIG51bGwsIFt7XG5cdFx0a2V5OiAnZnJhZ1NoYWRlclN0cmluZycsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gZnJhZ1NoYWRlclN0cmluZztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICd2ZXJ0U2hhZGVyU3RyaW5nJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB2ZXJ0U2hhZGVyU3RyaW5nO1xuXHRcdH1cblx0XHQvKipcbiAgICogQGNvbnN0cnVjdG9yIFdlYkdMS2VybmVsXG4gICAqXG4gICAqIEBkZXNjIEtlcm5lbCBJbXBsZW1lbnRhdGlvbiBmb3IgV2ViR0wuXG4gICAqIDxwPlRoaXMgYnVpbGRzIHRoZSBzaGFkZXJzIGFuZCBydW5zIHRoZW0gb24gdGhlIEdQVSxcbiAgICogdGhlIG91dHB1dHMgdGhlIHJlc3VsdCBiYWNrIGFzIGZsb2F0KGVuYWJsZWQgYnkgZGVmYXVsdCkgYW5kIFRleHR1cmUuPC9wPlxuICAgKlxuICAgKiBAZXh0ZW5kcyBLZXJuZWxCYXNlXG4gICAqXG4gICAqIEBwcm9wIHtPYmplY3R9IHRleHR1cmVDYWNoZSAtIHdlYkdsIFRleHR1cmUgY2FjaGVcbiAgICogQHByb3Age09iamVjdH0gdGhyZWFkRGltIC0gVGhlIHRocmVhZCBkaW1lbnNpb25zLCB4LCB5IGFuZCB6XG4gICAqIEBwcm9wIHtPYmplY3R9IHByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZSAtIExvY2F0aW9uIG9mIHByb2dyYW0gdmFyaWFibGVzIGluIG1lbW9yeVxuICAgKiBAcHJvcCB7T2JqZWN0fSBmcmFtZWJ1ZmZlciAtIFdlYmdsIGZyYW1lQnVmZmVyXG4gICAqIEBwcm9wIHtPYmplY3R9IGJ1ZmZlciAtIFdlYkdMIGJ1ZmZlclxuICAgKiBAcHJvcCB7T2JqZWN0fSBwcm9ncmFtIC0gVGhlIHdlYkdsIFByb2dyYW1cbiAgICogQHByb3Age09iamVjdH0gZnVuY3Rpb25CdWlsZGVyIC0gRnVuY3Rpb24gQnVpbGRlciBpbnN0YW5jZSBib3VuZCB0byB0aGlzIEtlcm5lbFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gb3V0cHV0VG9UZXh0dXJlIC0gU2V0IG91dHB1dCB0eXBlIHRvIFRleHR1cmUsIGluc3RlYWQgb2YgZmxvYXRcbiAgICogQHByb3Age1N0cmluZ30gZW5kaWFubmVzcyAtIEVuZGlhbiBpbmZvcm1hdGlvbiBsaWtlIExpdHRsZS1lbmRpYW4sIEJpZy1lbmRpYW4uXG4gICAqIEBwcm9wIHtBcnJheX0gcGFyYW1UeXBlcyAtIFR5cGVzIG9mIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG4gICAqIEBwcm9wIHtudW1iZXJ9IGFyZ3VtZW50c0xlbmd0aCAtIE51bWJlciBvZiBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuICAgKiBAcHJvcCB7U3RyaW5nfSBjb21waWxlZEZyYWdTaGFkZXJTdHJpbmcgLSBDb21waWxlZCBmcmFnbWVudCBzaGFkZXIgc3RyaW5nXG4gICAqIEBwcm9wIHtTdHJpbmd9IGNvbXBpbGVkVmVydFNoYWRlclN0cmluZyAtIENvbXBpbGVkIFZlcnRpY2FsIHNoYWRlciBzdHJpbmdcbiAgICovXG5cblx0fV0pO1xuXG5cdGZ1bmN0aW9uIFdlYkdMS2VybmVsKGZuU3RyaW5nLCBzZXR0aW5ncykge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTEtlcm5lbCk7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViR0xLZXJuZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihXZWJHTEtlcm5lbCkpLmNhbGwodGhpcywgZm5TdHJpbmcsIHNldHRpbmdzKSk7XG5cblx0XHRfdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcblx0XHRfdGhpcy50aHJlYWREaW0gPSB7fTtcblx0XHRfdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGUgPSB7fTtcblx0XHRfdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XG5cblx0XHRfdGhpcy5idWZmZXIgPSBudWxsO1xuXHRcdF90aGlzLnByb2dyYW0gPSBudWxsO1xuXHRcdF90aGlzLm91dHB1dFRvVGV4dHVyZSA9IHNldHRpbmdzLm91dHB1dFRvVGV4dHVyZTtcblx0XHRfdGhpcy5lbmRpYW5uZXNzID0gdXRpbHMuc3lzdGVtRW5kaWFubmVzcygpO1xuXHRcdF90aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzID0gbnVsbDtcblx0XHRfdGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzID0gbnVsbDtcblx0XHRfdGhpcy5hcmd1bWVudHNMZW5ndGggPSAwO1xuXHRcdF90aGlzLmNvbnN0YW50c0xlbmd0aCA9IDA7XG5cdFx0X3RoaXMuY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nID0gbnVsbDtcblx0XHRfdGhpcy5jb21waWxlZFZlcnRTaGFkZXJTdHJpbmcgPSBudWxsO1xuXHRcdF90aGlzLmZyYWdTaGFkZXIgPSBudWxsO1xuXHRcdF90aGlzLnZlcnRTaGFkZXIgPSBudWxsO1xuXHRcdF90aGlzLmRyYXdCdWZmZXJzTWFwID0gbnVsbDtcblx0XHRfdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcblx0XHRfdGhpcy5tYXhUZXhTaXplID0gbnVsbDtcblx0XHRfdGhpcy51bmlmb3JtMWZDYWNoZSA9IHt9O1xuXHRcdF90aGlzLnVuaWZvcm0xaUNhY2hlID0ge307XG5cdFx0X3RoaXMudW5pZm9ybTJmQ2FjaGUgPSB7fTtcblx0XHRfdGhpcy51bmlmb3JtMmZ2Q2FjaGUgPSB7fTtcblx0XHRfdGhpcy51bmlmb3JtMml2Q2FjaGUgPSB7fTtcblx0XHRfdGhpcy51bmlmb3JtM2Z2Q2FjaGUgPSB7fTtcblx0XHRfdGhpcy51bmlmb3JtM2l2Q2FjaGUgPSB7fTtcblx0XHRpZiAoIV90aGlzLl93ZWJHbCkgX3RoaXMuX3dlYkdsID0gX3RoaXMuaW5pdFdlYkdsKCk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFdlYkdMS2VybmVsLCBbe1xuXHRcdGtleTogJ2luaXRXZWJHbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRXZWJHbCgpIHtcblx0XHRcdHJldHVybiB1dGlscy5pbml0V2ViR2wodGhpcy5nZXRDYW52YXMoKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHZhbGlkYXRlT3B0aW9uc1xuICAgKlxuICAgKiBAZGVzYyBWYWxpZGF0ZSBvcHRpb25zIHJlbGF0ZWQgdG8gS2VybmVsLCBzdWNoIGFzXG4gICAqIGZsb2F0T3V0cHV0cyBhbmQgVGV4dHVyZXMsIHRleFNpemUsIG91dHB1dCxcbiAgICogZ3JhcGhpY2FsIG91dHB1dC5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZhbGlkYXRlT3B0aW9ucycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucygpIHtcblx0XHRcdHZhciBpc0Zsb2F0UmVhZFBpeGVsID0gdXRpbHMuaXNGbG9hdFJlYWRQaXhlbHNTdXBwb3J0ZWQoKTtcblx0XHRcdGlmICh0aGlzLmZsb2F0VGV4dHVyZXMgPT09IHRydWUgJiYgIXV0aWxzLk9FU190ZXh0dXJlX2Zsb2F0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZmxvYXRPdXRwdXQgPT09IHRydWUgJiYgdGhpcy5mbG9hdE91dHB1dEZvcmNlICE9PSB0cnVlICYmICFpc0Zsb2F0UmVhZFBpeGVsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRmxvYXQgdGV4dHVyZSBvdXRwdXRzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlcicpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmZsb2F0VGV4dHVyZXMgPT09IHVuZGVmaW5lZCAmJiB1dGlscy5PRVNfdGV4dHVyZV9mbG9hdCkge1xuXHRcdFx0XHR0aGlzLmZsb2F0VGV4dHVyZXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmZsb2F0T3V0cHV0ID0gaXNGbG9hdFJlYWRQaXhlbDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhc0ludGVnZXJEaXZpc2lvbkJ1ZyA9IHV0aWxzLmhhc0ludGVnZXJEaXZpc2lvbkFjY3VyYWN5QnVnKCk7XG5cdFx0XHRpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ID0gaGFzSW50ZWdlckRpdmlzaW9uQnVnO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5ICYmICFoYXNJbnRlZ2VyRGl2aXNpb25CdWcpIHtcblx0XHRcdFx0dGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR1dGlscy5jaGVja091dHB1dCh0aGlzLm91dHB1dCk7XG5cblx0XHRcdGlmICghdGhpcy5vdXRwdXQgfHwgdGhpcy5vdXRwdXQubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBvbmx5IHN1cHBvcnRlZCBmb3Iga2VybmVscyB3aXRoIG9ubHkgb25lIGlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgYXJnVHlwZSA9IHV0aWxzLmdldEFyZ3VtZW50VHlwZShhcmd1bWVudHNbMF0pO1xuXHRcdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ0FycmF5Jykge1xuXHRcdFx0XHRcdHRoaXMub3V0cHV0ID0gdXRpbHMuZ2V0RGltZW5zaW9ucyhhcmdUeXBlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnTnVtYmVyVGV4dHVyZScgfHwgYXJnVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScpIHtcblx0XHRcdFx0XHR0aGlzLm91dHB1dCA9IGFyZ3VtZW50c1swXS5vdXRwdXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBdXRvIG91dHB1dCBub3Qgc3VwcG9ydGVkIGZvciBpbnB1dCB0eXBlOiAnICsgYXJnVHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy50ZXhTaXplID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdGhpcy5mbG9hdFRleHR1cmVzLFxuXHRcdFx0XHRmbG9hdE91dHB1dDogdGhpcy5mbG9hdE91dHB1dFxuXHRcdFx0fSwgdGhpcy5vdXRwdXQsIHRydWUpO1xuXG5cdFx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdFx0aWYgKHRoaXMub3V0cHV0Lmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignT3V0cHV0IG11c3QgaGF2ZSAyIGRpbWVuc2lvbnMgb24gZ3JhcGhpY2FsIG1vZGUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLmZsb2F0T3V0cHV0KSB7XG5cdFx0XHRcdFx0dGhpcy5mbG9hdE91dHB1dCA9IGZhbHNlO1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignQ2Fubm90IHVzZSBncmFwaGljYWwgbW9kZSBhbmQgZmxvYXQgb3V0cHV0IGF0IHRoZSBzYW1lIHRpbWUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmNsb25lKHRoaXMub3V0cHV0KTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5mbG9hdE91dHB1dCA9PT0gdW5kZWZpbmVkICYmIHV0aWxzLk9FU190ZXh0dXJlX2Zsb2F0KSB7XG5cdFx0XHRcdHRoaXMuZmxvYXRPdXRwdXQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3VwZGF0ZU1heFRleFNpemUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNYXhUZXhTaXplKCkge1xuXHRcdFx0dmFyIHRleFNpemUgPSB0aGlzLnRleFNpemU7XG5cdFx0XHR2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdFx0aWYgKHRoaXMubWF4VGV4U2l6ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2FudmFzSW5kZXggPSBjYW52YXNlcy5pbmRleE9mKGNhbnZhcyk7XG5cdFx0XHRcdGlmIChjYW52YXNJbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRjYW52YXNJbmRleCA9IGNhbnZhc2VzLmxlbmd0aDtcblx0XHRcdFx0XHRjYW52YXNlcy5wdXNoKGNhbnZhcyk7XG5cdFx0XHRcdFx0bWF4VGV4U2l6ZXNbY2FudmFzSW5kZXhdID0gW3RleFNpemVbMF0sIHRleFNpemVbMV1dO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubWF4VGV4U2l6ZSA9IG1heFRleFNpemVzW2NhbnZhc0luZGV4XTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm1heFRleFNpemVbMF0gPCB0ZXhTaXplWzBdKSB7XG5cdFx0XHRcdHRoaXMubWF4VGV4U2l6ZVswXSA9IHRleFNpemVbMF07XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5tYXhUZXhTaXplWzFdIDwgdGV4U2l6ZVsxXSkge1xuXHRcdFx0XHR0aGlzLm1heFRleFNpemVbMV0gPSB0ZXhTaXplWzFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBidWlsZFxuICAgKlxuICAgKiBAZGVzYyBCdWlsZHMgdGhlIEtlcm5lbCwgYnkgY29tcGlsaW5nIEZyYWdtZW50IGFuZCBWZXJ0aWNhbCBTaGFkZXJzLFxuICAgKiBhbmQgaW5zdGFudGlhdGVzIHRoZSBwcm9ncmFtLlxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYnVpbGQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBidWlsZCgpIHtcblx0XHRcdHRoaXMudmFsaWRhdGVPcHRpb25zKCk7XG5cdFx0XHR0aGlzLnNldHVwQ29uc3RhbnRzKCk7XG5cdFx0XHR0aGlzLnNldHVwUGFyYW1zKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnVwZGF0ZU1heFRleFNpemUoKTtcblx0XHRcdHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHRcdFx0dmFyIGdsID0gdGhpcy5fd2ViR2w7XG5cdFx0XHR2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXHRcdFx0Z2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG5cdFx0XHRnbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1heFRleFNpemVbMF0sIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG5cdFx0XHRjYW52YXMud2lkdGggPSB0aGlzLm1heFRleFNpemVbMF07XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5tYXhUZXhTaXplWzFdO1xuXHRcdFx0dmFyIHRocmVhZERpbSA9IHRoaXMudGhyZWFkRGltID0gdXRpbHMuY2xvbmUodGhpcy5vdXRwdXQpO1xuXHRcdFx0d2hpbGUgKHRocmVhZERpbS5sZW5ndGggPCAzKSB7XG5cdFx0XHRcdHRocmVhZERpbS5wdXNoKDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5mdW5jdGlvbkJ1aWxkZXIpIHRoaXMuX2FkZEtlcm5lbHMoKTtcblxuXHRcdFx0dmFyIGNvbXBpbGVkVmVydFNoYWRlclN0cmluZyA9IHRoaXMuX2dldFZlcnRTaGFkZXJTdHJpbmcoYXJndW1lbnRzKTtcblx0XHRcdHZhciB2ZXJ0U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuXHRcdFx0Z2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIGNvbXBpbGVkVmVydFNoYWRlclN0cmluZyk7XG5cdFx0XHRnbC5jb21waWxlU2hhZGVyKHZlcnRTaGFkZXIpO1xuXHRcdFx0dGhpcy52ZXJ0U2hhZGVyID0gdmVydFNoYWRlcjtcblxuXHRcdFx0dmFyIGNvbXBpbGVkRnJhZ1NoYWRlclN0cmluZyA9IHRoaXMuX2dldEZyYWdTaGFkZXJTdHJpbmcoYXJndW1lbnRzKTtcblx0XHRcdHZhciBmcmFnU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG5cdFx0XHRnbC5zaGFkZXJTb3VyY2UoZnJhZ1NoYWRlciwgY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nKTtcblx0XHRcdGdsLmNvbXBpbGVTaGFkZXIoZnJhZ1NoYWRlcik7XG5cdFx0XHR0aGlzLmZyYWdTaGFkZXIgPSBmcmFnU2hhZGVyO1xuXG5cdFx0XHRpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coY29tcGlsZWRWZXJ0U2hhZGVyU3RyaW5nKTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBzaGFkZXJzOiAnICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0U2hhZGVyKSk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgY29tcGlsaW5nIHZlcnRleCBzaGFkZXInKTtcblx0XHRcdH1cblx0XHRcdGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhjb21waWxlZEZyYWdTaGFkZXJTdHJpbmcpO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBjb21waWxpbmcgdGhlIHNoYWRlcnM6ICcgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpKTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvciBjb21waWxpbmcgZnJhZ21lbnQgc2hhZGVyJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCdPcHRpb25zOicpO1xuXHRcdFx0XHRjb25zb2xlLmRpcih0aGlzKTtcblx0XHRcdFx0Y29uc29sZS5sb2coJ0dMU0wgU2hhZGVyIE91dHB1dDonKTtcblx0XHRcdFx0Y29uc29sZS5sb2coY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHByb2dyYW0gPSB0aGlzLnByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdFx0XHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydFNoYWRlcik7XG5cdFx0XHRnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcik7XG5cdFx0XHRnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblx0XHRcdHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdFx0dGhpcy5mcmFtZWJ1ZmZlci53aWR0aCA9IHRleFNpemVbMF07XG5cdFx0XHR0aGlzLmZyYW1lYnVmZmVyLmhlaWdodCA9IHRleFNpemVbMV07XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWy0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxXSk7XG5cdFx0XHR2YXIgdGV4Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMSwgMCwgMCwgMSwgMSwgMV0pO1xuXG5cdFx0XHR2YXIgdGV4Q29vcmRPZmZzZXQgPSB2ZXJ0aWNlcy5ieXRlTGVuZ3RoO1xuXG5cdFx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cdFx0XHRpZiAoIWJ1ZmZlcikge1xuXHRcdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcblx0XHRcdFx0Z2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLmJ5dGVMZW5ndGggKyB0ZXhDb29yZHMuYnl0ZUxlbmd0aCwgZ2wuU1RBVElDX0RSQVcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG5cdFx0XHR9XG5cblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB2ZXJ0aWNlcyk7XG5cdFx0XHRnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRPZmZzZXQsIHRleENvb3Jkcyk7XG5cblx0XHRcdHZhciBhUG9zTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYVBvcycpO1xuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVBvc0xvYyk7XG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGFQb3NMb2MsIDIsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgMCk7XG5cdFx0XHR2YXIgYVRleENvb3JkTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYVRleENvb3JkJyk7XG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhVGV4Q29vcmRMb2MpO1xuXHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhVGV4Q29vcmRMb2MsIDIsIGdsLkZMT0FULCBnbC5GQUxTRSwgMCwgdGV4Q29vcmRPZmZzZXQpO1xuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblxuXHRcdFx0Zm9yICh2YXIgcCBpbiB0aGlzLmNvbnN0YW50cykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmNvbnN0YW50c1twXTtcblx0XHRcdFx0dmFyIHR5cGUgPSB1dGlscy5nZXRBcmd1bWVudFR5cGUodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ0Zsb2F0JyB8fCB0eXBlID09PSAnSW50ZWdlcicpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cdFx0XHRcdHRoaXMuX2FkZENvbnN0YW50KHRoaXMuY29uc3RhbnRzW3BdLCB0eXBlLCBwKTtcblx0XHRcdFx0dGhpcy5jb25zdGFudHNMZW5ndGgrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLm91dHB1dEltbXV0YWJsZSkge1xuXHRcdFx0XHR0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcblx0XHRcdFx0aWYgKHRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcyAhPT0gbnVsbCAmJiB0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXModGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgcnVuXG4gICAqXG4gICAqIEBkZXNjIFJ1biB0aGUga2VybmVsIHByb2dyYW0sIGFuZCBzZW5kIHRoZSBvdXRwdXQgdG8gcmVuZGVyT3V0cHV0XG4gICAqXG4gICAqIDxwPiBUaGlzIG1ldGhvZCBjYWxscyBhIGhlbHBlciBtZXRob2QgKnJlbmRlck91dHB1dCogdG8gcmV0dXJuIHRoZSByZXN1bHQuIDwvcD5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHxVbmRlZmluZWR9IFJlc3VsdCBUaGUgZmluYWwgb3V0cHV0IG9mIHRoZSBwcm9ncmFtLCBhcyBmbG9hdCwgYW5kIGFzIFRleHR1cmVzIGZvciByZXVzZS5cbiAgICpcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1bicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcblx0XHRcdGlmICh0aGlzLnByb2dyYW0gPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5idWlsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcmFtTmFtZXMgPSB0aGlzLnBhcmFtTmFtZXM7XG5cdFx0XHR2YXIgcGFyYW1UeXBlcyA9IHRoaXMucGFyYW1UeXBlcztcblx0XHRcdHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHRcdFx0dmFyIGdsID0gdGhpcy5fd2ViR2w7XG5cblx0XHRcdGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHRcdGdsLnNjaXNzb3IoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG5cblx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ3VPdXRwdXREaW0nLCB0aGlzLnRocmVhZERpbSk7XG5cdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdigndVRleFNpemUnLCB0ZXhTaXplKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXRVbmlmb3JtMmYoJ3JhdGlvJywgdGV4U2l6ZVswXSAvIHRoaXMubWF4VGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSAvIHRoaXMubWF4VGV4U2l6ZVsxXSk7XG5cblx0XHRcdHRoaXMuYXJndW1lbnRzTGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIHRleEluZGV4ID0gMDsgdGV4SW5kZXggPCBwYXJhbU5hbWVzLmxlbmd0aDsgdGV4SW5kZXgrKykge1xuXHRcdFx0XHR0aGlzLl9hZGRBcmd1bWVudChhcmd1bWVudHNbdGV4SW5kZXhdLCBwYXJhbVR5cGVzW3RleEluZGV4XSwgcGFyYW1OYW1lc1t0ZXhJbmRleF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5ncmFwaGljYWwpIHtcblx0XHRcdFx0aWYgKHRoaXMub3V0cHV0VG9UZXh0dXJlKSB7XG5cdFx0XHRcdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdFx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLm91dHB1dFRleHR1cmUgfHwgdGhpcy5vdXRwdXRJbW11dGFibGUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRleHR1cmUodGhpcy5vdXRwdXRUZXh0dXJlLCB0ZXhTaXplLCB0aGlzLnRocmVhZERpbSwgdGhpcy5vdXRwdXQsIHRoaXMuX3dlYkdsLCAnQXJyYXlUZXh0dXJlKDQpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuXHRcdFx0aWYgKHRoaXMub3V0cHV0SW1tdXRhYmxlKSB7XG5cdFx0XHRcdHRoaXMuX3NldHVwT3V0cHV0VGV4dHVyZSgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG91dHB1dFRleHR1cmUgPSB0aGlzLm91dHB1dFRleHR1cmU7XG5cblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKHRoaXMub3V0cHV0SW1tdXRhYmxlKSB7XG5cdFx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcyA9IFtdO1xuXHRcdFx0XHRcdHRoaXMuX3NldHVwU3ViT3V0cHV0VGV4dHVyZXModGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzLmxlbmd0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5kcmF3QnVmZmVycy5kcmF3QnVmZmVyc1dFQkdMKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblxuXHRcdFx0aWYgKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdFx0XHRvdXRwdXQucmVzdWx0ID0gdGhpcy5yZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKG5ldyBUZXh0dXJlKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXNbaV0sIHRleFNpemUsIHRoaXMudGhyZWFkRGltLCB0aGlzLm91dHB1dCwgdGhpcy5fd2ViR2wpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMgIT09IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgX291dHB1dCA9IHtcblx0XHRcdFx0XHRcdHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHZhciBfaSA9IDA7XG5cdFx0XHRcdFx0Zm9yICh2YXIgcCBpbiB0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRcdGlmICghdGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdF9vdXRwdXRbcF0gPSBuZXcgVGV4dHVyZSh0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzW19pXSwgdGV4U2l6ZSwgdGhpcy50aHJlYWREaW0sIHRoaXMub3V0cHV0LCB0aGlzLl93ZWJHbCk7XG5cdFx0XHRcdFx0XHRfaSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gX291dHB1dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHJlbmRlck91dHB1dFxuICAgKlxuICAgKlxuICAgKiBAZGVzYyBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHdlYkdsIGZ1bmN0aW9uJ3Mgb3V0cHV0LlxuICAgKiBTaW5jZSB0aGUgcHJvZ3JhbSBydW5zIG9uIEdQVSwgd2UgbmVlZCB0byBnZXQgdGhlXG4gICAqIG91dHB1dCBvZiB0aGUgcHJvZ3JhbSBiYWNrIHRvIENQVSBhbmQgdGhlbiByZXR1cm4gdGhlbS5cbiAgICpcbiAgICogKk5vdGUqOiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0VGV4dHVyZSAtIE91dHB1dCBUZXh0dXJlIHJldHVybmVkIGJ5IHdlYkdsIHByb2dyYW1cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHxBcnJheX0gcmVzdWx0XG4gICAqXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJPdXRwdXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSkge1xuXHRcdFx0dmFyIHRleFNpemUgPSB0aGlzLnRleFNpemU7XG5cdFx0XHR2YXIgZ2wgPSB0aGlzLl93ZWJHbDtcblx0XHRcdHZhciB0aHJlYWREaW0gPSB0aGlzLnRocmVhZERpbTtcblx0XHRcdHZhciBvdXRwdXQgPSB0aGlzLm91dHB1dDtcblx0XHRcdGlmICh0aGlzLm91dHB1dFRvVGV4dHVyZSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRleHR1cmUob3V0cHV0VGV4dHVyZSwgdGV4U2l6ZSwgdGhpcy50aHJlYWREaW0sIG91dHB1dCwgdGhpcy5fd2ViR2wpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHZvaWQgMDtcblx0XHRcdFx0aWYgKHRoaXMuZmxvYXRPdXRwdXQpIHtcblx0XHRcdFx0XHR2YXIgdyA9IHRleFNpemVbMF07XG5cdFx0XHRcdFx0dmFyIGggPSBNYXRoLmNlaWwodGV4U2l6ZVsxXSAvIDQpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KTtcblx0XHRcdFx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdsLkZMT0FULCByZXN1bHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRleFNpemVbMF0gKiB0ZXhTaXplWzFdICogNCk7XG5cdFx0XHRcdFx0Z2wucmVhZFBpeGVscygwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBieXRlcyk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShieXRlcy5idWZmZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cblx0XHRcdFx0aWYgKG91dHB1dC5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9IGVsc2UgaWYgKG91dHB1dC5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIG91dHB1dFswXSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdHZhciBjdWJlID0gdXRpbHMuc3BsaXRBcnJheShyZXN1bHQsIG91dHB1dFswXSAqIG91dHB1dFsxXSk7XG5cdFx0XHRcdFx0cmV0dXJuIGN1YmUubWFwKGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdXRpbHMuc3BsaXRBcnJheSh4LCBvdXRwdXRbMF0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGdldE91dHB1dFRleHR1cmVcbiAgICpcbiAgICogQGRlc2MgVGhpcyByZXR1cm4gZGVmaW5lZCBvdXRwdXRUZXh0dXJlLCB3aGljaCBpcyBzZXR1cCBpbiAuYnVpbGQoKSwgb3IgaWYgaW1tdXRhYmxlLCBpcyBkZWZpbmVkIGluIC5ydW4oKVxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPdXRwdXQgVGV4dHVyZSBDYWNoZVxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0T3V0cHV0VGV4dHVyZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE91dHB1dFRleHR1cmUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vdXRwdXRUZXh0dXJlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfc2V0dXBPdXRwdXRUZXh0dXJlXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBkZXNjIFNldHVwIGFuZCByZXBsYWNlIG91dHB1dCB0ZXh0dXJlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfc2V0dXBPdXRwdXRUZXh0dXJlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldHVwT3V0cHV0VGV4dHVyZSgpIHtcblx0XHRcdHZhciBnbCA9IHRoaXMuX3dlYkdsO1xuXHRcdFx0dmFyIHRleFNpemUgPSB0aGlzLnRleFNpemU7XG5cdFx0XHR2YXIgdGV4dHVyZSA9IHRoaXMub3V0cHV0VGV4dHVyZSA9IHRoaXMuX3dlYkdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMucGFyYW1OYW1lcy5sZW5ndGgpO1xuXHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0aWYgKHRoaXMuZmxvYXRPdXRwdXQpIHtcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAcGFyYW0gbGVuZ3RoXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBkZXNjIFNldHVwIGFuZCByZXBsYWNlIHN1Yi1vdXRwdXQgdGV4dHVyZXNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19zZXR1cFN1Yk91dHB1dFRleHR1cmVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMobGVuZ3RoKSB7XG5cdFx0XHR2YXIgZ2wgPSB0aGlzLl93ZWJHbDtcblx0XHRcdHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHRcdFx0dmFyIGRyYXdCdWZmZXJzTWFwID0gdGhpcy5kcmF3QnVmZmVyc01hcCA9IFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gdGhpcy5fd2ViR2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0XHR0ZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuXHRcdFx0XHRkcmF3QnVmZmVyc01hcC5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEpO1xuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLnBhcmFtTmFtZXMubGVuZ3RoICsgaSk7XG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRpZiAodGhpcy5mbG9hdE91dHB1dCkge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRBcmd1bWVudFRleHR1cmVcbiAgICpcbiAgICogQGRlc2MgVGhpcyB1c2VzICpnZXRUZXh0dXJlQ2FjaGUqKiB0byBnZXQgdGhlIFRleHR1cmUgQ2FjaGUgb2YgdGhlIGFyZ3VtZW50IHN1cHBsaWVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYXJndW1lbnRcbiAgICpcbiAgICogXHRUZXh0dXJlIGNhY2hlIGZvciB0aGUgc3VwcGxpZWQgYXJndW1lbnRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEFyZ3VtZW50VGV4dHVyZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEFyZ3VtZW50VGV4dHVyZShuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRUZXh0dXJlQ2FjaGUoJ0FSR1VNRU5UXycgKyBuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAbmFtZSBnZXRUZXh0dXJlQ2FjaGVcbiAgICogQGZ1bmN0aW9uXG4gICAqXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIFRleHR1cmUgQ2FjaGUgb2YgdGhlIHN1cHBsaWVkIHBhcmFtZXRlciAoY2FuIGJlIGtlcm5lbCwgc3ViLWtlcm5lbCBvciBhcmd1bWVudClcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdWJrZXJuZWwsIGFyZ3VtZW50LCBvciBrZXJuZWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRleHR1cmUgY2FjaGVcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFRleHR1cmVDYWNoZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFRleHR1cmVDYWNoZShuYW1lKSB7XG5cdFx0XHRpZiAodGhpcy50ZXh0dXJlQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW25hbWVdID0gdGhpcy5fd2ViR2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBuYW1lIGRldGFjaFRleHR1cmVDYWNoZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQGRlc2MgcmVtb3ZlcyBhIHRleHR1cmUgZnJvbSB0aGUga2VybmVsJ3MgY2FjaGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRleHR1cmVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2RldGFjaFRleHR1cmVDYWNoZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRldGFjaFRleHR1cmVDYWNoZShuYW1lKSB7XG5cdFx0XHRkZWxldGUgdGhpcy50ZXh0dXJlQ2FjaGVbbmFtZV07XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VW5pZm9ybTFmJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybTFmKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy51bmlmb3JtMWZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSB0aGlzLnVuaWZvcm0xZkNhY2hlW25hbWVdO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IGNhY2hlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVuaWZvcm0xZkNhY2hlW25hbWVdID0gdmFsdWU7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0XHR0aGlzLl93ZWJHbC51bmlmb3JtMWYobG9jLCB2YWx1ZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VW5pZm9ybTFpJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybTFpKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy51bmlmb3JtMWlDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSB0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IGNhY2hlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVuaWZvcm0xaUNhY2hlW25hbWVdID0gdmFsdWU7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0XHR0aGlzLl93ZWJHbC51bmlmb3JtMWkobG9jLCB2YWx1ZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VW5pZm9ybTJmJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybTJmKG5hbWUsIHZhbHVlMSwgdmFsdWUyKSB7XG5cdFx0XHRpZiAodGhpcy51bmlmb3JtMmZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSB0aGlzLnVuaWZvcm0yZkNhY2hlW25hbWVdO1xuXHRcdFx0XHRpZiAodmFsdWUxID09PSBjYWNoZVswXSAmJiB2YWx1ZTIgPT09IGNhY2hlWzFdKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVuaWZvcm0yZkNhY2hlW25hbWVdID0gW3ZhbHVlMSwgdmFsdWUyXTtcblx0XHRcdHZhciBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcblx0XHRcdHRoaXMuX3dlYkdsLnVuaWZvcm0yZihsb2MsIHZhbHVlMSwgdmFsdWUyKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdzZXRVbmlmb3JtMmZ2Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybTJmdihuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMudW5pZm9ybTJmdkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdHZhciBjYWNoZSA9IHRoaXMudW5pZm9ybTJmdkNhY2hlW25hbWVdO1xuXHRcdFx0XHRpZiAodmFsdWVbMF0gPT09IGNhY2hlWzBdICYmIHZhbHVlWzFdID09PSBjYWNoZVsxXSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51bmlmb3JtMmZ2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdHZhciBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcblx0XHRcdHRoaXMuX3dlYkdsLnVuaWZvcm0yZnYobG9jLCB2YWx1ZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VW5pZm9ybTJpdicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm0yaXYobmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLnVuaWZvcm0yaXZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSB0aGlzLnVuaWZvcm0yaXZDYWNoZVtuYW1lXTtcblx0XHRcdFx0aWYgKHZhbHVlWzBdID09PSBjYWNoZVswXSAmJiB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0pIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudW5pZm9ybTJpdkNhY2hlW25hbWVdID0gdmFsdWU7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG5cdFx0XHR0aGlzLl93ZWJHbC51bmlmb3JtMml2KGxvYywgdmFsdWUpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3NldFVuaWZvcm0zZnYnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtM2Z2KG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy51bmlmb3JtM2Z2Q2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0dmFyIGNhY2hlID0gdGhpcy51bmlmb3JtM2Z2Q2FjaGVbbmFtZV07XG5cdFx0XHRcdGlmICh2YWx1ZVswXSA9PT0gY2FjaGVbMF0gJiYgdmFsdWVbMV0gPT09IGNhY2hlWzFdICYmIHZhbHVlWzJdID09PSBjYWNoZVsyXSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51bmlmb3JtM2Z2Q2FjaGVbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdHZhciBsb2MgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihuYW1lKTtcblx0XHRcdHRoaXMuX3dlYkdsLnVuaWZvcm0zZnYobG9jLCB2YWx1ZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VW5pZm9ybTNpdicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm0zaXYobmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLnVuaWZvcm0zaXZDYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSB0aGlzLnVuaWZvcm0zaXZDYWNoZVtuYW1lXTtcblx0XHRcdFx0aWYgKHZhbHVlWzBdID09PSBjYWNoZVswXSAmJiB2YWx1ZVsxXSA9PT0gY2FjaGVbMV0gJiYgdmFsdWVbMl0gPT09IGNhY2hlWzJdKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVuaWZvcm0zaXZDYWNoZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuXHRcdFx0dGhpcy5fd2ViR2wudW5pZm9ybTNpdihsb2MsIHZhbHVlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgZ2V0VW5pZm9ybUxvY2F0aW9uXG4gICAqXG4gICAqIEBkZXNjIFJldHVybiBXZWJHbFVuaWZvcm1Mb2NhdGlvbiBmb3IgdmFyaW91cyB2YXJpYWJsZXNcbiAgICogcmVsYXRlZCB0byB3ZWJHbCBwcm9ncmFtLCBzdWNoIGFzIHVzZXItZGVmaWVuZCB2YXJpYWJsZXMsXG4gICAqIGFzIHdlbGwgYXMsIGRpbWVuc2lvbiBzaXplcywgZXRjLlxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0VW5pZm9ybUxvY2F0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpIHtcblx0XHRcdGlmICh0aGlzLnByb2dyYW1Vbmlmb3JtTG9jYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGVbbmFtZV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wcm9ncmFtVW5pZm9ybUxvY2F0aW9uQ2FjaGVbbmFtZV0gPSB0aGlzLl93ZWJHbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcFxuICAgKlxuICAgKiBAZGVzYyBHZW5lcmF0ZSBTaGFkZXIgYXJ0aWZhY3RzIGZvciB0aGUga2VybmVsIHByb2dyYW0uXG4gICAqIFRoZSBmaW5hbCBvYmplY3QgY29udGFpbnMgSEVBREVSLCBLRVJORUwsIE1BSU5fUkVTVUxULCBhbmQgb3RoZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgU2hhZGVyIEFydGlmYWN0cyhDT05TVEFOVFMsIEhFQURFUiwgS0VSTkVMLCBldGMuKVxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRGcmFnU2hhZGVyQXJ0aWZhY3RNYXAoYXJncykge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0SEVBREVSOiB0aGlzLl9nZXRIZWFkZXJTdHJpbmcoKSxcblx0XHRcdFx0TE9PUF9NQVg6IHRoaXMuX2dldExvb3BNYXhTdHJpbmcoKSxcblx0XHRcdFx0Q09OU1RBTlRTOiB0aGlzLl9nZXRDb25zdGFudHNTdHJpbmcoKSxcblx0XHRcdFx0REVDT0RFMzJfRU5ESUFOTkVTUzogdGhpcy5fZ2V0RGVjb2RlMzJFbmRpYW5uZXNzU3RyaW5nKCksXG5cdFx0XHRcdEVOQ09ERTMyX0VORElBTk5FU1M6IHRoaXMuX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZygpLFxuXHRcdFx0XHRESVZJREVfV0lUSF9JTlRFR0VSX0NIRUNLOiB0aGlzLl9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCksXG5cdFx0XHRcdEdFVF9XUkFQQVJPVU5EOiB0aGlzLl9nZXRHZXRXcmFwYXJvdW5kU3RyaW5nKCksXG5cdFx0XHRcdEdFVF9URVhUVVJFX0NIQU5ORUw6IHRoaXMuX2dldEdldFRleHR1cmVDaGFubmVsU3RyaW5nKCksXG5cdFx0XHRcdEdFVF9URVhUVVJFX0lOREVYOiB0aGlzLl9nZXRHZXRUZXh0dXJlSW5kZXhTdHJpbmcoKSxcblx0XHRcdFx0R0VUX1JFU1VMVDogdGhpcy5fZ2V0R2V0UmVzdWx0U3RyaW5nKCksXG5cdFx0XHRcdE1BSU5fUEFSQU1TOiB0aGlzLl9nZXRNYWluUGFyYW1zU3RyaW5nKGFyZ3MpLFxuXHRcdFx0XHRNQUlOX0NPTlNUQU5UUzogdGhpcy5fZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpLFxuXHRcdFx0XHRLRVJORUw6IHRoaXMuX2dldEtlcm5lbFN0cmluZygpLFxuXHRcdFx0XHRNQUlOX1JFU1VMVDogdGhpcy5fZ2V0TWFpblJlc3VsdFN0cmluZygpXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfYWRkQXJndW1lbnRcbiAgICpcbiAgICogQGRlc2MgQWRkcyBrZXJuZWwgcGFyYW1ldGVycyB0byB0aGUgQXJndW1lbnQgVGV4dHVyZSxcbiAgICogYmluZGluZyBpdCB0byB0aGUgd2ViR2wgaW5zdGFuY2UsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheXxUZXh0dXJlfE51bWJlcn0gdmFsdWUgLSBUaGUgYWN0dWFsIGFyZ3VtZW50IHN1cHBsaWVkIHRvIHRoZSBrZXJuZWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBUeXBlIG9mIHRoZSBhcmd1bWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfYWRkQXJndW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfYWRkQXJndW1lbnQodmFsdWUsIHR5cGUsIG5hbWUpIHtcblx0XHRcdHZhciBnbCA9IHRoaXMuX3dlYkdsO1xuXHRcdFx0dmFyIGFyZ3VtZW50VGV4dHVyZSA9IHRoaXMuZ2V0QXJndW1lbnRUZXh0dXJlKG5hbWUpO1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuXHRcdFx0XHR0eXBlID0gdmFsdWUudHlwZTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5KDIpJzpcblx0XHRcdFx0Y2FzZSAnQXJyYXkoMyknOlxuXHRcdFx0XHRjYXNlICdBcnJheSg0KSc6XG5cdFx0XHRcdGNhc2UgJ0FycmF5MkQnOlxuXHRcdFx0XHRjYXNlICdBcnJheTNEJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR2YXIgc2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdFx0XHRcdH0sIGRpbSk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHNpemVbMF0gKiBzaXplWzFdO1xuXG5cdFx0XHRcdFx0XHR2YXIgX2Zvcm1hdEFycmF5VHJhbnNmZXIyID0gdGhpcy5fZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoKSxcblx0XHRcdFx0XHRcdCAgICB2YWx1ZXNGbGF0ID0gX2Zvcm1hdEFycmF5VHJhbnNmZXIyLnZhbHVlc0ZsYXQsXG5cdFx0XHRcdFx0XHQgICAgYml0UmF0aW8gPSBfZm9ybWF0QXJyYXlUcmFuc2ZlcjIuYml0UmF0aW87XG5cblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSB2b2lkIDA7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5mbG9hdFRleHR1cmVzKSB7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHZhbHVlc0ZsYXQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzRmxhdC5idWZmZXIpO1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNpemVbMF0gLyBiaXRSYXRpbywgc2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdigndXNlcl8nICsgbmFtZSArICdEaW0nLCBkaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ3VzZXJfJyArIG5hbWUgKyAnU2l6ZScsIHNpemUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ3VzZXJfJyArIG5hbWUgKyAnQml0UmF0aW8nLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgndXNlcl8nICsgbmFtZSwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFmKCd1c2VyXycgKyBuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaW5wdXQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGltID0gaW5wdXQuc2l6ZTtcblx0XHRcdFx0XHRcdHZhciBfc2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdFx0XHRcdH0sIF9kaW0pO1xuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYXJndW1lbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cblx0XHRcdFx0XHRcdHZhciBfbGVuZ3RoID0gX3NpemVbMF0gKiBfc2l6ZVsxXTtcblxuXHRcdFx0XHRcdFx0dmFyIF9mb3JtYXRBcnJheVRyYW5zZmVyMyA9IHRoaXMuX2Zvcm1hdEFycmF5VHJhbnNmZXIodmFsdWUudmFsdWUsIF9sZW5ndGgpLFxuXHRcdFx0XHRcdFx0ICAgIF92YWx1ZXNGbGF0ID0gX2Zvcm1hdEFycmF5VHJhbnNmZXIzLnZhbHVlc0ZsYXQsXG5cdFx0XHRcdFx0XHQgICAgX2JpdFJhdGlvID0gX2Zvcm1hdEFycmF5VHJhbnNmZXIzLmJpdFJhdGlvO1xuXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5mbG9hdFRleHR1cmVzKSB7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3NpemVbMF0sIF9zaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgaW5wdXRBcnJheSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KF92YWx1ZXNGbGF0LmJ1ZmZlcik7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3NpemVbMF0gLyBfYml0UmF0aW8sIF9zaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBfYnVmZmVyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdigndXNlcl8nICsgbmFtZSArICdEaW0nLCBfZGltKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KCd1c2VyXycgKyBuYW1lICsgJ1NpemUnLCBfc2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgndXNlcl8nICsgbmFtZSArICdCaXRSYXRpbycsIF9iaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgndXNlcl8nICsgbmFtZSwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dEltYWdlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR2YXIgX2RpbTIgPSBbaW5wdXRJbWFnZS53aWR0aCwgaW5wdXRJbWFnZS5oZWlnaHQsIDFdO1xuXHRcdFx0XHRcdFx0dmFyIF9zaXplMiA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodF07XG5cblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHQvLyBVcGxvYWQgdGhlIGltYWdlIGludG8gdGhlIHRleHR1cmUuXG5cdFx0XHRcdFx0XHR2YXIgbWlwTGV2ZWwgPSAwOyAvLyB0aGUgbGFyZ2VzdCBtaXBcblx0XHRcdFx0XHRcdHZhciBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCB3ZSB3YW50IGluIHRoZSB0ZXh0dXJlXG5cdFx0XHRcdFx0XHR2YXIgc3JjRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdFx0dmFyIHNyY1R5cGUgPSBnbC5VTlNJR05FRF9CWVRFOyAvLyB0eXBlIG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBMZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHNyY0Zvcm1hdCwgc3JjVHlwZSwgaW5wdXRJbWFnZSk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ3VzZXJfJyArIG5hbWUgKyAnRGltJywgX2RpbTIpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KCd1c2VyXycgKyBuYW1lICsgJ1NpemUnLCBfc2l6ZTIpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ3VzZXJfJyArIG5hbWUsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0Y2FzZSAnTnVtYmVyVGV4dHVyZSc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGlucHV0VGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0dmFyIF9kaW0zID0gaW5wdXRUZXh0dXJlLmRpbWVuc2lvbnM7XG5cdFx0XHRcdFx0XHR2YXIgX3NpemUzID0gaW5wdXRUZXh0dXJlLnNpemU7XG5cblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCd1c2VyXycgKyBuYW1lICsgJ0RpbScsIF9kaW0zKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdigndXNlcl8nICsgbmFtZSArICdTaXplJywgX3NpemUzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCd1c2VyXycgKyBuYW1lICsgJ0JpdFJhdGlvJywgMSk7IC8vIGF3YXlzIGZsb2F0MzJcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCd1c2VyXycgKyBuYW1lLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlIG5vdCBzdXBwb3J0ZWQgKFdlYkdMKTogJyArIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYXJndW1lbnRzTGVuZ3RoKys7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9hZGRDb25zdGFudFxuICAgKlxuICAgKiBAZGVzYyBBZGRzIGtlcm5lbCBwYXJhbWV0ZXJzIHRvIHRoZSBBcmd1bWVudCBUZXh0dXJlLFxuICAgKiBiaW5kaW5nIGl0IHRvIHRoZSB3ZWJHbCBpbnN0YW5jZSwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fFRleHR1cmV8TnVtYmVyfSB2YWx1ZSAtIFRoZSBhY3R1YWwgYXJndW1lbnQgc3VwcGxpZWQgdG8gdGhlIGtlcm5lbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIFR5cGUgb2YgdGhlIGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYXJndW1lbnRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19hZGRDb25zdGFudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9hZGRDb25zdGFudCh2YWx1ZSwgdHlwZSwgbmFtZSkge1xuXHRcdFx0dmFyIGdsID0gdGhpcy5fd2ViR2w7XG5cdFx0XHR2YXIgYXJndW1lbnRUZXh0dXJlID0gdGhpcy5nZXRBcmd1bWVudFRleHR1cmUobmFtZSk7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG5cdFx0XHRcdHR5cGUgPSB2YWx1ZS50eXBlO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgZGltID0gdXRpbHMuZ2V0RGltZW5zaW9ucyh2YWx1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR2YXIgc2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdFx0XHRcdH0sIGRpbSk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYXJndW1lbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cblx0XHRcdFx0XHRcdHZhciBsZW5ndGggPSBzaXplWzBdICogc2l6ZVsxXTtcblxuXHRcdFx0XHRcdFx0dmFyIF9mb3JtYXRBcnJheVRyYW5zZmVyNCA9IHRoaXMuX2Zvcm1hdEFycmF5VHJhbnNmZXIodmFsdWUsIGxlbmd0aCksXG5cdFx0XHRcdFx0XHQgICAgdmFsdWVzRmxhdCA9IF9mb3JtYXRBcnJheVRyYW5zZmVyNC52YWx1ZXNGbGF0LFxuXHRcdFx0XHRcdFx0ICAgIGJpdFJhdGlvID0gX2Zvcm1hdEFycmF5VHJhbnNmZXI0LmJpdFJhdGlvO1xuXG5cdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gdm9pZCAwO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZmxvYXRUZXh0dXJlcykge1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNpemVbMF0sIHNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCB2YWx1ZXNGbGF0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlc0ZsYXQuYnVmZmVyKTtcblx0XHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzaXplWzBdIC8gYml0UmF0aW8sIHNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGJ1ZmZlcik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdEaW0nLCBkaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdTaXplJywgc2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgnY29uc3RhbnRzXycgKyBuYW1lICsgJ0JpdFJhdGlvJywgYml0UmF0aW8pO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ2NvbnN0YW50c18nICsgbmFtZSwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdJbnB1dCc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGlucHV0ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR2YXIgX2RpbTQgPSBpbnB1dC5zaXplO1xuXHRcdFx0XHRcdFx0dmFyIF9zaXplNCA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdFx0XHRcdH0sIF9kaW00KTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0dmFyIF9sZW5ndGgyID0gX3NpemU0WzBdICogX3NpemU0WzFdO1xuXG5cdFx0XHRcdFx0XHR2YXIgX2Zvcm1hdEFycmF5VHJhbnNmZXI1ID0gdGhpcy5fZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZS52YWx1ZSwgX2xlbmd0aDIpLFxuXHRcdFx0XHRcdFx0ICAgIF92YWx1ZXNGbGF0MiA9IF9mb3JtYXRBcnJheVRyYW5zZmVyNS52YWx1ZXNGbGF0LFxuXHRcdFx0XHRcdFx0ICAgIF9iaXRSYXRpbzIgPSBfZm9ybWF0QXJyYXlUcmFuc2ZlcjUuYml0UmF0aW87XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmZsb2F0VGV4dHVyZXMpIHtcblx0XHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfc2l6ZTRbMF0sIF9zaXplNFsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIGlucHV0QXJyYXkpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIF9idWZmZXIyID0gbmV3IFVpbnQ4QXJyYXkoX3ZhbHVlc0ZsYXQyLmJ1ZmZlcik7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3NpemU0WzBdIC8gX2JpdFJhdGlvMiwgX3NpemU0WzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBfYnVmZmVyMik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdEaW0nLCBfZGltNCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdignY29uc3RhbnRzXycgKyBuYW1lICsgJ1NpemUnLCBfc2l6ZTQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ2NvbnN0YW50c18nICsgbmFtZSArICdCaXRSYXRpbycsIF9iaXRSYXRpbzIpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ2NvbnN0YW50c18nICsgbmFtZSwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dEltYWdlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR2YXIgX2RpbTUgPSBbaW5wdXRJbWFnZS53aWR0aCwgaW5wdXRJbWFnZS5oZWlnaHQsIDFdO1xuXHRcdFx0XHRcdFx0dmFyIF9zaXplNSA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodF07XG5cblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdFx0XHRcdFx0Ly8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlLlxuXHRcdFx0XHRcdFx0dmFyIG1pcExldmVsID0gMDsgLy8gdGhlIGxhcmdlc3QgbWlwXG5cdFx0XHRcdFx0XHR2YXIgaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBOyAvLyBmb3JtYXQgd2Ugd2FudCBpbiB0aGUgdGV4dHVyZVxuXHRcdFx0XHRcdFx0dmFyIHNyY0Zvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCBvZiBkYXRhIHdlIGFyZSBzdXBwbHlpbmdcblx0XHRcdFx0XHRcdHZhciBzcmNUeXBlID0gZ2wuVU5TSUdORURfQllURTsgLy8gdHlwZSBvZiBkYXRhIHdlIGFyZSBzdXBwbHlpbmdcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwTGV2ZWwsIGludGVybmFsRm9ybWF0LCBzcmNGb3JtYXQsIHNyY1R5cGUsIGlucHV0SW1hZ2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCdjb25zdGFudHNfJyArIG5hbWUgKyAnRGltJywgX2RpbTUpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KCdjb25zdGFudHNfJyArIG5hbWUgKyAnU2l6ZScsIF9zaXplNSk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgnY29uc3RhbnRzXycgKyBuYW1lLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dFRleHR1cmUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGltNiA9IGlucHV0VGV4dHVyZS5kaW1lbnNpb25zO1xuXHRcdFx0XHRcdFx0dmFyIF9zaXplNiA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlLnRleHR1cmUpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdEaW0nLCBfZGltNik7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdTaXplJywgX3NpemU2KTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCdjb25zdGFudHNfJyArIG5hbWUgKyAnQml0UmF0aW8nLCAxKTsgLy8gYXdheXMgZmxvYXQzMlxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ2NvbnN0YW50c18nICsgbmFtZSwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdJbnRlZ2VyJzpcblx0XHRcdFx0Y2FzZSAnRmxvYXQnOlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZSBub3Qgc3VwcG9ydGVkIChXZWJHTCk6ICcgKyB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9mb3JtYXRBcnJheVRyYW5zZmVyXG4gICAqXG4gICAqIEBkZXNjIEFkZHMga2VybmVsIHBhcmFtZXRlcnMgdG8gdGhlIEFyZ3VtZW50IFRleHR1cmUsXG4gICAqIGJpbmRpbmcgaXQgdG8gdGhlIHdlYkdsIGluc3RhbmNlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIC0gVGhlIGFjdHVhbCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUga2VybmVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsZW5ndGggLSB0aGUgZXhwZWN0ZWQgdG90YWwgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gYml0UmF0aW8gLSBiaXQgc3RvcmFnZSByYXRpbyBvZiBzb3VyY2UgdG8gdGFyZ2V0ICdidWZmZXInLCBpLmUuIGlmIDhiaXQgYXJyYXkgLT4gMzJiaXQgdGV4ID0gNFxuICAgKiBcdFx0XHRcdCAgICAgdmFsdWVzRmxhdCAtIGZsYXR0ZW5lZCBhcnJheSB0byB0cmFuc2ZlclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2Zvcm1hdEFycmF5VHJhbnNmZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoKSB7XG5cdFx0XHR2YXIgYml0UmF0aW8gPSAxOyAvLyBiaXQgc3RvcmFnZSByYXRpbyBvZiBzb3VyY2UgdG8gdGFyZ2V0ICdidWZmZXInLCBpLmUuIGlmIDhiaXQgYXJyYXkgLT4gMzJiaXQgdGV4ID0gNFxuXHRcdFx0dmFyIHZhbHVlc0ZsYXQgPSB2YWx1ZTtcblx0XHRcdGlmICh1dGlscy5pc0FycmF5KHZhbHVlWzBdKSB8fCB0aGlzLmZsb2F0VGV4dHVyZXMpIHtcblx0XHRcdFx0Ly8gbm90IGFscmVhZHkgZmxhdFxuXHRcdFx0XHR2YWx1ZXNGbGF0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXHRcdFx0XHR1dGlscy5mbGF0dGVuVG8odmFsdWUsIHZhbHVlc0ZsYXQpO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0Y2FzZSBVaW50OEFycmF5OlxuXHRcdFx0XHRcdGNhc2UgSW50OEFycmF5OlxuXHRcdFx0XHRcdFx0Yml0UmF0aW8gPSA0O1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdFx0XHRjYXNlIEludDE2QXJyYXk6XG5cdFx0XHRcdFx0XHRiaXRSYXRpbyA9IDI7XG5cdFx0XHRcdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBJbnQzMkFycmF5OlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dmFsdWVzRmxhdCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcblx0XHRcdFx0XHRcdHV0aWxzLmZsYXR0ZW5Ubyh2YWx1ZSwgdmFsdWVzRmxhdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGJpdFJhdGlvOiBiaXRSYXRpbyxcblx0XHRcdFx0dmFsdWVzRmxhdDogdmFsdWVzRmxhdFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldEhlYWRlclN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgdGhlIGhlYWRlciBzdHJpbmcgZm9yIHRoZSBwcm9ncmFtLlxuICAgKiBUaGlzIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nIGlmIG5vIHN1Yi1rZXJuZWxzIGFyZSBkZWZpbmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRIZWFkZXJTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0SGVhZGVyU3RyaW5nKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCB8fCB0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMgIT09IG51bGwgP1xuXHRcdFx0Ly93ZWJnbDIgJyN2ZXJzaW9uIDMwMCBlc1xcbicgOlxuXHRcdFx0JyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmVcXG4nIDogJyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRMb29wTWF4U3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIEdldCB0aGUgbWF4aW11bSBsb29wIHNpemUgU3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRMb29wTWF4U3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldExvb3BNYXhTdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5sb29wTWF4SXRlcmF0aW9ucyA/ICcgJyArIHBhcnNlSW50KHRoaXMubG9vcE1heEl0ZXJhdGlvbnMpICsgJy4wO1xcbicgOiAnIDEwMDAuMDtcXG4nO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0Q29uc3RhbnRzU3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIEdlbmVyYXRlIHRyYW5zcGlsZWQgZ2xzbCBTdHJpbmdzIGZvciBjb25zdGFudCBwYXJhbWV0ZXJzIHNlbnQgdG8gYSBrZXJuZWxcbiAgICpcbiAgICogVGhleSBjYW4gYmUgZGVmaW5lZCBieSAqaGFyZGNvZGVDb25zdGFudHMqXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldENvbnN0YW50c1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRDb25zdGFudHNTdHJpbmcoKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR2YXIgdGhyZWFkRGltID0gdGhpcy50aHJlYWREaW07XG5cdFx0XHR2YXIgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcblx0XHRcdGlmICh0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCdpdmVjMyB1T3V0cHV0RGltID0gaXZlYzMoJyArIHRocmVhZERpbVswXSArICcsJyArIHRocmVhZERpbVsxXSArICcsICcgKyB0aHJlYWREaW1bMl0gKyAnKScsICdpdmVjMiB1VGV4U2l6ZSA9IGl2ZWMyKCcgKyB0ZXhTaXplWzBdICsgJywgJyArIHRleFNpemVbMV0gKyAnKScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goJ3VuaWZvcm0gaXZlYzMgdU91dHB1dERpbScsICd1bmlmb3JtIGl2ZWMyIHVUZXhTaXplJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRUZXh0dXJlQ29vcmRpbmF0ZVxuICAgKlxuICAgKiBAZGVzYyBHZXQgdGV4dHVyZSBjb29yZGluYXRlIHN0cmluZyBmb3IgdGhlIHByb2dyYW1cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfZ2V0VGV4dHVyZUNvb3JkaW5hdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0VGV4dHVyZUNvb3JkaW5hdGUoKSB7XG5cdFx0XHR2YXIgbmFtZXMgPSB0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXM7XG5cdFx0XHRpZiAobmFtZXMgPT09IG51bGwgfHwgbmFtZXMubGVuZ3RoIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAnb3V0IHZlYzIgdlRleENvb3JkO1xcbic7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgR2V0IERlY29kZTMyIGVuZGlhbm5lc3Mgc3RyaW5nIGZvciBsaXR0bGUtZW5kaWFuIGFuZCBiaWctZW5kaWFuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldERlY29kZTMyRW5kaWFubmVzc1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXREZWNvZGUzMkVuZGlhbm5lc3NTdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbmRpYW5uZXNzID09PSAnTEUnID8gJycgOiAnICByZ2JhLnJnYmEgPSByZ2JhLmFiZ3I7XFxuJztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgRW5jb2RlMzIgZW5kaWFubmVzcyBzdHJpbmcgZm9yIGxpdHRsZS1lbmRpYW4gYW5kIGJpZy1lbmRpYW5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfZ2V0RW5jb2RlMzJFbmRpYW5uZXNzU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldEVuY29kZTMyRW5kaWFubmVzc1N0cmluZygpIHtcblx0XHRcdHJldHVybiB0aGlzLmVuZGlhbm5lc3MgPT09ICdMRScgPyAnJyA6ICcgIHJnYmEucmdiYSA9IHJnYmEuYWJncjtcXG4nO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0RGl2aWRlV2l0aEludGVnZXJDaGVja1N0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBpZiBmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSBwcm92aWRlIG1ldGhvZCB0byByZXBsYWNlIC9cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfZ2V0RGl2aWRlV2l0aEludGVnZXJDaGVja1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXREaXZpZGVXaXRoSW50ZWdlckNoZWNrU3RyaW5nKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPyAnXFxuXFx0XFx0XFx0ICBmbG9hdCBkaXZfd2l0aF9pbnRfY2hlY2soZmxvYXQgeCwgZmxvYXQgeSkge1xcblxcdFxcdFxcdCAgaWYgKGZsb29yKHgpID09IHggJiYgZmxvb3IoeSkgPT0geSAmJiBpbnRlZ2VyTW9kKHgsIHkpID09IDAuMCkge1xcblxcdFxcdFxcdCAgICByZXR1cm4gZmxvYXQoaW50KHgpL2ludCh5KSk7XFxuXFx0XFx0XFx0ICB9XFxuXFx0XFx0XFx0ICByZXR1cm4geCAvIHk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdCcgOiAnJztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQG5hbWUgX2dldEdldFdyYXBhcm91bmRTdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gd3JhcGFyb3VuZCBzdHJpbmdcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRHZXRXcmFwYXJvdW5kU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldEdldFdyYXBhcm91bmRTdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy53cmFwYXJvdW5kID8gJyAgeHl6ID0gbW9kKHh5eiwgdGV4RGltKTtcXG4nIDogJyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRHZXRUZXh0dXJlQ2hhbm5lbFN0cmluZ1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEdldFRleHR1cmVDaGFubmVsU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldEdldFRleHR1cmVDaGFubmVsU3RyaW5nKCkge1xuXHRcdFx0aWYgKCF0aGlzLmZsb2F0VGV4dHVyZXMpIHJldHVybiAnJztcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2xpbmVzVG9TdHJpbmcoWycgIGludCBjaGFubmVsID0gaW50ZWdlck1vZChpbmRleCwgNCknLCAnICBpbmRleCA9IGluZGV4IC8gNCddKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldEdldFRleHR1cmVJbmRleFN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgZ2VuZXJpYyB0ZXh0dXJlIGluZGV4IHN0cmluZywgaWYgZmxvYXRUZXh0dXJlcyBmbGFnIGlzIHRydWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICcgIGluZGV4ID0gZmxvYXQoaW50KGluZGV4KS80KTtcXG4nXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfZ2V0R2V0VGV4dHVyZUluZGV4U3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldEdldFRleHR1cmVJbmRleFN0cmluZygpIHtcblx0XHRcdHJldHVybiB0aGlzLmZsb2F0VGV4dHVyZXMgPyAnICBpbmRleCA9IGluZGV4IC8gNDtcXG4nIDogJyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRHZXRSZXN1bHRTdHJpbmdcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRHZXRSZXN1bHRTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0R2V0UmVzdWx0U3RyaW5nKCkge1xuXHRcdFx0aWYgKCF0aGlzLmZsb2F0VGV4dHVyZXMpIHtcblx0XHRcdFx0cmV0dXJuICcgIHJldHVybiBkZWNvZGUodGV4ZWwsIHgsIGJpdFJhdGlvKTsnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2xpbmVzVG9TdHJpbmcoWycgIGlmIChjaGFubmVsID09IDApIHJldHVybiB0ZXhlbC5yJywgJyAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHRleGVsLmcnLCAnICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gdGV4ZWwuYicsICcgIGlmIChjaGFubmVsID09IDMpIHJldHVybiB0ZXhlbC5hJ10pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0TWFpblBhcmFtc1N0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZW5lcmF0ZSB0cmFuc3BpbGVkIGdsc2wgU3RyaW5ncyBmb3IgdXNlci1kZWZpbmVkIHBhcmFtZXRlcnMgc2VudCB0byBhIGtlcm5lbFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRNYWluUGFyYW1zU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldE1haW5QYXJhbXNTdHJpbmcoYXJncykge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0dmFyIHBhcmFtVHlwZXMgPSB0aGlzLnBhcmFtVHlwZXM7XG5cdFx0XHR2YXIgcGFyYW1OYW1lcyA9IHRoaXMucGFyYW1OYW1lcztcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1OYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFyYW0gPSBhcmdzW2ldO1xuXHRcdFx0XHR2YXIgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcblx0XHRcdFx0dmFyIHBhcmFtVHlwZSA9IHBhcmFtVHlwZXNbaV07XG5cdFx0XHRcdGlmICh0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0aWYgKHBhcmFtVHlwZSA9PT0gJ0FycmF5JyB8fCBwYXJhbVR5cGUgPT09ICdOdW1iZXJUZXh0dXJlJyB8fCBwYXJhbVR5cGUgPT09ICdBcnJheVRleHR1cmUoNCknKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGFyYW1EaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKHBhcmFtLCB0cnVlKTtcblx0XHRcdFx0XHRcdHZhciBwYXJhbVNpemUgPSB1dGlscy5kaW1Ub1RleFNpemUoe1xuXHRcdFx0XHRcdFx0XHRmbG9hdFRleHR1cmVzOiB0aGlzLmZsb2F0VGV4dHVyZXMsXG5cdFx0XHRcdFx0XHRcdGZsb2F0T3V0cHV0OiB0aGlzLmZsb2F0T3V0cHV0XG5cdFx0XHRcdFx0XHR9LCBwYXJhbURpbSk7XG5cblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCd1bmlmb3JtIHNhbXBsZXIyRCB1c2VyXycgKyBwYXJhbU5hbWUsICdpdmVjMiB1c2VyXycgKyBwYXJhbU5hbWUgKyAnU2l6ZSA9IGl2ZWMyKCcgKyBwYXJhbVNpemVbMF0gKyAnLCAnICsgcGFyYW1TaXplWzFdICsgJyknLCAnaXZlYzMgdXNlcl8nICsgcGFyYW1OYW1lICsgJ0RpbSA9IGl2ZWMzKCcgKyBwYXJhbURpbVswXSArICcsICcgKyBwYXJhbURpbVsxXSArICcsICcgKyBwYXJhbURpbVsyXSArICcpJywgJ3VuaWZvcm0gaW50IHVzZXJfJyArIHBhcmFtTmFtZSArICdCaXRSYXRpbycpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocGFyYW1UeXBlID09PSAnSW50ZWdlcicpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdmbG9hdCB1c2VyXycgKyBwYXJhbU5hbWUgKyAnID0gJyArIHBhcmFtICsgJy4wJyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwYXJhbVR5cGUgPT09ICdGbG9hdCcpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdmbG9hdCB1c2VyXycgKyBwYXJhbU5hbWUgKyAnID0gJyArIHBhcmFtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHBhcmFtVHlwZSA9PT0gJ0FycmF5JyB8fCBwYXJhbVR5cGUgPT09ICdOdW1iZXJUZXh0dXJlJyB8fCBwYXJhbVR5cGUgPT09ICdBcnJheVRleHR1cmUoNCknIHx8IHBhcmFtVHlwZSA9PT0gJ0lucHV0JyB8fCBwYXJhbVR5cGUgPT09ICdIVE1MSW1hZ2UnKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgndW5pZm9ybSBzYW1wbGVyMkQgdXNlcl8nICsgcGFyYW1OYW1lLCAndW5pZm9ybSBpdmVjMiB1c2VyXycgKyBwYXJhbU5hbWUgKyAnU2l6ZScsICd1bmlmb3JtIGl2ZWMzIHVzZXJfJyArIHBhcmFtTmFtZSArICdEaW0nKTtcblx0XHRcdFx0XHRcdGlmIChwYXJhbVR5cGUgIT09ICdIVE1MSW1hZ2UnKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCd1bmlmb3JtIGludCB1c2VyXycgKyBwYXJhbU5hbWUgKyAnQml0UmF0aW8nKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBhcmFtVHlwZSA9PT0gJ0ludGVnZXInIHx8IHBhcmFtVHlwZSA9PT0gJ0Zsb2F0Jykge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ3VuaWZvcm0gZmxvYXQgdXNlcl8nICsgcGFyYW1OYW1lKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYXJhbSB0eXBlICcgKyBwYXJhbVR5cGUgKyAnIG5vdCBzdXBwb3J0ZWQgaW4gV2ViR0wsIG9ubHkgV2ViR0wyJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fbGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0TWFpbkNvbnN0YW50c1N0cmluZ1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldE1haW5Db25zdGFudHNTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWFpbkNvbnN0YW50c1N0cmluZygpIHtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRcdGlmICh0aGlzLmNvbnN0YW50cykge1xuXHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIHRoaXMuY29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5jb25zdGFudHNbbmFtZV07XG5cdFx0XHRcdFx0dmFyIHR5cGUgPSB1dGlscy5nZXRBcmd1bWVudFR5cGUodmFsdWUpO1xuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdjb25zdCBmbG9hdCBjb25zdGFudHNfJyArIG5hbWUgKyAnID0gJyArIHBhcnNlSW50KHZhbHVlKSArICcuMCcpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ2NvbnN0IGZsb2F0IGNvbnN0YW50c18nICsgbmFtZSArICcgPSAnICsgcGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCd1bmlmb3JtIHNhbXBsZXIyRCBjb25zdGFudHNfJyArIG5hbWUsICd1bmlmb3JtIGl2ZWMyIGNvbnN0YW50c18nICsgbmFtZSArICdTaXplJywgJ3VuaWZvcm0gaXZlYzMgY29uc3RhbnRzXycgKyBuYW1lICsgJ0RpbScsICd1bmlmb3JtIGludCBjb25zdGFudHNfJyArIG5hbWUgKyAnQml0UmF0aW8nKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbnN0YW50ICcgKyBuYW1lICsgJyB0eXBlICcgKyB0eXBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRLZXJuZWxTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgR2V0IEtlcm5lbCBwcm9ncmFtIHN0cmluZyAoaW4gKmdsc2wqKSBmb3IgYSBrZXJuZWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEtlcm5lbFN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRLZXJuZWxTdHJpbmcoKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR2YXIgbmFtZXMgPSB0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXM7XG5cdFx0XHRpZiAobmFtZXMgIT09IG51bGwpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goJ2Zsb2F0IGtlcm5lbFJlc3VsdCA9IDAuMCcpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goJ2Zsb2F0ICcgKyBuYW1lc1tpXSArICcgPSAwLjAnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goJ2Zsb2F0IGtlcm5lbFJlc3VsdCA9IDAuMCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGluZXNUb1N0cmluZyhyZXN1bHQpICsgdGhpcy5mdW5jdGlvbkJ1aWxkZXIuZ2V0UHJvdG90eXBlU3RyaW5nKCdrZXJuZWwnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICpcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldE1haW5SZXN1bHRTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgR2V0IG1haW4gcmVzdWx0IHN0cmluZyB3aXRoIGNoZWNrcyBmb3IgZmxvYXRPdXRwdXQsIGdyYXBoaWNhbCwgc3ViS2VybmVsc091dHB1dHMsIGV0Yy5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gcmVzdWx0XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfZ2V0TWFpblJlc3VsdFN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRNYWluUmVzdWx0U3RyaW5nKCkge1xuXHRcdFx0dmFyIG5hbWVzID0gdGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXG5cdFx0XHRpZiAodGhpcy5mbG9hdE91dHB1dCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCgnICBpbmRleCAqPSA0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmdyYXBoaWNhbCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCgnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknLCAnICBrZXJuZWwoKScsICcgIGdsX0ZyYWdDb2xvciA9IGFjdHVhbENvbG9yJyk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZmxvYXRPdXRwdXQpIHtcblx0XHRcdFx0dmFyIGNoYW5uZWxzID0gWydyJywgJ2cnLCAnYicsICdhJ107XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVscy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScpO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCcgIGtlcm5lbCgpJyk7XG5cblx0XHRcdFx0XHRpZiAobmFtZXMpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCcgIGdsX0ZyYWdEYXRhWzBdLicgKyBjaGFubmVsc1tpXSArICcgPSBrZXJuZWxSZXN1bHQnKTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBnbF9GcmFnRGF0YVsnICsgKGogKyAxKSArICddLicgKyBjaGFubmVsc1tpXSArICcgPSAnICsgbmFtZXNbal0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBnbF9GcmFnQ29sb3IuJyArIGNoYW5uZWxzW2ldICsgJyA9IGtlcm5lbFJlc3VsdCcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpIDwgY2hhbm5lbHMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgaW5kZXggKz0gMScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChuYW1lcyAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCgnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknKTtcblx0XHRcdFx0cmVzdWx0LnB1c2goJyAga2VybmVsKCknKTtcblx0XHRcdFx0cmVzdWx0LnB1c2goJyAgZ2xfRnJhZ0RhdGFbMF0gPSBlbmNvZGUzMihrZXJuZWxSZXN1bHQpJyk7XG5cdFx0XHRcdGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5hbWVzLmxlbmd0aDsgX2kyKyspIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBnbF9GcmFnRGF0YVsnICsgKF9pMiArIDEpICsgJ10gPSBlbmNvZGUzMignICsgbmFtZXNbX2kyXSArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsICcgIGtlcm5lbCgpJywgJyAgZ2xfRnJhZ0NvbG9yID0gZW5jb2RlMzIoa2VybmVsUmVzdWx0KScpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5fbGluZXNUb1N0cmluZyhyZXN1bHQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfbGluZXNUb1N0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lcyAtIEFuIEFycmF5IG9mIHN0cmluZ3NcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gU2luZ2xlIGNvbWJpbmVkIFN0cmluZywgc2VwZXJhdGVkIGJ5ICpcXG4qXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfbGluZXNUb1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9saW5lc1RvU3RyaW5nKGxpbmVzKSB7XG5cdFx0XHRpZiAobGluZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRyZXR1cm4gbGluZXMuam9pbignO1xcbicpICsgJztcXG4nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICdcXG4nO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfcmVwbGFjZUFydGlmYWN0c1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIC0gU2hhZGVyIHN0cmluZ1xuICAgKiBAcGFyYW0ge0FycmF5fSBtYXAgLSBWYXJpYWJsZXMvQ29uc3RhbnRzIGFzc29jaWF0ZWQgd2l0aCBzaGFkZXJcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19yZXBsYWNlQXJ0aWZhY3RzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3JlcGxhY2VBcnRpZmFjdHMoc3JjLCBtYXApIHtcblx0XHRcdHJldHVybiBzcmMucmVwbGFjZSgvWyBdKl9fKFtBLVpdK1swLTldKihbX10/W0EtWl0pKilfXztcXG4vZywgZnVuY3Rpb24gKG1hdGNoLCBhcnRpZmFjdCkge1xuXHRcdFx0XHRpZiAobWFwLmhhc093blByb3BlcnR5KGFydGlmYWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBtYXBbYXJ0aWZhY3RdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93ICd1bmhhbmRsZWQgYXJ0aWZhY3QgJyArIGFydGlmYWN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9hZGRLZXJuZWxzXG4gICAqXG4gICAqIEBkZXNjIEFkZHMgYWxsIHRoZSBzdWIta2VybmVscyBzdXBwbGllZCB3aXRoIHRoaXMgS2VybmVsIGluc3RhbmNlLlxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2FkZEtlcm5lbHMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfYWRkS2VybmVscygpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR2YXIgYnVpbGRlciA9IHRoaXMuZnVuY3Rpb25CdWlsZGVyO1xuXHRcdFx0dmFyIGdsID0gdGhpcy5fd2ViR2w7XG5cblx0XHRcdGJ1aWxkZXIuYWRkRnVuY3Rpb25zKHRoaXMuZnVuY3Rpb25zLCB7XG5cdFx0XHRcdGNvbnN0YW50czogdGhpcy5jb25zdGFudHMsXG5cdFx0XHRcdG91dHB1dDogdGhpcy5vdXRwdXRcblx0XHRcdH0pO1xuXHRcdFx0YnVpbGRlci5hZGROYXRpdmVGdW5jdGlvbnModGhpcy5uYXRpdmVGdW5jdGlvbnMpO1xuXG5cdFx0XHRidWlsZGVyLmFkZEtlcm5lbCh0aGlzLmZuU3RyaW5nLCB7XG5cdFx0XHRcdHByb3RvdHlwZU9ubHk6IGZhbHNlLFxuXHRcdFx0XHRjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuXHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRkZWJ1ZzogdGhpcy5kZWJ1Zyxcblx0XHRcdFx0bG9vcE1heEl0ZXJhdGlvbnM6IHRoaXMubG9vcE1heEl0ZXJhdGlvbnMsXG5cdFx0XHRcdHBhcmFtTmFtZXM6IHRoaXMucGFyYW1OYW1lcyxcblx0XHRcdFx0cGFyYW1UeXBlczogdGhpcy5wYXJhbVR5cGVzLFxuXHRcdFx0XHRjb25zdGFudFR5cGVzOiB0aGlzLmNvbnN0YW50VHlwZXMsXG5cdFx0XHRcdGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5OiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgZHJhd0J1ZmZlcnMgPSB0aGlzLmRyYXdCdWZmZXJzID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcblx0XHRcdFx0aWYgKCFkcmF3QnVmZmVycykgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgaW5zdGFudGlhdGUgZHJhdyBidWZmZXJzIGV4dGVuc2lvbicpO1xuXHRcdFx0XHR0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxzLmZvckVhY2goZnVuY3Rpb24gKHN1Yktlcm5lbCkge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpczIuX2FkZFN1Yktlcm5lbChzdWJLZXJuZWwpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhciBfZHJhd0J1ZmZlcnMgPSB0aGlzLmRyYXdCdWZmZXJzID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcblx0XHRcdFx0aWYgKCFfZHJhd0J1ZmZlcnMpIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGluc3RhbnRpYXRlIGRyYXcgYnVmZmVycyBleHRlbnNpb24nKTtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzID0gW107XG5cdFx0XHRcdE9iamVjdC5rZXlzKHRoaXMuc3ViS2VybmVsUHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3RoaXMyLl9hZGRTdWJLZXJuZWwoX3RoaXMyLnN1Yktlcm5lbFByb3BlcnRpZXNbcHJvcGVydHldKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX2FkZFN1Yktlcm5lbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9hZGRTdWJLZXJuZWwoc3ViS2VybmVsKSB7XG5cdFx0XHR0aGlzLmZ1bmN0aW9uQnVpbGRlci5hZGRTdWJLZXJuZWwoc3ViS2VybmVsLCB7XG5cdFx0XHRcdHByb3RvdHlwZU9ubHk6IGZhbHNlLFxuXHRcdFx0XHRjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuXHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0LFxuXHRcdFx0XHRkZWJ1ZzogdGhpcy5kZWJ1Zyxcblx0XHRcdFx0bG9vcE1heEl0ZXJhdGlvbnM6IHRoaXMubG9vcE1heEl0ZXJhdGlvbnMsXG5cdFx0XHRcdGZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5OiB0aGlzLmZpeEludGVnZXJEaXZpc2lvbkFjY3VyYWN5XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcy5wdXNoKHN1Yktlcm5lbC5uYW1lICsgJ1Jlc3VsdCcpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0xLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0RnJhZ1NoYWRlclN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgdGhlIGZyYWdtZW50IHNoYWRlciBTdHJpbmcuXG4gICAqIElmIHRoZSBTdHJpbmcgaGFzbid0IGJlZW4gY29tcGlsZWQgeWV0LFxuICAgKiB0aGVuIHRoaXMgbWV0aG9kIGNvbXBpbGVzIGl0IGFzIHdlbGxcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIFRoZSBhY3R1YWwgcGFyYW1ldGVycyBzZW50IHRvIHRoZSBLZXJuZWxcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gRnJhZ21lbnQgU2hhZGVyIHN0cmluZ1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEZyYWdTaGFkZXJTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0RnJhZ1NoYWRlclN0cmluZyhhcmdzKSB7XG5cdFx0XHRpZiAodGhpcy5jb21waWxlZEZyYWdTaGFkZXJTdHJpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nID0gdGhpcy5fcmVwbGFjZUFydGlmYWN0cyh0aGlzLmNvbnN0cnVjdG9yLmZyYWdTaGFkZXJTdHJpbmcsIHRoaXMuX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRWZXJ0U2hhZGVyU3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIEdldCB0aGUgdmVydGljYWwgc2hhZGVyIFN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gVGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHNlbnQgdG8gdGhlIEtlcm5lbFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBWZXJ0aWNhbCBTaGFkZXIgc3RyaW5nXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdfZ2V0VmVydFNoYWRlclN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRWZXJ0U2hhZGVyU3RyaW5nKGFyZ3MpIHtcblx0XHRcdGlmICh0aGlzLmNvbXBpbGVkVmVydFNoYWRlclN0cmluZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZFZlcnRTaGFkZXJTdHJpbmc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5jb21waWxlZFZlcnRTaGFkZXJTdHJpbmcgPSB0aGlzLmNvbnN0cnVjdG9yLnZlcnRTaGFkZXJTdHJpbmc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTEtlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHRvU3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIFJldHVybnMgdGhlICpwcmUtY29tcGlsZWQqIEtlcm5lbCBhcyBhIEpTIE9iamVjdCBTdHJpbmcsIHRoYXQgY2FuIGJlIHJldXNlZC5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RvU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4ga2VybmVsU3RyaW5nKHRoaXMpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2FkZEZ1bmN0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkRnVuY3Rpb24oZm4pIHtcblx0XHRcdHRoaXMuZnVuY3Rpb25CdWlsZGVyLmFkZEZ1bmN0aW9uKG51bGwsIGZuKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdkZXN0cm95Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGVzdHJveShyZW1vdmVDYW52YXNSZWZlcmVuY2VzKSB7XG5cdFx0XHRfZ2V0KFdlYkdMS2VybmVsLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYkdMS2VybmVsLnByb3RvdHlwZSksICdkZXN0cm95JywgdGhpcykuY2FsbCh0aGlzKTtcblx0XHRcdGlmICh0aGlzLm91dHB1dFRleHR1cmUpIHtcblx0XHRcdFx0dGhpcy5fd2ViR2wuZGVsZXRlVGV4dHVyZSh0aGlzLm91dHB1dFRleHR1cmUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuYnVmZmVyKSB7XG5cdFx0XHRcdHRoaXMuX3dlYkdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmJ1ZmZlcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5mcmFtZWJ1ZmZlcikge1xuXHRcdFx0XHR0aGlzLl93ZWJHbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLmZyYW1lYnVmZmVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMudmVydFNoYWRlcikge1xuXHRcdFx0XHR0aGlzLl93ZWJHbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0U2hhZGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZnJhZ1NoYWRlcikge1xuXHRcdFx0XHR0aGlzLl93ZWJHbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnU2hhZGVyKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMucHJvZ3JhbSkge1xuXHRcdFx0XHR0aGlzLl93ZWJHbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy50ZXh0dXJlQ2FjaGUpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBrZXlzW2ldO1xuXHRcdFx0XHR0aGlzLl93ZWJHbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZUNhY2hlW25hbWVdKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgX2kzID0gMDsgX2kzIDwgdGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcy5sZW5ndGg7IF9pMysrKSB7XG5cdFx0XHRcdFx0dGhpcy5fd2ViR2wuZGVsZXRlVGV4dHVyZSh0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzW19pM10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocmVtb3ZlQ2FudmFzUmVmZXJlbmNlcykge1xuXHRcdFx0XHR2YXIgaWR4ID0gY2FudmFzZXMuaW5kZXhPZih0aGlzLl9jYW52YXMpO1xuXHRcdFx0XHRpZiAoaWR4ID49IDApIHtcblx0XHRcdFx0XHRjYW52YXNlc1tpZHhdID0gbnVsbDtcblx0XHRcdFx0XHRtYXhUZXhTaXplc1tpZHhdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHRoaXMuX3dlYkdsO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBXZWJHTEtlcm5lbDtcbn0oS2VybmVsQmFzZSk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSdW5uZXJCYXNlID0gcmVxdWlyZSgnLi4vcnVubmVyLWJhc2UnKTtcbnZhciBXZWJHTEtlcm5lbCA9IHJlcXVpcmUoJy4va2VybmVsJyk7XG52YXIgV2ViR0xGdW5jdGlvbkJ1aWxkZXIgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLWJ1aWxkZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX1J1bm5lckJhc2UpIHtcblx0X2luaGVyaXRzKFdlYkdMUnVubmVyLCBfUnVubmVyQmFzZSk7XG5cblx0LyoqXG4gICogQGNvbnN0cnVjdG9yIFdlYkdMUnVubmVyXG4gICpcbiBcdCAqIEBleHRlbmRzIFJ1bm5lckJhc2VcbiAgXHQgKiBAZGVzYyBJbnN0YW50aWF0ZXMgYSBSdW5uZXIgaW5zdGFuY2UgZm9yIHRoZSBrZXJuZWwuXG4gICogXG4gICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIC0gU2V0dGluZ3MgdG8gaW5zdGFudGlhdGUgcHJvcGVydGllcyBpbiBSdW5uZXJCYXNlLCB3aXRoIGdpdmVuIHZhbHVlc1xuICAqXG4gICovXG5cdGZ1bmN0aW9uIFdlYkdMUnVubmVyKHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMUnVubmVyKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChXZWJHTFJ1bm5lci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYkdMUnVubmVyKSkuY2FsbCh0aGlzLCBuZXcgV2ViR0xGdW5jdGlvbkJ1aWxkZXIoKSwgc2V0dGluZ3MpKTtcblxuXHRcdF90aGlzLktlcm5lbCA9IFdlYkdMS2VybmVsO1xuXHRcdF90aGlzLmtlcm5lbCA9IG51bGw7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogQG1lbWJlck9mIFdlYkdMUnVubmVyI1xuICAqIEBmdW5jdGlvblxuICAqIEBuYW1lIGdldE1vZGVcbiAgKlxuICAqIEBkZXNjIFJldHVybiB0aGUgY3VycmVudCBtb2RlIGluIHdoaWNoIGdwdS5qcyBpcyBleGVjdXRpbmcuXG4gICogXG4gICogQHJldHVybnMge1N0cmluZ30gVGhlIGN1cnJlbnQgbW9kZTsgXCJjcHVcIi5cbiAgKlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKFdlYkdMUnVubmVyLCBbe1xuXHRcdGtleTogJ2dldE1vZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlKCkge1xuXHRcdFx0cmV0dXJuICdncHUnO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBXZWJHTFJ1bm5lcjtcbn0oUnVubmVyQmFzZSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gXCJfX0hFQURFUl9fO1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuXFxuY29uc3QgZmxvYXQgTE9PUF9NQVggPSBfX0xPT1BfTUFYX187XFxuXFxuX19DT05TVEFOVFNfXztcXG5cXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcblxcbnZlYzQgcm91bmQodmVjNCB4KSB7XFxuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XFxufVxcblxcbmZsb2F0IHJvdW5kKGZsb2F0IHgpIHtcXG4gIHJldHVybiBmbG9vcih4ICsgMC41KTtcXG59XFxuXFxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xcbiAgdmVjMiByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xcbn1cXG5cXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XFxuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XFxuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XFxufVxcblxcbnZlYzQgaW50ZWdlck1vZCh2ZWM0IHgsIHZlYzQgeSkge1xcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xcbn1cXG5cXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcXG4gIGZsb2F0IHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XFxuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcXG59XFxuXFxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XFxuICByZXR1cm4geCAtICh5ICogaW50KHggLyB5KSk7XFxufVxcblxcbl9fRElWSURFX1dJVEhfSU5URUdFUl9DSEVDS19fO1xcblxcbi8vIEhlcmUgYmUgZHJhZ29ucyFcXG4vLyBETyBOT1QgT1BUSU1JWkUgVEhJUyBDT0RFXFxuLy8gWU9VIFdJTEwgQlJFQUsgU09NRVRISU5HIE9OIFNPTUVCT0RZJ1MgTUFDSElORVxcbi8vIExFQVZFIElUIEFTIElUIElTLCBMRVNUIFlPVSBXQVNURSBZT1VSIE9XTiBUSU1FXFxuY29uc3QgdmVjMiBNQUdJQ19WRUMgPSB2ZWMyKDEuMCwgLTI1Ni4wKTtcXG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUiA9IHZlYzQoMS4wLCAyNTYuMCwgNjU1MzYuMCwgMC4wKTtcXG5jb25zdCB2ZWM0IFNDQUxFX0ZBQ1RPUl9JTlYgPSB2ZWM0KDEuMCwgMC4wMDM5MDYyNSwgMC4wMDAwMTUyNTg3ODkwNjI1LCAwLjApOyAvLyAxLCAxLzI1NiwgMS82NTUzNlxcbmZsb2F0IGRlY29kZTMyKHZlYzQgcmdiYSkge1xcbiAgX19ERUNPREUzMl9FTkRJQU5ORVNTX187XFxuICByZ2JhICo9IDI1NS4wO1xcbiAgdmVjMiBndGUxMjg7XFxuICBndGUxMjgueCA9IHJnYmEuYiA+PSAxMjguMCA/IDEuMCA6IDAuMDtcXG4gIGd0ZTEyOC55ID0gcmdiYS5hID49IDEyOC4wID8gMS4wIDogMC4wO1xcbiAgZmxvYXQgZXhwb25lbnQgPSAyLjAgKiByZ2JhLmEgLSAxMjcuMCArIGRvdChndGUxMjgsIE1BR0lDX1ZFQyk7XFxuICBmbG9hdCByZXMgPSBleHAyKHJvdW5kKGV4cG9uZW50KSk7XFxuICByZ2JhLmIgPSByZ2JhLmIgLSAxMjguMCAqIGd0ZTEyOC54O1xcbiAgcmVzID0gZG90KHJnYmEsIFNDQUxFX0ZBQ1RPUikgKiBleHAyKHJvdW5kKGV4cG9uZW50LTIzLjApKSArIHJlcztcXG4gIHJlcyAqPSBndGUxMjgueSAqIC0yLjAgKyAxLjA7XFxuICByZXR1cm4gcmVzO1xcbn1cXG5cXG52ZWM0IGVuY29kZTMyKGZsb2F0IGYpIHtcXG4gIGZsb2F0IEYgPSBhYnMoZik7XFxuICBmbG9hdCBzaWduID0gZiA8IDAuMCA/IDEuMCA6IDAuMDtcXG4gIGZsb2F0IGV4cG9uZW50ID0gZmxvb3IobG9nMihGKSk7XFxuICBmbG9hdCBtYW50aXNzYSA9IChleHAyKC1leHBvbmVudCkgKiBGKTtcXG4gIC8vIGV4cG9uZW50ICs9IGZsb29yKGxvZzIobWFudGlzc2EpKTtcXG4gIHZlYzQgcmdiYSA9IHZlYzQoRiAqIGV4cDIoMjMuMC1leHBvbmVudCkpICogU0NBTEVfRkFDVE9SX0lOVjtcXG4gIHJnYmEucmcgPSBpbnRlZ2VyTW9kKHJnYmEucmcsIDI1Ni4wKTtcXG4gIHJnYmEuYiA9IGludGVnZXJNb2QocmdiYS5iLCAxMjguMCk7XFxuICByZ2JhLmEgPSBleHBvbmVudCowLjUgKyA2My41O1xcbiAgcmdiYS5iYSArPSB2ZWMyKGludGVnZXJNb2QoZXhwb25lbnQrMTI3LjAsIDIuMCksIHNpZ24pICogMTI4LjA7XFxuICByZ2JhID0gZmxvb3IocmdiYSk7XFxuICByZ2JhICo9IDAuMDAzOTIxNTY5OyAvLyAxLzI1NVxcbiAgX19FTkNPREUzMl9FTkRJQU5ORVNTX187XFxuICByZXR1cm4gcmdiYTtcXG59XFxuLy8gRHJhZ29ucyBlbmQgaGVyZVxcblxcbmZsb2F0IGRlY29kZSh2ZWM0IHJnYmEsIGludCB4LCBpbnQgYml0UmF0aW8pIHtcXG4gIGlmIChiaXRSYXRpbyA9PSAxKSB7XFxuICAgIHJldHVybiBkZWNvZGUzMihyZ2JhKTtcXG4gIH1cXG4gIF9fREVDT0RFMzJfRU5ESUFOTkVTU19fO1xcbiAgaW50IGNoYW5uZWwgPSBpbnRlZ2VyTW9kKHgsIGJpdFJhdGlvKTtcXG4gIGlmIChiaXRSYXRpbyA9PSA0KSB7XFxuICAgIGlmIChjaGFubmVsID09IDApIHJldHVybiByZ2JhLnIgKiAyNTUuMDtcXG4gICAgaWYgKGNoYW5uZWwgPT0gMSkgcmV0dXJuIHJnYmEuZyAqIDI1NS4wO1xcbiAgICBpZiAoY2hhbm5lbCA9PSAyKSByZXR1cm4gcmdiYS5iICogMjU1LjA7XFxuICAgIGlmIChjaGFubmVsID09IDMpIHJldHVybiByZ2JhLmEgKiAyNTUuMDtcXG4gIH1cXG4gIGVsc2Uge1xcbiAgICBpZiAoY2hhbm5lbCA9PSAwKSByZXR1cm4gcmdiYS5yICogMjU1LjAgKyByZ2JhLmcgKiA2NTI4MC4wO1xcbiAgICBpZiAoY2hhbm5lbCA9PSAxKSByZXR1cm4gcmdiYS5iICogMjU1LjAgKyByZ2JhLmEgKiA2NTI4MC4wO1xcbiAgfVxcbn1cXG5cXG5pbnQgaW5kZXg7XFxuaXZlYzMgdGhyZWFkSWQ7XFxuXFxuaXZlYzMgaW5kZXhUbzNEKGludCBpZHgsIGl2ZWMzIHRleERpbSkge1xcbiAgaW50IHogPSBpbnQoaWR4IC8gKHRleERpbS54ICogdGV4RGltLnkpKTtcXG4gIGlkeCAtPSB6ICogaW50KHRleERpbS54ICogdGV4RGltLnkpO1xcbiAgaW50IHkgPSBpbnQoaWR4IC8gdGV4RGltLngpO1xcbiAgaW50IHggPSBpbnQoaW50ZWdlck1vZChpZHgsIHRleERpbS54KSk7XFxuICByZXR1cm4gaXZlYzMoeCwgeSwgeik7XFxufVxcblxcbmZsb2F0IGdldChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCBiaXRSYXRpbywgIGludCB6LCBpbnQgeSwgaW50IHgpIHtcXG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xcbiAgX19HRVRfV1JBUEFST1VORF9fO1xcbiAgaW50IGluZGV4ID0geHl6LnggKyB0ZXhEaW0ueCAqICh4eXoueSArIHRleERpbS55ICogeHl6LnopO1xcbiAgX19HRVRfVEVYVFVSRV9DSEFOTkVMX187XFxuICBpbnQgdyA9IHRleFNpemUueDtcXG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XFxuICBfX0dFVF9URVhUVVJFX0lOREVYX187XFxuICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcXG4gIF9fR0VUX1JFU1VMVF9fO1xcbiAgXFxufVxcblxcbnZlYzQgZ2V0SW1hZ2UyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcXG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xcbiAgX19HRVRfV1JBUEFST1VORF9fO1xcbiAgaW50IGluZGV4ID0geHl6LnggKyB0ZXhEaW0ueCAqICh4eXoueSArIHRleERpbS55ICogeHl6LnopO1xcbiAgX19HRVRfVEVYVFVSRV9DSEFOTkVMX187XFxuICBpbnQgdyA9IHRleFNpemUueDtcXG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XFxuICBfX0dFVF9URVhUVVJFX0lOREVYX187XFxuICByZXR1cm4gdGV4dHVyZTJEKHRleCwgc3QgLyB2ZWMyKHRleFNpemUpKTtcXG59XFxuXFxuZmxvYXQgZ2V0KHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IGJpdFJhdGlvLCBpbnQgeSwgaW50IHgpIHtcXG4gIHJldHVybiBnZXQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIGJpdFJhdGlvLCBpbnQoMCksIHksIHgpO1xcbn1cXG5cXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeSwgaW50IHgpIHtcXG4gIHJldHVybiBnZXRJbWFnZTJEKHRleCwgdGV4U2l6ZSwgdGV4RGltLCBpbnQoMCksIHksIHgpO1xcbn1cXG5cXG5mbG9hdCBnZXQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgYml0UmF0aW8sIGludCB4KSB7XFxuICByZXR1cm4gZ2V0KHRleCwgdGV4U2l6ZSwgdGV4RGltLCBiaXRSYXRpbywgaW50KDApLCBpbnQoMCksIHgpO1xcbn1cXG5cXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeCkge1xcbiAgcmV0dXJuIGdldEltYWdlMkQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIGludCgwKSwgaW50KDApLCB4KTtcXG59XFxuXFxuXFxudmVjNCBhY3R1YWxDb2xvcjtcXG52b2lkIGNvbG9yKGZsb2F0IHIsIGZsb2F0IGcsIGZsb2F0IGIsIGZsb2F0IGEpIHtcXG4gIGFjdHVhbENvbG9yID0gdmVjNChyLGcsYixhKTtcXG59XFxuXFxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiKSB7XFxuICBjb2xvcihyLGcsYiwxLjApO1xcbn1cXG5cXG52b2lkIGNvbG9yKHNhbXBsZXIyRCBpbWFnZSkge1xcbiAgYWN0dWFsQ29sb3IgPSB0ZXh0dXJlMkQoaW1hZ2UsIHZUZXhDb29yZCk7XFxufVxcblxcbl9fTUFJTl9QQVJBTVNfXztcXG5fX01BSU5fQ09OU1RBTlRTX187XFxuX19LRVJORUxfXztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgaW5kZXggPSBpbnQodlRleENvb3JkLnMgKiBmbG9hdCh1VGV4U2l6ZS54KSkgKyBpbnQodlRleENvb3JkLnQgKiBmbG9hdCh1VGV4U2l6ZS55KSkgKiB1VGV4U2l6ZS54O1xcbiAgX19NQUlOX1JFU1VMVF9fO1xcbn1cIjsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuXFxuYXR0cmlidXRlIHZlYzIgYVBvcztcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4Q29vcmQ7XFxuXFxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG51bmlmb3JtIHZlYzIgcmF0aW87XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgoYVBvcyArIHZlYzIoMSkpICogcmF0aW8gKyB2ZWMyKC0xKSwgMCwgMSk7XFxuICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XFxufVwiOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgV2ViR0xLZXJuZWwgPSByZXF1aXJlKCcuL2tlcm5lbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlscycpO1xuXG4vKipcbiAqIEBjbGFzcyBXZWJHTFZhbGlkYXRvcktlcm5lbFxuICpcbiAqIEBkZXNjIEhlbHBlciBjbGFzcyBmb3IgV2ViR0xLZXJuZWwgdG8gdmFsaWRhdGUgdGV4dHVyZSBzaXplIGFuZCBkaW1lbnNpb25zLlxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX1dlYkdMS2VybmVsKSB7XG5cdF9pbmhlcml0cyhXZWJHTFZhbGlkYXRvcktlcm5lbCwgX1dlYkdMS2VybmVsKTtcblxuXHRmdW5jdGlvbiBXZWJHTFZhbGlkYXRvcktlcm5lbCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xWYWxpZGF0b3JLZXJuZWwpO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChXZWJHTFZhbGlkYXRvcktlcm5lbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYkdMVmFsaWRhdG9yS2VybmVsKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoV2ViR0xWYWxpZGF0b3JLZXJuZWwsIFt7XG5cdFx0a2V5OiAndmFsaWRhdGVPcHRpb25zJyxcblxuXG5cdFx0LyoqIFxuICAgKiBAbWVtYmVyT2YgV2ViR0xWYWxpZGF0b3JLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSB2YWxpZGF0ZU9wdGlvbnNcbiAgICpcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucygpIHtcblx0XHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdH0sIHRoaXMub3V0cHV0LCB0cnVlKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gV2ViR0xWYWxpZGF0b3JLZXJuZWw7XG59KFdlYkdMS2VybmVsKTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEZ1bmN0aW9uQnVpbGRlckJhc2UgPSByZXF1aXJlKCcuLi9mdW5jdGlvbi1idWlsZGVyLWJhc2UnKTtcbnZhciBXZWJHTDJGdW5jdGlvbk5vZGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9uLW5vZGUnKTtcblxuLyoqXG4gKiBAY2xhc3MgV2ViR0xGdW5jdGlvbkJ1aWxkZXJcbiAqXG4gKiBAZXh0ZW5kcyBGdW5jdGlvbkJ1aWxkZXJCYXNlXG4gKlxuICogQGRlc2MgQnVpbGRzIHdlYkdsIGZ1bmN0aW9ucyAoc2hhZGVycykgZnJvbSBKYXZhU2NyaXB0IGZ1bmN0aW9uIFN0cmluZ3NcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9GdW5jdGlvbkJ1aWxkZXJCYXNlKSB7XG4gIF9pbmhlcml0cyhXZWJHTDJGdW5jdGlvbkJ1aWxkZXIsIF9GdW5jdGlvbkJ1aWxkZXJCYXNlKTtcblxuICBmdW5jdGlvbiBXZWJHTDJGdW5jdGlvbkJ1aWxkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMMkZ1bmN0aW9uQnVpbGRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViR0wyRnVuY3Rpb25CdWlsZGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViR0wyRnVuY3Rpb25CdWlsZGVyKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5Ob2RlID0gV2ViR0wyRnVuY3Rpb25Ob2RlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBXZWJHTDJGdW5jdGlvbkJ1aWxkZXI7XG59KEZ1bmN0aW9uQnVpbGRlckJhc2UpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgV2ViR0xGdW5jdGlvbk5vZGUgPSByZXF1aXJlKCcuLi93ZWItZ2wvZnVuY3Rpb24tbm9kZScpO1xudmFyIERFQ09ERTMyX0VOQ09ERTMyID0gL2RlY29kZTMyXFwoXFxzK2VuY29kZTMyXFwoL2c7XG52YXIgRU5DT0RFMzJfREVDT0RFMzIgPSAvZW5jb2RlMzJcXChcXHMrZGVjb2RlMzJcXCgvZztcblxuLyoqIFxuICogQGNsYXNzIFdlYkdMMkZ1bmN0aW9uTm9kZVxuICpcbiAqIEBkZXNjIFtJTlRFUk5BTF0gVGFrZXMgaW4gYSBmdW5jdGlvbiBub2RlLCBhbmQgZG9lcyBhbGwgdGhlIEFTVCB2b29kb28gcmVxdWlyZWQgdG8gZ2VuZXJhdGUgaXRzIHJlc3BlY3RpdmUgd2ViR0wgY29kZS5cbiAqXG4gKiBAZXh0ZW5kcyBXZWJHTEZ1bmN0aW9uTm9kZVxuICpcbiAqIEByZXR1cm5zIHRoZSBjb252ZXJ0ZWQgd2ViR0wgZnVuY3Rpb24gc3RyaW5nXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfV2ViR0xGdW5jdGlvbk5vZGUpIHtcblx0X2luaGVyaXRzKFdlYkdMMkZ1bmN0aW9uTm9kZSwgX1dlYkdMRnVuY3Rpb25Ob2RlKTtcblxuXHRmdW5jdGlvbiBXZWJHTDJGdW5jdGlvbk5vZGUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMMkZ1bmN0aW9uTm9kZSk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFdlYkdMMkZ1bmN0aW9uTm9kZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYkdMMkZ1bmN0aW9uTm9kZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFdlYkdMMkZ1bmN0aW9uTm9kZSwgW3tcblx0XHRrZXk6ICdnZW5lcmF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuXHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0Y29uc29sZS5sb2codGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5wcm90b3R5cGVPbmx5KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFzdEZ1bmN0aW9uUHJvdG90eXBlKHRoaXMuZ2V0SnNBU1QoKSwgW10pLmpvaW4oJycpLnRyaW0oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZnVuY3Rpb25TdHJpbmdBcnJheSA9IHRoaXMuYXN0R2VuZXJpYyh0aGlzLmdldEpzQVNUKCksIFtdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnVuY3Rpb25TdHJpbmcgPSB3ZWJHbFJlZ2V4T3B0aW1pemUodGhpcy5mdW5jdGlvblN0cmluZ0FycmF5LmpvaW4oJycpLnRyaW0oKSk7XG5cdFx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvblN0cmluZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMMkZ1bmN0aW9uTm9kZSNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIGFzdElkZW50aWZpZXJFeHByZXNzaW9uXG4gICAqXG4gICAqIEBkZXNjIFBhcnNlcyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUgZm9yICppZGVudGlmaWVyKiBleHByZXNzaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpZHROb2RlIC0gQW4gYXN0IE5vZGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmV0QXJyIC0gcmV0dXJuIGFycmF5IHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcHBlbmQgcmV0QXJyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3RJZGVudGlmaWVyRXhwcmVzc2lvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzdElkZW50aWZpZXJFeHByZXNzaW9uKGlkdE5vZGUsIHJldEFycikge1xuXHRcdFx0aWYgKGlkdE5vZGUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG5cdFx0XHRcdHRocm93IHRoaXMuYXN0RXJyb3JPdXRwdXQoJ0lkZW50aWZpZXJFeHByZXNzaW9uIC0gbm90IGFuIElkZW50aWZpZXInLCBpZHROb2RlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZG8gd2UgbmVlZCB0byBjYXN0IGFkZHJlc3NpbmcgdmFsZXMgdG8gZmxvYXQ/XG5cdFx0XHR2YXIgY2FzdEZsb2F0ID0gIXRoaXMuaXNTdGF0ZSgnaW4tZ2V0LWNhbGwtcGFyYW1ldGVycycpO1xuXG5cdFx0XHRzd2l0Y2ggKGlkdE5vZGUubmFtZSkge1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWCc6XG5cdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueCcpO1xuXHRcdFx0XHRcdGNhc3RGbG9hdCAmJiByZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWSc6XG5cdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueScpO1xuXHRcdFx0XHRcdGNhc3RGbG9hdCAmJiByZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfdGhyZWFkWic6XG5cdFx0XHRcdFx0Y2FzdEZsb2F0ICYmIHJldEFyci5wdXNoKCdmbG9hdCgnKTtcblx0XHRcdFx0XHRyZXRBcnIucHVzaCgndGhyZWFkSWQueicpO1xuXHRcdFx0XHRcdGNhc3RGbG9hdCAmJiByZXRBcnIucHVzaCgnKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfb3V0cHV0WCc6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueCcpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfb3V0cHV0WSc6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHVfb3V0cHV0Wic6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ3VPdXRwdXREaW0ueicpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdJbmZpbml0eSc6XG5cdFx0XHRcdFx0cmV0QXJyLnB1c2goJ2ludEJpdHNUb0Zsb2F0KDIxMzkwOTUwMzkpJyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dmFyIHVzZXJQYXJhbU5hbWUgPSB0aGlzLmdldFVzZXJQYXJhbU5hbWUoaWR0Tm9kZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAodXNlclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dGhpcy5wdXNoUGFyYW1ldGVyKHJldEFyciwgJ3VzZXJfJyArIHVzZXJQYXJhbU5hbWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnB1c2hQYXJhbWV0ZXIocmV0QXJyLCAndXNlcl8nICsgaWR0Tm9kZS5uYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXRBcnI7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFdlYkdMMkZ1bmN0aW9uTm9kZTtcbn0oV2ViR0xGdW5jdGlvbk5vZGUpO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqIEBmdW5jdGlvblxuICogQG5hbWUgd2ViZ2xfcmVnZXhfb3B0aW1pemVcbiAqXG4gKiBAZGVzYyBbSU5URVJOQUxdIFRha2VzIHRoZSBuZWFyIGZpbmFsIHdlYmdsIGZ1bmN0aW9uIHN0cmluZywgYW5kIGRvIHJlZ2V4IHNlYXJjaCBhbmQgcmVwbGFjbWVudHMuXG4gKiBGb3Igdm9vZG9vIG9wdGltaXplIG91dCB0aGUgZm9sbG93aW5nOiBcbiAqXG4gKiAtIGRlY29kZTMyKGVuY29kZTMyKCA8YnI+XG4gKiAtIGVuY29kZTMyKGRlY29kZTMyKCA8YnI+XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGluU3RyIC0gVGhlIHdlYkdsIGZ1bmN0aW9uIFN0cmluZ1xuICpcbiAqL1xuZnVuY3Rpb24gd2ViR2xSZWdleE9wdGltaXplKGluU3RyKSB7XG5cdHJldHVybiBpblN0ci5yZXBsYWNlKERFQ09ERTMyX0VOQ09ERTMyLCAnKCgnKS5yZXBsYWNlKEVOQ09ERTMyX0RFQ09ERTMyLCAnKCgnKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFdlYkdMS2VybmVsID0gcmVxdWlyZSgnLi4vd2ViLWdsL2tlcm5lbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlscycpO1xudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3RleHR1cmUnKTtcbnZhciBmcmFnU2hhZGVyU3RyaW5nID0gcmVxdWlyZSgnLi9zaGFkZXItZnJhZycpO1xudmFyIHZlcnRTaGFkZXJTdHJpbmcgPSByZXF1aXJlKCcuL3NoYWRlci12ZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9XZWJHTEtlcm5lbCkge1xuXHRfaW5oZXJpdHMoV2ViR0wyS2VybmVsLCBfV2ViR0xLZXJuZWwpO1xuXG5cdGZ1bmN0aW9uIFdlYkdMMktlcm5lbCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0wyS2VybmVsKTtcblxuXHRcdHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViR0wyS2VybmVsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViR0wyS2VybmVsKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoV2ViR0wyS2VybmVsLCBbe1xuXHRcdGtleTogJ2luaXRXZWJHbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRXZWJHbCgpIHtcblx0XHRcdHJldHVybiB1dGlscy5pbml0V2ViR2wyKHRoaXMuZ2V0Q2FudmFzKCkpO1xuXHRcdH1cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMMktlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHZhbGlkYXRlT3B0aW9uc1xuICAgKlxuICAgKiBAZGVzYyBWYWxpZGF0ZSBvcHRpb25zIHJlbGF0ZWQgdG8gS2VybmVsLCBzdWNoIGFzXG4gICAqIGZsb2F0T3V0cHV0cyBhbmQgVGV4dHVyZXMsIHRleFNpemUsIG91dHB1dCxcbiAgICogZ3JhcGhpY2FsIG91dHB1dC5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZhbGlkYXRlT3B0aW9ucycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucygpIHtcblx0XHRcdHZhciBpc0Zsb2F0UmVhZFBpeGVsID0gdXRpbHMuaXNGbG9hdFJlYWRQaXhlbHNTdXBwb3J0ZWRXZWJHTDIoKTtcblx0XHRcdGlmICh0aGlzLmZsb2F0T3V0cHV0ID09PSB0cnVlICYmIHRoaXMuZmxvYXRPdXRwdXRGb3JjZSAhPT0gdHJ1ZSAmJiAhaXNGbG9hdFJlYWRQaXhlbCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IHRleHR1cmUgb3V0cHV0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXInKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5mbG9hdFRleHR1cmVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5mbG9hdFRleHR1cmVzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5mbG9hdE91dHB1dCA9IGlzRmxvYXRSZWFkUGl4ZWw7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBoYXNJbnRlZ2VyRGl2aXNpb25CdWcgPSB1dGlscy5oYXNJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeUJ1ZygpO1xuXHRcdFx0aWYgKHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSA9IGhhc0ludGVnZXJEaXZpc2lvbkJ1Zztcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeSAmJiAhaGFzSW50ZWdlckRpdmlzaW9uQnVnKSB7XG5cdFx0XHRcdHRoaXMuZml4SW50ZWdlckRpdmlzaW9uQWNjdXJhY3kgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dXRpbHMuY2hlY2tPdXRwdXQodGhpcy5vdXRwdXQpO1xuXG5cdFx0XHRpZiAoIXRoaXMub3V0cHV0IHx8IHRoaXMub3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgb25seSBzdXBwb3J0ZWQgZm9yIGtlcm5lbHMgd2l0aCBvbmx5IG9uZSBpbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGFyZ1R5cGUgPSB1dGlscy5nZXRBcmd1bWVudFR5cGUoYXJndW1lbnRzWzBdKTtcblx0XHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdBcnJheScpIHtcblx0XHRcdFx0XHR0aGlzLm91dHB1dCA9IHV0aWxzLmdldERpbWVuc2lvbnMoYXJnVHlwZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ051bWJlclRleHR1cmUnIHx8IGFyZ1R5cGUgPT09ICdBcnJheVRleHR1cmUoNCknKSB7XG5cdFx0XHRcdFx0dGhpcy5vdXRwdXQgPSBhcmd1bWVudHNbMF0ub3V0cHV0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQXV0byBvdXRwdXQgbm90IHN1cHBvcnRlZCBmb3IgaW5wdXQgdHlwZTogJyArIGFyZ1R5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudGV4U2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdH0sIHRoaXMub3V0cHV0LCB0cnVlKTtcblxuXHRcdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG5cdFx0XHRcdGlmICh0aGlzLm91dHB1dC5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ091dHB1dCBtdXN0IGhhdmUgMiBkaW1lbnNpb25zIG9uIGdyYXBoaWNhbCBtb2RlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGhpcy5mbG9hdE91dHB1dCkge1xuXHRcdFx0XHRcdHRoaXMuZmxvYXRPdXRwdXQgPSBmYWxzZTtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0Nhbm5vdCB1c2UgZ3JhcGhpY2FsIG1vZGUgYW5kIGZsb2F0IG91dHB1dCBhdCB0aGUgc2FtZSB0aW1lJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnRleFNpemUgPSB1dGlscy5jbG9uZSh0aGlzLm91dHB1dCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuZmxvYXRPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLmZsb2F0T3V0cHV0ID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZmxvYXRPdXRwdXQgfHwgdGhpcy5mbG9hdE91dHB1dEZvcmNlKSB7XG5cdFx0XHRcdHRoaXMuX3dlYkdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0wyS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgcnVuXG4gICAqXG4gICAqIEBkZXNjIFJ1biB0aGUga2VybmVsIHByb2dyYW0sIGFuZCBzZW5kIHRoZSBvdXRwdXQgdG8gcmVuZGVyT3V0cHV0XG4gICAqXG4gICAqIDxwPiBUaGlzIG1ldGhvZCBjYWxscyBhIGhlbHBlciBtZXRob2QgKnJlbmRlck91dHB1dCogdG8gcmV0dXJuIHRoZSByZXN1bHQuIDwvcD5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdHxVbmRlZmluZWR9IFJlc3VsdCBUaGUgZmluYWwgb3V0cHV0IG9mIHRoZSBwcm9ncmFtLCBhcyBmbG9hdCwgYW5kIGFzIFRleHR1cmVzIGZvciByZXVzZS5cbiAgICpcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1bicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcblx0XHRcdGlmICh0aGlzLnByb2dyYW0gPT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5idWlsZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcmFtTmFtZXMgPSB0aGlzLnBhcmFtTmFtZXM7XG5cdFx0XHR2YXIgcGFyYW1UeXBlcyA9IHRoaXMucGFyYW1UeXBlcztcblx0XHRcdHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHRcdFx0dmFyIGdsID0gdGhpcy5fd2ViR2w7XG5cblx0XHRcdGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcblx0XHRcdGdsLnNjaXNzb3IoMCwgMCwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSk7XG5cblx0XHRcdGlmICghdGhpcy5oYXJkY29kZUNvbnN0YW50cykge1xuXHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ3VPdXRwdXREaW0nLCBuZXcgSW50MzJBcnJheSh0aGlzLnRocmVhZERpbSkpO1xuXHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ3VUZXhTaXplJywgdGV4U2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0VW5pZm9ybTJmKCdyYXRpbycsIHRleFNpemVbMF0gLyB0aGlzLm1heFRleFNpemVbMF0sIHRleFNpemVbMV0gLyB0aGlzLm1heFRleFNpemVbMV0pO1xuXG5cdFx0XHR0aGlzLmFyZ3VtZW50c0xlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciB0ZXhJbmRleCA9IDA7IHRleEluZGV4IDwgcGFyYW1OYW1lcy5sZW5ndGg7IHRleEluZGV4KyspIHtcblx0XHRcdFx0dGhpcy5fYWRkQXJndW1lbnQoYXJndW1lbnRzW3RleEluZGV4XSwgcGFyYW1UeXBlc1t0ZXhJbmRleF0sIHBhcmFtTmFtZXNbdGV4SW5kZXhdKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG5cdFx0XHRcdGlmICh0aGlzLm91dHB1dFRvVGV4dHVyZSkge1xuXHRcdFx0XHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuXHRcdFx0XHRcdGlmICghdGhpcy5vdXRwdXRUZXh0dXJlIHx8IHRoaXMub3V0cHV0SW1tdXRhYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMub3V0cHV0VGV4dHVyZSwgdGV4U2l6ZSwgdGhpcy50aHJlYWREaW0sIHRoaXMub3V0cHV0LCB0aGlzLl93ZWJHbCwgJ0FycmF5VGV4dHVyZSg0KScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0XHRcdFx0Z2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lYnVmZmVyKTtcblx0XHRcdGlmICh0aGlzLm91dHB1dEltbXV0YWJsZSkge1xuXHRcdFx0XHR0aGlzLl9zZXR1cE91dHB1dFRleHR1cmUoKTtcblx0XHRcdH1cblx0XHRcdHZhciBvdXRwdXRUZXh0dXJlID0gdGhpcy5vdXRwdXRUZXh0dXJlO1xuXG5cdFx0XHRpZiAodGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmICh0aGlzLm91dHB1dEltbXV0YWJsZSkge1xuXHRcdFx0XHRcdHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgPSBbXTtcblx0XHRcdFx0XHR0aGlzLl9zZXR1cFN1Yk91dHB1dFRleHR1cmVzKHRoaXMuc3ViS2VybmVsT3V0cHV0VmFyaWFibGVOYW1lcy5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdsLmRyYXdCdWZmZXJzKHRoaXMuZHJhd0J1ZmZlcnNNYXApO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcblxuXHRcdFx0aWYgKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKHRoaXMuc3ViS2VybmVscyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdFx0XHRvdXRwdXQucmVzdWx0ID0gdGhpcy5yZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1Yktlcm5lbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKG5ldyBUZXh0dXJlKHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXNbaV0sIHRleFNpemUsIHRoaXMudGhyZWFkRGltLCB0aGlzLm91dHB1dCwgdGhpcy5fd2ViR2wpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMgIT09IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgX291dHB1dCA9IHtcblx0XHRcdFx0XHRcdHJlc3VsdDogdGhpcy5yZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHZhciBfaSA9IDA7XG5cdFx0XHRcdFx0Zm9yICh2YXIgcCBpbiB0aGlzLnN1Yktlcm5lbFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRcdGlmICghdGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdF9vdXRwdXRbcF0gPSBuZXcgVGV4dHVyZSh0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzW19pXSwgdGV4U2l6ZSwgdGhpcy50aHJlYWREaW0sIHRoaXMub3V0cHV0LCB0aGlzLl93ZWJHbCk7XG5cdFx0XHRcdFx0XHRfaSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gX291dHB1dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJPdXRwdXQob3V0cHV0VGV4dHVyZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBnZXRPdXRwdXRUZXh0dXJlXG4gICAqXG4gICAqIEBkZXNjIFRoaXMgcmV0dXJuIGRlZmluZWQgb3V0cHV0VGV4dHVyZSwgd2hpY2ggaXMgc2V0dXAgaW4gLmJ1aWxkKCksIG9yIGlmIGltbXV0YWJsZSwgaXMgZGVmaW5lZCBpbiAucnVuKClcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gT3V0cHV0IFRleHR1cmUgQ2FjaGVcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE91dHB1dFRleHR1cmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPdXRwdXRUZXh0dXJlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3V0cHV0VGV4dHVyZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMMktlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9zZXR1cE91dHB1dFRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQGRlc2MgU2V0dXAgYW5kIHJlcGxhY2Ugb3V0cHV0IHRleHR1cmVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19zZXR1cE91dHB1dFRleHR1cmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBPdXRwdXRUZXh0dXJlKCkge1xuXHRcdFx0dmFyIGdsID0gdGhpcy5fd2ViR2w7XG5cdFx0XHR2YXIgdGV4U2l6ZSA9IHRoaXMudGV4U2l6ZTtcblx0XHRcdHZhciB0ZXh0dXJlID0gdGhpcy5vdXRwdXRUZXh0dXJlID0gdGhpcy5fd2ViR2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5wYXJhbU5hbWVzLmxlbmd0aCk7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRpZiAodGhpcy5mbG9hdE91dHB1dCkge1xuXHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIHRleFNpemVbMF0sIHRleFNpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0wyS2VybmVsI1xuICAgKiBAcGFyYW0gbGVuZ3RoXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBkZXNjIFNldHVwIGFuZCByZXBsYWNlIHN1Yi1vdXRwdXQgdGV4dHVyZXNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19zZXR1cFN1Yk91dHB1dFRleHR1cmVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX3NldHVwU3ViT3V0cHV0VGV4dHVyZXMobGVuZ3RoKSB7XG5cdFx0XHR2YXIgZ2wgPSB0aGlzLl93ZWJHbDtcblx0XHRcdHZhciB0ZXhTaXplID0gdGhpcy50ZXhTaXplO1xuXHRcdFx0dmFyIGRyYXdCdWZmZXJzTWFwID0gdGhpcy5kcmF3QnVmZmVyc01hcCA9IFtnbC5DT0xPUl9BVFRBQ0hNRU5UMF07XG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnN1Yktlcm5lbE91dHB1dFRleHR1cmVzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gdGhpcy5fd2ViR2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdFx0XHR0ZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuXHRcdFx0XHRkcmF3QnVmZmVyc01hcC5wdXNoKGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEpO1xuXHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLnBhcmFtTmFtZXMubGVuZ3RoICsgaSk7XG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRpZiAodGhpcy5mbG9hdE91dHB1dCkge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGV4U2l6ZVswXSwgdGV4U2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSArIDEsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0wyS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2FkZEFyZ3VtZW50XG4gICAqXG4gICAqIEBkZXNjIEFkZHMga2VybmVsIHBhcmFtZXRlcnMgdG8gdGhlIEFyZ3VtZW50IFRleHR1cmUsXG4gICAqIGJpbmRpbmcgaXQgdG8gdGhlIHdlYkdsIGluc3RhbmNlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8VGV4dHVyZXxOdW1iZXJ9IHZhbHVlIC0gVGhlIGFjdHVhbCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUga2VybmVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgYXJndW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhcmd1bWVudFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2FkZEFyZ3VtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2FkZEFyZ3VtZW50KHZhbHVlLCB0eXBlLCBuYW1lKSB7XG5cdFx0XHR2YXIgZ2wgPSB0aGlzLl93ZWJHbDtcblx0XHRcdHZhciBhcmd1bWVudFRleHR1cmUgPSB0aGlzLmdldEFyZ3VtZW50VGV4dHVyZShuYW1lKTtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcblx0XHRcdFx0dHlwZSA9IHZhbHVlLnR5cGU7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBkaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcblx0XHRcdFx0XHRcdHZhciBzaXplID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdFx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdGhpcy5mbG9hdFRleHR1cmVzLFxuXHRcdFx0XHRcdFx0XHRmbG9hdE91dHB1dDogdGhpcy5mbG9hdE91dHB1dFxuXHRcdFx0XHRcdFx0fSwgZGltKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG5cdFx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gc2l6ZVswXSAqIHNpemVbMV07XG5cblx0XHRcdFx0XHRcdHZhciBfZm9ybWF0QXJyYXlUcmFuc2ZlciA9IHRoaXMuX2Zvcm1hdEFycmF5VHJhbnNmZXIodmFsdWUsIGxlbmd0aCksXG5cdFx0XHRcdFx0XHQgICAgdmFsdWVzRmxhdCA9IF9mb3JtYXRBcnJheVRyYW5zZmVyLnZhbHVlc0ZsYXQsXG5cdFx0XHRcdFx0XHQgICAgYml0UmF0aW8gPSBfZm9ybWF0QXJyYXlUcmFuc2Zlci5iaXRSYXRpbztcblxuXHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IHZvaWQgMDtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmZsb2F0VGV4dHVyZXMpIHtcblx0XHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCBzaXplWzBdLCBzaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgdmFsdWVzRmxhdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZXNGbGF0LmJ1ZmZlcik7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2l6ZVswXSAvIGJpdFJhdGlvLCBzaXplWzFdLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBidWZmZXIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCd1c2VyXycgKyBuYW1lICsgJ0RpbScsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdigndXNlcl8nICsgbmFtZSArICdTaXplJywgc2l6ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgndXNlcl8nICsgbmFtZSArICdCaXRSYXRpbycsIGJpdFJhdGlvKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCd1c2VyXycgKyBuYW1lLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWYoJ3VzZXJfJyArIG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnSW5wdXQnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0dmFyIF9kaW0gPSBpbnB1dC5zaXplO1xuXHRcdFx0XHRcdFx0dmFyIF9zaXplID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdFx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdGhpcy5mbG9hdFRleHR1cmVzLFxuXHRcdFx0XHRcdFx0XHRmbG9hdE91dHB1dDogdGhpcy5mbG9hdE91dHB1dFxuXHRcdFx0XHRcdFx0fSwgX2RpbSk7XG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0dmFyIF9sZW5ndGggPSBfc2l6ZVswXSAqIF9zaXplWzFdO1xuXG5cdFx0XHRcdFx0XHR2YXIgX2Zvcm1hdEFycmF5VHJhbnNmZXIyID0gdGhpcy5fZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZS52YWx1ZSwgX2xlbmd0aCksXG5cdFx0XHRcdFx0XHQgICAgX3ZhbHVlc0ZsYXQgPSBfZm9ybWF0QXJyYXlUcmFuc2ZlcjIudmFsdWVzRmxhdCxcblx0XHRcdFx0XHRcdCAgICBfYml0UmF0aW8gPSBfZm9ybWF0QXJyYXlUcmFuc2ZlcjIuYml0UmF0aW87XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmZsb2F0VGV4dHVyZXMpIHtcblx0XHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBMzJGLCBfc2l6ZVswXSwgX3NpemVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBpbnB1dEFycmF5KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoX3ZhbHVlc0ZsYXQuYnVmZmVyKTtcblx0XHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfc2l6ZVswXSAvIF9iaXRSYXRpbywgX3NpemVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIF9idWZmZXIpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCd1c2VyXycgKyBuYW1lICsgJ0RpbScsIF9kaW0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ3VzZXJfJyArIG5hbWUgKyAnU2l6ZScsIF9zaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCd1c2VyXycgKyBuYW1lICsgJ0JpdFJhdGlvJywgX2JpdFJhdGlvKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCd1c2VyXycgKyBuYW1lLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGlucHV0SW1hZ2UgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGltMiA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodCwgMV07XG5cdFx0XHRcdFx0XHR2YXIgX3NpemUyID0gW2lucHV0SW1hZ2Uud2lkdGgsIGlucHV0SW1hZ2UuaGVpZ2h0XTtcblxuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoICsgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYXJndW1lbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRcdFx0XHRcdC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZS5cblx0XHRcdFx0XHRcdHZhciBtaXBMZXZlbCA9IDA7IC8vIHRoZSBsYXJnZXN0IG1pcFxuXHRcdFx0XHRcdFx0dmFyIGludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IHdlIHdhbnQgaW4gdGhlIHRleHR1cmVcblx0XHRcdFx0XHRcdHZhciBzcmNGb3JtYXQgPSBnbC5SR0JBOyAvLyBmb3JtYXQgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0XHR2YXIgc3JjVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7IC8vIHR5cGUgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcExldmVsLCBpbnRlcm5hbEZvcm1hdCwgc3JjRm9ybWF0LCBzcmNUeXBlLCBpbnB1dEltYWdlKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdigndXNlcl8nICsgbmFtZSArICdEaW0nLCBfZGltMik7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ3VzZXJfJyArIG5hbWUgKyAnU2l6ZScsIF9zaXplMik7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgndXNlcl8nICsgbmFtZSwgdGhpcy5hcmd1bWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdIVE1MSW1hZ2VBcnJheSc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGlucHV0SW1hZ2VzID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR2YXIgX2RpbTMgPSBbaW5wdXRJbWFnZXNbMF0ud2lkdGgsIGlucHV0SW1hZ2VzWzBdLmhlaWdodCwgaW5wdXRJbWFnZXMubGVuZ3RoXTtcblx0XHRcdFx0XHRcdHZhciBfc2l6ZTMgPSBbaW5wdXRJbWFnZXNbMF0ud2lkdGgsIGlucHV0SW1hZ2VzWzBdLmhlaWdodF07XG5cblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCArIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkRfQVJSQVksIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkRfQVJSQVksIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cdFx0XHRcdFx0XHRnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcblx0XHRcdFx0XHRcdC8vIFVwbG9hZCB0aGUgaW1hZ2VzIGludG8gdGhlIHRleHR1cmUuXG5cdFx0XHRcdFx0XHR2YXIgX21pcExldmVsID0gMDsgLy8gdGhlIGxhcmdlc3QgbWlwXG5cdFx0XHRcdFx0XHR2YXIgX2ludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IHdlIHdhbnQgaW4gdGhlIHRleHR1cmVcblx0XHRcdFx0XHRcdHZhciB3aWR0aCA9IGlucHV0SW1hZ2VzWzBdLndpZHRoO1xuXHRcdFx0XHRcdFx0dmFyIGhlaWdodCA9IGlucHV0SW1hZ2VzWzBdLmhlaWdodDtcblx0XHRcdFx0XHRcdHZhciB0ZXh0dXJlRGVwdGggPSBpbnB1dEltYWdlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR2YXIgYm9yZGVyID0gMDtcblx0XHRcdFx0XHRcdHZhciBfc3JjRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdFx0dmFyIF9zcmNUeXBlID0gZ2wuVU5TSUdORURfQllURTsgLy8gdHlwZSBvZiBkYXRhIHdlIGFyZSBzdXBwbHlpbmdcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlM0QoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgX21pcExldmVsLCBfaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVEZXB0aCwgYm9yZGVyLCBfc3JjRm9ybWF0LCBfc3JjVHlwZSwgbnVsbCk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB4T2Zmc2V0ID0gMDtcblx0XHRcdFx0XHRcdFx0dmFyIHlPZmZzZXQgPSAwO1xuXHRcdFx0XHRcdFx0XHR2YXIgaW1hZ2VEZXB0aCA9IDE7XG5cdFx0XHRcdFx0XHRcdGdsLnRleFN1YkltYWdlM0QoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgX21pcExldmVsLCB4T2Zmc2V0LCB5T2Zmc2V0LCBpLCBpbnB1dEltYWdlc1tpXS53aWR0aCwgaW5wdXRJbWFnZXNbaV0uaGVpZ2h0LCBpbWFnZURlcHRoLCBfc3JjRm9ybWF0LCBfc3JjVHlwZSwgaW5wdXRJbWFnZXNbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCd1c2VyXycgKyBuYW1lICsgJ0RpbScsIF9kaW0zKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdigndXNlcl8nICsgbmFtZSArICdTaXplJywgX3NpemUzKTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCd1c2VyXycgKyBuYW1lLCB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0FycmF5VGV4dHVyZSg0KSc6XG5cdFx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dFRleHR1cmUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGltNCA9IGlucHV0VGV4dHVyZS5kaW1lbnNpb25zO1xuXHRcdFx0XHRcdFx0dmFyIF9zaXplNCA9IGlucHV0VGV4dHVyZS5zaXplO1xuXG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGggKyB0aGlzLmFyZ3VtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUudGV4dHVyZSk7XG5cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdigndXNlcl8nICsgbmFtZSArICdEaW0nLCBfZGltNCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ3VzZXJfJyArIG5hbWUgKyAnU2l6ZScsIF9zaXplNCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgndXNlcl8nICsgbmFtZSArICdCaXRSYXRpbycsIDEpOyAvLyBhbHdheXMgZmxvYXQzMlxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ3VzZXJfJyArIG5hbWUsIHRoaXMuYXJndW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGUgbm90IHN1cHBvcnRlZCAoV2ViR0wpOiAnICsgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hcmd1bWVudHNMZW5ndGgrKztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldE1haW5Db25zdGFudHNTdHJpbmdcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRNYWluQ29uc3RhbnRzU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldE1haW5Db25zdGFudHNTdHJpbmcoKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHRpZiAodGhpcy5jb25zdGFudHMpIHtcblx0XHRcdFx0Zm9yICh2YXIgbmFtZSBpbiB0aGlzLmNvbnN0YW50cykge1xuXHRcdFx0XHRcdGlmICghdGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuY29uc3RhbnRzW25hbWVdO1xuXHRcdFx0XHRcdHZhciB0eXBlID0gdXRpbHMuZ2V0QXJndW1lbnRUeXBlKHZhbHVlKTtcblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ0ludGVnZXInOlxuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnY29uc3QgZmxvYXQgY29uc3RhbnRzXycgKyBuYW1lICsgJyA9ICcgKyBwYXJzZUludCh2YWx1ZSkgKyAnLjAnKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdGbG9hdCc6XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdjb25zdCBmbG9hdCBjb25zdGFudHNfJyArIG5hbWUgKyAnID0gJyArIHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0XHRjYXNlICdJbnB1dCc6XG5cdFx0XHRcdFx0XHRjYXNlICdIVE1MSW1hZ2UnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnQXJyYXlUZXh0dXJlKDQpJzpcblx0XHRcdFx0XHRcdGNhc2UgJ051bWJlclRleHR1cmUnOlxuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgndW5pZm9ybSBoaWdocCBzYW1wbGVyMkQgY29uc3RhbnRzXycgKyBuYW1lLCAndW5pZm9ybSBoaWdocCBpdmVjMiBjb25zdGFudHNfJyArIG5hbWUgKyAnU2l6ZScsICd1bmlmb3JtIGhpZ2hwIGl2ZWMzIGNvbnN0YW50c18nICsgbmFtZSArICdEaW0nLCAndW5pZm9ybSBoaWdocCBpbnQgY29uc3RhbnRzXycgKyBuYW1lICsgJ0JpdFJhdGlvJyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgndW5pZm9ybSBoaWdocCBzYW1wbGVyMkRBcnJheSBjb25zdGFudHNfJyArIG5hbWUsICd1bmlmb3JtIGhpZ2hwIGl2ZWMyIGNvbnN0YW50c18nICsgbmFtZSArICdTaXplJywgJ3VuaWZvcm0gaGlnaHAgaXZlYzMgY29uc3RhbnRzXycgKyBuYW1lICsgJ0RpbScsICd1bmlmb3JtIGhpZ2hwIGludCBjb25zdGFudHNfJyArIG5hbWUgKyAnQml0UmF0aW8nKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29uc3RhbnQgJyArIG5hbWUgKyAnIHR5cGUgJyArIHR5cGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2xpbmVzVG9TdHJpbmcocmVzdWx0KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2FkZENvbnN0YW50XG4gICAqXG4gICAqIEBkZXNjIEFkZHMga2VybmVsIHBhcmFtZXRlcnMgdG8gdGhlIEFyZ3VtZW50IFRleHR1cmUsXG4gICAqIGJpbmRpbmcgaXQgdG8gdGhlIHdlYkdsIGluc3RhbmNlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl8VGV4dHVyZXxOdW1iZXJ9IHZhbHVlIC0gVGhlIGFjdHVhbCBhcmd1bWVudCBzdXBwbGllZCB0byB0aGUga2VybmVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgYXJndW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhcmd1bWVudFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2FkZENvbnN0YW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2FkZENvbnN0YW50KHZhbHVlLCB0eXBlLCBuYW1lKSB7XG5cdFx0XHR2YXIgZ2wgPSB0aGlzLl93ZWJHbDtcblx0XHRcdHZhciBhcmd1bWVudFRleHR1cmUgPSB0aGlzLmdldEFyZ3VtZW50VGV4dHVyZShuYW1lKTtcblx0XHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcblx0XHRcdFx0dHlwZSA9IHZhbHVlLnR5cGU7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBkaW0gPSB1dGlscy5nZXREaW1lbnNpb25zKHZhbHVlLCB0cnVlKTtcblx0XHRcdFx0XHRcdHZhciBzaXplID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdFx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdGhpcy5mbG9hdFRleHR1cmVzLFxuXHRcdFx0XHRcdFx0XHRmbG9hdE91dHB1dDogdGhpcy5mbG9hdE91dHB1dFxuXHRcdFx0XHRcdFx0fSwgZGltKTtcblx0XHRcdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBhcmd1bWVudFRleHR1cmUpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuXHRcdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHNpemVbMF0gKiBzaXplWzFdO1xuXG5cdFx0XHRcdFx0XHR2YXIgX2Zvcm1hdEFycmF5VHJhbnNmZXIzID0gdGhpcy5fZm9ybWF0QXJyYXlUcmFuc2Zlcih2YWx1ZSwgbGVuZ3RoKSxcblx0XHRcdFx0XHRcdCAgICB2YWx1ZXNGbGF0ID0gX2Zvcm1hdEFycmF5VHJhbnNmZXIzLnZhbHVlc0ZsYXQsXG5cdFx0XHRcdFx0XHQgICAgYml0UmF0aW8gPSBfZm9ybWF0QXJyYXlUcmFuc2ZlcjMuYml0UmF0aW87XG5cblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSB2b2lkIDA7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5mbG9hdFRleHR1cmVzKSB7XG5cdFx0XHRcdFx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2l6ZVswXSwgc2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHZhbHVlc0ZsYXQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWVzRmxhdC5idWZmZXIpO1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNpemVbMF0gLyBiaXRSYXRpbywgc2l6ZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgYnVmZmVyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdignY29uc3RhbnRzXycgKyBuYW1lICsgJ0RpbScsIGRpbSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdignY29uc3RhbnRzXycgKyBuYW1lICsgJ1NpemUnLCBzaXplKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCdjb25zdGFudHNfJyArIG5hbWUgKyAnQml0UmF0aW8nLCBiaXRSYXRpbyk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgnY29uc3RhbnRzXycgKyBuYW1lLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0lucHV0Jzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaW5wdXQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGltNSA9IGlucHV0LnNpemU7XG5cdFx0XHRcdFx0XHR2YXIgX3NpemU1ID0gdXRpbHMuZGltVG9UZXhTaXplKHtcblx0XHRcdFx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdGhpcy5mbG9hdFRleHR1cmVzLFxuXHRcdFx0XHRcdFx0XHRmbG9hdE91dHB1dDogdGhpcy5mbG9hdE91dHB1dFxuXHRcdFx0XHRcdFx0fSwgX2RpbTUpO1xuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG5cdFx0XHRcdFx0XHR2YXIgX2xlbmd0aDIgPSBfc2l6ZTVbMF0gKiBfc2l6ZTVbMV07XG5cblx0XHRcdFx0XHRcdHZhciBfZm9ybWF0QXJyYXlUcmFuc2ZlcjQgPSB0aGlzLl9mb3JtYXRBcnJheVRyYW5zZmVyKHZhbHVlLnZhbHVlLCBfbGVuZ3RoMiksXG5cdFx0XHRcdFx0XHQgICAgX3ZhbHVlc0ZsYXQyID0gX2Zvcm1hdEFycmF5VHJhbnNmZXI0LnZhbHVlc0ZsYXQsXG5cdFx0XHRcdFx0XHQgICAgX2JpdFJhdGlvMiA9IF9mb3JtYXRBcnJheVRyYW5zZmVyNC5iaXRSYXRpbztcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZmxvYXRUZXh0dXJlcykge1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkYsIF9zaXplNVswXSwgX3NpemU1WzFdLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgaW5wdXRBcnJheSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgX2J1ZmZlcjIgPSBuZXcgVWludDhBcnJheShfdmFsdWVzRmxhdDIuYnVmZmVyKTtcblx0XHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfc2l6ZTVbMF0gLyBfYml0UmF0aW8yLCBfc2l6ZTVbMV0sIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIF9idWZmZXIyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLmhhcmRjb2RlQ29uc3RhbnRzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdignY29uc3RhbnRzXycgKyBuYW1lICsgJ0RpbScsIF9kaW01KTtcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KCdjb25zdGFudHNfJyArIG5hbWUgKyAnU2l6ZScsIF9zaXplNSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgnY29uc3RhbnRzXycgKyBuYW1lICsgJ0JpdFJhdGlvJywgX2JpdFJhdGlvMik7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgnY29uc3RhbnRzXycgKyBuYW1lLCB0aGlzLmNvbnN0YW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgJ0hUTUxJbWFnZSc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dmFyIGlucHV0SW1hZ2UgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHZhciBfZGltNiA9IFtpbnB1dEltYWdlLndpZHRoLCBpbnB1dEltYWdlLmhlaWdodCwgMV07XG5cdFx0XHRcdFx0XHR2YXIgX3NpemU2ID0gW2lucHV0SW1hZ2Uud2lkdGgsIGlucHV0SW1hZ2UuaGVpZ2h0XTtcblxuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGFyZ3VtZW50VGV4dHVyZSk7XG5cdFx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXHRcdFx0XHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHQvLyBVcGxvYWQgdGhlIGltYWdlIGludG8gdGhlIHRleHR1cmUuXG5cdFx0XHRcdFx0XHR2YXIgbWlwTGV2ZWwgPSAwOyAvLyB0aGUgbGFyZ2VzdCBtaXBcblx0XHRcdFx0XHRcdHZhciBpbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkE7IC8vIGZvcm1hdCB3ZSB3YW50IGluIHRoZSB0ZXh0dXJlXG5cdFx0XHRcdFx0XHR2YXIgc3JjRm9ybWF0ID0gZ2wuUkdCQTsgLy8gZm9ybWF0IG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdFx0dmFyIHNyY1R5cGUgPSBnbC5VTlNJR05FRF9CWVRFOyAvLyB0eXBlIG9mIGRhdGEgd2UgYXJlIHN1cHBseWluZ1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBMZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHNyY0Zvcm1hdCwgc3JjVHlwZSwgaW5wdXRJbWFnZSk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0zaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdEaW0nLCBfZGltNik7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0yaXYoJ2NvbnN0YW50c18nICsgbmFtZSArICdTaXplJywgX3NpemU2KTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCdjb25zdGFudHNfJyArIG5hbWUsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnSFRNTEltYWdlQXJyYXknOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpbnB1dEltYWdlcyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0dmFyIF9kaW03ID0gW2lucHV0SW1hZ2VzWzBdLndpZHRoLCBpbnB1dEltYWdlc1swXS5oZWlnaHQsIGlucHV0SW1hZ2VzLmxlbmd0aF07XG5cdFx0XHRcdFx0XHR2YXIgX3NpemU3ID0gW2lucHV0SW1hZ2VzWzBdLndpZHRoLCBpbnB1dEltYWdlc1swXS5oZWlnaHRdO1xuXG5cdFx0XHRcdFx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgYXJndW1lbnRUZXh0dXJlKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcblx0XHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuXHRcdFx0XHRcdFx0Ly8gVXBsb2FkIHRoZSBpbWFnZXMgaW50byB0aGUgdGV4dHVyZS5cblx0XHRcdFx0XHRcdHZhciBfbWlwTGV2ZWwyID0gMDsgLy8gdGhlIGxhcmdlc3QgbWlwXG5cdFx0XHRcdFx0XHR2YXIgX2ludGVybmFsRm9ybWF0MiA9IGdsLlJHQkE7IC8vIGZvcm1hdCB3ZSB3YW50IGluIHRoZSB0ZXh0dXJlXG5cdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBpbnB1dEltYWdlc1swXS53aWR0aDtcblx0XHRcdFx0XHRcdHZhciBoZWlnaHQgPSBpbnB1dEltYWdlc1swXS5oZWlnaHQ7XG5cdFx0XHRcdFx0XHR2YXIgdGV4dHVyZURlcHRoID0gaW5wdXRJbWFnZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dmFyIGJvcmRlciA9IDA7XG5cdFx0XHRcdFx0XHR2YXIgX3NyY0Zvcm1hdDIgPSBnbC5SR0JBOyAvLyBmb3JtYXQgb2YgZGF0YSB3ZSBhcmUgc3VwcGx5aW5nXG5cdFx0XHRcdFx0XHR2YXIgX3NyY1R5cGUyID0gZ2wuVU5TSUdORURfQllURTsgLy8gdHlwZSBvZiBkYXRhIHdlIGFyZSBzdXBwbHlpbmdcblx0XHRcdFx0XHRcdGdsLnRleEltYWdlM0QoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgX21pcExldmVsMiwgX2ludGVybmFsRm9ybWF0Miwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZURlcHRoLCBib3JkZXIsIF9zcmNGb3JtYXQyLCBfc3JjVHlwZTIsIG51bGwpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dEltYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgeE9mZnNldCA9IDA7XG5cdFx0XHRcdFx0XHRcdHZhciB5T2Zmc2V0ID0gMDtcblx0XHRcdFx0XHRcdFx0dmFyIGltYWdlRGVwdGggPSAxO1xuXHRcdFx0XHRcdFx0XHRnbC50ZXhTdWJJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIF9taXBMZXZlbDIsIHhPZmZzZXQsIHlPZmZzZXQsIGksIGlucHV0SW1hZ2VzW2ldLndpZHRoLCBpbnB1dEltYWdlc1tpXS5oZWlnaHQsIGltYWdlRGVwdGgsIF9zcmNGb3JtYXQyLCBfc3JjVHlwZTIsIGlucHV0SW1hZ2VzW2ldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTNpdignY29uc3RhbnRzXycgKyBuYW1lICsgJ0RpbScsIF9kaW03KTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTJpdignY29uc3RhbnRzXycgKyBuYW1lICsgJ1NpemUnLCBfc2l6ZTcpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMWkoJ2NvbnN0YW50c18nICsgbmFtZSwgdGhpcy5jb25zdGFudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlICdBcnJheVRleHR1cmUoNCknOlxuXHRcdFx0XHRjYXNlICdOdW1iZXJUZXh0dXJlJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaW5wdXRUZXh0dXJlID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR2YXIgX2RpbTggPSBpbnB1dFRleHR1cmUuZGltZW5zaW9ucztcblx0XHRcdFx0XHRcdHZhciBfc2l6ZTggPSBpbnB1dFRleHR1cmUuc2l6ZTtcblxuXHRcdFx0XHRcdFx0Z2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGlucHV0VGV4dHVyZS50ZXh0dXJlKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtM2l2KCdjb25zdGFudHNfJyArIG5hbWUgKyAnRGltJywgX2RpbTgpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRVbmlmb3JtMml2KCdjb25zdGFudHNfJyArIG5hbWUgKyAnU2l6ZScsIF9zaXplOCk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFVuaWZvcm0xaSgnY29uc3RhbnRzXycgKyBuYW1lICsgJ0JpdFJhdGlvJywgMSk7IC8vIGF3YXlzIGZsb2F0MzJcblx0XHRcdFx0XHRcdHRoaXMuc2V0VW5pZm9ybTFpKCdjb25zdGFudHNfJyArIG5hbWUsIHRoaXMuY29uc3RhbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSAnSW50ZWdlcic6XG5cdFx0XHRcdGNhc2UgJ0Zsb2F0Jzpcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGUgbm90IHN1cHBvcnRlZCAoV2ViR0wpOiAnICsgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgV2ViR0wyS2VybmVsI1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgX2dldEdldFJlc3VsdFN0cmluZ1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEdldFJlc3VsdFN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRHZXRSZXN1bHRTdHJpbmcoKSB7XG5cdFx0XHRpZiAoIXRoaXMuZmxvYXRUZXh0dXJlcykge1xuXHRcdFx0XHRyZXR1cm4gJyAgcmV0dXJuIGRlY29kZSh0ZXhlbCwgeCwgYml0UmF0aW8pOyc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJyAgcmV0dXJuIHRleGVsW2NoYW5uZWxdOyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0SGVhZGVyU3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIEdldCB0aGUgaGVhZGVyIHN0cmluZyBmb3IgdGhlIHByb2dyYW0uXG4gICAqIFRoaXMgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gc3ViLWtlcm5lbHMgYXJlIGRlZmluZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEhlYWRlclN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRIZWFkZXJTdHJpbmcoKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0VGV4dHVyZUNvb3JkaW5hdGVcbiAgICpcbiAgICogQGRlc2MgR2V0IHRleHR1cmUgY29vcmRpbmF0ZSBzdHJpbmcgZm9yIHRoZSBwcm9ncmFtXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldFRleHR1cmVDb29yZGluYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldFRleHR1cmVDb29yZGluYXRlKCkge1xuXHRcdFx0dmFyIG5hbWVzID0gdGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzO1xuXHRcdFx0aWYgKG5hbWVzID09PSBudWxsIHx8IG5hbWVzLmxlbmd0aCA8IDEpIHtcblx0XHRcdFx0cmV0dXJuICdpbiBoaWdocCB2ZWMyIHZUZXhDb29yZDtcXG4nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICdvdXQgaGlnaHAgdmVjMiB2VGV4Q29vcmQ7XFxuJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMMktlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRNYWluUGFyYW1zU3RyaW5nXG4gICAqXG4gICAqIEBkZXNjIEdlbmVyYXRlIHRyYW5zcGlsZWQgZ2xzbCBTdHJpbmdzIGZvciB1c2VyLWRlZmluZWQgcGFyYW1ldGVycyBzZW50IHRvIGEga2VybmVsXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBUaGUgYWN0dWFsIHBhcmFtZXRlcnMgc2VudCB0byB0aGUgS2VybmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldE1haW5QYXJhbXNTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWFpblBhcmFtc1N0cmluZyhhcmdzKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR2YXIgcGFyYW1UeXBlcyA9IHRoaXMucGFyYW1UeXBlcztcblx0XHRcdHZhciBwYXJhbU5hbWVzID0gdGhpcy5wYXJhbU5hbWVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbU5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXJhbSA9IGFyZ3NbaV07XG5cdFx0XHRcdHZhciBwYXJhbU5hbWUgPSBwYXJhbU5hbWVzW2ldO1xuXHRcdFx0XHR2YXIgcGFyYW1UeXBlID0gcGFyYW1UeXBlc1tpXTtcblx0XHRcdFx0aWYgKHRoaXMuaGFyZGNvZGVDb25zdGFudHMpIHtcblx0XHRcdFx0XHRpZiAocGFyYW1UeXBlID09PSAnQXJyYXknIHx8IHBhcmFtVHlwZSA9PT0gJ051bWJlclRleHR1cmUnIHx8IHBhcmFtVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScpIHtcblx0XHRcdFx0XHRcdHZhciBwYXJhbURpbSA9IHV0aWxzLmdldERpbWVuc2lvbnMocGFyYW0sIHRydWUpO1xuXHRcdFx0XHRcdFx0dmFyIHBhcmFtU2l6ZSA9IHV0aWxzLmRpbVRvVGV4U2l6ZSh7XG5cdFx0XHRcdFx0XHRcdGZsb2F0VGV4dHVyZXM6IHRoaXMuZmxvYXRUZXh0dXJlcyxcblx0XHRcdFx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRoaXMuZmxvYXRPdXRwdXRcblx0XHRcdFx0XHRcdH0sIHBhcmFtRGltKTtcblxuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ3VuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIHVzZXJfJyArIHBhcmFtTmFtZSwgJ2hpZ2hwIGl2ZWMyIHVzZXJfJyArIHBhcmFtTmFtZSArICdTaXplID0gaXZlYzIoJyArIHBhcmFtU2l6ZVswXSArICcsICcgKyBwYXJhbVNpemVbMV0gKyAnKScsICdoaWdocCBpdmVjMyB1c2VyXycgKyBwYXJhbU5hbWUgKyAnRGltID0gaXZlYzMoJyArIHBhcmFtRGltWzBdICsgJywgJyArIHBhcmFtRGltWzFdICsgJywgJyArIHBhcmFtRGltWzJdICsgJyknLCAndW5pZm9ybSBoaWdocCBpbnQgdXNlcl8nICsgcGFyYW1OYW1lICsgJ0JpdFJhdGlvJyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwYXJhbVR5cGUgPT09ICdJbnRlZ2VyJykge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ2hpZ2hwIGZsb2F0IHVzZXJfJyArIHBhcmFtTmFtZSArICcgPSAnICsgcGFyYW0gKyAnLjAnKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBhcmFtVHlwZSA9PT0gJ0Zsb2F0Jykge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ2hpZ2hwIGZsb2F0IHVzZXJfJyArIHBhcmFtTmFtZSArICcgPSAnICsgcGFyYW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAocGFyYW1UeXBlID09PSAnQXJyYXknIHx8IHBhcmFtVHlwZSA9PT0gJ051bWJlclRleHR1cmUnIHx8IHBhcmFtVHlwZSA9PT0gJ0FycmF5VGV4dHVyZSg0KScgfHwgcGFyYW1UeXBlID09PSAnSW5wdXQnIHx8IHBhcmFtVHlwZSA9PT0gJ0hUTUxJbWFnZScpIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCd1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCB1c2VyXycgKyBwYXJhbU5hbWUsICd1bmlmb3JtIGhpZ2hwIGl2ZWMyIHVzZXJfJyArIHBhcmFtTmFtZSArICdTaXplJywgJ3VuaWZvcm0gaGlnaHAgaXZlYzMgdXNlcl8nICsgcGFyYW1OYW1lICsgJ0RpbScpO1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtVHlwZSAhPT0gJ0hUTUxJbWFnZScpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJ3VuaWZvcm0gaGlnaHAgaW50IHVzZXJfJyArIHBhcmFtTmFtZSArICdCaXRSYXRpbycpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocGFyYW1UeXBlID09PSAnSFRNTEltYWdlQXJyYXknKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgndW5pZm9ybSBoaWdocCBzYW1wbGVyMkRBcnJheSB1c2VyXycgKyBwYXJhbU5hbWUsICd1bmlmb3JtIGhpZ2hwIGl2ZWMyIHVzZXJfJyArIHBhcmFtTmFtZSArICdTaXplJywgJ3VuaWZvcm0gaGlnaHAgaXZlYzMgdXNlcl8nICsgcGFyYW1OYW1lICsgJ0RpbScpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocGFyYW1UeXBlID09PSAnSW50ZWdlcicgfHwgcGFyYW1UeXBlID09PSAnRmxvYXQnKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgndW5pZm9ybSBmbG9hdCB1c2VyXycgKyBwYXJhbU5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2xpbmVzVG9TdHJpbmcocmVzdWx0KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFdlYkdMMktlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIF9nZXRLZXJuZWxTdHJpbmdcbiAgICpcbiAgICogQGRlc2MgR2V0IEtlcm5lbCBwcm9ncmFtIHN0cmluZyAoaW4gKmdsc2wqKSBmb3IgYSBrZXJuZWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHJlc3VsdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEtlcm5lbFN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9nZXRLZXJuZWxTdHJpbmcoKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0XHR2YXIgbmFtZXMgPSB0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXM7XG5cdFx0XHRpZiAobmFtZXMgIT09IG51bGwpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goJ2Zsb2F0IGtlcm5lbFJlc3VsdCA9IDAuMCcpO1xuXHRcdFx0XHRyZXN1bHQucHVzaCgnbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgZGF0YTAnKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCdmbG9hdCAnICsgbmFtZXNbaV0gKyAnID0gMC4wJywgJ2xheW91dChsb2NhdGlvbiA9ICcgKyAoaSArIDEpICsgJykgb3V0IHZlYzQgZGF0YScgKyAoaSArIDEpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goJ291dCB2ZWM0IGRhdGEwJyk7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCdmbG9hdCBrZXJuZWxSZXN1bHQgPSAwLjAnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuX2xpbmVzVG9TdHJpbmcocmVzdWx0KSArIHRoaXMuZnVuY3Rpb25CdWlsZGVyLmdldFByb3RvdHlwZVN0cmluZygna2VybmVsJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0TWFpblJlc3VsdFN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgbWFpbiByZXN1bHQgc3RyaW5nIHdpdGggY2hlY2tzIGZvciBmbG9hdE91dHB1dCwgZ3JhcGhpY2FsLCBzdWJLZXJuZWxzT3V0cHV0cywgZXRjLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSByZXN1bHRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19nZXRNYWluUmVzdWx0U3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2dldE1haW5SZXN1bHRTdHJpbmcoKSB7XG5cdFx0XHR2YXIgbmFtZXMgPSB0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXM7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdGlmICh0aGlzLmZsb2F0T3V0cHV0KSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCcgIGluZGV4ICo9IDQnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZ3JhcGhpY2FsKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsICcgIGtlcm5lbCgpJywgJyAgZGF0YTAgPSBhY3R1YWxDb2xvcicpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmZsb2F0T3V0cHV0KSB7XG5cdFx0XHRcdHZhciBjaGFubmVscyA9IFsncicsICdnJywgJ2InLCAnYSddO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknKTtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBrZXJuZWwoKScpO1xuXG5cdFx0XHRcdFx0aWYgKG5hbWVzKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBkYXRhMC4nICsgY2hhbm5lbHNbaV0gKyAnID0ga2VybmVsUmVzdWx0Jyk7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbmFtZXMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgZGF0YScgKyAoaiArIDEpICsgJy4nICsgY2hhbm5lbHNbaV0gKyAnID0gJyArIG5hbWVzW2pdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgZGF0YTAuJyArIGNoYW5uZWxzW2ldICsgJyA9IGtlcm5lbFJlc3VsdCcpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpIDwgY2hhbm5lbHMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goJyAgaW5kZXggKz0gMScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChuYW1lcyAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCgnICB0aHJlYWRJZCA9IGluZGV4VG8zRChpbmRleCwgdU91dHB1dERpbSknKTtcblx0XHRcdFx0cmVzdWx0LnB1c2goJyAga2VybmVsKCknKTtcblx0XHRcdFx0cmVzdWx0LnB1c2goJyAgZGF0YTAgPSBlbmNvZGUzMihrZXJuZWxSZXN1bHQpJyk7XG5cdFx0XHRcdGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5hbWVzLmxlbmd0aDsgX2kyKyspIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaCgnICBkYXRhJyArIChfaTIgKyAxKSArICcgPSBlbmNvZGUzMignICsgbmFtZXNbX2kyXSArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKCcgIHRocmVhZElkID0gaW5kZXhUbzNEKGluZGV4LCB1T3V0cHV0RGltKScsICcgIGtlcm5lbCgpJywgJyAgZGF0YTAgPSBlbmNvZGUzMihrZXJuZWxSZXN1bHQpJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9saW5lc1RvU3RyaW5nKHJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfYWRkS2VybmVsc1xuICAgKlxuICAgKiBAZGVzYyBBZGRzIGFsbCB0aGUgc3ViLWtlcm5lbHMgc3VwcGxpZWQgd2l0aCB0aGlzIEtlcm5lbCBpbnN0YW5jZS5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ19hZGRLZXJuZWxzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2FkZEtlcm5lbHMoKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0dmFyIGJ1aWxkZXIgPSB0aGlzLmZ1bmN0aW9uQnVpbGRlcjtcblx0XHRcdHZhciBnbCA9IHRoaXMuX3dlYkdsO1xuXG5cdFx0XHRidWlsZGVyLmFkZEZ1bmN0aW9ucyh0aGlzLmZ1bmN0aW9ucywge1xuXHRcdFx0XHRjb25zdGFudHM6IHRoaXMuY29uc3RhbnRzLFxuXHRcdFx0XHRvdXRwdXQ6IHRoaXMub3V0cHV0XG5cdFx0XHR9KTtcblx0XHRcdGJ1aWxkZXIuYWRkTmF0aXZlRnVuY3Rpb25zKHRoaXMubmF0aXZlRnVuY3Rpb25zKTtcblxuXHRcdFx0YnVpbGRlci5hZGRLZXJuZWwodGhpcy5mblN0cmluZywge1xuXHRcdFx0XHRwcm90b3R5cGVPbmx5OiBmYWxzZSxcblx0XHRcdFx0Y29uc3RhbnRzOiB0aGlzLmNvbnN0YW50cyxcblx0XHRcdFx0b3V0cHV0OiB0aGlzLm91dHB1dCxcblx0XHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRcdGxvb3BNYXhJdGVyYXRpb25zOiB0aGlzLmxvb3BNYXhJdGVyYXRpb25zLFxuXHRcdFx0XHRwYXJhbU5hbWVzOiB0aGlzLnBhcmFtTmFtZXMsXG5cdFx0XHRcdHBhcmFtVHlwZXM6IHRoaXMucGFyYW1UeXBlcyxcblx0XHRcdFx0Y29uc3RhbnRUeXBlczogdGhpcy5jb25zdGFudFR5cGVzLFxuXHRcdFx0XHRmaXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeTogdGhpcy5maXhJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmICh0aGlzLnN1Yktlcm5lbHMgIT09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRUZXh0dXJlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLnN1Yktlcm5lbE91dHB1dFZhcmlhYmxlTmFtZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxzLmZvckVhY2goZnVuY3Rpb24gKHN1Yktlcm5lbCkge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpczIuX2FkZFN1Yktlcm5lbChzdWJLZXJuZWwpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5zdWJLZXJuZWxQcm9wZXJ0aWVzICE9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc3ViS2VybmVsT3V0cHV0VGV4dHVyZXMgPSBbXTtcblx0XHRcdFx0dGhpcy5zdWJLZXJuZWxPdXRwdXRWYXJpYWJsZU5hbWVzID0gW107XG5cdFx0XHRcdE9iamVjdC5rZXlzKHRoaXMuc3ViS2VybmVsUHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3RoaXMyLl9hZGRTdWJLZXJuZWwoX3RoaXMyLnN1Yktlcm5lbFByb3BlcnRpZXNbcHJvcGVydHldKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0RnJhZ1NoYWRlclN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgdGhlIGZyYWdtZW50IHNoYWRlciBTdHJpbmcuXG4gICAqIElmIHRoZSBTdHJpbmcgaGFzbid0IGJlZW4gY29tcGlsZWQgeWV0LFxuICAgKiB0aGVuIHRoaXMgbWV0aG9kIGNvbXBpbGVzIGl0IGFzIHdlbGxcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIFRoZSBhY3R1YWwgcGFyYW1ldGVycyBzZW50IHRvIHRoZSBLZXJuZWxcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gRnJhZ21lbnQgU2hhZGVyIHN0cmluZ1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldEZyYWdTaGFkZXJTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0RnJhZ1NoYWRlclN0cmluZyhhcmdzKSB7XG5cdFx0XHRpZiAodGhpcy5jb21waWxlZEZyYWdTaGFkZXJTdHJpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRGcmFnU2hhZGVyU3RyaW5nID0gdGhpcy5fcmVwbGFjZUFydGlmYWN0cyh0aGlzLmNvbnN0cnVjdG9yLmZyYWdTaGFkZXJTdHJpbmcsIHRoaXMuX2dldEZyYWdTaGFkZXJBcnRpZmFjdE1hcChhcmdzKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBXZWJHTDJLZXJuZWwjXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBfZ2V0VmVydFNoYWRlclN0cmluZ1xuICAgKlxuICAgKiBAZGVzYyBHZXQgdGhlIHZlcnRpY2FsIHNoYWRlciBTdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJncyAtIFRoZSBhY3R1YWwgcGFyYW1ldGVycyBzZW50IHRvIHRoZSBLZXJuZWxcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVmVydGljYWwgU2hhZGVyIHN0cmluZ1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnX2dldFZlcnRTaGFkZXJTdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmVydFNoYWRlclN0cmluZyhhcmdzKSB7XG5cdFx0XHRpZiAodGhpcy5jb21waWxlZFZlcnRTaGFkZXJTdHJpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0U2hhZGVyU3RyaW5nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuY29tcGlsZWRWZXJ0U2hhZGVyU3RyaW5nID0gdGhpcy5jb25zdHJ1Y3Rvci52ZXJ0U2hhZGVyU3RyaW5nO1xuXHRcdH1cblx0fV0sIFt7XG5cdFx0a2V5OiAnZnJhZ1NoYWRlclN0cmluZycsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gZnJhZ1NoYWRlclN0cmluZztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICd2ZXJ0U2hhZGVyU3RyaW5nJyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB2ZXJ0U2hhZGVyU3RyaW5nO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBXZWJHTDJLZXJuZWw7XG59KFdlYkdMS2VybmVsKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFJ1bm5lckJhc2UgPSByZXF1aXJlKCcuLi9ydW5uZXItYmFzZScpO1xudmFyIFdlYkdMMkZ1bmN0aW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tYnVpbGRlcicpO1xudmFyIFdlYkdMMktlcm5lbCA9IHJlcXVpcmUoJy4va2VybmVsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9SdW5uZXJCYXNlKSB7XG5cdF9pbmhlcml0cyhXZWJHTDJSdW5uZXIsIF9SdW5uZXJCYXNlKTtcblxuXHQvKipcbiAgKiBAY29uc3RydWN0b3IgV2ViR0wyUnVubmVyXG4gICpcbiAgKiBAZXh0ZW5kcyBSdW5uZXJCYXNlXG4gXHQgKiBAZGVzYyBJbnN0YW50aWF0ZXMgYSBSdW5uZXIgaW5zdGFuY2UgZm9yIHRoZSBrZXJuZWwuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgLSBTZXR0aW5ncyB0byBpbnN0YW50aWF0ZSBwcm9wZXJ0aWVzIGluIFJ1bm5lckJhc2UsIHdpdGggZ2l2ZW4gdmFsdWVzXG4gICpcbiAgKi9cblx0ZnVuY3Rpb24gV2ViR0wyUnVubmVyKHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMMlJ1bm5lcik7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViR0wyUnVubmVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViR0wyUnVubmVyKSkuY2FsbCh0aGlzLCBuZXcgV2ViR0wyRnVuY3Rpb25CdWlsZGVyKCksIHNldHRpbmdzKSk7XG5cblx0XHRfdGhpcy5LZXJuZWwgPSBXZWJHTDJLZXJuZWw7XG5cdFx0X3RoaXMua2VybmVsID0gbnVsbDtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBAbWVtYmVyT2YgV2ViR0wyUnVubmVyI1xuICAqIEBmdW5jdGlvblxuICAqIEBuYW1lIGdldE1vZGVcbiAgKlxuICAqIEBkZXNjIFJldHVybiB0aGUgY3VycmVudCBtb2RlIGluIHdoaWNoIGdwdS5qcyBpcyBleGVjdXRpbmcuXG4gICpcbiAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY3VycmVudCBtb2RlOyBcImdwdVwiLlxuICAqXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoV2ViR0wyUnVubmVyLCBbe1xuXHRcdGtleTogJ2dldE1vZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRNb2RlKCkge1xuXHRcdFx0cmV0dXJuICdncHUnO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBXZWJHTDJSdW5uZXI7XG59KFJ1bm5lckJhc2UpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxuX19IRUFERVJfXztcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxucHJlY2lzaW9uIGhpZ2hwIGludDtcXG5wcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xcblxcbmNvbnN0IGZsb2F0IExPT1BfTUFYID0gX19MT09QX01BWF9fO1xcblxcbl9fQ09OU1RBTlRTX187XFxuXFxuaW4gdmVjMiB2VGV4Q29vcmQ7XFxuXFxudmVjMiBpbnRlZ2VyTW9kKHZlYzIgeCwgZmxvYXQgeSkge1xcbiAgdmVjMiByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xcbn1cXG5cXG52ZWMzIGludGVnZXJNb2QodmVjMyB4LCBmbG9hdCB5KSB7XFxuICB2ZWMzIHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XFxuICByZXR1cm4gcmVzICogc3RlcCgxLjAgLSBmbG9vcih5KSwgLXJlcyk7XFxufVxcblxcbnZlYzQgaW50ZWdlck1vZCh2ZWM0IHgsIHZlYzQgeSkge1xcbiAgdmVjNCByZXMgPSBmbG9vcihtb2QoeCwgeSkpO1xcbiAgcmV0dXJuIHJlcyAqIHN0ZXAoMS4wIC0gZmxvb3IoeSksIC1yZXMpO1xcbn1cXG5cXG5mbG9hdCBpbnRlZ2VyTW9kKGZsb2F0IHgsIGZsb2F0IHkpIHtcXG4gIGZsb2F0IHJlcyA9IGZsb29yKG1vZCh4LCB5KSk7XFxuICByZXR1cm4gcmVzICogKHJlcyA+IGZsb29yKHkpIC0gMS4wID8gMC4wIDogMS4wKTtcXG59XFxuXFxuaW50IGludGVnZXJNb2QoaW50IHgsIGludCB5KSB7XFxuICByZXR1cm4geCAtICh5ICogaW50KHgveSkpO1xcbn1cXG5cXG5fX0RJVklERV9XSVRIX0lOVEVHRVJfQ0hFQ0tfXztcXG5cXG4vLyBIZXJlIGJlIGRyYWdvbnMhXFxuLy8gRE8gTk9UIE9QVElNSVpFIFRISVMgQ09ERVxcbi8vIFlPVSBXSUxMIEJSRUFLIFNPTUVUSElORyBPTiBTT01FQk9EWSdTIE1BQ0hJTkVcXG4vLyBMRUFWRSBJVCBBUyBJVCBJUywgTEVTVCBZT1UgV0FTVEUgWU9VUiBPV04gVElNRVxcbmNvbnN0IHZlYzIgTUFHSUNfVkVDID0gdmVjMigxLjAsIC0yNTYuMCk7XFxuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1IgPSB2ZWM0KDEuMCwgMjU2LjAsIDY1NTM2LjAsIDAuMCk7XFxuY29uc3QgdmVjNCBTQ0FMRV9GQUNUT1JfSU5WID0gdmVjNCgxLjAsIDAuMDAzOTA2MjUsIDAuMDAwMDE1MjU4Nzg5MDYyNSwgMC4wKTsgLy8gMSwgMS8yNTYsIDEvNjU1MzZcXG5mbG9hdCBkZWNvZGUzMih2ZWM0IHJnYmEpIHtcXG4gIF9fREVDT0RFMzJfRU5ESUFOTkVTU19fO1xcbiAgcmdiYSAqPSAyNTUuMDtcXG4gIHZlYzIgZ3RlMTI4O1xcbiAgZ3RlMTI4LnggPSByZ2JhLmIgPj0gMTI4LjAgPyAxLjAgOiAwLjA7XFxuICBndGUxMjgueSA9IHJnYmEuYSA+PSAxMjguMCA/IDEuMCA6IDAuMDtcXG4gIGZsb2F0IGV4cG9uZW50ID0gMi4wICogcmdiYS5hIC0gMTI3LjAgKyBkb3QoZ3RlMTI4LCBNQUdJQ19WRUMpO1xcbiAgZmxvYXQgcmVzID0gZXhwMihyb3VuZChleHBvbmVudCkpO1xcbiAgcmdiYS5iID0gcmdiYS5iIC0gMTI4LjAgKiBndGUxMjgueDtcXG4gIHJlcyA9IGRvdChyZ2JhLCBTQ0FMRV9GQUNUT1IpICogZXhwMihyb3VuZChleHBvbmVudC0yMy4wKSkgKyByZXM7XFxuICByZXMgKj0gZ3RlMTI4LnkgKiAtMi4wICsgMS4wO1xcbiAgcmV0dXJuIHJlcztcXG59XFxuXFxudmVjNCBlbmNvZGUzMihmbG9hdCBmKSB7XFxuICBmbG9hdCBGID0gYWJzKGYpO1xcbiAgZmxvYXQgc2lnbiA9IGYgPCAwLjAgPyAxLjAgOiAwLjA7XFxuICBmbG9hdCBleHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xcbiAgZmxvYXQgbWFudGlzc2EgPSAoZXhwMigtZXhwb25lbnQpICogRik7XFxuICAvLyBleHBvbmVudCArPSBmbG9vcihsb2cyKG1hbnRpc3NhKSk7XFxuICB2ZWM0IHJnYmEgPSB2ZWM0KEYgKiBleHAyKDIzLjAtZXhwb25lbnQpKSAqIFNDQUxFX0ZBQ1RPUl9JTlY7XFxuICByZ2JhLnJnID0gaW50ZWdlck1vZChyZ2JhLnJnLCAyNTYuMCk7XFxuICByZ2JhLmIgPSBpbnRlZ2VyTW9kKHJnYmEuYiwgMTI4LjApO1xcbiAgcmdiYS5hID0gZXhwb25lbnQqMC41ICsgNjMuNTtcXG4gIHJnYmEuYmEgKz0gdmVjMihpbnRlZ2VyTW9kKGV4cG9uZW50KzEyNy4wLCAyLjApLCBzaWduKSAqIDEyOC4wO1xcbiAgcmdiYSA9IGZsb29yKHJnYmEpO1xcbiAgcmdiYSAqPSAwLjAwMzkyMTU2OTsgLy8gMS8yNTVcXG4gIF9fRU5DT0RFMzJfRU5ESUFOTkVTU19fO1xcbiAgcmV0dXJuIHJnYmE7XFxufVxcbi8vIERyYWdvbnMgZW5kIGhlcmVcXG5cXG5mbG9hdCBkZWNvZGUodmVjNCByZ2JhLCBpbnQgeCwgaW50IGJpdFJhdGlvKSB7XFxuICBpZiAoYml0UmF0aW8gPT0gMSkge1xcbiAgICByZXR1cm4gZGVjb2RlMzIocmdiYSk7XFxuICB9XFxuICBfX0RFQ09ERTMyX0VORElBTk5FU1NfXztcXG4gIGludCBjaGFubmVsID0gaW50ZWdlck1vZCh4LCBiaXRSYXRpbyk7XFxuICBpZiAoYml0UmF0aW8gPT0gNCkge1xcbiAgICByZXR1cm4gcmdiYVtjaGFubmVsXSAqIDI1NS4wO1xcbiAgfVxcbiAgZWxzZSB7XFxuICAgIHJldHVybiByZ2JhW2NoYW5uZWwqMl0gKiAyNTUuMCArIHJnYmFbY2hhbm5lbCoyICsgMV0gKiA2NTI4MC4wO1xcbiAgfVxcbn1cXG5cXG5pbnQgaW5kZXg7XFxuaXZlYzMgdGhyZWFkSWQ7XFxuXFxuaXZlYzMgaW5kZXhUbzNEKGludCBpZHgsIGl2ZWMzIHRleERpbSkge1xcbiAgaW50IHogPSBpbnQoaWR4IC8gKHRleERpbS54ICogdGV4RGltLnkpKTtcXG4gIGlkeCAtPSB6ICogaW50KHRleERpbS54ICogdGV4RGltLnkpO1xcbiAgaW50IHkgPSBpbnQoaWR4IC8gdGV4RGltLngpO1xcbiAgaW50IHggPSBpbnQoaW50ZWdlck1vZChpZHgsIHRleERpbS54KSk7XFxuICByZXR1cm4gaXZlYzMoeCwgeSwgeik7XFxufVxcblxcbmZsb2F0IGdldChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCBiaXRSYXRpbywgIGludCB6LCBpbnQgeSwgaW50IHgpIHtcXG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xcbiAgX19HRVRfV1JBUEFST1VORF9fO1xcbiAgaW50IGluZGV4ID0geHl6LnggKyB0ZXhEaW0ueCAqICh4eXoueSArIHRleERpbS55ICogeHl6LnopO1xcbiAgX19HRVRfVEVYVFVSRV9DSEFOTkVMX187XFxuICBpbnQgdyA9IHRleFNpemUueDtcXG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XFxuICBfX0dFVF9URVhUVVJFX0lOREVYX187XFxuICB2ZWM0IHRleGVsID0gdGV4dHVyZSh0ZXgsIHN0IC8gdmVjMih0ZXhTaXplKSk7XFxuICBfX0dFVF9SRVNVTFRfXztcXG4gIFxcbn1cXG5cXG52ZWM0IGdldEltYWdlMkQoc2FtcGxlcjJEIHRleCwgaXZlYzIgdGV4U2l6ZSwgaXZlYzMgdGV4RGltLCBpbnQgeiwgaW50IHksIGludCB4KSB7XFxuICBpdmVjMyB4eXogPSBpdmVjMyh4LCB5LCB6KTtcXG4gIF9fR0VUX1dSQVBBUk9VTkRfXztcXG4gIGludCBpbmRleCA9IHh5ei54ICsgdGV4RGltLnggKiAoeHl6LnkgKyB0ZXhEaW0ueSAqIHh5ei56KTtcXG4gIF9fR0VUX1RFWFRVUkVfQ0hBTk5FTF9fO1xcbiAgaW50IHcgPSB0ZXhTaXplLng7XFxuICB2ZWMyIHN0ID0gdmVjMihmbG9hdChpbnRlZ2VyTW9kKGluZGV4LCB3KSksIGZsb2F0KGluZGV4IC8gdykpICsgMC41O1xcbiAgX19HRVRfVEVYVFVSRV9JTkRFWF9fO1xcbiAgcmV0dXJuIHRleHR1cmUodGV4LCBzdCAvIHZlYzIodGV4U2l6ZSkpO1xcbn1cXG5cXG52ZWM0IGdldEltYWdlM0Qoc2FtcGxlcjJEQXJyYXkgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB6LCBpbnQgeSwgaW50IHgpIHtcXG4gIGl2ZWMzIHh5eiA9IGl2ZWMzKHgsIHksIHopO1xcbiAgX19HRVRfV1JBUEFST1VORF9fO1xcbiAgaW50IGluZGV4ID0geHl6LnggKyB0ZXhEaW0ueCAqICh4eXoueSArIHRleERpbS55ICogeHl6LnopO1xcbiAgX19HRVRfVEVYVFVSRV9DSEFOTkVMX187XFxuICBpbnQgdyA9IHRleFNpemUueDtcXG4gIHZlYzIgc3QgPSB2ZWMyKGZsb2F0KGludGVnZXJNb2QoaW5kZXgsIHcpKSwgZmxvYXQoaW5kZXggLyB3KSkgKyAwLjU7XFxuICBfX0dFVF9URVhUVVJFX0lOREVYX187XFxuICByZXR1cm4gdGV4dHVyZSh0ZXgsIHZlYzMoc3QgLyB2ZWMyKHRleFNpemUpLCB6KSk7XFxufVxcblxcbmZsb2F0IGdldChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCBiaXRSYXRpbywgaW50IHksIGludCB4KSB7XFxuICByZXR1cm4gZ2V0KHRleCwgdGV4U2l6ZSwgdGV4RGltLCBiaXRSYXRpbywgMCwgeSwgeCk7XFxufVxcblxcbmZsb2F0IGdldChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCBiaXRSYXRpbywgaW50IHgpIHtcXG4gIHJldHVybiBnZXQodGV4LCB0ZXhTaXplLCB0ZXhEaW0sIGJpdFJhdGlvLCAwLCAwLCB4KTtcXG59XFxuXFxudmVjNCBnZXRJbWFnZTJEKHNhbXBsZXIyRCB0ZXgsIGl2ZWMyIHRleFNpemUsIGl2ZWMzIHRleERpbSwgaW50IHksIGludCB4KSB7XFxuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgMCwgeSwgeCk7XFxufVxcblxcbnZlYzQgZ2V0SW1hZ2UyRChzYW1wbGVyMkQgdGV4LCBpdmVjMiB0ZXhTaXplLCBpdmVjMyB0ZXhEaW0sIGludCB4KSB7XFxuICByZXR1cm4gZ2V0SW1hZ2UyRCh0ZXgsIHRleFNpemUsIHRleERpbSwgMCwgMCwgeCk7XFxufVxcblxcbnZlYzQgYWN0dWFsQ29sb3I7XFxudm9pZCBjb2xvcihmbG9hdCByLCBmbG9hdCBnLCBmbG9hdCBiLCBmbG9hdCBhKSB7XFxuICBhY3R1YWxDb2xvciA9IHZlYzQocixnLGIsYSk7XFxufVxcblxcbnZvaWQgY29sb3IoZmxvYXQgciwgZmxvYXQgZywgZmxvYXQgYikge1xcbiAgY29sb3IocixnLGIsMS4wKTtcXG59XFxuXFxuX19NQUlOX1BBUkFNU19fO1xcbl9fTUFJTl9DT05TVEFOVFNfXztcXG5fX0tFUk5FTF9fO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBpbmRleCA9IGludCh2VGV4Q29vcmQucyAqIGZsb2F0KHVUZXhTaXplLngpKSArIGludCh2VGV4Q29vcmQudCAqIGZsb2F0KHVUZXhTaXplLnkpKSAqIHVUZXhTaXplLng7XFxuICBfX01BSU5fUkVTVUxUX187XFxufVwiOyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMzAwIGVzXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcXG5cXG5pbiB2ZWMyIGFQb3M7XFxuaW4gdmVjMiBhVGV4Q29vcmQ7XFxuXFxub3V0IHZlYzIgdlRleENvb3JkO1xcbnVuaWZvcm0gdmVjMiByYXRpbztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KChhUG9zICsgdmVjMigxKSkgKiByYXRpbyArIHZlYzIoLTEpLCAwLCAxKTtcXG4gIHZUZXhDb29yZCA9IGFUZXhDb29yZDtcXG59XCI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBXZWJHTEtlcm5lbCA9IHJlcXVpcmUoJy4va2VybmVsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWxzJyk7XG5cbi8qKlxuICogQGNsYXNzIFdlYkdMVmFsaWRhdG9yS2VybmVsXG4gKlxuICogQGRlc2MgSGVscGVyIGNsYXNzIGZvciBXZWJHTEtlcm5lbCB0byB2YWxpZGF0ZSB0ZXh0dXJlIHNpemUgYW5kIGRpbWVuc2lvbnMuXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfV2ViR0xLZXJuZWwpIHtcblx0X2luaGVyaXRzKFdlYkdMMlZhbGlkYXRvcktlcm5lbCwgX1dlYkdMS2VybmVsKTtcblxuXHRmdW5jdGlvbiBXZWJHTDJWYWxpZGF0b3JLZXJuZWwoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMMlZhbGlkYXRvcktlcm5lbCk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFdlYkdMMlZhbGlkYXRvcktlcm5lbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYkdMMlZhbGlkYXRvcktlcm5lbCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFdlYkdMMlZhbGlkYXRvcktlcm5lbCwgW3tcblx0XHRrZXk6ICd2YWxpZGF0ZU9wdGlvbnMnLFxuXG5cblx0XHQvKiogXG4gICAqIEBtZW1iZXJPZiBXZWJHTFZhbGlkYXRvcktlcm5lbCNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIHZhbGlkYXRlT3B0aW9uc1xuICAgKlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKCkge1xuXHRcdFx0dGhpcy5fd2ViR2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG5cdFx0XHR0aGlzLnRleFNpemUgPSB1dGlscy5kaW1Ub1RleFNpemUoe1xuXHRcdFx0XHRmbG9hdFRleHR1cmVzOiB0aGlzLmZsb2F0VGV4dHVyZXMsXG5cdFx0XHRcdGZsb2F0T3V0cHV0OiB0aGlzLmZsb2F0T3V0cHV0XG5cdFx0XHR9LCB0aGlzLm91dHB1dCwgdHJ1ZSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFdlYkdMMlZhbGlkYXRvcktlcm5lbDtcbn0oV2ViR0xLZXJuZWwpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhbGlhcyhuYW1lLCBmbikge1xuXHR2YXIgZm5TdHJpbmcgPSBmbi50b1N0cmluZygpO1xuXHRyZXR1cm4gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24gJyArIG5hbWUgKyAnICgnICsgdXRpbHMuZ2V0UGFyYW1OYW1lc0Zyb21TdHJpbmcoZm5TdHJpbmcpLmpvaW4oJywgJykgKyAnKSB7JyArIHV0aWxzLmdldEZ1bmN0aW9uQm9keUZyb21TdHJpbmcoZm5TdHJpbmcpICsgJ30nKSgpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBVdGlsc0NvcmUgPSByZXF1aXJlKFwiLi91dGlscy1jb3JlXCIpO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtaW5pbWFsaXN0aWMgdmVyc2lvbiBvZiBHUFUuanMgdXNlZCBcbiAqIHRvIHJ1biBwcmVjb21waWxlZCBHUFUuSlMgY29kZS5cbiAqXG4gKiBUaGlzIGludGVudGlvbmFsbHkgZXhjbHVkZXMgdGhlIEpTIEFTVCBjb21waWxsZXIgOiB3aGljaCBpcyA0MDBrYiBhbG9uZS9cbiAqXG4gKiBAY2xhc3MgR1BVQ29yZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gR1BVQ29yZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgR1BVQ29yZSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoR1BVQ29yZSwgbnVsbCwgW3tcblx0XHRrZXk6IFwidmFsaWRhdGVLZXJuZWxPYmpcIixcblxuXG5cdFx0LyoqXG4gICAqIEBuYW1lIHZhbGlkYXRlS2VybmVsT2JqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBHUFVDb3JlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBWYWxpZGF0ZXMgdGhlIEtlcm5lbE9iaiB0byBjb21wbHkgd2l0aCB0aGUgZGVmaW5lZCBmb3JtYXRcbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lcyBvbmx5IGEgbGltaXRlZCBzYW5pdHkgY2hlY2ssIGFuZCBkb2VzIG5vdCAgXG4gICAqIGd1YXJhbnRlZSBhIGZ1bGwgd29ya2luZyB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBGb3IgdGhlIGtlcm5lbCBvYmplY3QgZm9ybWF0IHNlZSA6IDxrZXJuZWxPYmotZm9ybWF0PlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtlcm5lbE9iaiAtIEtlcm5lbE9iaiB1c2VkIHRvIHZhbGlkYXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB2YWxpZGF0ZWQga2VybmVsIG9iamVjdCwgY29udmVydGVkIGZyb20gSlNPTiBpZiBuZWVkZWRcbiAgICpcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlS2VybmVsT2JqKGtlcm5lbE9iaikge1xuXG5cdFx0XHQvLyBOVUxMIHZhbGlkYXRpb25cblx0XHRcdGlmIChrZXJuZWxPYmogPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgXCJLZXJuZWxPYmogYmVpbmcgdmFsaWRhdGVkIGlzIE5VTExcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RyaW5nIEpTT04gY29udmVyc2lvblxuXHRcdFx0aWYgKHR5cGVvZiBrZXJuZWxPYmogPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRrZXJuZWxPYmogPSBKU09OLnBhcnNlKGtlcm5lbE9iaik7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGUpO1xuXHRcdFx0XHRcdHRocm93IFwiRmFpbGVkIHRvIGNvbnZlcnQgS2VybmVsT2JqIGZyb20gSlNPTiBzdHJpbmdcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE5VTEwgdmFsaWRhdGlvblxuXHRcdFx0XHRpZiAoa2VybmVsT2JqID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhyb3cgXCJJbnZhbGlkIChOVUxMKSBLZXJuZWxPYmogSlNPTiBzdHJpbmcgcmVwcmVzZW50YXRpb25cIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3Iga2VybmVsIG9iaiBmbGFnXG5cdFx0XHRpZiAoa2VybmVsT2JqLmlzS2VybmVsT2JqICE9PSB0cnVlKSB7XG5cdFx0XHRcdHRocm93IFwiRmFpbGVkIG1pc3NpbmcgaXNLZXJuZWxPYmogZmxhZyBjaGVja1wiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gdGhlIHZhbGlkYXRlZCBrZXJuZWxPYmpcblx0XHRcdHJldHVybiBrZXJuZWxPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBuYW1lIGxvYWRLZXJuZWxPYmpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIEdQVUNvcmVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIExvYWRzIHRoZSBwcmVjb21waWxlZCBrZXJuZWwgb2JqZWN0LiBGb3IgR1BVQ29yZSB0aGlzIGlzIHRoZSBPTkxZIHdheSB0byBjcmVhdGUgdGhlIGtlcm5lbC5cbiAgICogVG8gZ2VuZXJhdGUgdGhlIGtlcm5lbE9iaiB1c2UgPEtlcm5lbC5leHBvcnRLZXJuZWxPYmo+XG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbGxzIDx2YWxpZGF0ZUtlcm5lbE9iaj4gaW50ZXJuYWxseSwgYW5kIHRocm93cyBhbiBleGNlcHRpb24gaWYgaXQgZmFpbHMuXG4gICAqXG4gICAqIEBzZWUgR1BVQ29yZS52YWxpZGF0ZUtlcm5lbE9ialxuICAgKiBAc2VlXHRLZXJuZWwuZXhwb3J0S2VybmVsT2JqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBrZXJuZWxPYmogLSBUaGUgcHJlY29tcGlsZWQga2VybmVsIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5PcHQgLSBbT3B0aW9uYWxdIHRoZSBvcHRpb24gb3ZlcnJpZGVzIHRvIHVzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFRoZSBrZXJuZWwgZnVuY3Rpb25cbiAgICogXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6IFwibG9hZEtlcm5lbE9ialwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBsb2FkS2VybmVsT2JqKGtlcm5lbE9iaiwgaW5PcHQpIHtcblxuXHRcdFx0Ly8gVmFsaWRhdGVzIHRoZSBrZXJuZWxPYmosIHRocm93cyBhbiBleGNlcHRpb24gaWYgaXQgZmFpbHNcblx0XHRcdGtlcm5lbE9iaiA9IHZhbGlkYXRlS2VybmVsT2JqKGtlcm5lbE9iaik7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEdQVUNvcmU7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBXZWJHTFJ1bm5lciA9IHJlcXVpcmUoJy4uL2JhY2tlbmQvd2ViLWdsL3J1bm5lcicpO1xudmFyIFdlYkdMMlJ1bm5lciA9IHJlcXVpcmUoJy4uL2JhY2tlbmQvd2ViLWdsMi9ydW5uZXInKTtcbnZhciBDUFVSdW5uZXIgPSByZXF1aXJlKCcuLi9iYWNrZW5kL2NwdS9ydW5uZXInKTtcbnZhciBXZWJHTFZhbGlkYXRvcktlcm5lbCA9IHJlcXVpcmUoJy4uL2JhY2tlbmQvd2ViLWdsL3ZhbGlkYXRvci1rZXJuZWwnKTtcbnZhciBXZWJHTDJWYWxpZGF0b3JLZXJuZWwgPSByZXF1aXJlKCcuLi9iYWNrZW5kL3dlYi1nbDIvdmFsaWRhdG9yLWtlcm5lbCcpO1xudmFyIEdQVUNvcmUgPSByZXF1aXJlKFwiLi9ncHUtY29yZVwiKTtcblxuLyoqXG4gKiBJbml0aWFsaXNlcyB0aGUgR1BVLmpzIGxpYnJhcnkgY2xhc3Mgd2hpY2ggbWFuYWdlcyB0aGUgd2ViR2xDb250ZXh0IGZvciB0aGUgY3JlYXRlZCBmdW5jdGlvbnMuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEdQVUNvcmVcbiAqL1xuXG52YXIgR1BVID0gZnVuY3Rpb24gKF9HUFVDb3JlKSB7XG5cdF9pbmhlcml0cyhHUFUsIF9HUFVDb3JlKTtcblxuXHQvKipcbiAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEdQVS5cbiAgKiBAcGFyYW0ge2FueX0gc2V0dGluZ3MgLSBTZXR0aW5ncyB0byBzZXQgbW9kZSwgYW5kb3RoZXIgcHJvcGVydGllcy4gU2VlICNHUFVDb3JlXG4gICogQG1lbWJlck9mIEdQVSNcbiAgKi9cblx0ZnVuY3Rpb24gR1BVKHNldHRpbmdzKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdQVSk7XG5cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoR1BVLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR1BVKSkuY2FsbCh0aGlzLCBzZXR0aW5ncykpO1xuXG5cdFx0c2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcblx0XHRfdGhpcy5fY2FudmFzID0gc2V0dGluZ3MuY2FudmFzIHx8IG51bGw7XG5cdFx0X3RoaXMuX3dlYkdsID0gc2V0dGluZ3Mud2ViR2wgfHwgbnVsbDtcblx0XHR2YXIgbW9kZSA9IHNldHRpbmdzLm1vZGU7XG5cdFx0dmFyIGRldGVjdGVkTW9kZSA9IHZvaWQgMDtcblx0XHRpZiAoIXV0aWxzLmlzV2ViR2xTdXBwb3J0ZWQoKSkge1xuXHRcdFx0aWYgKG1vZGUgJiYgbW9kZSAhPT0gJ2NwdScpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdBIHJlcXVlc3RlZCBtb2RlIG9mIFwiJyArIG1vZGUgKyAnXCIgYW5kIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignV2FybmluZzogZ3B1IG5vdCBzdXBwb3J0ZWQsIGZhbGxpbmcgYmFjayB0byBjcHUgc3VwcG9ydCcpO1xuXHRcdFx0XHRkZXRlY3RlZE1vZGUgPSAnY3B1Jztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKF90aGlzLl93ZWJHbCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIF90aGlzLl93ZWJHbC5jb25zdHJ1Y3RvciA9PT0gV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuXHRcdFx0XHRcdGRldGVjdGVkTW9kZSA9ICd3ZWJnbDInO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIF90aGlzLl93ZWJHbC5jb25zdHJ1Y3RvciA9PT0gV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGV0ZWN0ZWRNb2RlID0gJ3dlYmdsJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gV2ViR0wgQ29udGV4dCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZXRlY3RlZE1vZGUgPSBtb2RlIHx8ICdncHUnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRfdGhpcy5rZXJuZWxzID0gW107XG5cblx0XHR2YXIgcnVubmVyU2V0dGluZ3MgPSB7XG5cdFx0XHRjYW52YXM6IF90aGlzLl9jYW52YXMsXG5cdFx0XHR3ZWJHbDogX3RoaXMuX3dlYkdsXG5cdFx0fTtcblxuXHRcdHN3aXRjaCAoZGV0ZWN0ZWRNb2RlKSB7XG5cdFx0XHQvLyBwdWJsaWMgb3B0aW9uc1xuXHRcdFx0Y2FzZSAnY3B1Jzpcblx0XHRcdFx0X3RoaXMuX3J1bm5lciA9IG5ldyBDUFVSdW5uZXIocnVubmVyU2V0dGluZ3MpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2dwdSc6XG5cdFx0XHRcdHZhciBSdW5uZXIgPSBfdGhpcy5nZXRHUFVSdW5uZXIoKTtcblx0XHRcdFx0X3RoaXMuX3J1bm5lciA9IG5ldyBSdW5uZXIocnVubmVyU2V0dGluZ3MpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gcHJpdmF0ZSBleHBsaWNpdCBvcHRpb25zIGZvciB0ZXN0aW5nXG5cdFx0XHRjYXNlICd3ZWJnbDInOlxuXHRcdFx0XHRfdGhpcy5fcnVubmVyID0gbmV3IFdlYkdMMlJ1bm5lcihydW5uZXJTZXR0aW5ncyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnd2ViZ2wnOlxuXHRcdFx0XHRfdGhpcy5fcnVubmVyID0gbmV3IFdlYkdMUnVubmVyKHJ1bm5lclNldHRpbmdzKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIHByaXZhdGUgZXhwbGljaXQgb3B0aW9ucyBmb3IgaW50ZXJuYWxcblx0XHRcdGNhc2UgJ3dlYmdsMi12YWxpZGF0b3InOlxuXHRcdFx0XHRfdGhpcy5fcnVubmVyID0gbmV3IFdlYkdMMlJ1bm5lcihydW5uZXJTZXR0aW5ncyk7XG5cdFx0XHRcdF90aGlzLl9ydW5uZXIuS2VybmVsID0gV2ViR0wyVmFsaWRhdG9yS2VybmVsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3dlYmdsLXZhbGlkYXRvcic6XG5cdFx0XHRcdF90aGlzLl9ydW5uZXIgPSBuZXcgV2ViR0xSdW5uZXIocnVubmVyU2V0dGluZ3MpO1xuXHRcdFx0XHRfdGhpcy5fcnVubmVyLktlcm5lbCA9IFdlYkdMVmFsaWRhdG9yS2VybmVsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignXCInICsgbW9kZSArICdcIiBtb2RlIGlzIG5vdCBkZWZpbmVkJyk7XG5cdFx0fVxuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXHQvKipcbiAgKlxuICAqIFRoaXMgY3JlYXRlcyBhIGNhbGxhYmxlIGZ1bmN0aW9uIG9iamVjdCB0byBjYWxsIHRoZSBrZXJuZWwgZnVuY3Rpb24gd2l0aCB0aGUgYXJndW1lbnQgcGFyYW1ldGVyIHNldFxuICAqXG4gICogQG5hbWUgY3JlYXRlS2VybmVsXG4gICogQGZ1bmN0aW9uXG4gICogQG1lbWJlck9mIEdQVSMjXG4gICpcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBjYWxsaW5nIHRvIHBlcmZvcm0gdGhlIGNvbnZlcnNpb25cbiAgKiBAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzXSAtIFRoZSBwYXJhbWV0ZXIgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gc2V0dGluZ3MuZGltZW5zaW9ucyAtIFRocmVhZCBkaW1lbnNpb24gYXJyYXkgKERlZmF1bHRzIHRvIFsxMDI0XSlcbiAgKiBAcHJvcGVydHkge1N0cmluZ30gc2V0dGluZ3MubW9kZSAtIENQVSAvIEdQVSBjb25maWd1cmF0aW9uIG1vZGUgKERlZmF1bHRzIHRvIG51bGwpXG4gICpcbiAgKiBUaGUgZm9sbG93aW5nIG1vZGVzIGFyZSBzdXBwb3J0ZWRcbiAgKiAqJ2ZhbHNleScqIDogQXR0ZW1wdHMgdG8gYnVpbGQgR1BVIG1vZGUsIGVsc2UgZmFsbGJhY2tzXG4gICogKidncHUnKiA6IEF0dGVtcHRzIHRvIGJ1aWxkIEdQVSBtb2RlLCBlbHNlIGZhbGxiYWNrc1xuICAqIConY3B1JyogOiBGb3JjZXMgSlMgZmFsbGJhY2sgbW9kZSBvbmx5XG4gICpcbiAgKlxuICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gY2FsbGFibGUgZnVuY3Rpb24gdG8gcnVuXG4gICpcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhHUFUsIFt7XG5cdFx0a2V5OiAnY3JlYXRlS2VybmVsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY3JlYXRlS2VybmVsKGZuLCBzZXR0aW5ncykge1xuXHRcdFx0Ly9cblx0XHRcdC8vIGJhc2ljIHBhcmFtZXRlcnMgc2FmZXR5IGNoZWNrc1xuXHRcdFx0Ly9cblx0XHRcdGlmICh0eXBlb2YgZm4gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRocm93ICdNaXNzaW5nIGZuIHBhcmFtZXRlcic7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXV0aWxzLmlzRnVuY3Rpb24oZm4pICYmIHR5cGVvZiBmbiAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhyb3cgJ2ZuIHBhcmFtZXRlciBub3QgYSBmdW5jdGlvbic7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtZXJnZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdFx0XHR3ZWJHbDogdGhpcy5fd2ViR2wsXG5cdFx0XHRcdGNhbnZhczogdGhpcy5fY2FudmFzXG5cdFx0XHR9LCBzZXR0aW5ncyB8fCB7fSk7XG5cblx0XHRcdHZhciBrZXJuZWwgPSB0aGlzLl9ydW5uZXIuYnVpbGRLZXJuZWwoZm4sIG1lcmdlZFNldHRpbmdzKTtcblxuXHRcdFx0Ly9pZiBjYW52YXMgZGlkbid0IGNvbWUgZnJvbSB0aGlzLCBwcm9wYWdhdGUgZnJvbSBrZXJuZWxcblx0XHRcdGlmICghdGhpcy5fY2FudmFzKSB7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcyA9IGtlcm5lbC5nZXRDYW52YXMoKTtcblx0XHRcdH1cblx0XHRcdGlmICghdGhpcy5fcnVubmVyLmNhbnZhcykge1xuXHRcdFx0XHR0aGlzLl9ydW5uZXIuY2FudmFzID0ga2VybmVsLmdldENhbnZhcygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmtlcm5lbHMucHVzaChrZXJuZWwpO1xuXG5cdFx0XHRyZXR1cm4ga2VybmVsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKlxuICAgKiBDcmVhdGUgYSBzdXBlciBrZXJuZWwgd2hpY2ggZXhlY3V0ZXMgc3ViIGtlcm5lbHNcbiAgICogYW5kIHNhdmVzIHRoZWlyIG91dHB1dCB0byBiZSB1c2VkIHdpdGggdGhlIG5leHQgc3ViIGtlcm5lbC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHdlIHdhbnQgdG8gc2F2ZSB0aGUgb3V0cHV0IG9uIG9uZSBrZXJuZWwsXG4gICAqIGFuZCB0aGVuIHVzZSBpdCBhcyBhbiBpbnB1dCB0byBhbm90aGVyIGtlcm5lbC4gKk1hY2hpbmUgTGVhcm5pbmcqXG4gICAqXG4gICAqIEBuYW1lIGNyZWF0ZUtlcm5lbE1hcFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIEdQVSNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHN1Yktlcm5lbHMgLSBTdWIga2VybmVscyBmb3IgdGhpcyBrZXJuZWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcm9vdEtlcm5lbCAtIFJvb3Qga2VybmVsXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gY2FsbGFibGUga2VybmVsIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG1lZ2FLZXJuZWwgPSBncHUuY3JlYXRlS2VybmVsTWFwKHtcbiAgICogICBhZGRSZXN1bHQ6IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAqICAgICByZXR1cm4gYVt0aGlzLnRocmVhZC54XSArIGJbdGhpcy50aHJlYWQueF07XG4gICAqICAgfSxcbiAgICogICBtdWx0aXBseVJlc3VsdDogZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICAgKiAgICAgcmV0dXJuIGFbdGhpcy50aHJlYWQueF0gKiBiW3RoaXMudGhyZWFkLnhdO1xuICAgKiAgIH0sXG4gICAqICB9LCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAqICAgICAgIHJldHVybiBtdWx0aXBseShhZGQoYSwgYiksIGMpO1xuICAgKiB9KTtcbiAgICpcbiAgICogbWVnYUtlcm5lbChhLCBiLCBjKTtcbiAgICpcbiAgICogTm90ZTogWW91IGNhbiBhbHNvIGRlZmluZSBzdWJLZXJuZWxzIGFzIGFuIGFycmF5IG9mIGZ1bmN0aW9ucy5cbiAgICogPiBbYWRkLCBtdWx0aXBseV1cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NyZWF0ZUtlcm5lbE1hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUtlcm5lbE1hcCgpIHtcblx0XHRcdHZhciBmbiA9IHZvaWQgMDtcblx0XHRcdHZhciBzZXR0aW5ncyA9IHZvaWQgMDtcblx0XHRcdGlmICh0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAyXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMl07XG5cdFx0XHRcdHNldHRpbmdzID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZuID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF1dGlscy5pc1dlYkdsRHJhd0J1ZmZlcnNTdXBwb3J0ZWQoKSkge1xuXHRcdFx0XHR0aGlzLl9ydW5uZXIgPSBuZXcgQ1BVUnVubmVyKHNldHRpbmdzKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtlcm5lbCA9IHRoaXMuY3JlYXRlS2VybmVsKGZuLCBzZXR0aW5ncyk7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG5cdFx0XHRcdHZhciBmdW5jdGlvbnMgPSBhcmd1bWVudHNbMF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0a2VybmVsLmFkZFN1Yktlcm5lbChmdW5jdGlvbnNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgX2Z1bmN0aW9ucyA9IGFyZ3VtZW50c1swXTtcblx0XHRcdFx0Zm9yICh2YXIgcCBpbiBfZnVuY3Rpb25zKSB7XG5cdFx0XHRcdFx0aWYgKCFfZnVuY3Rpb25zLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcblx0XHRcdFx0XHRrZXJuZWwuYWRkU3ViS2VybmVsUHJvcGVydHkocCwgX2Z1bmN0aW9uc1twXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGtlcm5lbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICpcbiAgICogQ29tYmluZSBkaWZmZXJlbnQga2VybmVscyBpbnRvIG9uZSBzdXBlciBLZXJuZWwsXG4gICAqIHVzZWZ1bCB0byBwZXJmb3JtIG11bHRpcGxlIG9wZXJhdGlvbnMgaW5zaWRlIG9uZVxuICAgKiBrZXJuZWwgd2l0aG91dCB0aGUgcGVuYWx0eSBvZiBkYXRhIHRyYW5zZmVyIGJldHdlZW5cbiAgICogY3B1IGFuZCBncHUuXG4gICAqXG4gICAqIFRoZSBudW1iZXIgb2Yga2VybmVsIGZ1bmN0aW9ucyBzZW50IHRvIHRoaXMgbWV0aG9kIGNhbiBiZSB2YXJpYWJsZS5cbiAgICogWW91IGNhbiBzZW5kIGluIG9uZSwgdHdvLCBldGMuXG4gICAqXG4gICAqIEBuYW1lIGNvbWJpbmVLZXJuZWxzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgR1BVI1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJLZXJuZWxzIC0gS2VybmVsIGZ1bmN0aW9uKHMpIHRvIGNvbWJpbmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJvb3RLZXJuZWwgLSBSb290IGtlcm5lbCB0byBjb21iaW5lIGtlcm5lbHMgaW50b1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBcdGNvbWJpbmVLZXJuZWxzKGFkZCwgbXVsdGlwbHksIGZ1bmN0aW9uKGEsYixjKXtcbiAgICpcdCBcdHJldHVybiBhZGQobXVsdGlwbHkoYSxiKSwgYylcbiAgICpcdH0pXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQ2FsbGFibGUga2VybmVsIGZ1bmN0aW9uXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb21iaW5lS2VybmVscycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbWJpbmVLZXJuZWxzKCkge1xuXHRcdFx0dmFyIGxhc3RLZXJuZWwgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDJdO1xuXHRcdFx0dmFyIGNvbWJpbmVkS2VybmVsID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcblx0XHRcdGlmICh0aGlzLmdldE1vZGUoKSA9PT0gJ2NwdScpIHJldHVybiBjb21iaW5lZEtlcm5lbDtcblxuXHRcdFx0dmFyIGNhbnZhcyA9IGFyZ3VtZW50c1swXS5nZXRDYW52YXMoKTtcblx0XHRcdHZhciB3ZWJHbCA9IGFyZ3VtZW50c1swXS5nZXRXZWJHbCgpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdFx0YXJndW1lbnRzW2ldLnNldENhbnZhcyhjYW52YXMpLnNldFdlYkdsKHdlYkdsKS5zZXRPdXRwdXRUb1RleHR1cmUodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvbWJpbmVkS2VybmVsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHZhciB0ZXhTaXplID0gbGFzdEtlcm5lbC50ZXhTaXplO1xuXHRcdFx0XHR2YXIgZ2wgPSBsYXN0S2VybmVsLmdldFdlYkdsKCk7XG5cdFx0XHRcdHZhciB0aHJlYWREaW0gPSBsYXN0S2VybmVsLnRocmVhZERpbTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHZvaWQgMDtcblx0XHRcdFx0aWYgKGxhc3RLZXJuZWwuZmxvYXRPdXRwdXQpIHtcblx0XHRcdFx0XHR2YXIgdyA9IHRleFNpemVbMF07XG5cdFx0XHRcdFx0dmFyIGggPSBNYXRoLmNlaWwodGV4U2l6ZVsxXSAvIDQpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KTtcblx0XHRcdFx0XHRnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdsLkZMT0FULCByZXN1bHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRleFNpemVbMF0gKiB0ZXhTaXplWzFdICogNCk7XG5cdFx0XHRcdFx0Z2wucmVhZFBpeGVscygwLCAwLCB0ZXhTaXplWzBdLCB0ZXhTaXplWzFdLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBieXRlcyk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShieXRlcy5idWZmZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnN1YmFycmF5KDAsIHRocmVhZERpbVswXSAqIHRocmVhZERpbVsxXSAqIHRocmVhZERpbVsyXSk7XG5cblx0XHRcdFx0aWYgKGxhc3RLZXJuZWwub3V0cHV0Lmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzLnNwbGl0QXJyYXkocmVzdWx0LCBsYXN0S2VybmVsLm91dHB1dFswXSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGFzdEtlcm5lbC5vdXRwdXQubGVuZ3RoID09PSAzKSB7XG5cdFx0XHRcdFx0dmFyIGN1YmUgPSB1dGlscy5zcGxpdEFycmF5KHJlc3VsdCwgbGFzdEtlcm5lbC5vdXRwdXRbMF0gKiBsYXN0S2VybmVsLm91dHB1dFsxXSk7XG5cdFx0XHRcdFx0cmV0dXJuIGN1YmUubWFwKGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdXRpbHMuc3BsaXRBcnJheSh4LCBsYXN0S2VybmVsLm91dHB1dFswXSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0R1BVUnVubmVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0R1BVUnVubmVyKCkge1xuXHRcdFx0aWYgKHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiB1dGlscy5pc1dlYkdsMlN1cHBvcnRlZCgpKSByZXR1cm4gV2ViR0wyUnVubmVyO1xuXHRcdFx0aWYgKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gV2ViR0xSdW5uZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBmdW5jdGlvbnMsIHRoYXQgdGhlIGtlcm5lbCBtYXkgY2FsbC5cbiAgICpcbiAgICogQG5hbWUgYWRkRnVuY3Rpb25cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBHUFUjXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiAtIEpTIEZ1bmN0aW9uIHRvIGRvIGNvbnZlcnNpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge0dQVX0gcmV0dXJucyBpdHNlbGZcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZEZ1bmN0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkRnVuY3Rpb24oZm4sIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuX3J1bm5lci5mdW5jdGlvbkJ1aWxkZXIuYWRkRnVuY3Rpb24obnVsbCwgZm4sIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIEFkZHMgYWRkaXRpb25hbCBuYXRpdmUgZnVuY3Rpb25zLCB0aGF0IHRoZSBrZXJuZWwgbWF5IGNhbGwuXG4gICAqXG4gICAqIEBuYW1lIGFkZE5hdGl2ZUZ1bmN0aW9uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgR1BVI1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hdGl2ZSBmdW5jdGlvbiBuYW1lLCB1c2VkIGZvciByZXZlcnNlIGxvb2t1cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmF0aXZlRnVuY3Rpb24gLSB0aGUgbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLCBhcyBpdCB3b3VsZCBiZSBkZWZpbmVkIGluIGl0J3MgZW50aXJldHlcbiAgICpcbiAgICogQHJldHVybnMge0dQVX0gcmV0dXJucyBpdHNlbGZcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZE5hdGl2ZUZ1bmN0aW9uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgbmF0aXZlRnVuY3Rpb24pIHtcblx0XHRcdHRoaXMuX3J1bm5lci5mdW5jdGlvbkJ1aWxkZXIuYWRkTmF0aXZlRnVuY3Rpb24obmFtZSwgbmF0aXZlRnVuY3Rpb24pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBtb2RlIGluIHdoaWNoIGdwdS5qcyBpcyBleGVjdXRpbmcuXG4gICAqIEBuYW1lIGdldE1vZGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBHUFUjXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBjdXJyZW50IG1vZGUsIFwiY3B1XCIsIFwid2ViZ2xcIiwgZXRjLlxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0TW9kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE1vZGUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcnVubmVyLmdldE1vZGUoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICpcbiAgICogUmV0dXJuIFRSVUUsIGlmIGJyb3dzZXIgc3VwcG9ydHMgV2ViR2wgQU5EIENhbnZhc1xuICAgKlxuICAgKiBAbmFtZSBnZXQgaXNXZWJHbFN1cHBvcnRlZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIEdQVSNcbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBjYW4gYWxzbyBiZSBjYWxsZWQgZGlyZWN0bHkgYEdQVS5pc1dlYkdsU3VwcG9ydGVkKClgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUUlVFIGlmIGJyb3dzZXIgc3VwcG9ydHMgd2ViR2xcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzV2ViR2xTdXBwb3J0ZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc1dlYkdsU3VwcG9ydGVkKCkge1xuXHRcdFx0cmV0dXJuIHV0aWxzLmlzV2ViR2xTdXBwb3J0ZWQoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICpcbiAgICogUmV0dXJuIFRSVUUsIGlmIHN5c3RlbSBoYXMgaW50ZWdlciBkaXZpc2lvbiBhY2N1cmFjeSBpc3N1ZVxuICAgKlxuICAgKiBAbmFtZSBnZXQgaGFzSW50ZWdlckRpdmlzaW9uQWNjdXJhY3lCdWdcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBHUFUjXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gYmUgY2FsbGVkIGRpcmVjdGx5IGBHUFUuaGFzSW50ZWdlckRpdmlzaW9uQWNjdXJhY3lCdWcoKWBcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRSVUUgaWYgc3lzdGVtIGhhcyBpbnRlZ2VyIGRpdmlzaW9uIGFjY3VyYWN5IGlzc3VlXG4gICAqXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeUJ1ZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc0ludGVnZXJEaXZpc2lvbkFjY3VyYWN5QnVnKCkge1xuXHRcdFx0cmV0dXJuIHV0aWxzLmhhc0ludGVnZXJEaXZpc2lvbkFjY3VyYWN5QnVnKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIFJldHVybiB0aGUgY2FudmFzIG9iamVjdCBib3VuZCB0byB0aGlzIGdwdSBpbnN0YW5jZS5cbiAgICpcbiAgICogQG5hbWUgZ2V0Q2FudmFzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgR1BVI1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBDYW52YXMgb2JqZWN0IGlmIHByZXNlbnRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldENhbnZhcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldENhbnZhcygpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIFJldHVybiB0aGUgd2ViR2wgb2JqZWN0IGJvdW5kIHRvIHRoaXMgZ3B1IGluc3RhbmNlLlxuICAgKlxuICAgKiBAbmFtZSBnZXRXZWJHbFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIEdQVSNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gV2ViR2wgb2JqZWN0IGlmIHByZXNlbnRcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFdlYkdsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0V2ViR2woKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fd2ViR2w7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqXG4gICAqIERlc3Ryb3lzIGFsbCBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIGdwdS5qcyAmIHRoZSB3ZWJHbCBpZiB3ZSBjcmVhdGVkIGl0XG4gICAqXG4gICAqIEBuYW1lIGRlc3Ryb3lcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBHUFUjXG4gICAqXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkZXN0cm95Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHQvLyBwZXJmb3JtIG9uIG5leHQgcnVubG9vcCAtIGZvciBzb21lIHJlYXNvbiB3ZSBkb250IGdldCBsb3NlIGNvbnRleHQgZXZlbnRzIFxuXHRcdFx0Ly8gaWYgd2ViR2wgaXMgY3JlYXRlZCBhbmQgZGVzdHJveWVkIGluIHRoZSBzYW1lIHJ1biBsb29wLlxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBrZXJuZWxzID0gX3RoaXMyLmtlcm5lbHM7XG5cblx0XHRcdFx0dmFyIGRlc3Ryb3lXZWJHbCA9ICFfdGhpczIuX3dlYkdsICYmIGtlcm5lbHMubGVuZ3RoICYmIGtlcm5lbHNbMF0uX3dlYkdsO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzMi5rZXJuZWxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0X3RoaXMyLmtlcm5lbHNbaV0uZGVzdHJveSh0cnVlKTsgLy8gcmVtb3ZlIGNhbnZhcyBpZiBleGlzdHNcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkZXN0cm95V2ViR2wpIHtcblx0XHRcdFx0XHRkZXN0cm95V2ViR2wuT0VTX3RleHR1cmVfZmxvYXQgPSBudWxsO1xuXHRcdFx0XHRcdGRlc3Ryb3lXZWJHbC5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBudWxsO1xuXHRcdFx0XHRcdGRlc3Ryb3lXZWJHbC5PRVNfZWxlbWVudF9pbmRleF91aW50ID0gbnVsbDtcblx0XHRcdFx0XHR2YXIgbG9zZUNvbnRleHRFeHQgPSBkZXN0cm95V2ViR2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcblx0XHRcdFx0XHRpZiAobG9zZUNvbnRleHRFeHQpIHtcblx0XHRcdFx0XHRcdGxvc2VDb250ZXh0RXh0Lmxvc2VDb250ZXh0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gR1BVO1xufShHUFVDb3JlKTtcblxuO1xuXG4vLyBUaGlzIGVuc3VyZSBzdGF0aWMgbWV0aG9kcyBhcmUgXCJpbmhlcml0ZWRcIlxuLy8gU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDQxNTA4L2hvdy10by1pbmhlcml0LXN0YXRpYy1tZXRob2RzLWZyb20tYmFzZS1jbGFzcy1pbi1qYXZhc2NyaXB0XG5PYmplY3QuYXNzaWduKEdQVSwgR1BVQ29yZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gR1BVOyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIElucHV0KHZhbHVlLCBzaXplKSB7XG5cdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnB1dCk7XG5cblx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRpZiAoQXJyYXkuaXNBcnJheShzaXplKSkge1xuXHRcdHRoaXMuc2l6ZSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5zaXplW2ldID0gc2l6ZVtpXTtcblx0XHR9XG5cdFx0d2hpbGUgKHRoaXMuc2l6ZS5sZW5ndGggPCAzKSB7XG5cdFx0XHR0aGlzLnNpemUucHVzaCgxKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKHNpemUueikge1xuXHRcdFx0dGhpcy5zaXplID0gW3NpemUueCwgc2l6ZS55LCBzaXplLnpdO1xuXHRcdH0gZWxzZSBpZiAoc2l6ZS55KSB7XG5cdFx0XHR0aGlzLnNpemUgPSBbc2l6ZS54LCBzaXplLnksIDFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNpemUgPSBbc2l6ZS54LCAxLCAxXTtcblx0XHR9XG5cdH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHQvKipcbiAgKiBAZGVzYyBXZWJHbCBUZXh0dXJlIGltcGxlbWVudGF0aW9uIGluIEpTXG4gICogQGNvbnN0cnVjdG9yIFRleHR1cmVcbiAgKiBAcGFyYW0ge09iamVjdH0gdGV4dHVyZVxuICAqIEBwYXJhbSB7QXJyYXl9IHNpemVcbiAgKiBAcGFyYW0gZGltZW5zaW9uc1xuICAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dFxuICAqIEBwYXJhbSB7T2JqZWN0fSB3ZWJHbFxuICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV1cbiAgKi9cblx0ZnVuY3Rpb24gVGV4dHVyZSh0ZXh0dXJlLCBzaXplLCBkaW1lbnNpb25zLCBvdXRwdXQsIHdlYkdsKSB7XG5cdFx0dmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6ICdOdW1iZXJUZXh0dXJlJztcblxuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0dXJlKTtcblxuXHRcdHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0dGhpcy5zaXplID0gc2l6ZTtcblx0XHR0aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuXHRcdHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuXHRcdHRoaXMud2ViR2wgPSB3ZWJHbDtcblx0XHR0aGlzLmtlcm5lbCA9IG51bGw7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0fVxuXG5cdC8qKlxuICAqIEBuYW1lIHRvQXJyYXlcbiAgKiBAZnVuY3Rpb25cbiAgKiBAbWVtYmVyT2YgVGV4dHVyZSNcbiAgKlxuICAqIEBkZXNjIENvbnZlcnRzIHRoZSBUZXh0dXJlIGludG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAqIFxuICAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgYGdwdWAgT2JqZWN0XG4gICpcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhUZXh0dXJlLCBbe1xuXHRcdGtleTogJ3RvQXJyYXknLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KGdwdSkge1xuXHRcdFx0aWYgKCFncHUpIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcGFzcyB0aGUgR1BVIG9iamVjdCBmb3IgdG9BcnJheSB0byB3b3JrLicpO1xuXHRcdFx0aWYgKHRoaXMua2VybmVsKSByZXR1cm4gdGhpcy5rZXJuZWwodGhpcyk7XG5cblx0XHRcdHRoaXMua2VybmVsID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAoeCkge1xuXHRcdFx0XHRyZXR1cm4geFt0aGlzLnRocmVhZC56XVt0aGlzLnRocmVhZC55XVt0aGlzLnRocmVhZC54XTtcblx0XHRcdH0pLnNldE91dHB1dCh0aGlzLm91dHB1dCk7XG5cblx0XHRcdHJldHVybiB0aGlzLmtlcm5lbCh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBkZXNjIERlbGV0ZXMgdGhlIFRleHR1cmUuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgVGV4dHVyZSNcbiAgICpcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2RlbGV0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy53ZWJHbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFRleHR1cmU7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqXG4gKiBAZGVzYyBSZWR1Y2VkIHN1YnNldCBvZiBVdGlscywgdXNlZCBleGNsdXNpdmVseSBpbiBncHUtY29yZS5qc1xuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyAvIHNuaXBwZXRzIG9mIGNvZGUgdGhhdCBHUFUuSlMgdXNlcyBpbnRlcm5hbGx5LlxcXG4gKiBUaGlzIGNvdmVycyB2YXJpb3VzIHNuaXBwZXRzIG9mIGNvZGUgdGhhdCBpcyBub3QgZW50aXJlbHkgZ3B1LmpzIHNwZWNpZmljIChpZS4gbWF5IGZpbmQgdXNlcyBlbHNld2hlcmUpXG4gKlxuICogTm90ZSB0aGF0IGFsbCBtZXRob2RzIGluIHRoaXMgY2xhc3MgaXMgJ3N0YXRpYycgYnkgbmF0dXJlIGBVdGlsc0NvcmUuZnVuY3Rpb25OYW1lKClgXG4gKlxuICogQGNsYXNzIFV0aWxzQ29yZVxuICpcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVXRpbHNDb3JlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBVdGlsc0NvcmUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzQ29yZSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoVXRpbHNDb3JlLCBudWxsLCBbe1xuXHRcdGtleTogJ2lzQ2FudmFzJyxcblxuXG5cdFx0LyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IHdlYkdsQ29udGV4dFxuICAgKi9cblxuXHRcdC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW52YXNET01PYmplY3RcbiAgICovXG5cblx0XHQvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly9cblx0XHQvLyAgQ2FudmFzIHZhbGlkYXRpb24gYW5kIHN1cHBvcnRcblx0XHQvL1xuXHRcdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdC8qKlxuICAgKiBAbmFtZSBpc0NhbnZhc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgVXRpbHNDb3JlXG4gICAqXG4gICAqXG4gICAqIEBkZXNjIFJldHVybiBUUlVFLCBvbiBhIHZhbGlkIERPTSBjYW52YXMgb3IgT2Zmc2NyZWVuQ2FudmFzIG9iamVjdFxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGRvZXMganVzdCBhIFZFUlkgc2ltcGx5IHNhbml0eSBjaGVjay4gQW5kIG1heSBnaXZlIGZhbHNlIHBvc2l0aXZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNET01PYmplY3R9IGNhbnZhc09iaiAtIE9iamVjdCB0byB2YWxpZGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVFJVRSBpZiB0aGUgb2JqZWN0IGlzIGEgRE9NIGNhbnZhcyBvciBPZmZzY3JlZW5DYW52YXNcbiAgICpcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzQ2FudmFzKGNhbnZhc09iaikge1xuXHRcdFx0cmV0dXJuIGNhbnZhc09iaiAhPT0gbnVsbCAmJiAoY2FudmFzT2JqLm5vZGVOYW1lICYmIGNhbnZhc09iai5nZXRDb250ZXh0ICYmIGNhbnZhc09iai5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJyB8fCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXNPYmogaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbmFtZSBpc0NhbnZhc1N1cHBvcnRlZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgVXRpbHNDb3JlXG4gICAqXG4gICAqIEBkZXNjIFJldHVybiBUUlVFLCBpZiBicm93c2VyIHN1cHBvcnRzIGNhbnZhc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVFJVRSBpZiBicm93c2VyIHN1cHBvcnRzIGNhbnZhc1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNDYW52YXNTdXBwb3J0ZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0NhbnZhc1N1cHBvcnRlZCgpIHtcblx0XHRcdHJldHVybiBfaXNDYW52YXNTdXBwb3J0ZWQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBuYW1lIGluaXRDYW52YXNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIFV0aWxzQ29yZVxuICAgKlxuICAgKiBAZGVzYyBJbml0aWF0ZSBhbmQgcmV0dXJucyBhIGNhbnZhcywgZm9yIHVzYWdlIGluIGluaXRfd2ViZ2wuXG4gICAqIFJldHVybnMgb25seSBpZiBjYW52YXMgaXMgc3VwcG9ydGVkIGJ5IGJyb3dzZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDYW52YXNET01PYmplY3R9IENhbnZhc0RPTU9iamVjdCBpZiBzdXBwb3J0ZWQgYnkgYnJvd3NlciwgZWxzZSBudWxsXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpbml0Q2FudmFzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcblx0XHRcdC8vIEZhaWwgZmFzdCBpZiBicm93c2VyIHByZXZpb3VzbHkgZGV0ZWN0ZWQgbm8gc3VwcG9ydFxuXHRcdFx0aWYgKCFfaXNDYW52YXNTdXBwb3J0ZWQpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBhIG5ldyBjYW52YXMgRE9NXG5cdFx0XHR2YXIgY2FudmFzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcblxuXHRcdFx0Ly8gRGVmYXVsdCB3aWR0aCBhbmQgaGVpZ2h0LCB0byBmaXggd2ViZ2wgaXNzdWUgaW4gc2FmYXJpXG5cdFx0XHRjYW52YXMud2lkdGggPSAyO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IDI7XG5cblx0XHRcdC8vIFJldHVybnMgdGhlIGNhbnZhc1xuXHRcdFx0cmV0dXJuIGNhbnZhcztcblx0XHR9XG5cblx0XHQvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly9cblx0XHQvLyAgV2ViZ2wgdmFsaWRhdGlvbiBhbmQgc3VwcG9ydFxuXHRcdC8vXG5cdFx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cblx0XHQvKipcbiAgICpcbiAgICogQG5hbWUgaXNXZWJHbFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgVXRpbHNDb3JlXG4gICAqXG4gICAqIEBkZXNjIFJldHVybiBUUlVFLCBvbiBhIHZhbGlkIHdlYkdsQ29udGV4dCBvYmplY3RcbiAgICpcbiAgICogTm90ZTogVGhpcyBkb2VzIGp1c3QgYSBWRVJZIHNpbXBseSBzYW5pdHkgY2hlY2suIEFuZCBtYXkgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7d2ViR2xDb250ZXh0fSB3ZWJHbE9iaiAtIE9iamVjdCB0byB2YWxpZGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVFJVRSBpZiB0aGUgb2JqZWN0IGlzIGEgd2ViR2xDb250ZXh0IG9iamVjdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNXZWJHbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzV2ViR2wod2ViR2xPYmopIHtcblx0XHRcdHJldHVybiB3ZWJHbE9iaiAmJiB0eXBlb2Ygd2ViR2xPYmouZ2V0RXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKlxuICAgKiBAbmFtZSBpc1dlYkdsMlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgVXRpbHNDb3JlXG4gICAqXG4gICAqIEBkZXNjIFJldHVybiBUUlVFLCBvbiBhIHZhbGlkIHdlYkdsMkNvbnRleHQgb2JqZWN0XG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZG9lcyBqdXN0IGEgVkVSWSBzaW1wbHkgc2FuaXR5IGNoZWNrLiBBbmQgbWF5IGdpdmUgZmFsc2UgcG9zaXRpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3dlYkdsQ29udGV4dH0gd2ViR2wyT2JqIC0gT2JqZWN0IHRvIHZhbGlkYXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUUlVFIGlmIHRoZSBvYmplY3QgaXMgYSB3ZWJHbDJDb250ZXh0IG9iamVjdFxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNXZWJHbDInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc1dlYkdsMih3ZWJHbDJPYmopIHtcblx0XHRcdHJldHVybiB3ZWJHbDJPYmogJiYgdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIHdlYkdsMk9iaiBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBuYW1lIGlzV2ViR2xTdXBwb3J0ZWRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIFV0aWxzQ29yZVxuICAgKlxuICAgKiBAZGVzYyBSZXR1cm4gVFJVRSwgaWYgYnJvd3NlciBzdXBwb3J0cyB3ZWJnbFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVFJVRSBpZiBicm93c2VyIHN1cHBvcnRzIHdlYmdsXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc1dlYkdsU3VwcG9ydGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNXZWJHbFN1cHBvcnRlZCgpIHtcblx0XHRcdHJldHVybiBfaXNXZWJHbFN1cHBvcnRlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG5hbWUgaXNXZWJHbFN1cHBvcnRlZDJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIFV0aWxzQ29yZVxuICAgKlxuICAgKiBAZGVzYyBSZXR1cm4gVFJVRSwgaWYgYnJvd3NlciBzdXBwb3J0cyB3ZWJnbDJcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRSVUUgaWYgYnJvd3NlciBzdXBwb3J0cyB3ZWJnbDJcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzV2ViR2wyU3VwcG9ydGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNXZWJHbDJTdXBwb3J0ZWQoKSB7XG5cdFx0XHRyZXR1cm4gX2lzV2ViR2wyU3VwcG9ydGVkO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2lzV2ViR2xEcmF3QnVmZmVyc1N1cHBvcnRlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzV2ViR2xEcmF3QnVmZmVyc1N1cHBvcnRlZCgpIHtcblx0XHRcdHJldHVybiBfaXNXZWJHbERyYXdCdWZmZXJzU3VwcG9ydGVkO1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgd2ViZ2wgb3B0aW9ucyB0byB1c2VcblxuXHR9LCB7XG5cdFx0a2V5OiAnaW5pdFdlYkdsRGVmYXVsdE9wdGlvbnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpbml0V2ViR2xEZWZhdWx0T3B0aW9ucygpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGFscGhhOiBmYWxzZSxcblx0XHRcdFx0ZGVwdGg6IGZhbHNlLFxuXHRcdFx0XHRhbnRpYWxpYXM6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbmFtZSBpbml0V2ViR2xcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIFV0aWxzQ29yZVxuICAgKlxuICAgKiBAZGVzYyBJbml0aWF0ZSBhbmQgcmV0dXJucyBhIHdlYkdsLCBmcm9tIGEgY2FudmFzIG9iamVjdFxuICAgKiBSZXR1cm5zIG9ubHkgaWYgd2ViR2wgaXMgc3VwcG9ydGVkIGJ5IGJyb3dzZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzRE9NT2JqZWN0fSBjYW52YXNPYmogLSBPYmplY3QgdG8gdmFsaWRhdGVcbiAgICpcbiAgICogQHJldHVybnMge0NhbnZhc0RPTU9iamVjdH0gQ2FudmFzRE9NT2JqZWN0IGlmIHN1cHBvcnRlZCBieSBicm93c2VyLCBlbHNlIG51bGxcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2luaXRXZWJHbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRXZWJHbChjYW52YXNPYmopIHtcblxuXHRcdFx0Ly8gRmlyc3QgdGltZSBzZXR1cCwgZG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGNoZWNrIG1lbW9yaXplclxuXHRcdFx0aWYgKHR5cGVvZiBfaXNDYW52YXNTdXBwb3J0ZWQgIT09ICd1bmRlZmluZWQnIHx8IGNhbnZhc09iaiA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIV9pc0NhbnZhc1N1cHBvcnRlZCkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhaWwgZmFzdCBmb3IgaW52YWxpZCBjYW52YXMgb2JqZWN0XG5cdFx0XHRpZiAoIVV0aWxzQ29yZS5pc0NhbnZhcyhjYW52YXNPYmopKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjYW52YXMgb2JqZWN0IC0gJyArIGNhbnZhc09iaik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBhIG5ldyBjYW52YXMgRE9NXG5cdFx0XHR2YXIgd2ViR2wgPSBudWxsO1xuXHRcdFx0dmFyIGRlZmF1bHRPcHRpb25zID0gVXRpbHNDb3JlLmluaXRXZWJHbERlZmF1bHRPcHRpb25zKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3ZWJHbCA9IGNhbnZhc09iai5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBkZWZhdWx0T3B0aW9ucyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vICdleHBlcmltZW50YWwtd2ViZ2wnIGlzIG5vdCBhIHN1cHBvcnRlZCBjb250ZXh0IHR5cGVcblx0XHRcdFx0Ly8gZmFsbGJhY2sgdG8gJ3dlYmdsMicgb3IgJ3dlYmdsJyBiZWxvd1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2ViR2wgPT09IG51bGwpIHtcblx0XHRcdFx0d2ViR2wgPSBjYW52YXNPYmouZ2V0Q29udGV4dCgnd2ViZ2wyJywgZGVmYXVsdE9wdGlvbnMpIHx8IGNhbnZhc09iai5nZXRDb250ZXh0KCd3ZWJnbCcsIGRlZmF1bHRPcHRpb25zKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHdlYkdsKSB7XG5cdFx0XHRcdC8vIEdldCB0aGUgZXh0ZW5zaW9uIHRoYXQgaXMgbmVlZGVkXG5cdFx0XHRcdHdlYkdsLk9FU190ZXh0dXJlX2Zsb2F0ID0gd2ViR2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuXHRcdFx0XHR3ZWJHbC5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSB3ZWJHbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuXHRcdFx0XHR3ZWJHbC5PRVNfZWxlbWVudF9pbmRleF91aW50ID0gd2ViR2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50Jyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybnMgdGhlIGNhbnZhc1xuXHRcdFx0cmV0dXJuIHdlYkdsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbmFtZSBpbml0V2ViR2wyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBVdGlsc0NvcmVcbiAgICpcbiAgICogQGRlc2MgSW5pdGlhdGUgYW5kIHJldHVybnMgYSB3ZWJHbCwgZnJvbSBhIGNhbnZhcyBvYmplY3RcbiAgICogUmV0dXJucyBvbmx5IGlmIHdlYkdsIGlzIHN1cHBvcnRlZCBieSBicm93c2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc0RPTU9iamVjdH0gY2FudmFzT2JqIC0gT2JqZWN0IHRvIHZhbGlkYXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtDYW52YXNET01PYmplY3R9IENhbnZhc0RPTU9iamVjdCBpZiBzdXBwb3J0ZWQgYnkgYnJvd3NlciwgZWxzZSBudWxsXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpbml0V2ViR2wyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdFdlYkdsMihjYW52YXNPYmopIHtcblxuXHRcdFx0Ly8gRmlyc3QgdGltZSBzZXR1cCwgZG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGNoZWNrIG1lbW9yaXplclxuXHRcdFx0aWYgKHR5cGVvZiBfaXNDYW52YXNTdXBwb3J0ZWQgIT09ICd1bmRlZmluZWQnIHx8IGNhbnZhc09iaiA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIV9pc0NhbnZhc1N1cHBvcnRlZCkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhaWwgZmFzdCBmb3IgaW52YWxpZCBjYW52YXMgb2JqZWN0XG5cdFx0XHRpZiAoIVV0aWxzQ29yZS5pc0NhbnZhcyhjYW52YXNPYmopKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjYW52YXMgb2JqZWN0IC0gJyArIGNhbnZhc09iaik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBhIG5ldyBjYW52YXMgRE9NXG5cdFx0XHRyZXR1cm4gY2FudmFzT2JqLmdldENvbnRleHQoJ3dlYmdsMicsIFV0aWxzQ29yZS5pbml0V2ViR2xEZWZhdWx0T3B0aW9ucygpKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIFV0aWxzQ29yZVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBvdXRwdXRcbiAgICogQHRocm93cyBpZiBub3QgY29ycmVjdGx5IGRlZmluZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NoZWNrT3V0cHV0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2hlY2tPdXRwdXQob3V0cHV0KSB7XG5cdFx0XHRpZiAoIW91dHB1dCB8fCAhQXJyYXkuaXNBcnJheShvdXRwdXQpKSB0aHJvdyBuZXcgRXJyb3IoJ2tlcm5lbC5vdXRwdXQgbm90IGFuIGFycmF5Jyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoaXNOYU4ob3V0cHV0W2ldKSB8fCBvdXRwdXRbaV0gPCAxKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdrZXJuZWwub3V0cHV0WycgKyBpICsgJ10gaW5jb3JyZWN0bHkgZGVmaW5lZCBhcyBgJyArIG91dHB1dFtpXSArICdgLCBuZWVkcyB0byBiZSBudW1lcmljLCBhbmQgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBVdGlsc0NvcmU7XG59KCk7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyAgQ2FudmFzICYgV2ViZ2wgdmFsaWRhdGlvbiBhbmQgc3VwcG9ydCBjb25zdGFudHNcbi8vXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBfaXNDYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gVXRpbHNDb3JlLmlzQ2FudmFzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKSA6IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnO1xudmFyIF90ZXN0aW5nV2ViR2wgPSBVdGlsc0NvcmUuaW5pdFdlYkdsKFV0aWxzQ29yZS5pbml0Q2FudmFzKCkpO1xudmFyIF90ZXN0aW5nV2ViR2wyID0gVXRpbHNDb3JlLmluaXRXZWJHbDIoVXRpbHNDb3JlLmluaXRDYW52YXMoKSk7XG52YXIgX2lzV2ViR2xTdXBwb3J0ZWQgPSBVdGlsc0NvcmUuaXNXZWJHbChfdGVzdGluZ1dlYkdsKTtcbnZhciBfaXNXZWJHbDJTdXBwb3J0ZWQgPSBVdGlsc0NvcmUuaXNXZWJHbDIoX3Rlc3RpbmdXZWJHbDIpO1xudmFyIF9pc1dlYkdsRHJhd0J1ZmZlcnNTdXBwb3J0ZWQgPSBfaXNXZWJHbFN1cHBvcnRlZCAmJiBCb29sZWFuKF90ZXN0aW5nV2ViR2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSk7XG5cbmlmIChfaXNXZWJHbFN1cHBvcnRlZCkge1xuXHRVdGlsc0NvcmUuT0VTX3RleHR1cmVfZmxvYXQgPSBfdGVzdGluZ1dlYkdsLk9FU190ZXh0dXJlX2Zsb2F0O1xuXHRVdGlsc0NvcmUuT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyID0gX3Rlc3RpbmdXZWJHbC5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXI7XG5cdFV0aWxzQ29yZS5PRVNfZWxlbWVudF9pbmRleF91aW50ID0gX3Rlc3RpbmdXZWJHbC5PRVNfZWxlbWVudF9pbmRleF91aW50O1xufSBlbHNlIHtcblx0VXRpbHNDb3JlLk9FU190ZXh0dXJlX2Zsb2F0ID0gZmFsc2U7XG5cdFV0aWxzQ29yZS5PRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgPSBmYWxzZTtcblx0VXRpbHNDb3JlLk9FU19lbGVtZW50X2luZGV4X3VpbnQgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsc0NvcmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFxuICogQGNsYXNzZGVzYyBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIC8gc25pcHBldHMgb2YgY29kZSB0aGF0IEdQVS5KUyB1c2VzIGludGVybmFsbHkuXFxcbiAqIFRoaXMgY292ZXJzIHZhcmlvdXMgc25pcHBldHMgb2YgY29kZSB0aGF0IGlzIG5vdCBlbnRpcmVseSBncHUuanMgc3BlY2lmaWMgKGllLiBtYXkgZmluZCB1c2VzIGVsc2V3aGVyZSlcbiAqXG4gKiBOb3RlIHRoYXQgYWxsIG1ldGhvZHMgaW4gdGhpcyBjbGFzcyBhcmUgKnN0YXRpYyogYnkgbmF0dXJlIGBVdGlscy5mdW5jdGlvbk5hbWUoKWBcbiAqIFxuICogQGNsYXNzIFV0aWxzXG4gKiBAZXh0ZW5kcyBVdGlsc0NvcmVcbiAqXG4gKi9cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVdGlsc0NvcmUgPSByZXF1aXJlKFwiLi91dGlscy1jb3JlXCIpO1xudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpO1xudmFyIFRleHR1cmUgPSByZXF1aXJlKCcuL3RleHR1cmUnKTtcbi8vIEZVTkNUSU9OX05BTUUgcmVnZXhcbnZhciBGVU5DVElPTl9OQU1FID0gL2Z1bmN0aW9uIChbXihdKikvO1xuXG4vLyBTVFJJUCBDT01NRU5UUyByZWdleFxudmFyIFNUUklQX0NPTU1FTlRTID0gLygoXFwvXFwvLiokKXwoXFwvXFwqW1xcc1xcU10qP1xcKlxcLykpL21nO1xuXG4vLyBBUkdVTUVOVCBOQU1FUyByZWdleFxudmFyIEFSR1VNRU5UX05BTUVTID0gLyhbXlxccyxdKykvZztcblxudmFyIF9zeXN0ZW1FbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcblx0dmFyIGEgPSBuZXcgVWludDMyQXJyYXkoYik7XG5cdHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoYik7XG5cdGFbMF0gPSAweGRlYWRiZWVmO1xuXHRpZiAoY1swXSA9PT0gMHhlZikgcmV0dXJuICdMRSc7XG5cdGlmIChjWzBdID09PSAweGRlKSByZXR1cm4gJ0JFJztcblx0dGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGVuZGlhbm5lc3MnKTtcbn0oKTtcblxudmFyIF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZCA9IG51bGw7XG52YXIgX2lzRmxvYXRSZWFkUGl4ZWxzU3VwcG9ydGVkV2ViR0wyID0gbnVsbDtcblxudmFyIF9pc01peGVkSWRlbnRpZmllcnNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0bmV3IEZ1bmN0aW9uKCdsZXQgaSA9IDE7IGNvbnN0IGogPSAxOycpKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0oKTtcblxudmFyIF9oYXNJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeUJ1ZyA9IG51bGw7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBVdGlsc0NvcmVcbiAqL1xuXG52YXIgVXRpbHMgPSBmdW5jdGlvbiAoX1V0aWxzQ29yZSkge1xuXHRfaW5oZXJpdHMoVXRpbHMsIF9VdGlsc0NvcmUpO1xuXG5cdGZ1bmN0aW9uIFV0aWxzKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVdGlscyk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFV0aWxzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVXRpbHMpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhVdGlscywgbnVsbCwgW3tcblx0XHRrZXk6ICdzeXN0ZW1FbmRpYW5uZXNzJyxcblxuXG5cdFx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vXG5cdFx0Ly8gIFN5c3RlbSB2YWx1ZXMgc3VwcG9ydCAoY3VycmVudGx5IG9ubHkgZW5kaWFubmVzcylcblx0XHQvL1xuXHRcdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgVXRpbHNcbiAgICogQG5hbWUgc3lzdGVtRW5kaWFubmVzc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBHZXRzIHRoZSBzeXN0ZW0gZW5kaWFubmVzcywgYW5kIGNhY2hlIGl0XG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9ICdMRScgb3IgJ0JFJyBkZXBlbmRpbmcgb24gc3lzdGVtIGFyY2hpdGVjdHVyZVxuICAgKlxuICAgKiBDcmVkaXQ6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1Rvb1RhbGxOYXRlLzQ3NTA5NTNcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHN5c3RlbUVuZGlhbm5lc3MoKSB7XG5cdFx0XHRyZXR1cm4gX3N5c3RlbUVuZGlhbm5lc3M7XG5cdFx0fVxuXG5cdFx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vXG5cdFx0Ly8gIEZ1bmN0aW9uIGFuZCBmdW5jdGlvbiBzdHJpbmcgdmFsaWRhdGlvbnNcblx0XHQvL1xuXHRcdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgVXRpbHNcbiAgICogQG5hbWUgaXNGdW5jdGlvblxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBSZXR1cm4gVFJVRSwgb24gYSBKUyBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jT2JqIC0gT2JqZWN0IHRvIHZhbGlkYXRlIGlmIGl0cyBhIGZ1bmN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zXHR7Qm9vbGVhbn0gVFJVRSBpZiB0aGUgb2JqZWN0IGlzIGEgSlMgZnVuY3Rpb25cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRnVuY3Rpb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmNPYmopIHtcblx0XHRcdHJldHVybiB0eXBlb2YgZnVuY09iaiA9PT0gJ2Z1bmN0aW9uJztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25TdHJpbmdcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogUmV0dXJuIFRSVUUsIG9uIGEgdmFsaWQgSlMgZnVuY3Rpb24gc3RyaW5nXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZG9lcyBqdXN0IGEgVkVSWSBzaW1wbHkgc2FuaXR5IGNoZWNrLiBBbmQgbWF5IGdpdmUgZmFsc2UgcG9zaXRpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnVuY1N0ciAtIFN0cmluZyBvZiBKUyBmdW5jdGlvbiB0byB2YWxpZGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVFJVRSBpZiB0aGUgc3RyaW5nIHBhc3NlcyBiYXNpYyB2YWxpZGF0aW9uXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0Z1bmN0aW9uU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNGdW5jdGlvblN0cmluZyhmdW5jU3RyKSB7XG5cdFx0XHRpZiAoZnVuY1N0ciAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY1N0ci50b1N0cmluZygpLnNsaWNlKDAsICdmdW5jdGlvbicubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSAnZnVuY3Rpb24nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgVXRpbHNcbiAgICogQG5hbWUgZ2V0RnVuY3Rpb25OYW1lX2Zyb21TdHJpbmdcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogUmV0dXJuIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYSBKUyBmdW5jdGlvbiBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bmNTdHIgLSBTdHJpbmcgb2YgSlMgZnVuY3Rpb24gdG8gdmFsaWRhdGVcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gRnVuY3Rpb24gbmFtZSBzdHJpbmcgKGlmIGZvdW5kKVxuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0RnVuY3Rpb25OYW1lRnJvbVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZUZyb21TdHJpbmcoZnVuY1N0cikge1xuXHRcdFx0cmV0dXJuIEZVTkNUSU9OX05BTUUuZXhlYyhmdW5jU3RyKVsxXTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdnZXRGdW5jdGlvbkJvZHlGcm9tU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0RnVuY3Rpb25Cb2R5RnJvbVN0cmluZyhmdW5jU3RyKSB7XG5cdFx0XHRyZXR1cm4gZnVuY1N0ci5zdWJzdHJpbmcoZnVuY1N0ci5pbmRleE9mKCd7JykgKyAxLCBmdW5jU3RyLmxhc3RJbmRleE9mKCd9JykpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgVXRpbHNcbiAgICogQG5hbWUgZ2V0UGFyYW1OYW1lc19mcm9tU3RyaW5nXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIFJldHVybiBsaXN0IG9mIHBhcmFtZXRlciBuYW1lcyBleHRyYWN0ZWQgZnJvbSB0aGUgSlMgZnVuY3Rpb24gc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmdW5jU3RyIC0gU3RyaW5nIG9mIEpTIGZ1bmN0aW9uIHRvIHZhbGlkYXRlXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gIEFycmF5IHJlcHJlc2VudGluZyBhbGwgdGhlIHBhcmFtZXRlciBuYW1lc1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UGFyYW1OYW1lc0Zyb21TdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJhbU5hbWVzRnJvbVN0cmluZyhmdW5jKSB7XG5cdFx0XHR2YXIgZm5TdHIgPSBmdW5jLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpO1xuXHRcdFx0dmFyIHJlc3VsdCA9IGZuU3RyLnNsaWNlKGZuU3RyLmluZGV4T2YoJygnKSArIDEsIGZuU3RyLmluZGV4T2YoJyknKSkubWF0Y2goQVJHVU1FTlRfTkFNRVMpO1xuXHRcdFx0aWYgKHJlc3VsdCA9PT0gbnVsbCkgcmVzdWx0ID0gW107XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvL1xuXHRcdC8vICBPYmplY3QgLyBmdW5jdGlvbiBjbG9uaW5nIGFuZCBtYW5pcHVsYXRpb25cblx0XHQvL1xuXHRcdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgVXRpbHNcbiAgICogQG5hbWUgY2xvbmVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogUmV0dXJucyBhIGNsb25lXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3QgdG8gY2xvbmVcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gIENsb25lZCBvYmplY3RcbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Nsb25lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvbmUob2JqKSB7XG5cdFx0XHRpZiAob2JqID09PSBudWxsIHx8ICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSAhPT0gJ29iamVjdCcgfHwgb2JqLmhhc093blByb3BlcnR5KCdpc0FjdGl2ZUNsb25lJykpIHJldHVybiBvYmo7XG5cblx0XHRcdHZhciB0ZW1wID0gb2JqLmNvbnN0cnVjdG9yKCk7IC8vIGNoYW5nZWRcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuXHRcdFx0XHRcdG9iai5pc0FjdGl2ZUNsb25lID0gbnVsbDtcblx0XHRcdFx0XHR0ZW1wW2tleV0gPSBVdGlscy5jbG9uZShvYmpba2V5XSk7XG5cdFx0XHRcdFx0ZGVsZXRlIG9iai5pc0FjdGl2ZUNsb25lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0ZW1wO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAbWVtYmVyT2YgVXRpbHNcbiAgICogQG5hbWUgbmV3UHJvbWlzZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBSZXR1cm5zIGEgYG5ldyBQcm9taXNlYCBvYmplY3QgYmFzZWQgb24gdGhlIHVuZGVybHlpbmcgaW1wbG1lbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciAtIFByb21pc2UgYnVpbGRlciBmdW5jdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gIFByb21pc2Ugb2JqZWN0XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICduZXdQcm9taXNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbmV3UHJvbWlzZShleGVjdXRvcikge1xuXHRcdFx0dmFyIHNpbXBsZSA9IFByb21pc2UgfHwgc21hbGxfcHJvbWlzZTtcblx0XHRcdGlmIChzaW1wbGUgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKCdCcm93c2VyIGlzIG1pc3NpbmcgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbi4gQ29uc2lkZXIgYWRkaW5nIHNtYWxsX3Byb21pc2UuanMgcG9seWZpbGwnKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXcgc2ltcGxlKGV4ZWN1dG9yKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGZ1bmN0aW9uQmluZGVyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIExpbWl0ZWQgaW1wbGVtZW50YXRpb24gb2YgRnVuY3Rpb24uYmluZCwgd2l0aCBmYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbkZ1bmMgLSB0byBzZXR1cCBiaW5kIG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzT2JqIC0gVGhlIHRoaXMgcGFyYW1ldGVyIHRvIGFzc3VtZSBpbnNpZGUgdGhlIGJpbmRlZCBmdW5jdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259ICBUaGUgYmluZGVkIGZ1bmN0aW9uXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmdW5jdGlvbkJpbmRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZ1bmN0aW9uQmluZGVyKGluRnVuYywgdGhpc09iaikge1xuXHRcdFx0aWYgKGluRnVuYy5iaW5kKSB7XG5cdFx0XHRcdHJldHVybiBpbkZ1bmMuYmluZCh0aGlzT2JqKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2FyZ3VtZW50c1swXV0gOiBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRyZXR1cm4gaW5GdW5jLmFwcGx5KHRoaXNPYmosIGFyZ3MpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGlzQXJyYXlcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogKiBDaGVja3MgaWYgaXMgYW4gYXJyYXkgb3IgQXJyYXktbGlrZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIFRoZSBhcmd1bWVudCBvYmplY3QgdG8gY2hlY2sgaWYgaXMgYXJyYXlcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59ICB0cnVlIGlmIGlzIGFycmF5IG9yIEFycmF5LWxpa2Ugb2JqZWN0XG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0FycmF5Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNBcnJheShhcnJheSkge1xuXHRcdFx0aWYgKGlzTmFOKGFycmF5Lmxlbmd0aCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGdldEFyZ3VtZW50VHlwZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBFdmFsdWF0ZSB0aGUgYXJndW1lbnQgdHlwZSwgdG8gYXBwbHkgcmVzcGVjdGl2ZSBsb2dpYyBmb3IgaXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZyAtIFRoZSBhcmd1bWVudCBvYmplY3QgdG8gZXZhbHVhdGUgdHlwZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAgQXJndW1lbnQgdHlwZSBBcnJheS9OdW1iZXIvRmxvYXQvVGV4dHVyZS9Vbmtub3duXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRBcmd1bWVudFR5cGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRBcmd1bWVudFR5cGUoYXJnKSB7XG5cdFx0XHRpZiAoVXRpbHMuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmdbMF0ubm9kZU5hbWUgPT09ICdJTUcnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICdIVE1MSW1hZ2VBcnJheSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICdBcnJheSc7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gJ0ludGVnZXInO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnRmxvYXQnO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG5cdFx0XHRcdHJldHVybiBhcmcudHlwZTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgSW5wdXQpIHtcblx0XHRcdFx0cmV0dXJuICdJbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZy5ub2RlTmFtZSA9PT0gJ0lNRycpIHtcblx0XHRcdFx0cmV0dXJuICdIVE1MSW1hZ2UnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICdVbmtub3duJztcblx0XHRcdH1cblx0XHR9XG5cdFx0LyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IGdwdUpTT2JqZWN0XG4gICAqL1xuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBVdGlsc1xuICAgKiBAbmFtZSBpc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBDaGVja3MgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgcmVhZFBpeGVscyB3aXRoIGZsb2F0IHR5cGVcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgYnJvd3NlciBzdXBwb3J0c1xuICAgKlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNGbG9hdFJlYWRQaXhlbHNTdXBwb3J0ZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZCgpIHtcblx0XHRcdGlmIChfaXNGbG9hdFJlYWRQaXhlbHNTdXBwb3J0ZWQgIT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIEdQVSA9IHJlcXVpcmUoJy4uL2luZGV4Jyk7XG5cdFx0XHR2YXIgZ3B1ID0gbmV3IEdQVSh7XG5cdFx0XHRcdG1vZGU6ICd3ZWJnbC12YWxpZGF0b3InXG5cdFx0XHR9KTtcblx0XHRcdHZhciB4ID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSwge1xuXHRcdFx0XHRvdXRwdXQ6IFsyXSxcblx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdHJ1ZSxcblx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRydWUsXG5cdFx0XHRcdGZsb2F0T3V0cHV0Rm9yY2U6IHRydWVcblx0XHRcdH0pKCk7XG5cblx0XHRcdF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZCA9IHhbMF0gPT09IDE7XG5cdFx0XHRncHUuZGVzdHJveSgpO1xuXHRcdFx0cmV0dXJuIF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGlzRmxvYXRSZWFkUGl4ZWxzU3VwcG9ydGVkV2ViR0wyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIENoZWNrcyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyByZWFkUGl4ZWxzIHdpdGggZmxvYXQgdHlwZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZFdlYkdMMicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRmxvYXRSZWFkUGl4ZWxzU3VwcG9ydGVkV2ViR0wyKCkge1xuXHRcdFx0aWYgKF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZFdlYkdMMiAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gX2lzRmxvYXRSZWFkUGl4ZWxzU3VwcG9ydGVkV2ViR0wyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgR1BVID0gcmVxdWlyZSgnLi4vaW5kZXgnKTtcblx0XHRcdHZhciBncHUgPSBuZXcgR1BVKHtcblx0XHRcdFx0bW9kZTogJ3dlYmdsMi12YWxpZGF0b3InXG5cdFx0XHR9KTtcblx0XHRcdHZhciB4ID0gZ3B1LmNyZWF0ZUtlcm5lbChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSwge1xuXHRcdFx0XHRvdXRwdXQ6IFsyXSxcblx0XHRcdFx0ZmxvYXRUZXh0dXJlczogdHJ1ZSxcblx0XHRcdFx0ZmxvYXRPdXRwdXQ6IHRydWUsXG5cdFx0XHRcdGZsb2F0T3V0cHV0Rm9yY2U6IHRydWVcblx0XHRcdH0pKCk7XG5cblx0XHRcdF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZFdlYkdMMiA9IHhbMF0gPT09IDE7XG5cdFx0XHRncHUuZGVzdHJveSgpO1xuXHRcdFx0cmV0dXJuIF9pc0Zsb2F0UmVhZFBpeGVsc1N1cHBvcnRlZFdlYkdMMjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGhhc0ludGVnZXJEaXZpc2lvbkFjY3VyYWN5QnVnXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIENoZWNrcyBpZiB0aGUgc3lzdGVtIGhhcyBpbmFjY3VyYWNpZXMgd2hlbiBkaXZpZGluZyBpbnRlZ2Vyc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBidWcgaXMgZXhoaWJpdGVkIG9uIHRoaXMgc3lzdGVtXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeUJ1ZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc0ludGVnZXJEaXZpc2lvbkFjY3VyYWN5QnVnKCkge1xuXHRcdFx0aWYgKF9oYXNJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeUJ1ZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gX2hhc0ludGVnZXJEaXZpc2lvbkFjY3VyYWN5QnVnO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgR1BVID0gcmVxdWlyZSgnLi4vaW5kZXgnKTtcblx0XHRcdHZhciBncHUgPSBuZXcgR1BVKHtcblx0XHRcdFx0bW9kZTogJ3dlYmdsLXZhbGlkYXRvcidcblx0XHRcdH0pO1xuXHRcdFx0dmFyIHggPSBncHUuY3JlYXRlS2VybmVsKGZ1bmN0aW9uICh2MSwgdjIpIHtcblx0XHRcdFx0cmV0dXJuIHYxW3RoaXMudGhyZWFkLnhdIC8gdjJbdGhpcy50aHJlYWQueF07XG5cdFx0XHR9LCB7XG5cdFx0XHRcdG91dHB1dDogWzFdXG5cdFx0XHR9KShbNiwgNjAzMDQwMV0sIFszLCAzOTkxXSk7XG5cblx0XHRcdC8vIGhhdmUgd2Ugbm90IGdvdCB3aG9sZSBudW1iZXJzIGZvciA2LzMgb3IgNjAzMDQwMS8zOTkxXG5cdFx0XHQvLyBhZGQgbW9yZSBoZXJlIGlmIG90aGVycyBzZWUgdGhpcyBwcm9ibGVtXG5cdFx0XHRfaGFzSW50ZWdlckRpdmlzaW9uQWNjdXJhY3lCdWcgPSB4WzBdICE9PSAyIHx8IHhbMV0gIT09IDE1MTE7XG5cdFx0XHRncHUuZGVzdHJveSgpO1xuXHRcdFx0cmV0dXJuIF9oYXNJbnRlZ2VyRGl2aXNpb25BY2N1cmFjeUJ1Zztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdpc01peGVkSWRlbnRpZmllcnNTdXBwb3J0ZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc01peGVkSWRlbnRpZmllcnNTdXBwb3J0ZWQoKSB7XG5cdFx0XHRyZXR1cm4gX2lzTWl4ZWRJZGVudGlmaWVyc1N1cHBvcnRlZDtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdkaW1Ub1RleFNpemUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaW1Ub1RleFNpemUob3B0LCBkaW1lbnNpb25zLCBvdXRwdXQpIHtcblx0XHRcdHZhciBudW1UZXhlbHMgPSBkaW1lbnNpb25zWzBdO1xuXHRcdFx0dmFyIHcgPSBkaW1lbnNpb25zWzBdO1xuXHRcdFx0dmFyIGggPSBkaW1lbnNpb25zWzFdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBkaW1lbnNpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG51bVRleGVscyAqPSBkaW1lbnNpb25zW2ldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0LmZsb2F0VGV4dHVyZXMgJiYgKCFvdXRwdXQgfHwgb3B0LmZsb2F0T3V0cHV0KSkge1xuXHRcdFx0XHR3ID0gbnVtVGV4ZWxzID0gTWF0aC5jZWlsKG51bVRleGVscyAvIDQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgZ2l2ZW4gZGltZW5zaW9ucyA9PSBhIDJkIGltYWdlXG5cdFx0XHRpZiAoaCA+IDEgJiYgdyAqIGggPT09IG51bVRleGVscykge1xuXHRcdFx0XHRyZXR1cm4gW3csIGhdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCBhcyBjbG9zZSB0byBzcXVhcmUgd2lkdGgsIGhlaWdodCBzaXplcyBhcyBwb3NzaWJsZVxuXHRcdFx0dmFyIHNxcnQgPSBNYXRoLnNxcnQobnVtVGV4ZWxzKTtcblx0XHRcdHZhciBoaWdoID0gTWF0aC5jZWlsKHNxcnQpO1xuXHRcdFx0dmFyIGxvdyA9IE1hdGguZmxvb3Ioc3FydCk7XG5cdFx0XHR3aGlsZSAoaGlnaCAqIGxvdyA+IG51bVRleGVscykge1xuXHRcdFx0XHRoaWdoLS07XG5cdFx0XHRcdGxvdyA9IE1hdGguY2VpbChudW1UZXhlbHMgLyBoaWdoKTtcblx0XHRcdH1cblx0XHRcdHcgPSBsb3c7XG5cdFx0XHRoID0gTWF0aC5jZWlsKG51bVRleGVscyAvIHcpO1xuXHRcdFx0cmV0dXJuIFt3LCBoXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGdldERpbWVuc2lvbnNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gb2YgYW4gYXJyYXkuXG4gICAqIFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30geCAtIFRoZSBhcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZF0gLSBUbyBpbmNsdWRlIHBhZGRpbmcgaW4gdGhlIGRpbWVuc2lvbiBjYWxjdWxhdGlvbiBbT3B0aW9uYWxdXG4gICAqXG4gICAqXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXREaW1lbnNpb25zJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyh4LCBwYWQpIHtcblx0XHRcdHZhciByZXQgPSB2b2lkIDA7XG5cdFx0XHRpZiAoVXRpbHMuaXNBcnJheSh4KSkge1xuXHRcdFx0XHR2YXIgZGltID0gW107XG5cdFx0XHRcdHZhciB0ZW1wID0geDtcblx0XHRcdFx0d2hpbGUgKFV0aWxzLmlzQXJyYXkodGVtcCkpIHtcblx0XHRcdFx0XHRkaW0ucHVzaCh0ZW1wLmxlbmd0aCk7XG5cdFx0XHRcdFx0dGVtcCA9IHRlbXBbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0ID0gZGltLnJldmVyc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcblx0XHRcdFx0cmV0ID0geC5vdXRwdXQ7XG5cdFx0XHR9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBJbnB1dCkge1xuXHRcdFx0XHRyZXQgPSB4LnNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyAnVW5rbm93biBkaW1lbnNpb25zIG9mICcgKyB4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocGFkKSB7XG5cdFx0XHRcdHJldCA9IFV0aWxzLmNsb25lKHJldCk7XG5cdFx0XHRcdHdoaWxlIChyZXQubGVuZ3RoIDwgMykge1xuXHRcdFx0XHRcdHJldC5wdXNoKDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyByZXR1cm4gcmV0O1xuXHRcdFx0cmV0dXJuIG5ldyBJbnQzMkFycmF5KHJldCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBVdGlsc1xuICAgKiBAbmFtZSBwYWRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogUGFkIGFuIGFycmF5IEFORCBpdHMgZWxlbWVudHMgd2l0aCBsZWFkaW5nIGFuZCBlbmRpbmcgemVyb3NcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gdGhlIGFycmF5IHRvIHBhZCB6ZXJvcyB0b1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIGFtb3VudCBvZiBwYWRkaW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgd2l0aCBsZWFkaW5nIGFuZCBlbmRpbmcgemVyb3MsIGFuZCBhbGwgdGhlIGVsZW1lbnRzIHBhZGRlZCBieSB6ZXJvcy5cbiAgICpcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3BhZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHBhZChhcnIsIHBhZGRpbmcpIHtcblx0XHRcdGZ1bmN0aW9uIHplcm9zKG4pIHtcblx0XHRcdFx0cmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIG5ldyBBcnJheShuKSkubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsZW4gPSBhcnIubGVuZ3RoICsgcGFkZGluZyAqIDI7XG5cblx0XHRcdHZhciByZXQgPSBhcnIubWFwKGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdHJldHVybiBbXS5jb25jYXQoemVyb3MocGFkZGluZyksIHgsIHplcm9zKHBhZGRpbmcpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRpbmc7IGkrKykge1xuXHRcdFx0XHRyZXQgPSBbXS5jb25jYXQoW3plcm9zKGxlbildLCByZXQsIFt6ZXJvcyhsZW4pXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBVdGlsc1xuICAgKiBAbmFtZSBmbGF0dGVuMmRBcnJheVRvXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIFB1dHMgYSBuZXN0ZWQgMmQgYXJyYXkgaW50byBhIG9uZS1kaW1lbnNpb25hbCB0YXJnZXQgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheXwqfSBhcnJheVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXl9IHRhcmdldFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhdHRlbjJkQXJyYXlUbycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW4yZEFycmF5VG8oYXJyYXksIHRhcmdldCkge1xuXHRcdFx0dmFyIG9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKHZhciB5ID0gMDsgeSA8IGFycmF5Lmxlbmd0aDsgeSsrKSB7XG5cdFx0XHRcdHRhcmdldC5zZXQoYXJyYXlbeV0sIG9mZnNldCk7XG5cdFx0XHRcdG9mZnNldCArPSBhcnJheVt5XS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBtZW1iZXJPZiBVdGlsc1xuICAgKiBAbmFtZSBmbGF0dGVuM2RBcnJheVRvXG4gICAqIEBmdW5jdGlvblxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIFB1dHMgYSBuZXN0ZWQgM2QgYXJyYXkgaW50byBhIG9uZS1kaW1lbnNpb25hbCB0YXJnZXQgYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheXwqfSBhcnJheVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXl9IHRhcmdldFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhdHRlbjNkQXJyYXlUbycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW4zZEFycmF5VG8oYXJyYXksIHRhcmdldCkge1xuXHRcdFx0dmFyIG9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKHZhciB6ID0gMDsgeiA8IGFycmF5Lmxlbmd0aDsgeisrKSB7XG5cdFx0XHRcdGZvciAodmFyIHkgPSAwOyB5IDwgYXJyYXlbel0ubGVuZ3RoOyB5KyspIHtcblx0XHRcdFx0XHR0YXJnZXQuc2V0KGFycmF5W3pdW3ldLCBvZmZzZXQpO1xuXHRcdFx0XHRcdG9mZnNldCArPSBhcnJheVt6XVt5XS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIGZsYXR0ZW4zZEFycmF5VG9cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogUHV0cyBhIG5lc3RlZCAxZCwgMmQsIG9yIDNkIGFycmF5IGludG8gYSBvbmUtZGltZW5zaW9uYWwgdGFyZ2V0IGFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl8Kn0gYXJyYXlcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fSB0YXJnZXRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZsYXR0ZW5UbycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW5UbyhhcnJheSwgdGFyZ2V0KSB7XG5cdFx0XHRpZiAoVXRpbHMuaXNBcnJheShhcnJheVswXSkpIHtcblx0XHRcdFx0aWYgKFV0aWxzLmlzQXJyYXkoYXJyYXlbMF1bMF0pKSB7XG5cdFx0XHRcdFx0VXRpbHMuZmxhdHRlbjNkQXJyYXlUbyhhcnJheSwgdGFyZ2V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRVdGlscy5mbGF0dGVuMmRBcnJheVRvKGFycmF5LCB0YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXQuc2V0KGFycmF5KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQG1lbWJlck9mIFV0aWxzXG4gICAqIEBuYW1lIHNwbGl0QXJyYXlcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogU3BsaXRzIGFuIGFycmF5IGludG8gc21hbGxlciBhcnJheXMuXG4gICAqIE51bWJlciBvZiBlbGVtZW50cyBpbiBvbmUgc21hbGwgY2h1bmsgaXMgZ2l2ZW4gYnkgYHBhcnRgXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHNwbGl0IGludG8gY2h1bmtzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcnQgLSBlbGVtZW50cyBpbiBvbmUgY2h1bmtcbiAgICpcbiAgXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIHNtYWxsZXIgY2h1bmtzXG4gICAqXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzcGxpdEFycmF5Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgcGFydCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gcGFydCkge1xuXHRcdFx0XHRyZXN1bHQucHVzaChuZXcgYXJyYXkuY29uc3RydWN0b3IoYXJyYXkuYnVmZmVyLCBpICogNCArIGFycmF5LmJ5dGVPZmZzZXQsIHBhcnQpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0QXN0U3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0QXN0U3RyaW5nKHNvdXJjZSwgYXN0KSB7XG5cdFx0XHR2YXIgbGluZXMgPSBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vZyk7XG5cdFx0XHR2YXIgc3RhcnQgPSBhc3QubG9jLnN0YXJ0O1xuXHRcdFx0dmFyIGVuZCA9IGFzdC5sb2MuZW5kO1xuXHRcdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdFx0cmVzdWx0LnB1c2gobGluZXNbc3RhcnQubGluZSAtIDFdLnNsaWNlKHN0YXJ0LmNvbHVtbikpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0LmxpbmU7IGkgPCBlbmQubGluZSAtIDE7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQucHVzaChsaW5lc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaChsaW5lc1tlbmQubGluZSAtIDFdLnNsaWNlKDAsIGVuZC5jb2x1bW4pKTtcblx0XHRcdHJldHVybiByZXN1bHQuam9pbignXFxuJyk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnYWxsUHJvcGVydGllc09mJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWxsUHJvcGVydGllc09mKG9iaikge1xuXHRcdFx0dmFyIHByb3BzID0gW107XG5cblx0XHRcdGRvIHtcblx0XHRcdFx0cHJvcHMucHVzaC5hcHBseShwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKSk7XG5cdFx0XHR9IHdoaWxlIChvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cblx0XHRcdHJldHVybiBwcm9wcztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gVXRpbHM7XG59KFV0aWxzQ29yZSk7XG5cbi8vIFRoaXMgZW5zdXJlIHN0YXRpYyBtZXRob2RzIGFyZSBcImluaGVyaXRlZFwiXG4vLyBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0NDE1MDgvaG93LXRvLWluaGVyaXQtc3RhdGljLW1ldGhvZHMtZnJvbS1iYXNlLWNsYXNzLWluLWphdmFzY3JpcHRcblxuXG5PYmplY3QuYXNzaWduKFV0aWxzLCBVdGlsc0NvcmUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdQVSA9IHJlcXVpcmUoJy4vY29yZS9ncHUnKTtcbnZhciBhbGlhcyA9IHJlcXVpcmUoJy4vY29yZS9hbGlhcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb3JlL3V0aWxzJyk7XG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2NvcmUvaW5wdXQnKTtcbnZhciBUZXh0dXJlID0gcmVxdWlyZSgnLi9jb3JlL3RleHR1cmUnKTtcblxudmFyIENQVUZ1bmN0aW9uQnVpbGRlciA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUvZnVuY3Rpb24tYnVpbGRlcicpO1xudmFyIENQVUZ1bmN0aW9uTm9kZSA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUvZnVuY3Rpb24tbm9kZScpO1xudmFyIENQVUtlcm5lbCA9IHJlcXVpcmUoJy4vYmFja2VuZC9jcHUva2VybmVsJyk7XG52YXIgQ1BVUnVubmVyID0gcmVxdWlyZSgnLi9iYWNrZW5kL2NwdS9ydW5uZXInKTtcblxudmFyIFdlYkdMRnVuY3Rpb25CdWlsZGVyID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbC9mdW5jdGlvbi1idWlsZGVyJyk7XG52YXIgV2ViR0xGdW5jdGlvbk5vZGUgPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL2Z1bmN0aW9uLW5vZGUnKTtcbnZhciBXZWJHTEtlcm5lbCA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wva2VybmVsJyk7XG52YXIgV2ViR0xSdW5uZXIgPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsL3J1bm5lcicpO1xuXG52YXIgV2ViR0wyRnVuY3Rpb25CdWlsZGVyID0gcmVxdWlyZSgnLi9iYWNrZW5kL3dlYi1nbDIvZnVuY3Rpb24tYnVpbGRlcicpO1xudmFyIFdlYkdMMkZ1bmN0aW9uTm9kZSA9IHJlcXVpcmUoJy4vYmFja2VuZC93ZWItZ2wyL2Z1bmN0aW9uLW5vZGUnKTtcbnZhciBXZWJHTDJLZXJuZWwgPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9rZXJuZWwnKTtcbnZhciBXZWJHTDJSdW5uZXIgPSByZXF1aXJlKCcuL2JhY2tlbmQvd2ViLWdsMi9ydW5uZXInKTtcblxuR1BVLmFsaWFzID0gYWxpYXM7XG5HUFUudXRpbHMgPSB1dGlscztcbkdQVS5UZXh0dXJlID0gVGV4dHVyZTtcbkdQVS5JbnB1dCA9IElucHV0O1xuR1BVLmlucHV0ID0gZnVuY3Rpb24gKHZhbHVlLCBzaXplKSB7XG5cdHJldHVybiBuZXcgSW5wdXQodmFsdWUsIHNpemUpO1xufTtcblxuR1BVLkNQVUZ1bmN0aW9uQnVpbGRlciA9IENQVUZ1bmN0aW9uQnVpbGRlcjtcbkdQVS5DUFVGdW5jdGlvbk5vZGUgPSBDUFVGdW5jdGlvbk5vZGU7XG5HUFUuQ1BVS2VybmVsID0gQ1BVS2VybmVsO1xuR1BVLkNQVVJ1bm5lciA9IENQVVJ1bm5lcjtcblxuR1BVLldlYkdMRnVuY3Rpb25CdWlsZGVyID0gV2ViR0xGdW5jdGlvbkJ1aWxkZXI7XG5HUFUuV2ViR0xGdW5jdGlvbk5vZGUgPSBXZWJHTEZ1bmN0aW9uTm9kZTtcbkdQVS5XZWJHTEtlcm5lbCA9IFdlYkdMS2VybmVsO1xuR1BVLldlYkdMUnVubmVyID0gV2ViR0xSdW5uZXI7XG5cbkdQVS5XZWJHTDJGdW5jdGlvbkJ1aWxkZXIgPSBXZWJHTDJGdW5jdGlvbkJ1aWxkZXI7XG5HUFUuV2ViR0wyRnVuY3Rpb25Ob2RlID0gV2ViR0wyRnVuY3Rpb25Ob2RlO1xuR1BVLldlYkdMMktlcm5lbCA9IFdlYkdMMktlcm5lbDtcbkdQVS5XZWJHTDJSdW5uZXIgPSBXZWJHTDJSdW5uZXI7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IEdQVTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuR1BVID0gR1BVO1xufVxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHRzZWxmLkdQVSA9IEdQVTtcbn0iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuYWNvcm4gPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gUmVzZXJ2ZWQgd29yZCBsaXN0cyBmb3IgdmFyaW91cyBkaWFsZWN0cyBvZiB0aGUgbGFuZ3VhZ2VcblxudmFyIHJlc2VydmVkV29yZHMgPSB7XG4gIDM6IFwiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZVwiLFxuICA1OiBcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIsXG4gIDY6IFwiZW51bVwiLFxuICBzdHJpY3Q6IFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiLFxuICBzdHJpY3RCaW5kOiBcImV2YWwgYXJndW1lbnRzXCJcbn07XG5cbi8vIEFuZCB0aGUga2V5d29yZHNcblxudmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIjtcblxudmFyIGtleXdvcmRzID0ge1xuICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG4vLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBcIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzN2ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyZlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNWQwLVxcdTA1ZWFcXHUwNWVmLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZhXFx1MDhhMC1cXHUwOGI0XFx1MDhiNi1cXHUwOGJkXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwOWZjXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmVmXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YjlcXHVhN2Y3LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY1XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTIwMGNcXHUyMDBkXFx4YjdcXHUwMzAwLVxcdTAzNmZcXHUwMzg3XFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA3ZmRcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGQzLVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTA5ZmVcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBhZmEtXFx1MGFmZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmMi1cXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjgsNDMsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDE0LDM1LDQ3NywyOCwxMSwwLDksMjEsMTkwLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMTIsMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsNTQsNDcsMjEsMSwyLDAsMTg1LDQ2LDQyLDMsMzcsNDcsMjEsMCw2MCw0Miw4NiwyNiwyMzAsNDMsMTE3LDYzLDMyLDAsMjU3LDAsMTEsMzksOCwwLDIyLDAsMTIsMzksMywzLDIwLDAsMzUsNTYsMjY0LDgsMiwzNiwxOCwwLDUwLDI5LDExMyw2LDIsMSwyLDM3LDIyLDAsMjYsNSwyLDEsMiwzMSwxNSwwLDMyOCwxOCwyNzAsOTIxLDEwMywxMTAsMTgsMTk1LDI3NDksMTA3MCw0MDUwLDU4Miw4NjM0LDU2OCw4LDMwLDExNCwyOSwxOSw0NywxNywzLDMyLDIwLDYsMTgsNjg5LDYzLDEyOSw2OCwxMiwwLDY3LDEyLDY1LDEsMzEsNjEyOSwxNSw3NTQsOTQ4NiwyODYsODIsMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDQxNDksMTk2LDYwLDY3LDEyMTMsMywyLDI2LDIsMSwyLDAsMywwLDIsOSwyLDMsMiwwLDIsMCw3LDAsNSwwLDIsMCwyLDAsMiwyLDIsMSwyLDAsMywwLDIsMCwyLDAsMiwwLDIsMCwyLDEsMiwwLDMsMywyLDYsMiwzLDIsMywyLDAsMiw5LDIsMTYsNiwyLDIsNCwyLDE2LDQ0MjEsNDI3MTAsNDIsNDE0OCwxMiwyMjEsMyw1NzYxLDE1LDc0NzIsMzEwNCw1NDFdO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tbWEtc3BhY2luZ1xudmFyIGFzdHJhbElkZW50aWZpZXJDb2RlcyA9IFs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksNTI1LDEwLDE3NiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsNCw5LDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksMjgwLDksNDEsNiwyLDMsOSwwLDEwLDEwLDQ3LDE1LDQwNiw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTIzLDUsNCwwLDIsMSwyLDYsMiwwLDksOSw0OSw0LDIsMSwyLDQsOSw5LDMzMCwzLDE5MzA2LDksMTM1LDQsNjAsNiwyNiw5LDEwMTYsNDUsMTcsMywxOTcyMywxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDIyMTQsNiwxMTAsNiw2LDksNzkyNDg3LDIzOV07XG5cbi8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbi8vIGFzc3VtcHRpb24gaXMgdGhhdCBsb29raW5nIHVwIGFzdHJhbCBpZGVudGlmaWVyIGNoYXJhY3RlcnMgaXNcbi8vIHJhcmUuXG5mdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX07XG52YXIgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbnZhciBrZXl3b3JkcyQxID0ge307XG5cbi8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbmZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyA9IHtcbiAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gIC8vXG4gIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gIC8vXG4gIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIEtleXdvcmQgdG9rZW4gdHlwZXMuXG4gIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gIF9pZjoga3coXCJpZlwiKSxcbiAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gIF90cnk6IGt3KFwidHJ5XCIpLFxuICBfdmFyOiBrdyhcInZhclwiKSxcbiAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIpLFxuICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG59O1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xudmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUsIGVjbWEyMDE5U3RyaW5nKSB7XG4gIHJldHVybiBjb2RlID09PSAxMCB8fCBjb2RlID09PSAxMyB8fCAoIWVjbWEyMDE5U3RyaW5nICYmIChjb2RlID09PSAweDIwMjggfHwgY29kZSA9PT0gMHgyMDI5KSlcbn1cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbnZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG52YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gPSBjb2w7XG59O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG59O1xuXG52YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICB9XG4gIH1cbn1cblxuLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4vLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdFxuICAvLyBiZSBlaXRoZXIgMywgNSwgNiAoMjAxNSksIDcgKDIwMTYpLCBvciA4ICgyMDE3KS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnRcbiAgLy8gZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3JcbiAgLy8gbmV3IHN5bnRheCBmZWF0dXJlcy4gVGhlIGRlZmF1bHQgaXMgNy5cbiAgZWNtYVZlcnNpb246IDcsXG4gIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGggcG9zaXRpb24gb2YgdGhlIGNvbW1hIGFzIGFuIG9mZnNldCwgYW5kIGlmIGBsb2NhdGlvbnNgIGlzXG4gIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBhd2FpdCBpZGVudGlmaWVycyBhcmUgYWxsb3dlZCB0byBhcHBlYXIgYXQgdGhlIHRvcC1sZXZlbCBzY29wZSxcbiAgLy8gYnV0IHRoZXkgYXJlIHN0aWxsIG5vdCBhbGxvd2VkIGluIG5vbi1hc3luYyBmdW5jdGlvbnMuXG4gIGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGVcbiAgLy8gaXMgYWxsb3dlZCBhbmQgdHJlYXRlZCBhcyBhIGxpbmUgY29tbWVudC5cbiAgYWxsb3dIYXNoQmFuZzogZmFsc2UsXG4gIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyBpbiBge2xpbmUsIGNvbHVtbn1gIGZvcm0gKHdpdGhcbiAgLy8gbGluZSBiZWluZyAxLWJhc2VkIGFuZCBjb2x1bW4gMC1iYXNlZCkgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGVcbiAgLy8gbm9kZXMuXG4gIGxvY2F0aW9uczogZmFsc2UsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Ub2tlbmAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAvLyBmb3JtYXQgYXMgdG9rZW5zIHJldHVybmVkIGZyb20gYHRva2VuaXplcigpLmdldFRva2VuKClgLiBOb3RlXG4gIC8vIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZSBwYXJzZXIgZnJvbSB0aGVcbiAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gIG9uVG9rZW46IG51bGwsXG4gIC8vIEEgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCBhcyBgb25Db21tZW50YCBvcHRpb24sIHdoaWNoIHdpbGxcbiAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gIC8vIGVuZClgIHBhcmFtZXRlcnMgd2hlbmV2ZXIgYSBjb21tZW50IGlzIHNraXBwZWQuIGBibG9ja2AgaXMgYVxuICAvLyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIGEgYmxvY2sgKGAvKiAqL2ApIGNvbW1lbnQsXG4gIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAvLyBjaGFyYWN0ZXIgb2Zmc2V0cyB0aGF0IGRlbm90ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgY29tbWVudC5cbiAgLy8gV2hlbiB0aGUgYGxvY2F0aW9uc2Agb3B0aW9uIGlzIG9uLCB0d28gbW9yZSBwYXJhbWV0ZXJzIGFyZVxuICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgLy8gZW5kIG9mIHRoZSBjb21tZW50cy4gTm90ZSB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGVcbiAgLy8gcGFyc2VyIGZyb20gdGhlIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvbkNvbW1lbnQ6IG51bGwsXG4gIC8vIE5vZGVzIGhhdmUgdGhlaXIgc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXJzIG9mZnNldHMgcmVjb3JkZWQgaW5cbiAgLy8gYHN0YXJ0YCBhbmQgYGVuZGAgcHJvcGVydGllcyAoZGlyZWN0bHkgb24gdGhlIG5vZGUsIHJhdGhlciB0aGFuXG4gIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgLy8gW3NlbWktc3RhbmRhcmRpemVkXVtyYW5nZV0gYHJhbmdlYCBwcm9wZXJ0eSBob2xkaW5nIGEgYFtzdGFydCxcbiAgLy8gZW5kXWAgYXJyYXkgd2l0aCB0aGUgc2FtZSBudW1iZXJzLCBzZXQgdGhlIGByYW5nZXNgIG9wdGlvbiB0b1xuICAvLyBgdHJ1ZWAuXG4gIC8vXG4gIC8vIFtyYW5nZV06IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc0NTY3OFxuICByYW5nZXM6IGZhbHNlLFxuICAvLyBJdCBpcyBwb3NzaWJsZSB0byBwYXJzZSBtdWx0aXBsZSBmaWxlcyBpbnRvIGEgc2luZ2xlIEFTVCBieVxuICAvLyBwYXNzaW5nIHRoZSB0cmVlIHByb2R1Y2VkIGJ5IHBhcnNpbmcgdGhlIGZpcnN0IGZpbGUgYXNcbiAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgLy8gdG9wbGV2ZWwgZm9ybXMgb2YgdGhlIHBhcnNlZCBmaWxlIHRvIHRoZSBgUHJvZ3JhbWAgKHRvcCkgbm9kZVxuICAvLyBvZiBhbiBleGlzdGluZyBwYXJzZSB0cmVlLlxuICBwcm9ncmFtOiBudWxsLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCB5b3UgY2FuIHBhc3MgdGhpcyB0byByZWNvcmQgdGhlIHNvdXJjZVxuICAvLyBmaWxlIGluIGV2ZXJ5IG5vZGUncyBgbG9jYCBvYmplY3QuXG4gIHNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFRoaXMgdmFsdWUsIGlmIGdpdmVuLCBpcyBzdG9yZWQgaW4gZXZlcnkgbm9kZSwgd2hldGhlclxuICAvLyBgbG9jYXRpb25zYCBpcyBvbiBvciBvZmYuXG4gIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gIC8vIFdoZW4gZW5hYmxlZCwgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBhcmUgcmVwcmVzZW50ZWQgYnlcbiAgLy8gKG5vbi1zdGFuZGFyZCkgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gbm9kZXNcbiAgcHJlc2VydmVQYXJlbnM6IGZhbHNlLFxuICBwbHVnaW5zOiB7fVxufTtcblxuLy8gSW50ZXJwcmV0IGFuZCBkZWZhdWx0IGFuIG9wdGlvbnMgb2JqZWN0XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSlcbiAgICB7IG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTsgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBSZWdpc3RlcmVkIHBsdWdpbnNcbnZhciBwbHVnaW5zID0ge307XG5cbmZ1bmN0aW9uIGtleXdvcmRSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbn1cblxudmFyIFBhcnNlciA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgdGhpcy5rZXl3b3JkcyA9IGtleXdvcmRSZWdleHAoa2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKCFvcHRpb25zLmFsbG93UmVzZXJ2ZWQpIHtcbiAgICBmb3IgKHZhciB2ID0gb3B0aW9ucy5lY21hVmVyc2lvbjs7IHYtLSlcbiAgICAgIHsgaWYgKHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1t2XSkgeyBicmVhayB9IH1cbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiKSB7IHJlc2VydmVkICs9IFwiIGF3YWl0XCI7IH1cbiAgfVxuICB0aGlzLnJlc2VydmVkV29yZHMgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkKTtcbiAgdmFyIHJlc2VydmVkU3RyaWN0ID0gKHJlc2VydmVkID8gcmVzZXJ2ZWQgKyBcIiBcIiA6IFwiXCIpICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3Q7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA9IGtleXdvcmRSZWdleHAocmVzZXJ2ZWRTdHJpY3QpO1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbiAgdGhpcy5pbnB1dCA9IFN0cmluZyhpbnB1dCk7XG5cbiAgLy8gVXNlZCB0byBzaWduYWwgdG8gY2FsbGVycyBvZiBgcmVhZFdvcmQxYCB3aGV0aGVyIHRoZSB3b3JkXG4gIC8vIGNvbnRhaW5lZCBhbnkgZXNjYXBlIHNlcXVlbmNlcy4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB3b3JkcyB3aXRoXG4gIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZTtcblxuICAvLyBMb2FkIHBsdWdpbnNcbiAgdGhpcy5sb2FkUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuXG4gIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSB0b2tlbml6ZXIgaW4gdGhlIGlucHV0LlxuICBpZiAoc3RhcnRQb3MpIHtcbiAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5pbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCBzdGFydFBvcyAtIDEpICsgMTtcbiAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmlucHV0LnNsaWNlKDAsIHRoaXMubGluZVN0YXJ0KS5zcGxpdChsaW5lQnJlYWspLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMubGluZVN0YXJ0ID0gMDtcbiAgICB0aGlzLmN1ckxpbmUgPSAxO1xuICB9XG5cbiAgLy8gUHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0b2tlbjpcbiAgLy8gSXRzIHR5cGVcbiAgdGhpcy50eXBlID0gdHlwZXMuZW9mO1xuICAvLyBGb3IgdG9rZW5zIHRoYXQgaW5jbHVkZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgdHlwZSwgdGhlIHZhbHVlXG4gIHRoaXMudmFsdWUgPSBudWxsO1xuICAvLyBJdHMgc3RhcnQgYW5kIGVuZCBvZmZzZXRcbiAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIC8vIEFuZCwgaWYgbG9jYXRpb25zIGFyZSB1c2VkLCB0aGUge2xpbmUsIGNvbHVtbn0gb2JqZWN0XG4gIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7XG5cbiAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3M7XG5cbiAgLy8gVGhlIGNvbnRleHQgc3RhY2sgaXMgdXNlZCB0byBzdXBlcmZpY2lhbGx5IHRyYWNrIHN5bnRhY3RpY1xuICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgLy8gZ2l2ZW4gcG9zaXRpb24uXG4gIHRoaXMuY29udGV4dCA9IHRoaXMuaW5pdGlhbENvbnRleHQoKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gIHRoaXMuaW5Nb2R1bGUgPSBvcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gIHRoaXMuc3RyaWN0ID0gdGhpcy5pbk1vZHVsZSB8fCB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLnBvcyk7XG5cbiAgLy8gVXNlZCB0byBzaWduaWZ5IHRoZSBzdGFydCBvZiBhIHBvdGVudGlhbCBhcnJvdyBmdW5jdGlvblxuICB0aGlzLnBvdGVudGlhbEFycm93QXQgPSAtMTtcblxuICAvLyBGbGFncyB0byB0cmFjayB3aGV0aGVyIHdlIGFyZSBpbiBhIGZ1bmN0aW9uLCBhIGdlbmVyYXRvciwgYW4gYXN5bmMgZnVuY3Rpb24uXG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRoaXMuaW5HZW5lcmF0b3IgPSB0aGlzLmluQXN5bmMgPSBmYWxzZTtcbiAgLy8gUG9zaXRpb25zIHRvIGRlbGF5ZWQtY2hlY2sgdGhhdCB5aWVsZC9hd2FpdCBkb2VzIG5vdCBleGlzdCBpbiBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gIHRoaXMueWllbGRQb3MgPSB0aGlzLmF3YWl0UG9zID0gMDtcbiAgLy8gTGFiZWxzIGluIHNjb3BlLlxuICB0aGlzLmxhYmVscyA9IFtdO1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlckZ1bmN0aW9uU2NvcGUoKTtcblxuICAvLyBGb3IgUmVnRXhwIHZhbGlkYXRpb25cbiAgdGhpcy5yZWdleHBTdGF0ZSA9IG51bGw7XG59O1xuXG4vLyBERVBSRUNBVEVEIEtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHVudGlsIDMuMCBpbiBjYXNlIGEgcGx1Z2luIHVzZXMgdGhlbVxuUGFyc2VyLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiBpc0tleXdvcmQgKHdvcmQpIHsgcmV0dXJuIHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSB9O1xuUGFyc2VyLnByb3RvdHlwZS5pc1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkICh3b3JkKSB7IHJldHVybiB0aGlzLnJlc2VydmVkV29yZHMudGVzdCh3b3JkKSB9O1xuXG5QYXJzZXIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAobmFtZSwgZikge1xuICB0aGlzW25hbWVdID0gZih0aGlzW25hbWVdKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUubG9hZFBsdWdpbnMgPSBmdW5jdGlvbiBsb2FkUGx1Z2lucyAocGx1Z2luQ29uZmlncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luQ29uZmlncykge1xuICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgIGlmICghcGx1Z2luKSB7IHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiAnXCIgKyBuYW1lICsgXCInIG5vdCBmb3VuZFwiKSB9XG4gICAgcGx1Z2luKHRoaXMkMSwgcGx1Z2luQ29uZmlnc1tuYW1lXSk7XG4gIH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxufTtcblxudmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG52YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcLnxbXiddKSo/KSd8XCIoKD86XFxcXC58W15cIl0pKj8pXCJ8OykvO1xucHAuc3RyaWN0RGlyZWN0aXZlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICg7Oykge1xuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcyQxLmlucHV0KVswXS5sZW5ndGg7XG4gICAgdmFyIG1hdGNoID0gbGl0ZXJhbC5leGVjKHRoaXMkMS5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiAhdGhpcy5jb250YWluc0VzY1xufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKG5hbWUpKSB7IHJldHVybiBmYWxzZSB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG5wcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG5wcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwLnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcC5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT09IHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSlcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rU3RhcnRMb2MpOyB9XG4gICAgaWYgKCFub3ROZXh0KVxuICAgICAgeyB0aGlzLm5leHQoKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbi8vIHJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwLmV4cGVjdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKCk7XG59O1xuXG4vLyBSYWlzZSBhbiB1bmV4cGVjdGVkIHRva2VuIGVycm9yLlxuXG5wcC51bmV4cGVjdGVkID0gZnVuY3Rpb24ocG9zKSB7XG4gIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIik7XG59O1xuXG5mdW5jdGlvbiBEZXN0cnVjdHVyaW5nRXJyb3JzKCkge1xuICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9XG4gIHRoaXMudHJhaWxpbmdDb21tYSA9XG4gIHRoaXMucGFyZW50aGVzaXplZEFzc2lnbiA9XG4gIHRoaXMucGFyZW50aGVzaXplZEJpbmQgPVxuICB0aGlzLmRvdWJsZVByb3RvID1cbiAgICAtMTtcbn1cblxucHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgaXNBc3NpZ24pIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiB9XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPiAtMSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gIHZhciBwYXJlbnMgPSBpc0Fzc2lnbiA/IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA6IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQ7XG4gIGlmIChwYXJlbnMgPiAtMSkgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocGFyZW5zLCBcIlBhcmVudGhlc2l6ZWQgcGF0dGVyblwiKTsgfVxufTtcblxucHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzaG9ydGhhbmRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbjtcbiAgdmFyIGRvdWJsZVByb3RvID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5kb3VibGVQcm90bztcbiAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gc2hvcnRoYW5kQXNzaWduID49IDAgfHwgZG91YmxlUHJvdG8gPj0gMCB9XG4gIGlmIChzaG9ydGhhbmRBc3NpZ24gPj0gMClcbiAgICB7IHRoaXMucmFpc2Uoc2hvcnRoYW5kQXNzaWduLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpOyB9XG4gIGlmIChkb3VibGVQcm90byA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGRvdWJsZVByb3RvLCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbn07XG5cbnBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbn07XG5cbnBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxufTtcblxudmFyIHBwJDEgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuLy8gUGFyc2UgYSBwcm9ncmFtLiBJbml0aWFsaXplcyB0aGUgcGFyc2VyLCByZWFkcyBhbnkgbnVtYmVyIG9mXG4vLyBzdGF0ZW1lbnRzLCBhbmQgd3JhcHMgdGhlbSBpbiBhIFByb2dyYW0gbm9kZS4gIE9wdGlvbmFsbHkgdGFrZXMgYVxuLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuLy8gdG8gaXRzIGJvZHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBub2RlLlxuXG5wcCQxLnBhcnNlVG9wTGV2ZWwgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBleHBvcnRzID0ge307XG4gIGlmICghbm9kZS5ib2R5KSB7IG5vZGUuYm9keSA9IFtdOyB9XG4gIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLmVvZikge1xuICAgIHZhciBzdG10ID0gdGhpcyQxLnBhcnNlU3RhdGVtZW50KHRydWUsIHRydWUsIGV4cG9ydHMpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgbm9kZS5zb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb2dyYW1cIilcbn07XG5cbnZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9O1xudmFyIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG5wcCQxLmlzTGV0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmlzQ29udGV4dHVhbChcImxldFwiKSkgeyByZXR1cm4gZmFsc2UgfVxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgaWYgKG5leHRDaCA9PT0gOTEgfHwgbmV4dENoID09PSAxMjMpIHsgcmV0dXJuIHRydWUgfSAvLyAneycgYW5kICdbJ1xuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoLCB0cnVlKSkge1xuICAgIHZhciBwb3MgPSBuZXh0ICsgMTtcbiAgICB3aGlsZSAoaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSkpIHsgKytwb3M7IH1cbiAgICB2YXIgaWRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKG5leHQsIHBvcyk7XG4gICAgaWYgKCFrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QoaWRlbnQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGNoZWNrICdhc3luYyBbbm8gTGluZVRlcm1pbmF0b3IgaGVyZV0gZnVuY3Rpb24nXG4vLyAtICdhc3luYyAvKmZvbyovIGZ1bmN0aW9uJyBpcyBPSy5cbi8vIC0gJ2FzeW5jIC8qXFxuKi8gZnVuY3Rpb24nIGlzIGludmFsaWQuXG5wcCQxLmlzQXN5bmNGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgOCB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlcbiAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoO1xuICByZXR1cm4gIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIG5leHQpKSAmJlxuICAgIHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgbmV4dCArIDgpID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAobmV4dCArIDggPT09IHRoaXMuaW5wdXQubGVuZ3RoIHx8ICFpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckF0KG5leHQgKyA4KSkpXG59O1xuXG4vLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4vL1xuLy8gSWYgZXhwZWN0aW5nIGEgc3RhdGVtZW50IGFuZCBmaW5kaW5nIGEgc2xhc2ggb3BlcmF0b3IsIHBhcnNlIGFcbi8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4vLyBgaWYgKGZvbykgL2JsYWgvLmV4ZWMoZm9vKWAsIHdoZXJlIGxvb2tpbmcgYXQgdGhlIHByZXZpb3VzIHRva2VuXG4vLyBkb2VzIG5vdCBoZWxwLlxuXG5wcCQxLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oZGVjbGFyYXRpb24sIHRvcExldmVsLCBleHBvcnRzKSB7XG4gIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gIGlmICh0aGlzLmlzTGV0KCkpIHtcbiAgICBzdGFydHR5cGUgPSB0eXBlcy5fdmFyO1xuICAgIGtpbmQgPSBcImxldFwiO1xuICB9XG5cbiAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgLy8gc3RhcnQgd2l0aC4gTWFueSBhcmUgdHJpdmlhbCB0byBwYXJzZSwgc29tZSByZXF1aXJlIGEgYml0IG9mXG4gIC8vIGNvbXBsZXhpdHkuXG5cbiAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgY2FzZSB0eXBlcy5fYnJlYWs6IGNhc2UgdHlwZXMuX2NvbnRpbnVlOiByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgc3RhcnR0eXBlLmtleXdvcmQpXG4gIGNhc2UgdHlwZXMuX2RlYnVnZ2VyOiByZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2RvOiByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2ZvcjogcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZnVuY3Rpb246XG4gICAgaWYgKCFkZWNsYXJhdGlvbiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UpXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIGlmICghZGVjbGFyYXRpb24pIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gIGNhc2UgdHlwZXMuX2lmOiByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl90aHJvdzogcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2NvbnN0OiBjYXNlIHR5cGVzLl92YXI6XG4gICAga2luZCA9IGtpbmQgfHwgdGhpcy52YWx1ZTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uICYmIGtpbmQgIT09IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICBjYXNlIHR5cGVzLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2soKVxuICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKCFkZWNsYXJhdGlvbikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUpXG4gICAgfVxuXG4gICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmIChzdGFydHR5cGUgPT09IHR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PT0gXCJicmVha1wiO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5sYWJlbCA9IG51bGw7IH1cbiAgZWxzZSBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gIGVsc2Uge1xuICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYW4gYWN0dWFsIGRlc3RpbmF0aW9uIHRvIGJyZWFrIG9yXG4gIC8vIGNvbnRpbnVlIHRvLlxuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdGhpcy5sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbGFiID0gdGhpcyQxLmxhYmVsc1tpXTtcbiAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuX3doaWxlKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyB0aGlzLmVhdCh0eXBlcy5zZW1pKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpXG59O1xuXG4vLyBEaXNhbWJpZ3VhdGluZyBiZXR3ZWVuIGEgYGZvcmAgYW5kIGEgYGZvcmAvYGluYCBvciBgZm9yYC9gb2ZgXG4vLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbi8vIHN0YXRlbWVudCBvciBleHByZXNzaW9uLCBkaXNhbGxvd2luZyB0aGUgYGluYCBvcGVyYXRvciAoc2VlXG4vLyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0byBgcGFyc2VFeHByZXNzaW9uYCksIGFuZCB0aGVuIGNoZWNrXG4vLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4vLyBwYXJ0IChzZW1pY29sb24gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMpLCBpdFxuLy8gaXMgYSByZWd1bGFyIGBmb3JgIGxvb3AuXG5cbnBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB2YXIgYXdhaXRBdCA9ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKFwiYXdhaXRcIikpID8gdGhpcy5sYXN0VG9rU3RhcnQgOiAtMTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICB0aGlzLmVudGVyTGV4aWNhbFNjb3BlKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkpIHtcbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpXG4gIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICEoa2luZCAhPT0gXCJ2YXJcIiAmJiBpbml0JDEuZGVjbGFyYXRpb25zWzBdLmluaXQpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luKSB7XG4gICAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0JDEpXG4gICAgfVxuICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICB9XG4gIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gIHZhciBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgICAgfSBlbHNlIHsgbm9kZS5hd2FpdCA9IGF3YWl0QXQgPiAtMTsgfVxuICAgIH1cbiAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0LCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICB9XG4gIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUsIGZhbHNlLCBpc0FzeW5jKVxufTtcblxucHAkMS5wYXJzZUlmU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICAvLyBhbGxvdyBmdW5jdGlvbiBkZWNsYXJhdGlvbnMgaW4gYnJhbmNoZXMsIGJ1dCBvbmx5IGluIG5vbi1zdHJpY3QgbW9kZVxuICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KCF0aGlzLnN0cmljdCAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbik7XG4gIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5lYXQodHlwZXMuX2Vsc2UpID8gdGhpcy5wYXJzZVN0YXRlbWVudCghdGhpcy5zdHJpY3QgJiYgdGhpcy50eXBlID09PSB0eXBlcy5fZnVuY3Rpb24pIDogbnVsbDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAoIXRoaXMuaW5GdW5jdGlvbiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb25cIik7IH1cbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gSW4gYHJldHVybmAgKGFuZCBgYnJlYWtgL2Bjb250aW51ZWApLCB0aGUga2V5d29yZHMgd2l0aFxuICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gIC8vIHBvc3NpYmlsaXR5IHRvIGluc2VydCBvbmUuXG5cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnNlbWkpIHx8IHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgbm9kZS5hcmd1bWVudCA9IG51bGw7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyB0aGlzLnNlbWljb2xvbigpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5jYXNlcyA9IFtdO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZUwpO1xuICB0aGlzLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgdGhpcy5lbnRlckxleGljYWxTY29wZSgpO1xuXG4gIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAvLyBub2Rlcy4gYGN1cmAgaXMgdXNlZCB0byBrZWVwIHRoZSBub2RlIHRoYXQgd2UgYXJlIGN1cnJlbnRseVxuICAvLyBhZGRpbmcgc3RhdGVtZW50cyB0by5cblxuICB2YXIgY3VyO1xuICBmb3IgKHZhciBzYXdEZWZhdWx0ID0gZmFsc2U7IHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VSOykge1xuICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuX2Nhc2UgfHwgdGhpcyQxLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcyQxLnR5cGUgPT09IHR5cGVzLl9jYXNlO1xuICAgICAgaWYgKGN1cikgeyB0aGlzJDEuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMkMS5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgY3VyLnRlc3QgPSB0aGlzJDEucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2F3RGVmYXVsdCkgeyB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZSh0aGlzJDEubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgfVxuICAgICAgICBzYXdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VyKSB7IHRoaXMkMS51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcyQxLnBhcnNlU3RhdGVtZW50KHRydWUpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG59O1xuXG4vLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxudmFyIGVtcHR5ID0gW107XG5cbnBwJDEucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXRjaCkge1xuICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgIHRoaXMuZW50ZXJMZXhpY2FsU2NvcGUoKTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGNsYXVzZS5wYXJhbSwgXCJsZXRcIik7XG4gICAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgMTApIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICB0aGlzLmVudGVyTGV4aWNhbFNjb3BlKCk7XG4gICAgfVxuICAgIGNsYXVzZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICB0aGlzLmV4aXRMZXhpY2FsU2NvcGUoKTtcbiAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICB9XG4gIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQodHlwZXMuX2ZpbmFsbHkpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpXG4gICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVmFyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwga2luZCkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VXaXRoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5zdHJpY3QpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwcikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0ID0gdGhpcyQxLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgIHtcbiAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgeyB0aGlzJDEucmFpc2UoZXhwci5zdGFydCwgXCJMYWJlbCAnXCIgKyBtYXliZU5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgfSB9XG4gIHZhciBraW5kID0gdGhpcy50eXBlLmlzTG9vcCA/IFwibG9vcFwiIDogdGhpcy50eXBlID09PSB0eXBlcy5fc3dpdGNoID8gXCJzd2l0Y2hcIiA6IG51bGw7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYWJlbCQxID0gdGhpcyQxLmxhYmVsc1tpXTtcbiAgICBpZiAobGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgLy8gVXBkYXRlIGluZm9ybWF0aW9uIGFib3V0IHByZXZpb3VzIGxhYmVscyBvbiB0aGlzIG5vZGVcbiAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gIGlmIChub2RlLmJvZHkudHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgfHxcbiAgICAgIG5vZGUuYm9keS50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJiBub2RlLmJvZHkua2luZCAhPT0gXCJ2YXJcIiB8fFxuICAgICAgbm9kZS5ib2R5LnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiICYmICh0aGlzLnN0cmljdCB8fCBub2RlLmJvZHkuZ2VuZXJhdG9yIHx8IG5vZGUuYm9keS5hc3luYykpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5ib2R5LnN0YXJ0LCBcIkludmFsaWQgbGFiZWxlZCBkZWNsYXJhdGlvblwiKTsgfVxuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGV4cHIpIHtcbiAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgc2VtaWNvbG9uLWVuY2xvc2VkIGJsb2NrIG9mIHN0YXRlbWVudHMsIGhhbmRsaW5nIGBcInVzZVxuLy8gc3RyaWN0XCJgIGRlY2xhcmF0aW9ucyB3aGVuIGBhbGxvd1N0cmljdGAgaXMgdHJ1ZSAodXNlZCBmb3Jcbi8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbnBwJDEucGFyc2VCbG9jayA9IGZ1bmN0aW9uKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgIHRoaXMuZW50ZXJMZXhpY2FsU2NvcGUoKTtcbiAgfVxuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICB2YXIgc3RtdCA9IHRoaXMkMS5wYXJzZVN0YXRlbWVudCh0cnVlKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7XG4gICAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbi8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuLy8gZXhwcmVzc2lvbi5cblxucHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgbm9kZS5pbml0ID0gaW5pdDtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICB0aGlzLmV4aXRMZXhpY2FsU2NvcGUoKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIGBmb3JgL2BpbmAgYW5kIGBmb3JgL2BvZmAgbG9vcCwgd2hpY2ggYXJlIGFsbW9zdFxuLy8gc2FtZSBmcm9tIHBhcnNlcidzIHBlcnNwZWN0aXZlLlxuXG5wcCQxLnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIHZhciB0eXBlID0gdGhpcy50eXBlID09PSB0eXBlcy5faW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiKSB7XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiIHx8XG4gICAgICAoaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJiBpbml0LmRlY2xhcmF0aW9uc1swXS5pbml0ICE9IG51bGwgJiZcbiAgICAgICAodGhpcy5zdHJpY3QgfHwgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpKSlcbiAgICAgIHsgdGhpcy5yYWlzZShpbml0LnN0YXJ0LCBcIkludmFsaWQgYXNzaWdubWVudCBpbiBmb3ItaW4gbG9vcCBoZWFkXCIpOyB9XG4gIH1cbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IHR5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKVxufTtcblxuLy8gUGFyc2UgYSBsaXN0IG9mIHZhcmlhYmxlIGRlY2xhcmF0aW9ucy5cblxucHAkMS5wYXJzZVZhciA9IGZ1bmN0aW9uKG5vZGUsIGlzRm9yLCBraW5kKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZGVjbCA9IHRoaXMkMS5zdGFydE5vZGUoKTtcbiAgICB0aGlzJDEucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcyQxLmVhdCh0eXBlcy5lcSkpIHtcbiAgICAgIGRlY2wuaW5pdCA9IHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKGlzRm9yKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMkMS50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMkMS5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcyQxLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMkMS51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5faW4gfHwgdGhpcyQxLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMkMS5yYWlzZSh0aGlzJDEubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzJDEuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbShraW5kKTtcbiAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCwgZmFsc2UpO1xufTtcblxuLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jKSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICBpZiAoaXNTdGF0ZW1lbnQpIHtcbiAgICBub2RlLmlkID0gaXNTdGF0ZW1lbnQgPT09IFwibnVsbGFibGVJRFwiICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSA/IG51bGwgOiB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICBpZiAobm9kZS5pZCkge1xuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgdGhpcy5pbk1vZHVsZSAmJiAhdGhpcy5pbkZ1bmN0aW9uID8gXCJsZXRcIiA6IFwidmFyXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3IsIG9sZEluQXN5bmMgPSB0aGlzLmluQXN5bmMsXG4gICAgICBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkSW5GdW5jID0gdGhpcy5pbkZ1bmN0aW9uO1xuICB0aGlzLmluR2VuZXJhdG9yID0gbm9kZS5nZW5lcmF0b3I7XG4gIHRoaXMuaW5Bc3luYyA9IG5vZGUuYXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgdGhpcy5lbnRlckZ1bmN0aW9uU2NvcGUoKTtcblxuICBpZiAoIWlzU3RhdGVtZW50KVxuICAgIHsgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDsgfVxuXG4gIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5KTtcblxuICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbn07XG5cbi8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLm5leHQoKTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBtZW1iZXIgPSB0aGlzJDEucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHkpO1xuICAgIGlmIChtZW1iZXIgJiYgbWVtYmVyLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiICYmIG1lbWJlci5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGlmIChoYWRDb25zdHJ1Y3RvcikgeyB0aGlzJDEucmFpc2UobWVtYmVyLnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VDbGFzc01lbWJlciA9IGZ1bmN0aW9uKGNsYXNzQm9keSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBtZXRob2QgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgdHJ5Q29udGV4dHVhbCA9IGZ1bmN0aW9uIChrLCBub0xpbmVCcmVhaykge1xuICAgIGlmICggbm9MaW5lQnJlYWsgPT09IHZvaWQgMCApIG5vTGluZUJyZWFrID0gZmFsc2U7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzJDEuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcyQxLnN0YXJ0TG9jO1xuICAgIGlmICghdGhpcyQxLmVhdENvbnRleHR1YWwoaykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcyQxLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiAoIW5vTGluZUJyZWFrIHx8ICF0aGlzJDEuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAobWV0aG9kLmtleSkgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgbWV0aG9kLmtleSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydCwgc3RhcnRMb2MpO1xuICAgIG1ldGhvZC5rZXkubmFtZSA9IGs7XG4gICAgdGhpcyQxLmZpbmlzaE5vZGUobWV0aG9kLmtleSwgXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgbWV0aG9kLnN0YXRpYyA9IHRyeUNvbnRleHR1YWwoXCJzdGF0aWNcIik7XG4gIHZhciBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuICBpZiAoIWlzR2VuZXJhdG9yKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIHRyeUNvbnRleHR1YWwoXCJhc3luY1wiLCB0cnVlKSkge1xuICAgICAgaXNBc3luYyA9IHRydWU7XG4gICAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcImdldFwiKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcImdldFwiO1xuICAgIH0gZWxzZSBpZiAodHJ5Q29udGV4dHVhbChcInNldFwiKSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcInNldFwiO1xuICAgIH1cbiAgfVxuICBpZiAoIW1ldGhvZC5rZXkpIHsgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpOyB9XG4gIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICBpZiAobWV0aG9kLmtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgaWYgKGlzR2VuZXJhdG9yKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gIH0gZWxzZSBpZiAobWV0aG9kLnN0YXRpYyAmJiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICB0aGlzLnJhaXNlKGtleS5zdGFydCwgXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGVcIik7XG4gIH1cbiAgdGhpcy5wYXJzZUNsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICByZXR1cm4gbWV0aG9kXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgbWV0aG9kLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJNZXRob2REZWZpbml0aW9uXCIpKTtcbn07XG5cbnBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogaXNTdGF0ZW1lbnQgPT09IHRydWUgPyB0aGlzLnVuZXhwZWN0ZWQoKSA6IG51bGw7XG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xufTtcblxuLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbnBwJDEucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgIHZhciBpc0FzeW5jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgXCJudWxsYWJsZUlEXCIsIGZhbHNlLCBpc0FzeW5jKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzJDEuY2hlY2tVbnJlc2VydmVkKHNwZWMubG9jYWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEuY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbn07XG5cbnBwJDEuY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMkMS5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcCk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIilcbiAgICB7IGZvciAodmFyIGkkMSA9IDAsIGxpc3QkMSA9IHBhdC5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbHQgPSBsaXN0JDFbaSQxXTtcblxuICAgICAgICBpZiAoZWx0KSB7IHRoaXMkMS5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZWx0KTsgfVxuICAgIH0gfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlByb3BlcnR5XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQudmFsdWUpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5sZWZ0KTsgfVxuICBlbHNlIGlmICh0eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBwYXQuYXJndW1lbnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5leHByZXNzaW9uKTsgfVxufTtcblxucHAkMS5jaGVja1ZhcmlhYmxlRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgZGVjbHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gZGVjbHM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgZGVjbCA9IGxpc3RbaV07XG5cbiAgICB0aGlzJDEuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICB9XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG5wcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMkMS5wYXJzZUlkZW50KHRydWUpO1xuICAgIG5vZGUuZXhwb3J0ZWQgPSB0aGlzJDEuZWF0Q29udGV4dHVhbChcImFzXCIpID8gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgIHRoaXMkMS5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmV4cG9ydGVkLm5hbWUsIG5vZGUuZXhwb3J0ZWQuc3RhcnQpO1xuICAgIG5vZGVzLnB1c2godGhpcyQxLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGltcG9ydCAnLi4uJ1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcpIHtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIilcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBpbXBvcnRzLlxuXG5wcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgLy8gaW1wb3J0IGRlZmF1bHRPYmosIHsgeCwgeSBhcyB6IH0gZnJvbSAnLi4uJ1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5sb2NhbCwgXCJsZXRcIik7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyByZXR1cm4gbm9kZXMgfVxuICB9XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpIHtcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKTtcbiAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlJDEubG9jYWwsIFwibGV0XCIpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgIHJldHVybiBub2Rlc1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMuYnJhY2VSKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIG5vZGUkMiA9IHRoaXMkMS5zdGFydE5vZGUoKTtcbiAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzJDEucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAodGhpcyQxLmVhdENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcyQxLnBhcnNlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcyQxLmNoZWNrVW5yZXNlcnZlZChub2RlJDIuaW1wb3J0ZWQpO1xuICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkO1xuICAgIH1cbiAgICB0aGlzJDEuY2hlY2tMVmFsKG5vZGUkMi5sb2NhbCwgXCJsZXRcIik7XG4gICAgbm9kZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKTtcbiAgfVxuICByZXR1cm4gbm9kZXNcbn07XG5cbi8vIFNldCBgRXhwcmVzc2lvblN0YXRlbWVudCNkaXJlY3RpdmVgIHByb3BlcnR5IGZvciBkaXJlY3RpdmUgcHJvbG9ndWVzLlxucHAkMS5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlID0gZnVuY3Rpb24oc3RhdGVtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoICYmIHRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoc3RhdGVtZW50c1tpXSk7ICsraSkge1xuICAgIHN0YXRlbWVudHNbaV0uZGlyZWN0aXZlID0gc3RhdGVtZW50c1tpXS5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSk7XG4gIH1cbn07XG5wcCQxLmlzRGlyZWN0aXZlQ2FuZGlkYXRlID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGVtZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmXG4gICAgc3RhdGVtZW50LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiZcbiAgICB0eXBlb2Ygc3RhdGVtZW50LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAvLyBSZWplY3QgcGFyZW50aGVzaXplZCBzdHJpbmdzLlxuICAgICh0aGlzLmlucHV0W3N0YXRlbWVudC5zdGFydF0gPT09IFwiXFxcIlwiIHx8IHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCInXCIpXG4gIClcbn07XG5cbnZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ29udmVydCBleGlzdGluZyBleHByZXNzaW9uIGF0b20gdG8gYXNzaWduYWJsZSBwYXR0ZXJuXG4vLyBpZiBwb3NzaWJsZS5cblxucHAkMi50b0Fzc2lnbmFibGUgPSBmdW5jdGlvbihub2RlLCBpc0JpbmRpbmcsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBpZiAodGhpcy5pbkFzeW5jICYmIG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgICAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7IH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIHRoaXMkMS50b0Fzc2lnbmFibGUocHJvcCwgaXNCaW5kaW5nKTtcbiAgICAgICAgLy8gRWFybHkgZXJyb3I6XG4gICAgICAgIC8vICAgQXNzaWdubWVudFJlc3RQcm9wZXJ0eVtZaWVsZCwgQXdhaXRdIDpcbiAgICAgICAgLy8gICAgIGAuLi5gIERlc3RydWN0dXJpbmdBc3NpZ25tZW50VGFyZ2V0W1lpZWxkLCBBd2FpdF1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICBJdCBpcyBhIFN5bnRheCBFcnJvciBpZiB8RGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXR8IGlzIGFuIHxBcnJheUxpdGVyYWx8IG9yIGFuIHxPYmplY3RMaXRlcmFsfC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmXG4gICAgICAgICAgKHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIiB8fCBwcm9wLmFyZ3VtZW50LnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzJDEucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byBBc3NpZ25tZW50UGF0dGVyblxuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzJDEudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICB9XG4gIGlmIChlbmQpIHtcbiAgICB2YXIgbGFzdCA9IGV4cHJMaXN0W2VuZCAtIDFdO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPT09IDYgJiYgaXNCaW5kaW5nICYmIGxhc3QgJiYgbGFzdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgbGFzdC5hcmd1bWVudC50eXBlICE9PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKGxhc3QuYXJndW1lbnQuc3RhcnQpOyB9XG4gIH1cbiAgcmV0dXJuIGV4cHJMaXN0XG59O1xuXG4vLyBQYXJzZXMgc3ByZWFkIGVsZW1lbnQuXG5cbnBwJDIucGFyc2VTcHJlYWQgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxufTtcblxucHAkMi5wYXJzZVJlc3RCaW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gUmVzdEVsZW1lbnQgaW5zaWRlIG9mIGEgZnVuY3Rpb24gcGFyYW1ldGVyIG11c3QgYmUgYW4gaWRlbnRpZmllclxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSlcbiAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG5cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuXG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxufTtcblxuLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxucHAkMi5wYXJzZUJpbmRpbmdBdG9tID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgY2FzZSB0eXBlcy5icmFja2V0TDpcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpXG5cbiAgICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKHRydWUpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlSWRlbnQoKVxufTtcblxucHAkMi5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2U7IH1cbiAgICBlbHNlIHsgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7IH1cbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgdmFyIHJlc3QgPSB0aGlzJDEucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcyQxLnBhcnNlQmluZGluZ0xpc3RJdGVtKHJlc3QpO1xuICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICAgICAgdGhpcyQxLmV4cGVjdChjbG9zZSk7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMkMS5wYXJzZU1heWJlRGVmYXVsdCh0aGlzJDEuc3RhcnQsIHRoaXMkMS5zdGFydExvYyk7XG4gICAgICB0aGlzJDEucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIHBhcmFtXG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG59O1xuXG4vLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4vLyB0by5cbi8vIGJpbmRpbmdUeXBlIGNhbiBiZSBlaXRoZXI6XG4vLyAndmFyJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhICd2YXInIGJpbmRpbmdcbi8vICdsZXQnIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgbGV4aWNhbCAoJ2xldCcgb3IgJ2NvbnN0JykgYmluZGluZ1xuLy8gJ25vbmUnIGluZGljYXRpbmcgdGhhdCB0aGUgYmluZGluZyBzaG91bGQgYmUgY2hlY2tlZCBmb3IgaWxsZWdhbCBpZGVudGlmaWVycywgYnV0IG5vdCBmb3IgZHVwbGljYXRlIHJlZmVyZW5jZXNcblxucHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpOyB9XG4gICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmJiBiaW5kaW5nVHlwZSAhPT0gXCJub25lXCIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYmluZGluZ1R5cGUgPT09IFwidmFyXCIgJiYgIXRoaXMuY2FuRGVjbGFyZVZhck5hbWUoZXhwci5uYW1lKSB8fFxuICAgICAgICBiaW5kaW5nVHlwZSAhPT0gXCJ2YXJcIiAmJiAhdGhpcy5jYW5EZWNsYXJlTGV4aWNhbE5hbWUoZXhwci5uYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoXCJJZGVudGlmaWVyICdcIiArIChleHByLm5hbWUpICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBcInZhclwiKSB7XG4gICAgICAgIHRoaXMuZGVjbGFyZVZhck5hbWUoZXhwci5uYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjbGFyZUxleGljYWxOYW1lKGV4cHIubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBpZiAoYmluZGluZ1R5cGUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgdGhpcyQxLmNoZWNrTFZhbChwcm9wLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgLy8gQXNzaWdubWVudFByb3BlcnR5IGhhcyB0eXBlID09PSBcIlByb3BlcnR5XCJcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLnZhbHVlLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgIGlmIChlbGVtKSB7IHRoaXMkMS5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIik7XG4gIH1cbn07XG5cbi8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4vLyBzeW50YWN0aWMgZWxlbWVudHMsIGFuZCByZWN1cnNpdmVseSBjYWxsaW5nIHRob3NlLCBlYWNoIGZ1bmN0aW9uXG4vLyBhZHZhbmNpbmcgdGhlIGlucHV0IHN0cmVhbSBhbmQgcmV0dXJuaW5nIGFuIEFTVCBub2RlLiBQcmVjZWRlbmNlXG4vLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuLy8gaW5zdGVhZCBvZiBgKCF4KVsxXWAgaXMgaGFuZGxlZCBieSB0aGUgZmFjdCB0aGF0IHRoZSBwYXJzZXJcbi8vIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIHVuYXJ5IHByZWZpeCBvcGVyYXRvcnMgaXMgY2FsbGVkIGZpcnN0LCBhbmRcbi8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuLy8gd2F5LCBpdCdsbCByZWNlaXZlIHRoZSBub2RlIGZvciBgeFsxXWAgYWxyZWFkeSBwYXJzZWQsIGFuZCB3cmFwc1xuLy8gKnRoYXQqIGluIHRoZSB1bmFyeSBvcGVyYXRvciBub2RlLlxuLy9cbi8vIEFjb3JuIHVzZXMgYW4gW29wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2VyXVtvcHBdIHRvIGhhbmRsZSBiaW5hcnlcbi8vIG9wZXJhdG9yIHByZWNlZGVuY2UsIGJlY2F1c2UgaXQgaXMgbXVjaCBtb3JlIGNvbXBhY3QgdGhhbiB1c2luZ1xuLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3Rpbmdcbi8vIGZ1bmN0aW9ucyB0byBzcGVjaWZ5IHByZWNlZGVuY2UsIGZvciBhbGwgb2YgdGhlIHRlbiBiaW5hcnlcbi8vIHByZWNlZGVuY2UgbGV2ZWxzIHRoYXQgSmF2YVNjcmlwdCBkZWZpbmVzLlxuLy9cbi8vIFtvcHBdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdG9yLXByZWNlZGVuY2VfcGFyc2VyXG5cbnZhciBwcCQzID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gQ2hlY2sgaWYgcHJvcGVydHkgbmFtZSBjbGFzaGVzIHdpdGggYWxyZWFkeSBhZGRlZC5cbi8vIE9iamVjdC9jbGFzcyBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGFyZSBub3QgYWxsb3dlZCB0byBjbGFzaCDigJRcbi8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbi8vIHN0cmljdCBtb2RlLCBpbml0IHByb3BlcnRpZXMgYXJlIGFsc28gbm90IGFsbG93ZWQgdG8gYmUgcmVwZWF0ZWQuXG5cbnBwJDMuY2hlY2tQcm9wQ2xhc2ggPSBmdW5jdGlvbihwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgcHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIilcbiAgICB7IHJldHVybiB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykge1xuICAgICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvIDwgMCkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvID0ga2V5LnN0YXJ0OyB9XG4gICAgICAgIC8vIEJhY2t3YXJkcy1jb21wYXQga2x1ZGdlLiBDYW4gYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMFxuICAgICAgICBlbHNlIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGtleS5zdGFydCwgXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5XCIpOyB9XG4gICAgICB9XG4gICAgICBwcm9wSGFzaC5wcm90byA9IHRydWU7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIG5hbWUgPSBcIiRcIiArIG5hbWU7XG4gIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdO1xuICBpZiAob3RoZXIpIHtcbiAgICB2YXIgcmVkZWZpbml0aW9uO1xuICAgIGlmIChraW5kID09PSBcImluaXRcIikge1xuICAgICAgcmVkZWZpbml0aW9uID0gdGhpcy5zdHJpY3QgJiYgb3RoZXIuaW5pdCB8fCBvdGhlci5nZXQgfHwgb3RoZXIuc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRlZmluaXRpb24gPSBvdGhlci5pbml0IHx8IG90aGVyW2tpbmRdO1xuICAgIH1cbiAgICBpZiAocmVkZWZpbml0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKTsgfVxuICB9IGVsc2Uge1xuICAgIG90aGVyID0gcHJvcEhhc2hbbmFtZV0gPSB7XG4gICAgICBpbml0OiBmYWxzZSxcbiAgICAgIGdldDogZmFsc2UsXG4gICAgICBzZXQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBvdGhlcltraW5kXSA9IHRydWU7XG59O1xuXG4vLyAjIyMgRXhwcmVzc2lvbiBwYXJzaW5nXG5cbi8vIFRoZXNlIG5lc3QsIGZyb20gdGhlIG1vc3QgZ2VuZXJhbCBleHByZXNzaW9uIHR5cGUgYXQgdGhlIHRvcCB0b1xuLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2Zcbi8vIHRoZSBmdW5jdGlvbnMgd2lsbCBzaW1wbHkgbGV0IHRoZSBmdW5jdGlvbihzKSBiZWxvdyB0aGVtIHBhcnNlLFxuLy8gYW5kLCAqaWYqIHRoZSBzeW50YWN0aWMgY29uc3RydWN0IHRoZXkgaGFuZGxlIGlzIHByZXNlbnQsIHdyYXBcbi8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuLy8gUGFyc2UgYSBmdWxsIGV4cHJlc3Npb24uIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgYXJlIHVzZWQgdG9cbi8vIGZvcmJpZCB0aGUgYGluYCBvcGVyYXRvciAoaW4gZm9yIGxvb3BzIGluaXRhbGl6YXRpb24gZXhwcmVzc2lvbnMpXG4vLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbi8vIHByb3BlcnR5IGFzc2lnbm1lbnQgaW4gY29udGV4dHMgd2hlcmUgYm90aCBvYmplY3QgZXhwcmVzc2lvblxuLy8gYW5kIG9iamVjdCBwYXR0ZXJuIG1pZ2h0IGFwcGVhciAoc28gaXQncyBwb3NzaWJsZSB0byByYWlzZVxuLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbnBwJDMucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG4gICAgd2hpbGUgKHRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICBpZiAodGhpcy5pbkdlbmVyYXRvciAmJiB0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQoKSB9XG5cbiAgdmFyIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSBmYWxzZSwgb2xkUGFyZW5Bc3NpZ24gPSAtMSwgb2xkVHJhaWxpbmdDb21tYSA9IC0xO1xuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIG9sZFBhcmVuQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduO1xuICAgIG9sZFRyYWlsaW5nQ29tbWEgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWE7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSA6IGxlZnQ7XG4gICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IERlc3RydWN0dXJpbmdFcnJvcnMuY2FsbChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgdGhpcy5jaGVja0xWYWwobGVmdCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICB9XG4gIGlmIChvbGRQYXJlbkFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IG9sZFBhcmVuQXNzaWduOyB9XG4gIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICByZXR1cm4gbGVmdFxufTtcblxuLy8gUGFyc2UgYSB0ZXJuYXJ5IGNvbmRpdGlvbmFsIChgPzpgKSBvcGVyYXRvci5cblxucHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnF1ZXN0aW9uKSkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgdGhpcy5leHBlY3QodHlwZXMuY29sb24pO1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgfVxuICByZXR1cm4gZXhwclxufTtcblxuLy8gU3RhcnQgdGhlIHByZWNlZGVuY2UgcGFyc2VyLlxuXG5wcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgcmV0dXJuIGV4cHIuc3RhcnQgPT09IHN0YXJ0UG9zICYmIGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID8gZXhwciA6IHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSwgbm9Jbilcbn07XG5cbi8vIFBhcnNlIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBwYXJzaW5nXG4vLyBhbGdvcml0aG0uIGBsZWZ0YCBpcyB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgdGhlIG9wZXJhdG9yLlxuLy8gYG1pblByZWNgIHByb3ZpZGVzIGNvbnRleHQgdGhhdCBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIHN0b3AgYW5kXG4vLyBkZWZlciBmdXJ0aGVyIHBhcnNlciB0byBvbmUgb2YgaXRzIGNhbGxlcnMgd2hlbiBpdCBlbmNvdW50ZXJzIGFuXG4vLyBvcGVyYXRvciB0aGF0IGhhcyBhIGxvd2VyIHByZWNlZGVuY2UgdGhhbiB0aGUgc2V0IGl0IGlzIHBhcnNpbmcuXG5cbnBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICB2YXIgcHJlYyA9IHRoaXMudHlwZS5iaW5vcDtcbiAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0eXBlcy5faW4pKSB7XG4gICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICB2YXIgbG9naWNhbCA9IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbE9SIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubG9naWNhbEFORDtcbiAgICAgIHZhciBvcCA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMsIG5vSW4pO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG5wcCQzLmJ1aWxkQmluYXJ5ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUub3BlcmF0b3IgPSBvcDtcbiAgbm9kZS5yaWdodCA9IHJpZ2h0O1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHVuYXJ5IG9wZXJhdG9ycywgYm90aCBwcmVmaXggYW5kIHBvc3RmaXguXG5cbnBwJDMucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnkpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCBleHByO1xuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJhd2FpdFwiKSAmJiAodGhpcy5pbkFzeW5jIHx8ICghdGhpcy5pbkZ1bmN0aW9uICYmIHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uKSkpIHtcbiAgICBleHByID0gdGhpcy5wYXJzZUF3YWl0KCk7XG4gICAgc2F3VW5hcnkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5wcmVmaXgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuaW5jRGVjO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUucHJlZml4ID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgaWYgKHVwZGF0ZSkgeyB0aGlzLmNoZWNrTFZhbChub2RlLmFyZ3VtZW50KTsgfVxuICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZVwiKTsgfVxuICAgIGVsc2UgeyBzYXdVbmFyeSA9IHRydWU7IH1cbiAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHVwZGF0ZSA/IFwiVXBkYXRlRXhwcmVzc2lvblwiIDogXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcyQxLnZhbHVlO1xuICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgIHRoaXMkMS5jaGVja0xWYWwoZXhwcik7XG4gICAgICB0aGlzJDEubmV4dCgpO1xuICAgICAgZXhwciA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQodHlwZXMuc3RhcnN0YXIpKVxuICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIFwiKipcIiwgZmFsc2UpIH1cbiAgZWxzZVxuICAgIHsgcmV0dXJuIGV4cHIgfVxufTtcblxuLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbnBwJDMucGFyc2VFeHByU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgdmFyIHNraXBBcnJvd1N1YnNjcmlwdHMgPSBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIjtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHx8IHNraXBBcnJvd1N1YnNjcmlwdHMpIHsgcmV0dXJuIGV4cHIgfVxuICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5pbnB1dC5zbGljZShiYXNlLnN0YXJ0LCBiYXNlLmVuZCkgPT09IFwiYXN5bmNcIjtcbiAgZm9yICh2YXIgY29tcHV0ZWQgPSAodm9pZCAwKTs7KSB7XG4gICAgaWYgKChjb21wdXRlZCA9IHRoaXMkMS5lYXQodHlwZXMuYnJhY2tldEwpKSB8fCB0aGlzJDEuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgICBub2RlLnByb3BlcnR5ID0gY29tcHV0ZWQgPyB0aGlzJDEucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzJDEucGFyc2VJZGVudCh0cnVlKTtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSAhIWNvbXB1dGVkO1xuICAgICAgaWYgKGNvbXB1dGVkKSB7IHRoaXMkMS5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcyQxLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMkMS55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzJDEuYXdhaXRQb3M7XG4gICAgICB0aGlzJDEueWllbGRQb3MgPSAwO1xuICAgICAgdGhpcyQxLmF3YWl0UG9zID0gMDtcbiAgICAgIHZhciBleHByTGlzdCA9IHRoaXMkMS5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcyQxLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMkMS5lYXQodHlwZXMuYXJyb3cpKSB7XG4gICAgICAgIHRoaXMkMS5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgICB0aGlzJDEuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICAgIHRoaXMkMS55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICAgICAgICB0aGlzJDEuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMkMS5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZXhwckxpc3QsIHRydWUpXG4gICAgICB9XG4gICAgICB0aGlzJDEuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgICAgdGhpcyQxLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcyQxLnlpZWxkUG9zO1xuICAgICAgdGhpcyQxLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcyQxLmF3YWl0UG9zO1xuICAgICAgdmFyIG5vZGUkMSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQxLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlJDEuYXJndW1lbnRzID0gZXhwckxpc3Q7XG4gICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQxLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZSkge1xuICAgICAgdmFyIG5vZGUkMiA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgICBub2RlJDIucXVhc2kgPSB0aGlzJDEucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6IHRydWV9KTtcbiAgICAgIGJhc2UgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmFzZVxuICAgIH1cbiAgfVxufTtcblxuLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4vLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4vLyBvciBge31gLlxuXG5wcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicgb3V0c2lkZSBvZiBmdW5jdGlvbiBvciBjbGFzc1wiKTsgfVxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciBBcmd1bWVudHNcbiAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTClcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICBjYXNlIHR5cGVzLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMubmFtZTpcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQodGhpcy50eXBlICE9PSB0eXBlcy5uYW1lKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZmFsc2UsIGZhbHNlLCB0cnVlKSB9XG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCBmYWxzZSkgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgIWNvbnRhaW5zRXNjKSB7XG4gICAgICAgIGlkID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFnc307XG4gICAgcmV0dXJuIG5vZGVcblxuICBjYXNlIHR5cGVzLm51bTogY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcy5fbnVsbDogY2FzZSB0eXBlcy5fdHJ1ZTogY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSB0eXBlcy5fdHJ1ZTtcbiAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9iaihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcblxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKVxuXG4gIGNhc2UgdHlwZXMuX2NsYXNzOlxuICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpXG5cbiAgY2FzZSB0eXBlcy5fbmV3OlxuICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICBjYXNlIHR5cGVzLmJhY2tRdW90ZTpcbiAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKClcblxuICBkZWZhdWx0OlxuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbn07XG5cbnBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHJldHVybiB2YWxcbn07XG5cbnBwJDMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGNhbkJlQXJyb3cpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWwsIGFsbG93VHJhaWxpbmdDb21tYSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4O1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGV4cHJMaXN0ID0gW10sIGZpcnN0ID0gdHJ1ZSwgbGFzdElzQ29tbWEgPSBmYWxzZTtcbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgc3ByZWFkU3RhcnQ7XG4gICAgdGhpcy55aWVsZFBvcyA9IDA7XG4gICAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gICAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMucGFyZW5SKSB7XG4gICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICAgIHNwcmVhZFN0YXJ0ID0gdGhpcyQxLnN0YXJ0O1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMkMS5wYXJzZVBhcmVuSXRlbSh0aGlzJDEucGFyc2VSZXN0QmluZGluZygpKSk7XG4gICAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMkMS5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbn07XG5cbi8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudCB0b1xuLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbi8vIGFyZ3VtZW50IHRvIHBhcnNlU3Vic2NyaXB0cyB0byBwcmV2ZW50IGl0IGZyb20gY29uc3VtaW5nIHRoZVxuLy8gYXJndW1lbnQgbGlzdC5cblxudmFyIGVtcHR5JDEgPSBbXTtcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIgfHwgY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCIpOyB9XG4gICAgaWYgKCF0aGlzLmluRnVuY3Rpb24pXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIm5ldy50YXJnZXQgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnNcIik7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gIH1cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUpO1xuICBpZiAodGhpcy5lYXQodHlwZXMucGFyZW5MKSkgeyBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4LCBmYWxzZSk7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAkMy5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgfVxuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICBjb29rZWQ6IG51bGxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxufTtcblxucHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpc1RhZ2dlZCA9IHJlZi5pc1RhZ2dlZDsgaWYgKCBpc1RhZ2dlZCA9PT0gdm9pZCAwICkgaXNUYWdnZWQgPSBmYWxzZTtcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmV4cHJlc3Npb25zID0gW107XG4gIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KTtcbiAgbm9kZS5xdWFzaXMgPSBbY3VyRWx0XTtcbiAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuZW9mKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEucG9zLCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpOyB9XG4gICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzJDEucGFyc2VFeHByZXNzaW9uKCkpO1xuICAgIHRoaXMkMS5leHBlY3QodHlwZXMuYnJhY2VSKTtcbiAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMkMS5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG59O1xuXG5wcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbnBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLm5leHQoKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMkMS5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcyQxLmNoZWNrUHJvcENsYXNoKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5lbGxpcHNpcykpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUmVzdEVsZW1lbnRcIilcbiAgICB9XG4gICAgLy8gVG8gZGlzYWxsb3cgcGFyZW50aGVzaXplZCBpZGVudGlmaWVyIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA8IDApIHtcbiAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIGFyZ3VtZW50LlxuICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIC8vIFRvIGRpc2FsbG93IHRyYWlsaW5nIGNvbW1hIHZpYSBgdGhpcy50b0Fzc2lnbmFibGUoKWAuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvLyBGaW5pc2hcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB9XG4gICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgfVxuICB2YXIgY29udGFpbnNFc2MgPSB0aGlzLmNvbnRhaW5zRXNjO1xuICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgIWlzR2VuZXJhdG9yICYmIHRoaXMuaXNBc3luY1Byb3AocHJvcCkpIHtcbiAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICBpc0dlbmVyYXRvciA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIH0gZWxzZSB7XG4gICAgaXNBc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBjb250YWluc0VzYykge1xuICBpZiAoKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29sb24pXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5jb2xvbikpIHtcbiAgICBwcm9wLnZhbHVlID0gaXNQYXR0ZXJuID8gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwpIHtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcHJvcC5raW5kID0gXCJpbml0XCI7XG4gICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfSBlbHNlIGlmICghaXNQYXR0ZXJuICYmICFjb250YWluc0VzYyAmJlxuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAodGhpcy50eXBlICE9PSB0eXBlcy5jb21tYSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoaXNHZW5lcmF0b3IgfHwgaXNBc3luYykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWU7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChmYWxzZSk7XG4gICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBpZiAocHJvcC52YWx1ZS5wYXJhbXMubGVuZ3RoICE9PSBwYXJhbUNvdW50KSB7XG4gICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0O1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJnZXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3Aua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3AudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpOyB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gdGhpcy5zdGFydDsgfVxuICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AudmFsdWUgPSBwcm9wLmtleTtcbiAgICB9XG4gICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICB9IGVsc2UgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKSkge1xuICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWU7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpO1xuICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0eXBlcy5udW0gfHwgdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0cnVlKVxufTtcblxuLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG5wcCQzLmluaXRGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5pZCA9IG51bGw7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KVxuICAgIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG59O1xuXG4vLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG5wcCQzLnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3IsIG9sZEluQXN5bmMgPSB0aGlzLmluQXN5bmMsXG4gICAgICBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkSW5GdW5jID0gdGhpcy5pbkZ1bmN0aW9uO1xuXG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLmluR2VuZXJhdG9yID0gbm9kZS5nZW5lcmF0b3I7XG4gIHRoaXMuaW5Bc3luYyA9IG5vZGUuYXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgdGhpcy5lbnRlckZ1bmN0aW9uU2NvcGUoKTtcblxuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UpO1xuXG4gIHRoaXMuaW5HZW5lcmF0b3IgPSBvbGRJbkdlbjtcbiAgdGhpcy5pbkFzeW5jID0gb2xkSW5Bc3luYztcbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IG9sZEluRnVuYztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvbiB3aXRoIGdpdmVuIHBhcmFtZXRlcnMuXG5cbnBwJDMucGFyc2VBcnJvd0V4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMpIHtcbiAgdmFyIG9sZEluR2VuID0gdGhpcy5pbkdlbmVyYXRvciwgb2xkSW5Bc3luYyA9IHRoaXMuaW5Bc3luYyxcbiAgICAgIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRJbkZ1bmMgPSB0aGlzLmluRnVuY3Rpb247XG5cbiAgdGhpcy5lbnRlckZ1bmN0aW9uU2NvcGUoKTtcbiAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICB0aGlzLmluR2VuZXJhdG9yID0gZmFsc2U7XG4gIHRoaXMuaW5Bc3luYyA9IG5vZGUuYXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5pbkZ1bmN0aW9uID0gdHJ1ZTtcblxuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUpO1xuXG4gIHRoaXMuaW5HZW5lcmF0b3IgPSBvbGRJbkdlbjtcbiAgdGhpcy5pbkFzeW5jID0gb2xkSW5Bc3luYztcbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IG9sZEluRnVuYztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBmdW5jdGlvbiBib2R5IGFuZCBjaGVjayBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uKSB7XG4gIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZUw7XG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdCwgdXNlU3RyaWN0ID0gZmFsc2U7XG5cbiAgaWYgKGlzRXhwcmVzc2lvbikge1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRydWU7XG4gICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vblNpbXBsZSA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICBpZiAoIW9sZFN0cmljdCB8fCBub25TaW1wbGUpIHtcbiAgICAgIHVzZVN0cmljdCA9IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKTtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpY3QgbW9kZSBmdW5jdGlvbiwgdmVyaWZ5IHRoYXQgYXJndW1lbnQgbmFtZXNcbiAgICAgIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gICAgICAvLyBvciBgYXJndW1lbnRzYC5cbiAgICAgIGlmICh1c2VTdHJpY3QgJiYgbm9uU2ltcGxlKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3RcIik7IH1cbiAgICB9XG4gICAgLy8gU3RhcnQgYSBuZXcgc2NvcGUgd2l0aCByZWdhcmQgdG8gbGFiZWxzIGFuZCB0aGUgYGluRnVuY3Rpb25gXG4gICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICB2YXIgb2xkTGFiZWxzID0gdGhpcy5sYWJlbHM7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICBpZiAodXNlU3RyaWN0KSB7IHRoaXMuc3RyaWN0ID0gdHJ1ZTsgfVxuXG4gICAgLy8gQWRkIHRoZSBwYXJhbXMgdG8gdmFyRGVjbGFyZWROYW1lcyB0byBlbnN1cmUgdGhhdCBhbiBlcnJvciBpcyB0aHJvd25cbiAgICAvLyBpZiBhIGxldC9jb25zdCBkZWNsYXJhdGlvbiBpbiB0aGUgZnVuY3Rpb24gY2xhc2hlcyB3aXRoIG9uZSBvZiB0aGUgcGFyYW1zLlxuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIW9sZFN0cmljdCAmJiAhdXNlU3RyaWN0ICYmICFpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcykpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayhmYWxzZSk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keS5ib2R5KTtcbiAgICB0aGlzLmxhYmVscyA9IG9sZExhYmVscztcbiAgfVxuICB0aGlzLmV4aXRGdW5jdGlvblNjb3BlKCk7XG5cbiAgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUuaWQpIHtcbiAgICAvLyBFbnN1cmUgdGhlIGZ1bmN0aW9uIG5hbWUgaXNuJ3QgYSBmb3JiaWRkZW4gaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZSwgZS5nLiAnZXZhbCdcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBcIm5vbmVcIik7XG4gIH1cbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG59O1xuXG5wcCQzLmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbnBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5hbWVIYXNoID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgdGhpcyQxLmNoZWNrTFZhbChwYXJhbSwgXCJ2YXJcIiwgYWxsb3dEdXBsaWNhdGVzID8gbnVsbCA6IG5hbWVIYXNoKTtcbiAgfVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZXhwcmVzc2lvbnMsIGFuZCByZXR1cm5zIHRoZW0gYXNcbi8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4vLyBgYWxsb3dFbXB0eWAgY2FuIGJlIHR1cm5lZCBvbiB0byBhbGxvdyBzdWJzZXF1ZW50IGNvbW1hcyB3aXRoXG4vLyBub3RoaW5nIGluIGJldHdlZW4gdGhlbSB0byBiZSBwYXJzZWQgYXMgYG51bGxgICh3aGljaCBpcyBuZWVkZWRcbi8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbnBwJDMucGFyc2VFeHByTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd1RyYWlsaW5nQ29tbWEsIGFsbG93RW1wdHksIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgeyBicmVhayB9XG4gICAgfSBlbHNlIHsgZmlyc3QgPSBmYWxzZTsgfVxuXG4gICAgdmFyIGVsdCA9ICh2b2lkIDApO1xuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSlcbiAgICAgIHsgZWx0ID0gbnVsbDsgfVxuICAgIGVsc2UgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgZWx0ID0gdGhpcyQxLnBhcnNlU3ByZWFkKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgdGhpcyQxLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA8IDApXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcyQxLnN0YXJ0OyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB9XG4gICAgZWx0cy5wdXNoKGVsdCk7XG4gIH1cbiAgcmV0dXJuIGVsdHNcbn07XG5cbnBwJDMuY2hlY2tVbnJlc2VydmVkID0gZnVuY3Rpb24ocmVmKSB7XG4gIHZhciBzdGFydCA9IHJlZi5zdGFydDtcbiAgdmFyIGVuZCA9IHJlZi5lbmQ7XG4gIHZhciBuYW1lID0gcmVmLm5hbWU7XG5cbiAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgbmFtZSA9PT0gXCJ5aWVsZFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbiBub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2FuIG5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICBpZiAodGhpcy5pc0tleXdvcmQobmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJVbmV4cGVjdGVkIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJ1wiKSk7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW4gbm90IHVzZSBrZXl3b3JkICdhd2FpdCcgb3V0c2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgKFwiVGhlIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZFwiKSk7XG4gIH1cbn07XG5cbi8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4vLyB3aGVuIHBhcnNpbmcgcHJvcGVydGllcyksIGl0IHdpbGwgYWxzbyBjb252ZXJ0IGtleXdvcmRzIGludG9cbi8vIGlkZW50aWZpZXJzLlxuXG5wcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsLCBpc0JpbmRpbmcpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAobGliZXJhbCAmJiB0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gXCJuZXZlclwiKSB7IGxpYmVyYWwgPSBmYWxzZTsgfVxuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9hY29ybmpzL2Fjb3JuL2lzc3Vlcy81NzVcbiAgICAvLyBgY2xhc3NgIGFuZCBgZnVuY3Rpb25gIGtleXdvcmRzIHB1c2ggbmV3IGNvbnRleHQgaW50byB0aGlzLmNvbnRleHQuXG4gICAgLy8gQnV0IHRoZXJlIGlzIG5vIGNoYW5jZSB0byBwb3AgdGhlIGNvbnRleHQgaWYgdGhlIGtleXdvcmQgaXMgY29uc3VtZWQgYXMgYW4gaWRlbnRpZmllciBzdWNoIGFzIGEgcHJvcGVydHkgbmFtZS5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdG9rZW4gaXMgYSBkb3QsIHRoaXMgZG9lcyBub3QgYXBwbHkgYmVjYXVzZSB0aGUgY29udGV4dC1tYW5hZ2luZyBjb2RlIGFscmVhZHkgaWdub3JlZCB0aGUga2V5d29yZFxuICAgIGlmICgobm9kZS5uYW1lID09PSBcImNsYXNzXCIgfHwgbm9kZS5uYW1lID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICh0aGlzLmxhc3RUb2tFbmQgIT09IHRoaXMubGFzdFRva1N0YXJ0ICsgMSB8fCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5sYXN0VG9rU3RhcnQpICE9PSA0NikpIHtcbiAgICAgIHRoaXMuY29udGV4dC5wb3AoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIGlmICghbGliZXJhbCkgeyB0aGlzLmNoZWNrVW5yZXNlcnZlZChub2RlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxucHAkMy5wYXJzZVlpZWxkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy55aWVsZFBvcykgeyB0aGlzLnlpZWxkUG9zID0gdGhpcy5zdGFydDsgfVxuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgfHwgdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSB8fCAodGhpcy50eXBlICE9PSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG52YXIgcHAkNCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByYWlzZSBleGNlcHRpb25zIG9uIHBhcnNlIGVycm9ycy4gSXRcbi8vIHRha2VzIGFuIG9mZnNldCBpbnRlZ2VyIChpbnRvIHRoZSBjdXJyZW50IGBpbnB1dGApIHRvIGluZGljYXRlXG4vLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuLy8gb2YgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZCB0aGVuIHJhaXNlcyBhIGBTeW50YXhFcnJvcmAgd2l0aCB0aGF0XG4vLyBtZXNzYWdlLlxuXG5wcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gIHZhciBsb2MgPSBnZXRMaW5lSW5mbyh0aGlzLmlucHV0LCBwb3MpO1xuICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG4gIHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG4gIGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRoaXMucG9zO1xuICB0aHJvdyBlcnJcbn07XG5cbnBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2U7XG5cbnBwJDQuY3VyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydClcbiAgfVxufTtcblxudmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBPYmplY3QuYXNzaWduIHBvbHlmaWxsXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHNvdXJjZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIHNvdXJjZSA9IGxpc3RbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59O1xuXG4vLyBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGtlZXAgdHJhY2sgb2YgZGVjbGFyZWQgdmFyaWFibGVzIGluIHRoZSBjdXJyZW50IHNjb3BlIGluIG9yZGVyIHRvIGRldGVjdCBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZXMuXG5cbnBwJDUuZW50ZXJGdW5jdGlvblNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIC8vIHZhcjogYSBoYXNoIG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIC8vIGxleGljYWw6IGEgaGFzaCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAvLyBjaGlsZFZhcjogYSBoYXNoIG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiBhbGwgY2hpbGQgbGV4aWNhbCBzY29wZXMgb2YgdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSAod2l0aGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHNjb3BlKVxuICAvLyBwYXJlbnRMZXhpY2FsOiBhIGhhc2ggb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIGFsbCBwYXJlbnQgbGV4aWNhbCBzY29wZXMgb2YgdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSAod2l0aGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uIHNjb3BlKVxuICB0aGlzLnNjb3BlU3RhY2sucHVzaCh7dmFyOiB7fSwgbGV4aWNhbDoge30sIGNoaWxkVmFyOiB7fSwgcGFyZW50TGV4aWNhbDoge319KTtcbn07XG5cbnBwJDUuZXhpdEZ1bmN0aW9uU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xufTtcblxucHAkNS5lbnRlckxleGljYWxTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB2YXIgY2hpbGRTY29wZSA9IHt2YXI6IHt9LCBsZXhpY2FsOiB7fSwgY2hpbGRWYXI6IHt9LCBwYXJlbnRMZXhpY2FsOiB7fX07XG5cbiAgdGhpcy5zY29wZVN0YWNrLnB1c2goY2hpbGRTY29wZSk7XG4gIGFzc2lnbihjaGlsZFNjb3BlLnBhcmVudExleGljYWwsIHBhcmVudFNjb3BlLmxleGljYWwsIHBhcmVudFNjb3BlLnBhcmVudExleGljYWwpO1xufTtcblxucHAkNS5leGl0TGV4aWNhbFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGlsZFNjb3BlID0gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB2YXIgcGFyZW50U2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gIGFzc2lnbihwYXJlbnRTY29wZS5jaGlsZFZhciwgY2hpbGRTY29wZS52YXIsIGNoaWxkU2NvcGUuY2hpbGRWYXIpO1xufTtcblxuLyoqXG4gKiBBIG5hbWUgY2FuIGJlIGRlY2xhcmVkIHdpdGggYHZhcmAgaWYgdGhlcmUgYXJlIG5vIHZhcmlhYmxlcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGVjbGFyZWQgd2l0aCBgbGV0YC9gY29uc3RgXG4gKiBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlIG9yIGFueSBvZiB0aGUgcGFyZW50IGxleGljYWwgc2NvcGVzIGluIHRoaXMgZnVuY3Rpb24uXG4gKi9cbnBwJDUuY2FuRGVjbGFyZVZhck5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjdXJyZW50U2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gIHJldHVybiAhaGFzKGN1cnJlbnRTY29wZS5sZXhpY2FsLCBuYW1lKSAmJiAhaGFzKGN1cnJlbnRTY29wZS5wYXJlbnRMZXhpY2FsLCBuYW1lKVxufTtcblxuLyoqXG4gKiBBIG5hbWUgY2FuIGJlIGRlY2xhcmVkIHdpdGggYGxldGAvYGNvbnN0YCBpZiB0aGVyZSBhcmUgbm8gdmFyaWFibGVzIHdpdGggdGhlIHNhbWUgbmFtZSBkZWNsYXJlZCB3aXRoIGBsZXRgL2Bjb25zdGBcbiAqIGluIHRoZSBjdXJyZW50IHNjb3BlLCBhbmQgdGhlcmUgYXJlIG5vIHZhcmlhYmxlcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGVjbGFyZWQgd2l0aCBgdmFyYCBpbiB0aGUgY3VycmVudCBzY29wZSBvciBpblxuICogYW55IGNoaWxkIGxleGljYWwgc2NvcGVzIGluIHRoaXMgZnVuY3Rpb24uXG4gKi9cbnBwJDUuY2FuRGVjbGFyZUxleGljYWxOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3VycmVudFNjb3BlID0gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcblxuICByZXR1cm4gIWhhcyhjdXJyZW50U2NvcGUubGV4aWNhbCwgbmFtZSkgJiYgIWhhcyhjdXJyZW50U2NvcGUudmFyLCBuYW1lKSAmJiAhaGFzKGN1cnJlbnRTY29wZS5jaGlsZFZhciwgbmFtZSlcbn07XG5cbnBwJDUuZGVjbGFyZVZhck5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV0udmFyW25hbWVdID0gdHJ1ZTtcbn07XG5cbnBwJDUuZGVjbGFyZUxleGljYWxOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdLmxleGljYWxbbmFtZV0gPSB0cnVlO1xufTtcblxudmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgdGhpcy50eXBlID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IHBvcztcbiAgdGhpcy5lbmQgPSAwO1xuICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuICAgIHsgdGhpcy5zb3VyY2VGaWxlID0gcGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwb3MsIDBdOyB9XG59O1xuXG4vLyBTdGFydCBhbiBBU1Qgbm9kZSwgYXR0YWNoaW5nIGEgc3RhcnQgb2Zmc2V0LlxuXG52YXIgcHAkNiA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQ2LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbi8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcbi8vIGdpdmVuIHBvaW50IGluIHRoZSBwcm9ncmFtIGlzIGxvb3NlbHkgYmFzZWQgb24gc3dlZXQuanMnIGFwcHJvYWNoLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cbnZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbn07XG5cbnZhciBwcCQ3ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNy5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3R5cGVzJDEuYl9zdGF0XVxufTtcblxucHAkNy5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmIChwYXJlbnQgPT09IHR5cGVzJDEuZl9leHByIHx8IHBhcmVudCA9PT0gdHlwZXMkMS5mX3N0YXQpXG4gICAgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuY29sb24gJiYgKHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfHwgcGFyZW50ID09PSB0eXBlcyQxLmJfZXhwcikpXG4gICAgeyByZXR1cm4gIXBhcmVudC5pc0V4cHIgfVxuXG4gIC8vIFRoZSBjaGVjayBmb3IgYHR0Lm5hbWUgJiYgZXhwckFsbG93ZWRgIGRldGVjdHMgd2hldGhlciB3ZSBhcmVcbiAgLy8gYWZ0ZXIgYSBgeWllbGRgIG9yIGBvZmAgY29uc3RydWN0LiBTZWUgdGhlIGB1cGRhdGVDb250ZXh0YCBmb3JcbiAgLy8gYHR0Lm5hbWVgLlxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gfHwgcHJldlR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy5leHByQWxsb3dlZClcbiAgICB7IHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fZWxzZSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuc2VtaSB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuZW9mIHx8IHByZXZUeXBlID09PSB0eXBlcy5wYXJlblIgfHwgcHJldlR5cGUgPT09IHR5cGVzLmFycm93KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmJyYWNlTClcbiAgICB7IHJldHVybiBwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fdmFyIHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ3LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzJDEuY29udGV4dFtpXTtcbiAgICBpZiAoY29udGV4dC50b2tlbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxucHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHVwZGF0ZSwgdHlwZSA9IHRoaXMudHlwZTtcbiAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PT0gdHlwZXMuZG90KVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlOyB9XG4gIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICB7IHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKTsgfVxuICBlbHNlXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gdHlwZS5iZWZvcmVFeHByOyB9XG59O1xuXG4vLyBUb2tlbi1zcGVjaWZpYyBjb250ZXh0IHVwZGF0ZSBjb2RlXG5cbnR5cGVzLnBhcmVuUi51cGRhdGVDb250ZXh0ID0gdHlwZXMuYnJhY2VSLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICBpZiAob3V0ID09PSB0eXBlcyQxLmJfc3RhdCAmJiB0aGlzLmN1ckNvbnRleHQoKS50b2tlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpO1xuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSAhb3V0LmlzRXhwcjtcbn07XG5cbnR5cGVzLmJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2socHJldlR5cGUpID8gdHlwZXMkMS5iX3N0YXQgOiB0eXBlcyQxLmJfZXhwcik7XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5iX3RtcGwpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHN0YXRlbWVudFBhcmVucyA9IHByZXZUeXBlID09PSB0eXBlcy5faWYgfHwgcHJldlR5cGUgPT09IHR5cGVzLl9mb3IgfHwgcHJldlR5cGUgPT09IHR5cGVzLl93aXRoIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2hpbGU7XG4gIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzJDEucF9zdGF0IDogdHlwZXMkMS5wX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLmluY0RlYy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHRva0V4cHJBbGxvd2VkIHN0YXlzIHVuY2hhbmdlZFxufTtcblxudHlwZXMuX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5fY2xhc3MudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZS5iZWZvcmVFeHByICYmIHByZXZUeXBlICE9PSB0eXBlcy5zZW1pICYmIHByZXZUeXBlICE9PSB0eXBlcy5fZWxzZSAmJlxuICAgICAgISgocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uIHx8IHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcyQxLmJfc3RhdCkpXG4gICAgeyB0aGlzLmNvbnRleHQucHVzaCh0eXBlcyQxLmZfZXhwcik7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX3N0YXQpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5xX3RtcGwpXG4gICAgeyB0aGlzLmNvbnRleHQucG9wKCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5xX3RtcGwpOyB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTtcbn07XG5cbnR5cGVzLnN0YXIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Z1bmN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKHRoaXMuY29udGV4dFtpbmRleF0gPT09IHR5cGVzJDEuZl9leHByKVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2dlbjsgfVxuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHByZXZUeXBlICE9PSB0eXBlcy5kb3QpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJvZlwiICYmICF0aGlzLmV4cHJBbGxvd2VkIHx8XG4gICAgICAgIHRoaXMudmFsdWUgPT09IFwieWllbGRcIiAmJiB0aGlzLmluR2VuZXJhdG9yQ29udGV4dCgpKVxuICAgICAgeyBhbGxvd2VkID0gdHJ1ZTsgfVxuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSBhbGxvd2VkO1xufTtcblxudmFyIGRhdGEgPSB7XG4gIFwiJExPTkVcIjogW1xuICAgIFwiQVNDSUlcIixcbiAgICBcIkFTQ0lJX0hleF9EaWdpdFwiLFxuICAgIFwiQUhleFwiLFxuICAgIFwiQWxwaGFiZXRpY1wiLFxuICAgIFwiQWxwaGFcIixcbiAgICBcIkFueVwiLFxuICAgIFwiQXNzaWduZWRcIixcbiAgICBcIkJpZGlfQ29udHJvbFwiLFxuICAgIFwiQmlkaV9DXCIsXG4gICAgXCJCaWRpX01pcnJvcmVkXCIsXG4gICAgXCJCaWRpX01cIixcbiAgICBcIkNhc2VfSWdub3JhYmxlXCIsXG4gICAgXCJDSVwiLFxuICAgIFwiQ2FzZWRcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9DYXNlZm9sZGVkXCIsXG4gICAgXCJDV0NGXCIsXG4gICAgXCJDaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZFwiLFxuICAgIFwiQ1dDTVwiLFxuICAgIFwiQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWRcIixcbiAgICBcIkNXTFwiLFxuICAgIFwiQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZFwiLFxuICAgIFwiQ1dLQ0ZcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9UaXRsZWNhc2VkXCIsXG4gICAgXCJDV1RcIixcbiAgICBcIkNoYW5nZXNfV2hlbl9VcHBlcmNhc2VkXCIsXG4gICAgXCJDV1VcIixcbiAgICBcIkRhc2hcIixcbiAgICBcIkRlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnRcIixcbiAgICBcIkRJXCIsXG4gICAgXCJEZXByZWNhdGVkXCIsXG4gICAgXCJEZXBcIixcbiAgICBcIkRpYWNyaXRpY1wiLFxuICAgIFwiRGlhXCIsXG4gICAgXCJFbW9qaVwiLFxuICAgIFwiRW1vamlfQ29tcG9uZW50XCIsXG4gICAgXCJFbW9qaV9Nb2RpZmllclwiLFxuICAgIFwiRW1vamlfTW9kaWZpZXJfQmFzZVwiLFxuICAgIFwiRW1vamlfUHJlc2VudGF0aW9uXCIsXG4gICAgXCJFeHRlbmRlclwiLFxuICAgIFwiRXh0XCIsXG4gICAgXCJHcmFwaGVtZV9CYXNlXCIsXG4gICAgXCJHcl9CYXNlXCIsXG4gICAgXCJHcmFwaGVtZV9FeHRlbmRcIixcbiAgICBcIkdyX0V4dFwiLFxuICAgIFwiSGV4X0RpZ2l0XCIsXG4gICAgXCJIZXhcIixcbiAgICBcIklEU19CaW5hcnlfT3BlcmF0b3JcIixcbiAgICBcIklEU0JcIixcbiAgICBcIklEU19UcmluYXJ5X09wZXJhdG9yXCIsXG4gICAgXCJJRFNUXCIsXG4gICAgXCJJRF9Db250aW51ZVwiLFxuICAgIFwiSURDXCIsXG4gICAgXCJJRF9TdGFydFwiLFxuICAgIFwiSURTXCIsXG4gICAgXCJJZGVvZ3JhcGhpY1wiLFxuICAgIFwiSWRlb1wiLFxuICAgIFwiSm9pbl9Db250cm9sXCIsXG4gICAgXCJKb2luX0NcIixcbiAgICBcIkxvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uXCIsXG4gICAgXCJMT0VcIixcbiAgICBcIkxvd2VyY2FzZVwiLFxuICAgIFwiTG93ZXJcIixcbiAgICBcIk1hdGhcIixcbiAgICBcIk5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50XCIsXG4gICAgXCJOQ2hhclwiLFxuICAgIFwiUGF0dGVybl9TeW50YXhcIixcbiAgICBcIlBhdF9TeW5cIixcbiAgICBcIlBhdHRlcm5fV2hpdGVfU3BhY2VcIixcbiAgICBcIlBhdF9XU1wiLFxuICAgIFwiUXVvdGF0aW9uX01hcmtcIixcbiAgICBcIlFNYXJrXCIsXG4gICAgXCJSYWRpY2FsXCIsXG4gICAgXCJSZWdpb25hbF9JbmRpY2F0b3JcIixcbiAgICBcIlJJXCIsXG4gICAgXCJTZW50ZW5jZV9UZXJtaW5hbFwiLFxuICAgIFwiU1Rlcm1cIixcbiAgICBcIlNvZnRfRG90dGVkXCIsXG4gICAgXCJTRFwiLFxuICAgIFwiVGVybWluYWxfUHVuY3R1YXRpb25cIixcbiAgICBcIlRlcm1cIixcbiAgICBcIlVuaWZpZWRfSWRlb2dyYXBoXCIsXG4gICAgXCJVSWRlb1wiLFxuICAgIFwiVXBwZXJjYXNlXCIsXG4gICAgXCJVcHBlclwiLFxuICAgIFwiVmFyaWF0aW9uX1NlbGVjdG9yXCIsXG4gICAgXCJWU1wiLFxuICAgIFwiV2hpdGVfU3BhY2VcIixcbiAgICBcInNwYWNlXCIsXG4gICAgXCJYSURfQ29udGludWVcIixcbiAgICBcIlhJRENcIixcbiAgICBcIlhJRF9TdGFydFwiLFxuICAgIFwiWElEU1wiXG4gIF0sXG4gIFwiR2VuZXJhbF9DYXRlZ29yeVwiOiBbXG4gICAgXCJDYXNlZF9MZXR0ZXJcIixcbiAgICBcIkxDXCIsXG4gICAgXCJDbG9zZV9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGVcIixcbiAgICBcIkNvbm5lY3Rvcl9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGNcIixcbiAgICBcIkNvbnRyb2xcIixcbiAgICBcIkNjXCIsXG4gICAgXCJjbnRybFwiLFxuICAgIFwiQ3VycmVuY3lfU3ltYm9sXCIsXG4gICAgXCJTY1wiLFxuICAgIFwiRGFzaF9QdW5jdHVhdGlvblwiLFxuICAgIFwiUGRcIixcbiAgICBcIkRlY2ltYWxfTnVtYmVyXCIsXG4gICAgXCJOZFwiLFxuICAgIFwiZGlnaXRcIixcbiAgICBcIkVuY2xvc2luZ19NYXJrXCIsXG4gICAgXCJNZVwiLFxuICAgIFwiRmluYWxfUHVuY3R1YXRpb25cIixcbiAgICBcIlBmXCIsXG4gICAgXCJGb3JtYXRcIixcbiAgICBcIkNmXCIsXG4gICAgXCJJbml0aWFsX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQaVwiLFxuICAgIFwiTGV0dGVyXCIsXG4gICAgXCJMXCIsXG4gICAgXCJMZXR0ZXJfTnVtYmVyXCIsXG4gICAgXCJObFwiLFxuICAgIFwiTGluZV9TZXBhcmF0b3JcIixcbiAgICBcIlpsXCIsXG4gICAgXCJMb3dlcmNhc2VfTGV0dGVyXCIsXG4gICAgXCJMbFwiLFxuICAgIFwiTWFya1wiLFxuICAgIFwiTVwiLFxuICAgIFwiQ29tYmluaW5nX01hcmtcIixcbiAgICBcIk1hdGhfU3ltYm9sXCIsXG4gICAgXCJTbVwiLFxuICAgIFwiTW9kaWZpZXJfTGV0dGVyXCIsXG4gICAgXCJMbVwiLFxuICAgIFwiTW9kaWZpZXJfU3ltYm9sXCIsXG4gICAgXCJTa1wiLFxuICAgIFwiTm9uc3BhY2luZ19NYXJrXCIsXG4gICAgXCJNblwiLFxuICAgIFwiTnVtYmVyXCIsXG4gICAgXCJOXCIsXG4gICAgXCJPcGVuX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQc1wiLFxuICAgIFwiT3RoZXJcIixcbiAgICBcIkNcIixcbiAgICBcIk90aGVyX0xldHRlclwiLFxuICAgIFwiTG9cIixcbiAgICBcIk90aGVyX051bWJlclwiLFxuICAgIFwiTm9cIixcbiAgICBcIk90aGVyX1B1bmN0dWF0aW9uXCIsXG4gICAgXCJQb1wiLFxuICAgIFwiT3RoZXJfU3ltYm9sXCIsXG4gICAgXCJTb1wiLFxuICAgIFwiUGFyYWdyYXBoX1NlcGFyYXRvclwiLFxuICAgIFwiWnBcIixcbiAgICBcIlByaXZhdGVfVXNlXCIsXG4gICAgXCJDb1wiLFxuICAgIFwiUHVuY3R1YXRpb25cIixcbiAgICBcIlBcIixcbiAgICBcInB1bmN0XCIsXG4gICAgXCJTZXBhcmF0b3JcIixcbiAgICBcIlpcIixcbiAgICBcIlNwYWNlX1NlcGFyYXRvclwiLFxuICAgIFwiWnNcIixcbiAgICBcIlNwYWNpbmdfTWFya1wiLFxuICAgIFwiTWNcIixcbiAgICBcIlN1cnJvZ2F0ZVwiLFxuICAgIFwiQ3NcIixcbiAgICBcIlN5bWJvbFwiLFxuICAgIFwiU1wiLFxuICAgIFwiVGl0bGVjYXNlX0xldHRlclwiLFxuICAgIFwiTHRcIixcbiAgICBcIlVuYXNzaWduZWRcIixcbiAgICBcIkNuXCIsXG4gICAgXCJVcHBlcmNhc2VfTGV0dGVyXCIsXG4gICAgXCJMdVwiXG4gIF0sXG4gIFwiU2NyaXB0XCI6IFtcbiAgICBcIkFkbGFtXCIsXG4gICAgXCJBZGxtXCIsXG4gICAgXCJBaG9tXCIsXG4gICAgXCJBbmF0b2xpYW5fSGllcm9nbHlwaHNcIixcbiAgICBcIkhsdXdcIixcbiAgICBcIkFyYWJpY1wiLFxuICAgIFwiQXJhYlwiLFxuICAgIFwiQXJtZW5pYW5cIixcbiAgICBcIkFybW5cIixcbiAgICBcIkF2ZXN0YW5cIixcbiAgICBcIkF2c3RcIixcbiAgICBcIkJhbGluZXNlXCIsXG4gICAgXCJCYWxpXCIsXG4gICAgXCJCYW11bVwiLFxuICAgIFwiQmFtdVwiLFxuICAgIFwiQmFzc2FfVmFoXCIsXG4gICAgXCJCYXNzXCIsXG4gICAgXCJCYXRha1wiLFxuICAgIFwiQmF0a1wiLFxuICAgIFwiQmVuZ2FsaVwiLFxuICAgIFwiQmVuZ1wiLFxuICAgIFwiQmhhaWtzdWtpXCIsXG4gICAgXCJCaGtzXCIsXG4gICAgXCJCb3BvbW9mb1wiLFxuICAgIFwiQm9wb1wiLFxuICAgIFwiQnJhaG1pXCIsXG4gICAgXCJCcmFoXCIsXG4gICAgXCJCcmFpbGxlXCIsXG4gICAgXCJCcmFpXCIsXG4gICAgXCJCdWdpbmVzZVwiLFxuICAgIFwiQnVnaVwiLFxuICAgIFwiQnVoaWRcIixcbiAgICBcIkJ1aGRcIixcbiAgICBcIkNhbmFkaWFuX0Fib3JpZ2luYWxcIixcbiAgICBcIkNhbnNcIixcbiAgICBcIkNhcmlhblwiLFxuICAgIFwiQ2FyaVwiLFxuICAgIFwiQ2F1Y2FzaWFuX0FsYmFuaWFuXCIsXG4gICAgXCJBZ2hiXCIsXG4gICAgXCJDaGFrbWFcIixcbiAgICBcIkNha21cIixcbiAgICBcIkNoYW1cIixcbiAgICBcIkNoZXJva2VlXCIsXG4gICAgXCJDaGVyXCIsXG4gICAgXCJDb21tb25cIixcbiAgICBcIlp5eXlcIixcbiAgICBcIkNvcHRpY1wiLFxuICAgIFwiQ29wdFwiLFxuICAgIFwiUWFhY1wiLFxuICAgIFwiQ3VuZWlmb3JtXCIsXG4gICAgXCJYc3V4XCIsXG4gICAgXCJDeXByaW90XCIsXG4gICAgXCJDcHJ0XCIsXG4gICAgXCJDeXJpbGxpY1wiLFxuICAgIFwiQ3lybFwiLFxuICAgIFwiRGVzZXJldFwiLFxuICAgIFwiRHNydFwiLFxuICAgIFwiRGV2YW5hZ2FyaVwiLFxuICAgIFwiRGV2YVwiLFxuICAgIFwiRHVwbG95YW5cIixcbiAgICBcIkR1cGxcIixcbiAgICBcIkVneXB0aWFuX0hpZXJvZ2x5cGhzXCIsXG4gICAgXCJFZ3lwXCIsXG4gICAgXCJFbGJhc2FuXCIsXG4gICAgXCJFbGJhXCIsXG4gICAgXCJFdGhpb3BpY1wiLFxuICAgIFwiRXRoaVwiLFxuICAgIFwiR2VvcmdpYW5cIixcbiAgICBcIkdlb3JcIixcbiAgICBcIkdsYWdvbGl0aWNcIixcbiAgICBcIkdsYWdcIixcbiAgICBcIkdvdGhpY1wiLFxuICAgIFwiR290aFwiLFxuICAgIFwiR3JhbnRoYVwiLFxuICAgIFwiR3JhblwiLFxuICAgIFwiR3JlZWtcIixcbiAgICBcIkdyZWtcIixcbiAgICBcIkd1amFyYXRpXCIsXG4gICAgXCJHdWpyXCIsXG4gICAgXCJHdXJtdWtoaVwiLFxuICAgIFwiR3VydVwiLFxuICAgIFwiSGFuXCIsXG4gICAgXCJIYW5pXCIsXG4gICAgXCJIYW5ndWxcIixcbiAgICBcIkhhbmdcIixcbiAgICBcIkhhbnVub29cIixcbiAgICBcIkhhbm9cIixcbiAgICBcIkhhdHJhblwiLFxuICAgIFwiSGF0clwiLFxuICAgIFwiSGVicmV3XCIsXG4gICAgXCJIZWJyXCIsXG4gICAgXCJIaXJhZ2FuYVwiLFxuICAgIFwiSGlyYVwiLFxuICAgIFwiSW1wZXJpYWxfQXJhbWFpY1wiLFxuICAgIFwiQXJtaVwiLFxuICAgIFwiSW5oZXJpdGVkXCIsXG4gICAgXCJaaW5oXCIsXG4gICAgXCJRYWFpXCIsXG4gICAgXCJJbnNjcmlwdGlvbmFsX1BhaGxhdmlcIixcbiAgICBcIlBobGlcIixcbiAgICBcIkluc2NyaXB0aW9uYWxfUGFydGhpYW5cIixcbiAgICBcIlBydGlcIixcbiAgICBcIkphdmFuZXNlXCIsXG4gICAgXCJKYXZhXCIsXG4gICAgXCJLYWl0aGlcIixcbiAgICBcIkt0aGlcIixcbiAgICBcIkthbm5hZGFcIixcbiAgICBcIktuZGFcIixcbiAgICBcIkthdGFrYW5hXCIsXG4gICAgXCJLYW5hXCIsXG4gICAgXCJLYXlhaF9MaVwiLFxuICAgIFwiS2FsaVwiLFxuICAgIFwiS2hhcm9zaHRoaVwiLFxuICAgIFwiS2hhclwiLFxuICAgIFwiS2htZXJcIixcbiAgICBcIktobXJcIixcbiAgICBcIktob2praVwiLFxuICAgIFwiS2hvalwiLFxuICAgIFwiS2h1ZGF3YWRpXCIsXG4gICAgXCJTaW5kXCIsXG4gICAgXCJMYW9cIixcbiAgICBcIkxhb29cIixcbiAgICBcIkxhdGluXCIsXG4gICAgXCJMYXRuXCIsXG4gICAgXCJMZXBjaGFcIixcbiAgICBcIkxlcGNcIixcbiAgICBcIkxpbWJ1XCIsXG4gICAgXCJMaW1iXCIsXG4gICAgXCJMaW5lYXJfQVwiLFxuICAgIFwiTGluYVwiLFxuICAgIFwiTGluZWFyX0JcIixcbiAgICBcIkxpbmJcIixcbiAgICBcIkxpc3VcIixcbiAgICBcIkx5Y2lhblwiLFxuICAgIFwiTHljaVwiLFxuICAgIFwiTHlkaWFuXCIsXG4gICAgXCJMeWRpXCIsXG4gICAgXCJNYWhhamFuaVwiLFxuICAgIFwiTWFoalwiLFxuICAgIFwiTWFsYXlhbGFtXCIsXG4gICAgXCJNbHltXCIsXG4gICAgXCJNYW5kYWljXCIsXG4gICAgXCJNYW5kXCIsXG4gICAgXCJNYW5pY2hhZWFuXCIsXG4gICAgXCJNYW5pXCIsXG4gICAgXCJNYXJjaGVuXCIsXG4gICAgXCJNYXJjXCIsXG4gICAgXCJNYXNhcmFtX0dvbmRpXCIsXG4gICAgXCJHb25tXCIsXG4gICAgXCJNZWV0ZWlfTWF5ZWtcIixcbiAgICBcIk10ZWlcIixcbiAgICBcIk1lbmRlX0tpa2FrdWlcIixcbiAgICBcIk1lbmRcIixcbiAgICBcIk1lcm9pdGljX0N1cnNpdmVcIixcbiAgICBcIk1lcmNcIixcbiAgICBcIk1lcm9pdGljX0hpZXJvZ2x5cGhzXCIsXG4gICAgXCJNZXJvXCIsXG4gICAgXCJNaWFvXCIsXG4gICAgXCJQbHJkXCIsXG4gICAgXCJNb2RpXCIsXG4gICAgXCJNb25nb2xpYW5cIixcbiAgICBcIk1vbmdcIixcbiAgICBcIk1yb1wiLFxuICAgIFwiTXJvb1wiLFxuICAgIFwiTXVsdGFuaVwiLFxuICAgIFwiTXVsdFwiLFxuICAgIFwiTXlhbm1hclwiLFxuICAgIFwiTXltclwiLFxuICAgIFwiTmFiYXRhZWFuXCIsXG4gICAgXCJOYmF0XCIsXG4gICAgXCJOZXdfVGFpX0x1ZVwiLFxuICAgIFwiVGFsdVwiLFxuICAgIFwiTmV3YVwiLFxuICAgIFwiTmtvXCIsXG4gICAgXCJOa29vXCIsXG4gICAgXCJOdXNodVwiLFxuICAgIFwiTnNodVwiLFxuICAgIFwiT2doYW1cIixcbiAgICBcIk9nYW1cIixcbiAgICBcIk9sX0NoaWtpXCIsXG4gICAgXCJPbGNrXCIsXG4gICAgXCJPbGRfSHVuZ2FyaWFuXCIsXG4gICAgXCJIdW5nXCIsXG4gICAgXCJPbGRfSXRhbGljXCIsXG4gICAgXCJJdGFsXCIsXG4gICAgXCJPbGRfTm9ydGhfQXJhYmlhblwiLFxuICAgIFwiTmFyYlwiLFxuICAgIFwiT2xkX1Blcm1pY1wiLFxuICAgIFwiUGVybVwiLFxuICAgIFwiT2xkX1BlcnNpYW5cIixcbiAgICBcIlhwZW9cIixcbiAgICBcIk9sZF9Tb3V0aF9BcmFiaWFuXCIsXG4gICAgXCJTYXJiXCIsXG4gICAgXCJPbGRfVHVya2ljXCIsXG4gICAgXCJPcmtoXCIsXG4gICAgXCJPcml5YVwiLFxuICAgIFwiT3J5YVwiLFxuICAgIFwiT3NhZ2VcIixcbiAgICBcIk9zZ2VcIixcbiAgICBcIk9zbWFueWFcIixcbiAgICBcIk9zbWFcIixcbiAgICBcIlBhaGF3aF9IbW9uZ1wiLFxuICAgIFwiSG1uZ1wiLFxuICAgIFwiUGFsbXlyZW5lXCIsXG4gICAgXCJQYWxtXCIsXG4gICAgXCJQYXVfQ2luX0hhdVwiLFxuICAgIFwiUGF1Y1wiLFxuICAgIFwiUGhhZ3NfUGFcIixcbiAgICBcIlBoYWdcIixcbiAgICBcIlBob2VuaWNpYW5cIixcbiAgICBcIlBobnhcIixcbiAgICBcIlBzYWx0ZXJfUGFobGF2aVwiLFxuICAgIFwiUGhscFwiLFxuICAgIFwiUmVqYW5nXCIsXG4gICAgXCJSam5nXCIsXG4gICAgXCJSdW5pY1wiLFxuICAgIFwiUnVuclwiLFxuICAgIFwiU2FtYXJpdGFuXCIsXG4gICAgXCJTYW1yXCIsXG4gICAgXCJTYXVyYXNodHJhXCIsXG4gICAgXCJTYXVyXCIsXG4gICAgXCJTaGFyYWRhXCIsXG4gICAgXCJTaHJkXCIsXG4gICAgXCJTaGF2aWFuXCIsXG4gICAgXCJTaGF3XCIsXG4gICAgXCJTaWRkaGFtXCIsXG4gICAgXCJTaWRkXCIsXG4gICAgXCJTaWduV3JpdGluZ1wiLFxuICAgIFwiU2dud1wiLFxuICAgIFwiU2luaGFsYVwiLFxuICAgIFwiU2luaFwiLFxuICAgIFwiU29yYV9Tb21wZW5nXCIsXG4gICAgXCJTb3JhXCIsXG4gICAgXCJTb3lvbWJvXCIsXG4gICAgXCJTb3lvXCIsXG4gICAgXCJTdW5kYW5lc2VcIixcbiAgICBcIlN1bmRcIixcbiAgICBcIlN5bG90aV9OYWdyaVwiLFxuICAgIFwiU3lsb1wiLFxuICAgIFwiU3lyaWFjXCIsXG4gICAgXCJTeXJjXCIsXG4gICAgXCJUYWdhbG9nXCIsXG4gICAgXCJUZ2xnXCIsXG4gICAgXCJUYWdiYW53YVwiLFxuICAgIFwiVGFnYlwiLFxuICAgIFwiVGFpX0xlXCIsXG4gICAgXCJUYWxlXCIsXG4gICAgXCJUYWlfVGhhbVwiLFxuICAgIFwiTGFuYVwiLFxuICAgIFwiVGFpX1ZpZXRcIixcbiAgICBcIlRhdnRcIixcbiAgICBcIlRha3JpXCIsXG4gICAgXCJUYWtyXCIsXG4gICAgXCJUYW1pbFwiLFxuICAgIFwiVGFtbFwiLFxuICAgIFwiVGFuZ3V0XCIsXG4gICAgXCJUYW5nXCIsXG4gICAgXCJUZWx1Z3VcIixcbiAgICBcIlRlbHVcIixcbiAgICBcIlRoYWFuYVwiLFxuICAgIFwiVGhhYVwiLFxuICAgIFwiVGhhaVwiLFxuICAgIFwiVGliZXRhblwiLFxuICAgIFwiVGlidFwiLFxuICAgIFwiVGlmaW5hZ2hcIixcbiAgICBcIlRmbmdcIixcbiAgICBcIlRpcmh1dGFcIixcbiAgICBcIlRpcmhcIixcbiAgICBcIlVnYXJpdGljXCIsXG4gICAgXCJVZ2FyXCIsXG4gICAgXCJWYWlcIixcbiAgICBcIlZhaWlcIixcbiAgICBcIldhcmFuZ19DaXRpXCIsXG4gICAgXCJXYXJhXCIsXG4gICAgXCJZaVwiLFxuICAgIFwiWWlpaVwiLFxuICAgIFwiWmFuYWJhemFyX1NxdWFyZVwiLFxuICAgIFwiWmFuYlwiXG4gIF1cbn07XG5BcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkYXRhLiRMT05FLCBkYXRhLkdlbmVyYWxfQ2F0ZWdvcnkpO1xuZGF0YS5nYyA9IGRhdGEuR2VuZXJhbF9DYXRlZ29yeTtcbmRhdGEuc2MgPSBkYXRhLlNjcmlwdF9FeHRlbnNpb25zID0gZGF0YS5zY3ggPSBkYXRhLlNjcmlwdDtcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG52YXIgUmVnRXhwVmFsaWRhdGlvblN0YXRlID0gZnVuY3Rpb24gUmVnRXhwVmFsaWRhdGlvblN0YXRlKHBhcnNlcikge1xuICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgdGhpcy52YWxpZEZsYWdzID0gXCJnaW1cIiArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gXCJ1eVwiIDogXCJcIikgKyAocGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSA/IFwic1wiIDogXCJcIik7XG4gIHRoaXMuc291cmNlID0gXCJcIjtcbiAgdGhpcy5mbGFncyA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLnN3aXRjaFUgPSBmYWxzZTtcbiAgdGhpcy5zd2l0Y2hOID0gZmFsc2U7XG4gIHRoaXMucG9zID0gMDtcbiAgdGhpcy5sYXN0SW50VmFsdWUgPSAwO1xuICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgdGhpcy5tYXhCYWNrUmVmZXJlbmNlID0gMDtcbiAgdGhpcy5ncm91cE5hbWVzID0gW107XG4gIHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzID0gW107XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKHN0YXJ0LCBwYXR0ZXJuLCBmbGFncykge1xuICB2YXIgdW5pY29kZSA9IGZsYWdzLmluZGV4T2YoXCJ1XCIpICE9PSAtMTtcbiAgdGhpcy5zdGFydCA9IHN0YXJ0IHwgMDtcbiAgdGhpcy5zb3VyY2UgPSBwYXR0ZXJuICsgXCJcIjtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB0aGlzLnN3aXRjaFUgPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgdGhpcy5zd2l0Y2hOID0gdW5pY29kZSAmJiB0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLnJhaXNlID0gZnVuY3Rpb24gcmFpc2UgKG1lc3NhZ2UpIHtcbiAgdGhpcy5wYXJzZXIucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCAoXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogL1wiICsgKHRoaXMuc291cmNlKSArIFwiLzogXCIgKyBtZXNzYWdlKSk7XG59O1xuXG4vLyBJZiB1IGZsYWcgaXMgZ2l2ZW4sIHRoaXMgcmV0dXJucyB0aGUgY29kZSBwb2ludCBhdCB0aGUgaW5kZXggKGl0IGNvbWJpbmVzIGEgc3Vycm9nYXRlIHBhaXIpLlxuLy8gT3RoZXJ3aXNlLCB0aGlzIHJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiB0aGUgaW5kZXggKGNhbiBiZSBhIHBhcnQgb2YgYSBzdXJyb2dhdGUgcGFpcikuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gYXQgKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICBpZiAoIXRoaXMuc3dpdGNoVSB8fCBjIDw9IDB4RDdGRiB8fCBjID49IDB4RTAwMCB8fCBpICsgMSA+PSBsKSB7XG4gICAgcmV0dXJuIGNcbiAgfVxuICByZXR1cm4gKGMgPDwgMTApICsgcy5jaGFyQ29kZUF0KGkgKyAxKSAtIDB4MzVGREMwMFxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5uZXh0SW5kZXggPSBmdW5jdGlvbiBuZXh0SW5kZXggKGkpIHtcbiAgdmFyIHMgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgaWYgKGkgPj0gbCkge1xuICAgIHJldHVybiBsXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICByZXR1cm4gaSArIDFcbiAgfVxuICByZXR1cm4gaSArIDJcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQgKCkge1xuICByZXR1cm4gdGhpcy5hdCh0aGlzLnBvcylcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUubG9va2FoZWFkID0gZnVuY3Rpb24gbG9va2FoZWFkICgpIHtcbiAgcmV0dXJuIHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gYWR2YW5jZSAoKSB7XG4gIHRoaXMucG9zID0gdGhpcy5uZXh0SW5kZXgodGhpcy5wb3MpO1xufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiBlYXQgKGNoKSB7XG4gIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gY2gpIHtcbiAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmckMShjaCkge1xuICBpZiAoY2ggPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSB9XG4gIGNoIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDkudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICB0aGlzJDEucmFpc2Uoc3RhdGUuc3RhcnQsIFwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmluZGV4T2YoZmxhZywgaSArIDEpID4gLTEpIHtcbiAgICAgIHRoaXMkMS5yYWlzZShzdGF0ZS5zdGFydCwgXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBwYXR0ZXJuIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDkudmFsaWRhdGVSZWdFeHBQYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG5cbiAgLy8gVGhlIGdvYWwgc3ltYm9sIGZvciB0aGUgcGFyc2UgaXMgfFBhdHRlcm5bflUsIH5OXXwuIElmIHRoZSByZXN1bHQgb2ZcbiAgLy8gcGFyc2luZyBjb250YWlucyBhIHxHcm91cE5hbWV8LCByZXBhcnNlIHdpdGggdGhlIGdvYWwgc3ltYm9sXG4gIC8vIHxQYXR0ZXJuW35VLCArTl18IGFuZCB1c2UgdGhpcyByZXN1bHQgaW5zdGVhZC4gVGhyb3cgYSAqU3ludGF4RXJyb3IqXG4gIC8vIGV4Y2VwdGlvbiBpZiBfUF8gZGlkIG5vdCBjb25mb3JtIHRvIHRoZSBncmFtbWFyLCBpZiBhbnkgZWxlbWVudHMgb2YgX1BfXG4gIC8vIHdlcmUgbm90IG1hdGNoZWQgYnkgdGhlIHBhcnNlLCBvciBpZiBhbnkgRWFybHkgRXJyb3IgY29uZGl0aW9ucyBleGlzdC5cbiAgaWYgKCFzdGF0ZS5zd2l0Y2hOICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID4gMCkge1xuICAgIHN0YXRlLnN3aXRjaE4gPSB0cnVlO1xuICAgIHRoaXMucmVnZXhwX3BhdHRlcm4oc3RhdGUpO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1QYXR0ZXJuXG5wcCQ5LnJlZ2V4cF9wYXR0ZXJuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUucG9zID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG4gIHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucyA9IDA7XG4gIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICBzdGF0ZS5ncm91cE5hbWVzLmxlbmd0aCA9IDA7XG4gIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGggPSAwO1xuXG4gIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcblxuICBpZiAoc3RhdGUucG9zICE9PSBzdGF0ZS5zb3VyY2UubGVuZ3RoKSB7XG4gICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlcyBhcyBWOC5cbiAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiVW5tYXRjaGVkICcpJ1wiKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIFsgKi8pIHx8IHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPiBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBuYW1lID0gbGlzdFtpXTtcblxuICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGlzanVuY3Rpb25cbnBwJDkucmVnZXhwX2Rpc2p1bmN0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoc3RhdGUpO1xuICB3aGlsZSAoc3RhdGUuZWF0KDB4N0MgLyogfCAqLykpIHtcbiAgICB0aGlzJDEucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgfVxuXG4gIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQWx0ZXJuYXRpdmVcbnBwJDkucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgeyAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLVRlcm1cbnBwJDkucmVnZXhwX2VhdFRlcm0gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0QXNzZXJ0aW9uKHN0YXRlKSkge1xuICAgIC8vIEhhbmRsZSBgUXVhbnRpZmlhYmxlQXNzZXJ0aW9uIFF1YW50aWZpZXJgIGFsdGVybmF0aXZlLlxuICAgIC8vIGBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGVgIGlzIHRydWUgaWYgdGhlIGxhc3QgZWF0ZW4gQXNzZXJ0aW9uXG4gICAgLy8gaXMgYSBRdWFudGlmaWFibGVBc3NlcnRpb24uXG4gICAgaWYgKHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZSAmJiB0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKHN0YXRlKSkge1xuICAgICAgLy8gTWFrZSB0aGUgc2FtZSBtZXNzYWdlIGFzIFY4LlxuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHF1YW50aWZpZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoc3RhdGUuc3dpdGNoVSA/IHRoaXMucmVnZXhwX2VhdEF0b20oc3RhdGUpIDogdGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKHN0YXRlKSkge1xuICAgIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1Bc3NlcnRpb25cbnBwJDkucmVnZXhwX2VhdEFzc2VydGlvbiA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gZmFsc2U7XG5cbiAgLy8gXiwgJFxuICBpZiAoc3RhdGUuZWF0KDB4NUUgLyogXiAqLykgfHwgc3RhdGUuZWF0KDB4MjQgLyogJCAqLykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gXFxiIFxcQlxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDQyIC8qIEIgKi8pIHx8IHN0YXRlLmVhdCgweDYyIC8qIGIgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIC8vIExvb2thaGVhZCAvIExvb2tiZWhpbmRcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pICYmIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgdmFyIGxvb2tiZWhpbmQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICAgIGxvb2tiZWhpbmQgPSBzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmVhdCgweDNEIC8qID0gKi8pIHx8IHN0YXRlLmVhdCgweDIxIC8qICEgKi8pKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoIXN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlID0gIWxvb2tiZWhpbmQ7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVF1YW50aWZpZXJcbnBwJDkucmVnZXhwX2VhdFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICBpZiAoIG5vRXJyb3IgPT09IHZvaWQgMCApIG5vRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChzdGF0ZSwgbm9FcnJvcikpIHtcbiAgICBzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclByZWZpeFxucHAkOS5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeCA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGUuZWF0KDB4MkEgLyogKiAqLykgfHxcbiAgICBzdGF0ZS5lYXQoMHgyQiAvKiArICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgbm9FcnJvcilcbiAgKVxufTtcbnBwJDkucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSwgbm9FcnJvcikge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSkge1xuICAgIHZhciBtaW4gPSAwLCBtYXggPSAtMTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhzdGF0ZSkpIHtcbiAgICAgIG1pbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyQyAvKiAsICovKSAmJiB0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgICBtYXggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgICAgLy8gU3ludGF4RXJyb3IgaW4gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3NlYy10ZXJtXG4gICAgICAgIGlmIChtYXggIT09IC0xICYmIG1heCA8IG1pbiAmJiAhbm9FcnJvcikge1xuICAgICAgICAgIHN0YXRlLnJhaXNlKFwibnVtYmVycyBvdXQgb2Ygb3JkZXIgaW4ge30gcXVhbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAhbm9FcnJvcikge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbmNvbXBsZXRlIHF1YW50aWZpZXJcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQXRvbVxucHAkOS5yZWdleHBfZWF0QXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoc3RhdGUpIHx8XG4gICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSlcbiAgKVxufTtcbnBwJDkucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRBdG9tRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOS5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pICYmIHN0YXRlLmVhdCgweDNBIC8qIDogKi8pKSB7XG4gICAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ5LnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHgyOCAvKiAoICovKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgdGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDNGIC8qID8gKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgICB9XG4gICAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zICs9IDE7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIlVudGVybWluYXRlZCBncm91cFwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZEF0b21cbnBwJDkucmVnZXhwX2VhdEV4dGVuZGVkQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGUuZWF0KDB4MkUgLyogLiAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3Moc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXIoc3RhdGUpXG4gIClcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JbnZhbGlkQnJhY2VkUXVhbnRpZmllclxucHAkOS5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihzdGF0ZSwgdHJ1ZSkpIHtcbiAgICBzdGF0ZS5yYWlzZShcIk5vdGhpbmcgdG8gcmVwZWF0XCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtU3ludGF4Q2hhcmFjdGVyXG5wcCQ5LnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1N5bnRheENoYXJhY3RlcihjaCkge1xuICByZXR1cm4gKFxuICAgIGNoID09PSAweDI0IC8qICQgKi8gfHxcbiAgICBjaCA+PSAweDI4IC8qICggKi8gJiYgY2ggPD0gMHgyQiAvKiArICovIHx8XG4gICAgY2ggPT09IDB4MkUgLyogLiAqLyB8fFxuICAgIGNoID09PSAweDNGIC8qID8gKi8gfHxcbiAgICBjaCA+PSAweDVCIC8qIFsgKi8gJiYgY2ggPD0gMHg1RSAvKiBeICovIHx8XG4gICAgY2ggPj0gMHg3QiAvKiB7ICovICYmIGNoIDw9IDB4N0QgLyogfSAqL1xuICApXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5DaGFyYWN0ZXJcbi8vIEJ1dCBlYXQgZWFnZXIuXG5wcCQ5LnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgd2hpbGUgKChjaCA9IHN0YXRlLmN1cnJlbnQoKSkgIT09IC0xICYmICFpc1N5bnRheENoYXJhY3RlcihjaCkpIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1FeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXJcbnBwJDkucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKFxuICAgIGNoICE9PSAtMSAmJlxuICAgIGNoICE9PSAweDI0IC8qICQgKi8gJiZcbiAgICAhKGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8pICYmXG4gICAgY2ggIT09IDB4MkUgLyogLiAqLyAmJlxuICAgIGNoICE9PSAweDNGIC8qID8gKi8gJiZcbiAgICBjaCAhPT0gMHg1QiAvKiBbICovICYmXG4gICAgY2ggIT09IDB4NUUgLyogXiAqLyAmJlxuICAgIGNoICE9PSAweDdDIC8qIHwgKi9cbiAgKSB7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBHcm91cFNwZWNpZmllcltVXSA6OlxuLy8gICBbZW1wdHldXG4vLyAgIGA/YCBHcm91cE5hbWVbP1VdXG5wcCQ5LnJlZ2V4cF9ncm91cFNwZWNpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHgzRiAvKiA/ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBpZiAoc3RhdGUuZ3JvdXBOYW1lcy5pbmRleE9mKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiRHVwbGljYXRlIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmdyb3VwTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBncm91cFwiKTtcbiAgfVxufTtcblxuLy8gR3JvdXBOYW1lW1VdIDo6XG4vLyAgIGA8YCBSZWdFeHBJZGVudGlmaWVyTmFtZVs/VV0gYD5gXG4vLyBOb3RlOiB0aGlzIHVwZGF0ZXMgYHN0YXRlLmxhc3RTdHJpbmdWYWx1ZWAgcHJvcGVydHkgd2l0aCB0aGUgZWF0ZW4gbmFtZS5cbnBwJDkucmVnZXhwX2VhdEdyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmIChzdGF0ZS5lYXQoMHgzQyAvKiA8ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShzdGF0ZSkgJiYgc3RhdGUuZWF0KDB4M0UgLyogPiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjYXB0dXJlIGdyb3VwIG5hbWVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyTmFtZVtVXSA6OlxuLy8gICBSZWdFeHBJZGVudGlmaWVyU3RhcnRbP1VdXG4vLyAgIFJlZ0V4cElkZW50aWZpZXJOYW1lWz9VXSBSZWdFeHBJZGVudGlmaWVyUGFydFs/VV1cbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkOS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllck5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBpZiAodGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0KHN0YXRlKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyQxKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nJDEoc3RhdGUubGFzdEludFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJTdGFydFtVXSA6OlxuLy8gICBVbmljb2RlSURTdGFydFxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWz9VXVxucHAkOS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclN0YXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIHN0YXRlLmFkdmFuY2UoKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzUmVnRXhwSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJTdGFydChjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJQYXJ0W1VdIDo6XG4vLyAgIFVuaWNvZGVJRENvbnRpbnVlXG4vLyAgIGAkYFxuLy8gICBgX2Bcbi8vICAgYFxcYCBSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VbP1VdXG4vLyAgIDxaV05KPlxuLy8gICA8WldKPlxucHAkOS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgc3RhdGUuYWR2YW5jZSgpO1xuXG4gIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLyAmJiB0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2Uoc3RhdGUpKSB7XG4gICAgY2ggPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gIH1cbiAgaWYgKGlzUmVnRXhwSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBpc0lkZW50aWZpZXJDaGFyKGNoLCB0cnVlKSB8fCBjaCA9PT0gMHgyNCAvKiAkICovIHx8IGNoID09PSAweDVGIC8qIF8gKi8gfHwgY2ggPT09IDB4MjAwQyAvKiA8WldOSj4gKi8gfHwgY2ggPT09IDB4MjAwRCAvKiA8WldKPiAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQXRvbUVzY2FwZVxucHAkOS5yZWdleHBfZWF0QXRvbUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSkgfHxcbiAgICAoc3RhdGUuc3dpdGNoTiAmJiB0aGlzLnJlZ2V4cF9lYXRLR3JvdXBOYW1lKHN0YXRlKSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDYzIC8qIGMgKi8pIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZVwiKTtcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGVzY2FwZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ5LnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAodGhpcy5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZShzdGF0ZSkpIHtcbiAgICB2YXIgbiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgLy8gRm9yIFN5bnRheEVycm9yIGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNzZWMtYXRvbWVzY2FwZVxuICAgICAgaWYgKG4gPiBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlKSB7XG4gICAgICAgIHN0YXRlLm1heEJhY2tSZWZlcmVuY2UgPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKG4gPD0gc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ5LnJlZ2V4cF9lYXRLR3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDZCIC8qIGsgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgbmFtZWQgcmVmZXJlbmNlXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNoYXJhY3RlckVzY2FwZVxucHAkOS5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFplcm8oc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2Uoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgICghc3RhdGUuc3dpdGNoVSAmJiB0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKHN0YXRlKSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShzdGF0ZSlcbiAgKVxufTtcbnBwJDkucmVnZXhwX2VhdENDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q29udHJvbExldHRlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDkucmVnZXhwX2VhdFplcm8gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuY3VycmVudCgpID09PSAweDMwIC8qIDAgKi8gJiYgIWlzRGVjaW1hbERpZ2l0KHN0YXRlLmxvb2thaGVhZCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sRXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPT09IDB4NzQgLyogdCAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDk7IC8qIFxcdCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg2RSAvKiBuICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQTsgLyogXFxuICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDc2IC8qIHYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBCOyAvKiBcXHYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NjYgLyogZiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEM7IC8qIFxcZiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3MiAvKiByICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwRDsgLyogXFxyICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1Db250cm9sTGV0dGVyXG5wcCQ5LnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNDb250cm9sTGV0dGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NUEgLyogWiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4N0EgLyogeiAqLylcbiAgKVxufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1SZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VcbnBwJDkucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NzUgLyogdSAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoc3RhdGUsIDQpKSB7XG4gICAgICB2YXIgbGVhZCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmIGxlYWQgPj0gMHhEODAwICYmIGxlYWQgPD0gMHhEQkZGKSB7XG4gICAgICAgIHZhciBsZWFkU3Vycm9nYXRlRW5kID0gc3RhdGUucG9zO1xuICAgICAgICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pICYmIHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pICYmIHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgICAgIHZhciB0cmFpbCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgICAgICBpZiAodHJhaWwgPj0gMHhEQzAwICYmIHRyYWlsIDw9IDB4REZGRikge1xuICAgICAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyA9IGxlYWRTdXJyb2dhdGVFbmQ7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGxlYWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3QiAvKiB7ICovKSAmJlxuICAgICAgdGhpcy5yZWdleHBfZWF0SGV4RGlnaXRzKHN0YXRlKSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykgJiZcbiAgICAgIGlzVmFsaWRVbmljb2RlKHN0YXRlLmxhc3RJbnRWYWx1ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNWYWxpZFVuaWNvZGUoY2gpIHtcbiAgcmV0dXJuIGNoID49IDAgJiYgY2ggPD0gMHgxMEZGRkZcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUlkZW50aXR5RXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5lYXQoMHgyRiAvKiAvICovKSkge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRjsgLyogLyAqL1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChjaCAhPT0gMHg2MyAvKiBjICovICYmICghc3RhdGUuc3dpdGNoTiB8fCBjaCAhPT0gMHg2QiAvKiBrICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EZWNpbWFsRXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggPj0gMHgzMSAvKiAxICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykge1xuICAgIGRvIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICB9IHdoaWxlICgoY2ggPSBzdGF0ZS5jdXJyZW50KCkpID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNoYXJhY3RlckNsYXNzRXNjYXBlXG5wcCQ5LnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcblxuICBpZiAoaXNDaGFyYWN0ZXJDbGFzc0VzY2FwZShjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChcbiAgICBzdGF0ZS5zd2l0Y2hVICYmXG4gICAgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiZcbiAgICAoY2ggPT09IDB4NTAgLyogUCAqLyB8fCBjaCA9PT0gMHg3MCAvKiBwICovKVxuICApIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAtMTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgaWYgKFxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIChcbiAgICBjaCA9PT0gMHg2NCAvKiBkICovIHx8XG4gICAgY2ggPT09IDB4NDQgLyogRCAqLyB8fFxuICAgIGNoID09PSAweDczIC8qIHMgKi8gfHxcbiAgICBjaCA9PT0gMHg1MyAvKiBTICovIHx8XG4gICAgY2ggPT09IDB4NzcgLyogdyAqLyB8fFxuICAgIGNoID09PSAweDU3IC8qIFcgKi9cbiAgKVxufVxuXG4vLyBVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbi8vICAgTG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlXG5wcCQ5LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgLy8gVW5pY29kZVByb3BlcnR5TmFtZSBgPWAgVW5pY29kZVByb3BlcnR5VmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoc3RhdGUpICYmIHN0YXRlLmVhdCgweDNEIC8qID0gKi8pKSB7XG4gICAgdmFyIG5hbWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKHN0YXRlKSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoc3RhdGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuXG4gIC8vIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxuICBpZiAodGhpcy5yZWdleHBfZWF0TG9uZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlKSkge1xuICAgIHZhciBuYW1lT3JWYWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKHN0YXRlLCBuYW1lT3JWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ5LnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgZGF0YVtuYW1lXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcHJvcGVydHkgbmFtZVwiKTtcbiAgfVxufTtcbnBwJDkucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZU9yVmFsdWUpIHtcbiAgaWYgKGRhdGEuJExPTkUuaW5kZXhPZihuYW1lT3JWYWx1ZSkgPT09IC0xKSB7XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cbn07XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcnNcbnBwJDkucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSAhPT0gXCJcIlxufTtcbmZ1bmN0aW9uIGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCkge1xuICByZXR1cm4gaXNDb250cm9sTGV0dGVyKGNoKSB8fCBjaCA9PT0gMHg1RiAvKiBfICovXG59XG5cbi8vIFVuaWNvZGVQcm9wZXJ0eVZhbHVlIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyc1xucHAkOS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICB3aGlsZSAoaXNVbmljb2RlUHJvcGVydHlWYWx1ZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmckMShjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxufVxuXG4vLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQ5LnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc1xucHAkOS5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICBzdGF0ZS5lYXQoMHg1RSAvKiBeICovKTtcbiAgICB0aGlzLnJlZ2V4cF9jbGFzc1JhbmdlcyhzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIFsgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBVbnJlYWNoYWJsZSBzaW5jZSBpdCB0aHJldyBcInVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiBlcnJvciBiZWZvcmUuXG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbnBwJDkucmVnZXhwX2NsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcyQxLnJlZ2V4cF9lYXRDbGFzc0F0b20oc3RhdGUpKSB7XG4gICAgICB2YXIgcmlnaHQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiAobGVmdCA9PT0gLTEgfHwgcmlnaHQgPT09IC0xKSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgIT09IC0xICYmIHJpZ2h0ICE9PSAtMSAmJiBsZWZ0ID4gcmlnaHQpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DbGFzc0F0b21Ob0Rhc2hcbnBwJDkucmVnZXhwX2VhdENsYXNzQXRvbSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgICAgIHZhciBjaCQxID0gc3RhdGUuY3VycmVudCgpO1xuICAgICAgaWYgKGNoJDEgPT09IDB4NjMgLyogYyAqLyB8fCBpc09jdGFsRGlnaXQoY2gkMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNsYXNzIGVzY2FwZVwiKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NUQgLyogWyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NFc2NhcGVcbnBwJDkucmVnZXhwX2VhdENsYXNzRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5lYXQoMHg2MiAvKiBiICovKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MDg7IC8qIDxCUz4gKi9cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4MkQgLyogLSAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDJEOyAvKiAtICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmICghc3RhdGUuc3dpdGNoVSAmJiBzdGF0ZS5lYXQoMHg2MyAvKiBjICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoc3RhdGUpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKHN0YXRlKVxuICApXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItQ2xhc3NDb250cm9sTGV0dGVyXG5wcCQ5LnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkgfHwgY2ggPT09IDB4NUYgLyogXyAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoICUgMHgyMDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQ5LnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDc4IC8qIHggKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbERpZ2l0c1xucHAkOS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDEwICogc3RhdGUubGFzdEludFZhbHVlICsgKGNoIC0gMHgzMCAvKiAwICovKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnBvcyAhPT0gc3RhcnRcbn07XG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdHNcbnBwJDkucmVnZXhwX2VhdEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgd2hpbGUgKGlzSGV4RGlnaXQoY2ggPSBzdGF0ZS5jdXJyZW50KCkpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMTYgKiBzdGF0ZS5sYXN0SW50VmFsdWUgKyBoZXhUb0ludChjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICByZXR1cm4gKFxuICAgIChjaCA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKSB8fFxuICAgIChjaCA+PSAweDQxIC8qIEEgKi8gJiYgY2ggPD0gMHg0NiAvKiBGICovKSB8fFxuICAgIChjaCA+PSAweDYxIC8qIGEgKi8gJiYgY2ggPD0gMHg2NiAvKiBmICovKVxuICApXG59XG5mdW5jdGlvbiBoZXhUb0ludChjaCkge1xuICBpZiAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NDEgLyogQSAqLylcbiAgfVxuICBpZiAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLykge1xuICAgIHJldHVybiAxMCArIChjaCAtIDB4NjEgLyogYSAqLylcbiAgfVxuICByZXR1cm4gY2ggLSAweDMwIC8qIDAgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUxlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2Vcbi8vIEFsbG93cyBvbmx5IDAtMzc3KG9jdGFsKSBpLmUuIDAtMjU1KGRlY2ltYWwpLlxucHAkOS5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgIHZhciBuMSA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICAgIHZhciBuMiA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIGlmIChuMSA8PSAzICYmIHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xICogNjQgKyBuMiAqIDggKyBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDggKyBuMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1PY3RhbERpZ2l0XG5wcCQ5LnJlZ2V4cF9lYXRPY3RhbERpZ2l0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoIC0gMHgzMDsgLyogMCAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzcgLyogNyAqL1xufVxuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXg0RGlnaXRzXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhEaWdpdFxuLy8gQW5kIEhleERpZ2l0IEhleERpZ2l0IGluIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUhleEVzY2FwZVNlcXVlbmNlXG5wcCQ5LnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyA9IGZ1bmN0aW9uKHN0YXRlLCBsZW5ndGgpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gT2JqZWN0IHR5cGUgdXNlZCB0byByZXByZXNlbnQgdG9rZW5zLiBOb3RlIHRoYXQgbm9ybWFsbHksIHRva2Vuc1xuLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuLy8gdXNlZCBmb3IgdGhlIG9uVG9rZW4gY2FsbGJhY2sgYW5kIHRoZSBleHRlcm5hbCB0b2tlbml6ZXIuXG5cbnZhciBUb2tlbiA9IGZ1bmN0aW9uIFRva2VuKHApIHtcbiAgdGhpcy50eXBlID0gcC50eXBlO1xuICB0aGlzLnZhbHVlID0gcC52YWx1ZTtcbiAgdGhpcy5zdGFydCA9IHAuc3RhcnQ7XG4gIHRoaXMuZW5kID0gcC5lbmQ7XG4gIGlmIChwLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocCwgcC5zdGFydExvYywgcC5lbmRMb2MpOyB9XG4gIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF07IH1cbn07XG5cbi8vICMjIFRva2VuaXplclxuXG52YXIgcHAkOCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxucHAkOC5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAkOC5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxufTtcblxuLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICB7IHBwJDhbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxucHAkOC5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG4vLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbi8vIHByb3BlcnRpZXMuXG5cbnBwJDgubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVvZikgfVxuXG4gIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbn07XG5cbnBwJDgucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLylcbiAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbn07XG5cbnBwJDguZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAkOC5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gIHRoaXMucG9zID0gZW5kICsgMjtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICArK3RoaXMkMS5jdXJMaW5lO1xuICAgICAgdGhpcyQxLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG5wcCQ4LnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzJDEucG9zKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMucG9zKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhcnNlIGFuZCBhZnRlciBldmVyeSB0b2tlbi4gU2tpcHNcbi8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbnBwJDguc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMzI6IGNhc2UgMTYwOiAvLyAnICdcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIGlmICh0aGlzJDEub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgICAgdGhpcyQxLmxpbmVTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgc3dpdGNoICh0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zICsgMSkpIHtcbiAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICB0aGlzJDEuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcyQxLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSB0b2tlbi4gU2V0cyBgZW5kYCwgYHZhbGAsIGFuZFxuLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbi8vIHJpZ2h0IHBvc2l0aW9uLlxuXG5wcCQ4LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xufTtcblxuLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gZmV0Y2ggdGhlIG5leHQgdG9rZW4uIEl0XG4vLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbi8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4vLyBpbnRvIGl0LlxuLy9cbi8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbi8vXG5wcCQ4LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lbGxpcHNpcylcbiAgfSBlbHNlIHtcbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvdClcbiAgfVxufTtcblxucHAkOC5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgKytzaXplO1xuICAgIHRva2VudHlwZSA9IHR5cGVzLnN0YXJzdGFyO1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbn07XG5cbnBwJDgucmVhZFRva2VuX3BpcGVfYW1wID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnfCYnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5iaXR3aXNlT1IgOiB0eXBlcy5iaXR3aXNlQU5ELCAxKVxufTtcblxucHAkOC5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0d2lzZVhPUiwgMSlcbn07XG5cbnBwJDgucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmluY0RlYywgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICB9XG4gIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnJlbGF0aW9uYWwsIHNpemUpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmFycm93KVxuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMuZXEgOiB0eXBlcy5wcmVmaXgsIDEpXG59O1xuXG5wcCQ4LmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHN3aXRjaCAoY29kZSkge1xuICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgY2FzZSA0NjogLy8gJy4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpXG4gIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuUilcbiAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSlcbiAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpXG4gIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRMKVxuICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0UilcbiAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlTClcbiAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlUilcbiAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pXG4gIGNhc2UgNjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnF1ZXN0aW9uKVxuXG4gIGNhc2UgOTY6IC8vICdgJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcblxuICBjYXNlIDQ4OiAvLyAnMCdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IC8vICcweCcsICcwWCcgLSBoZXggbnVtYmVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IC8vICcwbycsICcwTycgLSBvY3RhbCBudW1iZXJcbiAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgIH1cblxuICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMS05XG4gICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICBjYXNlIDM0OiBjYXNlIDM5OiAvLyAnXCInLCBcIidcIlxuICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgLy8gb2Z0ZW4gcmVmZXJyZWQgdG8uIGBmaW5pc2hPcGAgc2ltcGx5IHNraXBzIHRoZSBhbW91bnQgb2ZcbiAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXG4gIGNhc2UgNDc6IC8vICcvJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gIGNhc2UgOTQ6IC8vICdeJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICBjYXNlIDEyNjogLy8gJ34nXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKVxuICB9XG5cbiAgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSArIFwiJ1wiKTtcbn07XG5cbnBwJDguZmluaXNoT3AgPSBmdW5jdGlvbih0eXBlLCBzaXplKSB7XG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpO1xuICB0aGlzLnBvcyArPSBzaXplO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCBzdHIpXG59O1xuXG5wcCQ4LnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVzY2FwZWQsIGluQ2xhc3MsIHN0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcyQxLnBvcyA+PSB0aGlzJDEuaW5wdXQubGVuZ3RoKSB7IHRoaXMkMS5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJBdCh0aGlzJDEucG9zKTtcbiAgICBpZiAobGluZUJyZWFrLnRlc3QoY2gpKSB7IHRoaXMkMS5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpOyB9XG4gICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICBpZiAoY2ggPT09IFwiW1wiKSB7IGluQ2xhc3MgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCJdXCIgJiYgaW5DbGFzcykgeyBpbkNsYXNzID0gZmFsc2U7IH1cbiAgICAgIGVsc2UgaWYgKGNoID09PSBcIi9cIiAmJiAhaW5DbGFzcykgeyBicmVhayB9XG4gICAgICBlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuICAgIH0gZWxzZSB7IGVzY2FwZWQgPSBmYWxzZTsgfVxuICAgICsrdGhpcyQxLnBvcztcbiAgfVxuICB2YXIgcGF0dGVybiA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIGZsYWdzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgLy8gVmFsaWRhdGUgcGF0dGVyblxuICB2YXIgc3RhdGUgPSB0aGlzLnJlZ2V4cFN0YXRlIHx8ICh0aGlzLnJlZ2V4cFN0YXRlID0gbmV3IFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSh0aGlzKSk7XG4gIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gIHRoaXMudmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBDcmVhdGUgTGl0ZXJhbCN2YWx1ZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRVNUcmVlIHJlcXVpcmVzIG51bGwgaWYgaXQgZmFpbGVkIHRvIGluc3RhbnRpYXRlIFJlZ0V4cCBvYmplY3QuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9hMjcwMDNhZGY0ZmQ3YmZhZDQ0ZGU5Y2VmMzcyYTJlYWNkNTI3YjFjL2VzNS5tZCNyZWdleHBsaXRlcmFsXG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbi8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG5wcCQ4LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIHZhciBjb2RlID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyksIHZhbCA9ICh2b2lkIDApO1xuICAgIGlmIChjb2RlID49IDk3KSB7IHZhbCA9IGNvZGUgLSA5NyArIDEwOyB9IC8vIGFcbiAgICBlbHNlIGlmIChjb2RlID49IDY1KSB7IHZhbCA9IGNvZGUgLSA2NSArIDEwOyB9IC8vIEFcbiAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgdmFsID0gY29kZSAtIDQ4OyB9IC8vIDAtOVxuICAgIGVsc2UgeyB2YWwgPSBJbmZpbml0eTsgfVxuICAgIGlmICh2YWwgPj0gcmFkaXgpIHsgYnJlYWsgfVxuICAgICsrdGhpcyQxLnBvcztcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cbiAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gIHJldHVybiB0b3RhbFxufTtcblxucHAkOC5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbihyYWRpeCkge1xuICB0aGlzLnBvcyArPSAyOyAvLyAweFxuICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCArIDIsIFwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4IFwiICsgcmFkaXgpOyB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxucHAkOC5yZWFkTnVtYmVyID0gZnVuY3Rpb24oc3RhcnRzV2l0aERvdCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAobmV4dCA9PT0gNDYgJiYgIW9jdGFsKSB7IC8vICcuJ1xuICAgICsrdGhpcy5wb3M7XG4gICAgdGhpcy5yZWFkSW50KDEwKTtcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgfVxuICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIW9jdGFsKSB7IC8vICdlRSdcbiAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgeyArK3RoaXMucG9zOyB9IC8vICcrLSdcbiAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIH1cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuXG4gIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gIHZhciB2YWwgPSBvY3RhbCA/IHBhcnNlSW50KHN0ciwgOCkgOiBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsKVxufTtcblxuLy8gUmVhZCBhIHN0cmluZyB2YWx1ZSwgaW50ZXJwcmV0aW5nIGJhY2tzbGFzaC1lc2NhcGVzLlxuXG5wcCQ4LnJlYWRDb2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZTtcblxuICBpZiAoY2ggPT09IDEyMykgeyAvLyAneydcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHZhciBjb2RlUG9zID0gKyt0aGlzLnBvcztcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoXCJ9XCIsIHRoaXMucG9zKSAtIHRoaXMucG9zKTtcbiAgICArK3RoaXMucG9zO1xuICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIik7IH1cbiAgfSBlbHNlIHtcbiAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcig0KTtcbiAgfVxuICByZXR1cm4gY29kZVxufTtcblxuZnVuY3Rpb24gY29kZVBvaW50VG9TdHJpbmcoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnBwJDgucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzJDEucG9zID49IHRoaXMkMS5pbnB1dC5sZW5ndGgpIHsgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyk7XG4gICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMkMS5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ld0xpbmUoY2gsIHRoaXMkMS5vcHRpb25zLmVjbWFWZXJzaW9uID49IDEwKSkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICB9XG4gIH1cbiAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MrKyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnN0cmluZywgb3V0KVxufTtcblxuLy8gUmVhZHMgdGVtcGxhdGUgc3RyaW5nIHRva2Vucy5cblxudmFyIElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SID0ge307XG5cbnBwJDgudHJ5UmVhZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IHRydWU7XG4gIHRyeSB7XG4gICAgdGhpcy5yZWFkVG1wbFRva2VuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgPT09IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SKSB7XG4gICAgICB0aGlzLnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gZmFsc2U7XG59O1xuXG5wcCQ4LmludmFsaWRTdHJpbmdUb2tlbiA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmluVGVtcGxhdGVFbGVtZW50ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgdGhyb3cgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1JcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJhaXNlKHBvc2l0aW9uLCBtZXNzYWdlKTtcbiAgfVxufTtcblxucHAkOC5yZWFkVG1wbFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIGZvciAoOzspIHtcbiAgICBpZiAodGhpcyQxLnBvcyA+PSB0aGlzJDEuaW5wdXQubGVuZ3RoKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyk7XG4gICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyArIDEpID09PSAxMjMpIHsgLy8gJ2AnLCAnJHsnXG4gICAgICBpZiAodGhpcyQxLnBvcyA9PT0gdGhpcyQxLnN0YXJ0ICYmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMudGVtcGxhdGUgfHwgdGhpcyQxLnR5cGUgPT09IHR5cGVzLmludmFsaWRUZW1wbGF0ZSkpIHtcbiAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgIHRoaXMkMS5wb3MgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR5cGVzLmRvbGxhckJyYWNlTClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR5cGVzLnRlbXBsYXRlLCBvdXQpXG4gICAgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgIG91dCArPSB0aGlzJDEucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpID09PSAxMCkgeyArK3RoaXMkMS5wb3M7IH1cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIG91dCArPSBcIlxcblwiO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMkMS5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICArK3RoaXMkMS5jdXJMaW5lO1xuICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICAgIH1cbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgfVxuICB9XG59O1xuXG4vLyBSZWFkcyBhIHRlbXBsYXRlIHRva2VuIHRvIHNlYXJjaCBmb3IgdGhlIGVuZCwgd2l0aG91dCB2YWxpZGF0aW5nIGFueSBlc2NhcGUgc2VxdWVuY2VzXG5wcCQ4LnJlYWRJbnZhbGlkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKDsgdGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aDsgdGhpcy5wb3MrKykge1xuICAgIHN3aXRjaCAodGhpcyQxLmlucHV0W3RoaXMkMS5wb3NdKSB7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiJFwiOlxuICAgICAgaWYgKHRoaXMkMS5pbnB1dFt0aGlzJDEucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgY2FzZSBcImBcIjpcbiAgICAgIHJldHVybiB0aGlzJDEuZmluaXNoVG9rZW4odHlwZXMuaW52YWxpZFRlbXBsYXRlLCB0aGlzJDEuaW5wdXQuc2xpY2UodGhpcyQxLnN0YXJ0LCB0aGlzJDEucG9zKSlcblxuICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH1cbiAgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTtcbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBlc2NhcGVkIGNoYXJhY3RlcnNcblxucHAkOC5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgc3dpdGNoIChjaCkge1xuICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gIGNhc2UgMTE0OiByZXR1cm4gXCJcXHJcIiAvLyAncicgLT4gJ1xccidcbiAgY2FzZSAxMjA6IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEhleENoYXIoMikpIC8vICd4J1xuICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICByZXR1cm4gXCJcIlxuICBkZWZhdWx0OlxuICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbnBwJDgucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgcmV0dXJuIG5cbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcCQ4LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzJDEuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgdGhpcyQxLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgIHRoaXMkMS5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICB3b3JkICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICBpZiAodGhpcyQxLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzJDEucG9zKSAhPT0gMTE3KSAvLyBcInVcIlxuICAgICAgICB7IHRoaXMkMS5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcyQxLnBvcywgXCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFxcXHVYWFhYXCIpOyB9XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgICB2YXIgZXNjID0gdGhpcyQxLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgIHsgdGhpcyQxLmludmFsaWRTdHJpbmdUb2tlbihlc2NTdGFydCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpOyB9XG4gICAgICB3b3JkICs9IGNvZGVQb2ludFRvU3RyaW5nKGVzYyk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG59O1xuXG4vLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbi8vIHdvcmRzIHdoZW4gbmVjZXNzYXJ5LlxuXG5wcCQ4LnJlYWRXb3JkID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgdmFyIHR5cGUgPSB0eXBlcy5uYW1lO1xuICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHdvcmQpKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgXCIgKyB3b3JkKTsgfVxuICAgIHR5cGUgPSBrZXl3b3JkcyQxW3dvcmRdO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHdvcmQpXG59O1xuXG4vLyBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlxuLy9cbi8vIEFjb3JuIHdhcyB3cml0dGVuIGJ5IE1hcmlqbiBIYXZlcmJla2UsIEluZ3ZhciBTdGVwYW55YW4sIGFuZFxuLy8gdmFyaW91cyBjb250cmlidXRvcnMgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuLy9cbi8vIEdpdCByZXBvc2l0b3JpZXMgZm9yIEFjb3JuIGFyZSBhdmFpbGFibGUgYXRcbi8vXG4vLyAgICAgaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9naXQvYWNvcm5cbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vYWNvcm5qcy9hY29ybi5naXRcbi8vXG4vLyBQbGVhc2UgdXNlIHRoZSBbZ2l0aHViIGJ1ZyB0cmFja2VyXVtnaGJ0XSB0byByZXBvcnQgaXNzdWVzLlxuLy9cbi8vIFtnaGJ0XTogaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzXG4vL1xuLy8gVGhpcyBmaWxlIGRlZmluZXMgdGhlIG1haW4gcGFyc2VyIGludGVyZmFjZS4gVGhlIGxpYnJhcnkgYWxzbyBjb21lc1xuLy8gd2l0aCBhIFtlcnJvci10b2xlcmFudCBwYXJzZXJdW2RhbW1pdF0gYW5kIGFuXG4vLyBbYWJzdHJhY3Qgc3ludGF4IHRyZWUgd2Fsa2VyXVt3YWxrXSwgZGVmaW5lZCBpbiBvdGhlciBmaWxlcy5cbi8vXG4vLyBbZGFtbWl0XTogYWNvcm5fbG9vc2UuanNcbi8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cbnZhciB2ZXJzaW9uID0gXCI1LjcuM1wiO1xuXG4vLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuLy8gYnJvd3NlcikgaXMgYSBgcGFyc2VgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBjb2RlIHN0cmluZyBhbmRcbi8vIHJldHVybnMgYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgYXMgc3BlY2lmaWVkIGJ5IFtNb3ppbGxhIHBhcnNlclxuLy8gQVBJXVthcGldLlxuLy9cbi8vIFthcGldOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHAgPSBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwLm5leHRUb2tlbigpO1xuICByZXR1cm4gcC5wYXJzZUV4cHJlc3Npb24oKVxufVxuXG4vLyBBY29ybiBpcyBvcmdhbml6ZWQgYXMgYSB0b2tlbml6ZXIgYW5kIGEgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VyLlxuLy8gVGhlIGB0b2tlbml6ZXJgIGV4cG9ydCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdG8gdGhlIHRva2VuaXplci5cblxuZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUGFyc2VyKG9wdGlvbnMsIGlucHV0KVxufVxuXG4vLyBUaGlzIGlzIGEgdGVycmlibGUga2x1ZGdlIHRvIHN1cHBvcnQgdGhlIGV4aXN0aW5nLCBwcmUtRVM2XG4vLyBpbnRlcmZhY2Ugd2hlcmUgdGhlIGxvb3NlIHBhcnNlciBtb2R1bGUgcmV0cm9hY3RpdmVseSBhZGRzIGV4cG9ydHNcbi8vIHRvIHRoaXMgbW9kdWxlLlxuIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5mdW5jdGlvbiBhZGRMb29zZUV4cG9ydHMocGFyc2UsIFBhcnNlciQkMSwgcGx1Z2lucyQkMSkge1xuICBleHBvcnRzLnBhcnNlX2RhbW1pdCA9IHBhcnNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICBleHBvcnRzLkxvb3NlUGFyc2VyID0gUGFyc2VyJCQxO1xuICBleHBvcnRzLnBsdWdpbnNMb29zZSA9IHBsdWdpbnMkJDE7XG59XG5cbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnBhcnNlRXhwcmVzc2lvbkF0ID0gcGFyc2VFeHByZXNzaW9uQXQ7XG5leHBvcnRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbmV4cG9ydHMuYWRkTG9vc2VFeHBvcnRzID0gYWRkTG9vc2VFeHBvcnRzO1xuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5leHBvcnRzLnBsdWdpbnMgPSBwbHVnaW5zO1xuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuZXhwb3J0cy5Qb3NpdGlvbiA9IFBvc2l0aW9uO1xuZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xuZXhwb3J0cy5nZXRMaW5lSW5mbyA9IGdldExpbmVJbmZvO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuVG9rZW5UeXBlID0gVG9rZW5UeXBlO1xuZXhwb3J0cy50b2tUeXBlcyA9IHR5cGVzO1xuZXhwb3J0cy5rZXl3b3JkVHlwZXMgPSBrZXl3b3JkcyQxO1xuZXhwb3J0cy5Ub2tDb250ZXh0ID0gVG9rQ29udGV4dDtcbmV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcyQxO1xuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbmV4cG9ydHMuVG9rZW4gPSBUb2tlbjtcbmV4cG9ydHMuaXNOZXdMaW5lID0gaXNOZXdMaW5lO1xuZXhwb3J0cy5saW5lQnJlYWsgPSBsaW5lQnJlYWs7XG5leHBvcnRzLmxpbmVCcmVha0cgPSBsaW5lQnJlYWtHO1xuZXhwb3J0cy5ub25BU0NJSXdoaXRlc3BhY2UgPSBub25BU0NJSXdoaXRlc3BhY2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvKiEgSGFtbWVyLkpTIC0gdjIuMC44IC0gMjAxNi0wOS0zMFxuICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpICBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHsgXG4ndXNlIHN0cmljdCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiB1c2UgdGhlIHZhbDIgd2hlbiB2YWwxIGlzIHVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWwxXG4gKiBAcGFyYW0geyp9IHZhbDJcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBpZlVuZGVmaW5lZCh2YWwxLCB2YWwyKSB7XG4gIHJldHVybiB2YWwxID09PSB1bmRlZmluZWQgPyB2YWwyIDogdmFsMTtcbn1cblxudmFyIFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xudmFyIFRFU1RfRUxFTUVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG52YXIgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgbm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgcHJlZml4ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge1N0cmluZ3xVbmRlZmluZWR9IHByZWZpeGVkXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKG9iaiwgcHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeCA9IHZvaWQgMDtcbiAgdmFyIHByb3AgPSB2b2lkIDA7XG4gIHZhciBjYW1lbFByb3AgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IFZFTkRPUl9QUkVGSVhFUy5sZW5ndGgpIHtcbiAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgcHJvcCA9IHByZWZpeCA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgdmFyIGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcblxuICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICByZXR1cm4gdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luZG93LkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gIH0pO1xuICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ24gPSB2b2lkIDA7XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufSBlbHNlIHtcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxudmFyIGFzc2lnbiQxID0gYXNzaWduO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbnZhciBfdW5pcXVlSWQgPSAxO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIHJldHVybiBfdW5pcXVlSWQrKztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgdmFyIGkgPSB2b2lkIDA7XG5cbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gIGlmIChzcmMuaW5kZXhPZiAmJiAhZmluZEJ5S2V5KSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgIGlmIChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCB8fCAhZmluZEJ5S2V5ICYmIHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAvLyBkbyBub3QgdXNlID09PSBoZXJlLCB0ZXN0IGZhaWxzXG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbnZhciBhc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXdhaXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgIHZhciBmcm9udCwgYmFjaztcblxuICAgIGZ1bmN0aW9uIHNlbmQoa2V5LCBhcmcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGFyZzogYXJnLFxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgYmFjayA9IGJhY2submV4dCA9IHJlcXVlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbnQgPSBiYWNrID0gcmVxdWVzdDtcbiAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRWYWx1ZSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZS52YWx1ZSkudGhlbihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXN1bWUoXCJuZXh0XCIsIGFyZyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyBcInJldHVyblwiIDogXCJub3JtYWxcIiwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldHRsZShcInRocm93XCIsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZyb250ID0gZnJvbnQubmV4dDtcblxuICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbnZva2UgPSBzZW5kO1xuXG4gICAgaWYgKHR5cGVvZiBnZW4ucmV0dXJuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGFyZyk7XG4gIH07XG5cbiAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJ0aHJvd1wiLCBhcmcpO1xuICB9O1xuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJldHVyblwiLCBhcmcpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgd3JhcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jR2VuZXJhdG9yKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGF3YWl0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xufSgpO1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBsZXQgYSBib29sZWFuIHZhbHVlIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IG11c3QgcmV0dXJuIGEgYm9vbGVhblxuICogdGhpcyBmaXJzdCBpdGVtIGluIGFyZ3Mgd2lsbCBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHZhbFxuICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gIGlmICgodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5mdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICB2YXIgbWFuYWdlciA9IHJlY29nbml6ZXIubWFuYWdlcjtcblxuICBpZiAobWFuYWdlcikge1xuICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICB9XG4gIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVzYWJsZSBzdHJpbmcsIHVzZWQgYXMgZXZlbnQgcG9zdGZpeFxuICogQHBhcmFtIHtjb25zdGFudH0gc3RhdGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0YXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgIHJldHVybiAnY2FuY2VsJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgIHJldHVybiAnbW92ZSc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxudmFyIFJlY29nbml6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY29nbml6ZXIpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduJDEoe30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZUlkKCk7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuXG4gICAgLy8gZGVmYXVsdCBpcyBlbmFibGUgdHJ1ZVxuICAgIHRoaXMub3B0aW9ucy5lbmFibGUgPSBpZlVuZGVmaW5lZCh0aGlzLm9wdGlvbnMuZW5hYmxlLCB0cnVlKTtcblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB0aGlzLnNpbXVsdGFuZW91cyA9IHt9O1xuICAgIHRoaXMucmVxdWlyZUZhaWwgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtSZWNvZ25pemVyfVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFJlY29nbml6ZXIsIFt7XG4gICAga2V5OiAnc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG4gICAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlY29nbml6ZVdpdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbXVsdGFuZW91cyA9IHRoaXMuc2ltdWx0YW5lb3VzO1xuXG4gICAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcm9wUmVjb2duaXplV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3BSZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3JlcXVpcmVGYWlsdXJlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcXVpcmVGYWlsID0gdGhpcy5yZXF1aXJlRmFpbDtcblxuICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBkcm9wIHRoZSByZXF1aXJlRmFpbHVyZSBsaW5rLiBpdCBkb2VzIG5vdCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkcm9wUmVxdWlyZUZhaWx1cmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgIHZhciBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdoYXNSZXF1aXJlRmFpbHVyZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNSZXF1aXJlRmFpbHVyZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2FuUmVjb2duaXplV2l0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cblxuICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICAgIH1cblxuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgIGlmIChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpIHtcbiAgICAgICAgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gcGFuZW5kIGFuZCBwYW5jYW5jZWxcbiAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgICAqIG90aGVyd2lzZSwgc2V0dXAgdGhlIHN0YXRlIHRvIEZBSUxFRC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndHJ5RW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyeUVtaXQoaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY2FuRW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbkVtaXQoKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVjb2duaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIGlucHV0RGF0YSB3aXRob3V0IG1lc3NpbmcgdXAgdGhlIG90aGVyIHJlY29nbml6ZXJzXG4gICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24kMSh7fSwgaW5wdXREYXRhKTtcblxuICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Y29uc3RhbnR9IFNUQVRFXG4gICAgICovXG5cbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0RGF0YSkge31cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0VG91Y2hBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgICAqIEB2aXJ0dWFsXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7fVxuICB9XSk7XG4gIHJldHVybiBSZWNvZ25pemVyO1xufSgpO1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5kZWZhdWx0cyA9IHt9O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUaGlzIHJlY29nbml6ZXIgaXMganVzdCB1c2VkIGFzIGEgYmFzZSBmb3IgdGhlIHNpbXBsZSBhdHRyaWJ1dGUgcmVjb2duaXplcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG52YXIgQXR0clJlY29nbml6ZXIgPSBmdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgaW5oZXJpdHMoQXR0clJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBBdHRyUmVjb2duaXplcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdHRyUmVjb2duaXplcik7XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEF0dHJSZWNvZ25pemVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXR0clJlY29nbml6ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhBdHRyUmVjb2duaXplciwgW3tcbiAgICBrZXk6ICdhdHRyVGVzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9jZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cblxuICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICB2YXIgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgICAvLyBvbiBjYW5jZWwgaW5wdXQgYW5kIHdlJ3ZlIHJlY29nbml6ZWQgYmVmb3JlLCByZXR1cm4gU1RBVEVfQ0FOQ0VMTEVEXG4gICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0hBTkdFRDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBdHRyUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG5cbkF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIHBvaW50ZXJzOiAxXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFJvdGF0ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIGluaGVyaXRzKFJvdGF0ZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBSb3RhdGVSZWNvZ25pemVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUm90YXRlUmVjb2duaXplci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJvdGF0ZVJlY29nbml6ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFJvdGF0ZVJlY29nbml6ZXIsIFt7XG4gICAga2V5OiAnZ2V0VG91Y2hBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dHJUZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHJldHVybiBnZXQoUm90YXRlUmVjb2duaXplci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSb3RhdGVSZWNvZ25pemVyLnByb3RvdHlwZSksICdhdHRyVGVzdCcsIHRoaXMpLmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSb3RhdGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cblJvdGF0ZVJlY29nbml6ZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBldmVudDogJ3JvdGF0ZScsXG4gIHRocmVzaG9sZDogMCxcbiAgcG9pbnRlcnM6IDJcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFBpbmNoUmVjb2duaXplciA9IGZ1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgaW5oZXJpdHMoUGluY2hSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQaW5jaFJlY29nbml6ZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQaW5jaFJlY29nbml6ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQaW5jaFJlY29nbml6ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFBpbmNoUmVjb2duaXplciwgW3tcbiAgICBrZXk6ICdnZXRUb3VjaEFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXR0clRlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgcmV0dXJuIGdldChQaW5jaFJlY29nbml6ZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZSksICdhdHRyVGVzdCcsIHRoaXMpLmNhbGwodGhpcywgaW5wdXQpICYmIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgdmFyIGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBpbk91dDtcbiAgICAgIH1cbiAgICAgIGdldChQaW5jaFJlY29nbml6ZXIucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZSksICdlbWl0JywgdGhpcykuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQaW5jaFJlY29nbml6ZXI7XG59KEF0dHJSZWNvZ25pemVyKTtcblxuUGluY2hSZWNvZ25pemVyLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgZXZlbnQ6ICdwaW5jaCcsXG4gIHRocmVzaG9sZDogMCxcbiAgcG9pbnRlcnM6IDJcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtjb25zdGFudH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgcmV0dXJuICdkb3duJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9VUCkge1xuICAgIHJldHVybiAndXAnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgcmV0dXJuICdyaWdodCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFBhblJlY29nbml6ZXIgPSBmdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIGluaGVyaXRzKFBhblJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUGFuUmVjb2duaXplcigpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQYW5SZWNvZ25pemVyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBhblJlY29nbml6ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYW5SZWNvZ25pemVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfdGhpcy5wWCA9IG51bGw7XG4gICAgX3RoaXMucFkgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFBhblJlY29nbml6ZXIsIFt7XG4gICAga2V5OiAnZ2V0VG91Y2hBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuXG4gICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2RpcmVjdGlvblRlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXJlY3Rpb25UZXN0KGlucHV0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgdmFyIGhhc01vdmVkID0gdHJ1ZTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGlucHV0LmRpc3RhbmNlO1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcblxuICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgICAgLy8gbG9jayB0byBheGlzP1xuICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgZGlyZWN0aW9uID0geCA9PT0gMCA/IERJUkVDVElPTl9OT05FIDogeCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICBoYXNNb3ZlZCA9IHggIT09IHRoaXMucFg7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgaGFzTW92ZWQgPSB5ICE9PSB0aGlzLnBZO1xuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYXR0clRlc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgICAgcmV0dXJuIEF0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoIC8vIHJlcGxhY2Ugd2l0aCBhIHN1cGVyIGNhbGxcbiAgICAgIHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAhKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcblxuICAgICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBpbnB1dC5hZGRpdGlvbmFsRXZlbnQgPSB0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBnZXQoUGFuUmVjb2duaXplci5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYW5SZWNvZ25pemVyLnByb3RvdHlwZSksICdlbWl0JywgdGhpcykuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQYW5SZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cblBhblJlY29nbml6ZXIucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICBldmVudDogJ3BhbicsXG4gIHRocmVzaG9sZDogMTAsXG4gIHBvaW50ZXJzOiAxLFxuICBkaXJlY3Rpb246IERJUkVDVElPTl9BTExcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5cbnZhciBTd2lwZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIGluaGVyaXRzKFN3aXBlUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBTd2lwZVJlY29nbml6ZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3dpcGVSZWNvZ25pemVyKTtcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3dpcGVSZWNvZ25pemVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3dpcGVSZWNvZ25pemVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTd2lwZVJlY29nbml6ZXIsIFt7XG4gICAga2V5OiAnZ2V0VG91Y2hBY3Rpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2F0dHJUZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuXG4gICAgICB2YXIgdmVsb2NpdHkgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXQoU3dpcGVSZWNvZ25pemVyLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFN3aXBlUmVjb2duaXplci5wcm90b3R5cGUpLCAnYXR0clRlc3QnLCB0aGlzKS5jYWxsKHRoaXMsIGlucHV0KSAmJiBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiYgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmIGlucHV0Lm1heFBvaW50ZXJzID09PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiYgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW1pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3dpcGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cblN3aXBlUmVjb2duaXplci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGV2ZW50OiAnc3dpcGUnLFxuICB0aHJlc2hvbGQ6IDEwLFxuICB2ZWxvY2l0eTogMC4zLFxuICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICBwb2ludGVyczogMVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNldCBhIHRpbWVvdXQgd2l0aCBhIGdpdmVuIHNjb3BlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0Q29udGV4dChmbiwgdGltZW91dCwgY29udGV4dCkge1xuICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQSB0YXAgaXMgcmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxudmFyIFRhcFJlY29nbml6ZXIgPSBmdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgaW5oZXJpdHMoVGFwUmVjb2duaXplciwgX1JlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFRhcFJlY29nbml6ZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFwUmVjb2duaXplcik7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGFwUmVjb2duaXplci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRhcFJlY29nbml6ZXIpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF90aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgX3RoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIF90aGlzLmNvdW50ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhUYXBSZWNvZ25pemVyLCBbe1xuICAgIGtleTogJ2dldFRvdWNoQWN0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Byb2Nlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblxuICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfRU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsIDogdHJ1ZTtcbiAgICAgICAgdmFyIHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgdmFyIHRhcENvdW50ID0gdGhpcy5jb3VudCAlIG9wdGlvbnMudGFwcztcbiAgICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczIuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZhaWxUaW1lb3V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFpbFRpbWVvdXQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0Q29udGV4dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VtaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRhcFJlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG5UYXBSZWNvZ25pemVyLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgZXZlbnQ6ICd0YXAnLFxuICBwb2ludGVyczogMSxcbiAgdGFwczogMSxcbiAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gIHBvc1RocmVzaG9sZDogMTAgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxudmFyIFByZXNzUmVjb2duaXplciA9IGZ1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBpbmhlcml0cyhQcmVzc1JlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJlc3NSZWNvZ25pemVyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFByZXNzUmVjb2duaXplci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFByZXNzUmVjb2duaXplcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcbiAgICBfdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKFByZXNzUmVjb2duaXplciwgW3tcbiAgICBrZXk6ICdnZXRUb3VjaEFjdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvY2VzcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB2YXIgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgICAgX3RoaXMyLnRyeUVtaXQoKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArICd1cCcsIGlucHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFByZXNzUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG5cblByZXNzUmVjb2duaXplci5wcm90b3R5cGUuZGVmYXVsdHMgPSB7XG4gIGV2ZW50OiAncHJlc3MnLFxuICBwb2ludGVyczogMSxcbiAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICB0aHJlc2hvbGQ6IDkgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5mdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHdoZW4gdGhlIHRvdWNoQWN0aW9ucyBhcmUgY29sbGVjdGVkIHRoZXkgYXJlIG5vdCBhIHZhbGlkIHZhbHVlLCBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRoaW5ncyB1cC4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbnNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zKSB7XG4gIC8vIG5vbmVcbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfVxuXG4gIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAvLyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMsIGUuZy4gaG9yaXpvbnRhbCBwYW4gYnV0IHZlcnRpY2FsIHN3aXBlPylcbiAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gIH1cblxuICAvLyBwYW4teCBPUiBwYW4teVxuICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gIH1cblxuICAvLyBtYW5pcHVsYXRpb25cbiAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT047XG4gIH1cblxuICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgVG91Y2hBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVG91Y2hBY3Rpb24pO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKFRvdWNoQWN0aW9uLCBbe1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgIGlmICh2YWx1ZSA9PT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY29tcHV0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGUoKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uIChyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMuam9pbignICcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcmV2ZW50RGVmYXVsdHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoaW5wdXQpIHtcbiAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcblxuICAgICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgICAgaWYgKGhhc05vbmUpIHtcbiAgICAgICAgLy8gZG8gbm90IHByZXZlbnQgZGVmYXVsdHMgaWYgdGhpcyBpcyBhIHRhcCBnZXN0dXJlXG4gICAgICAgIHZhciBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgLy8gYHBhbi14IHBhbi15YCBtZWFucyBicm93c2VyIGhhbmRsZXMgYWxsIHNjcm9sbGluZy9wYW5uaW5nLCBkbyBub3QgcHJldmVudFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNOb25lIHx8IGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwgfHwgaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncHJldmVudFNyYycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXZlbnRTcmMoc3JjRXZlbnQpIHtcbiAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVG91Y2hBY3Rpb247XG59KCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIGEgc2ltcGxlIGNsb25lIGZyb20gdGhlIGlucHV0IHVzZWQgZm9yIHN0b3JhZ2Ugb2YgZmlyc3RJbnB1dCBhbmQgZmlyc3RNdWx0aXBsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBjbG9uZWRJbnB1dERhdGFcbiAqL1xuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCkge1xuICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgIH07XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0aW1lU3RhbXA6IG5vdygpLFxuICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge051bWJlcn0gZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldERpcmVjdGlvbih4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG5cbiAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICByZXR1cm4geCA8IDAgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgfVxuICByZXR1cm4geSA8IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgLy8gbGV0IHsgb2Zmc2V0RGVsdGE6b2Zmc2V0ID0ge30sIHByZXZEZWx0YSA9IHt9LCBwcmV2SW5wdXQgPSB7fSB9ID0gc2Vzc2lvbjtcbiAgLy8ganNjcyB0aHJvd2luZyBlcnJvciBvbiBkZWZhbHV0IGRlc3RydWN0dXJlZCB2YWx1ZXMgYW5kIHdpdGhvdXQgZGVmYXVsdHMgdGVzdHMgZmFpbFxuXG4gIHZhciBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gIHZhciBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgIH07XG5cbiAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueVxuICAgIH07XG4gIH1cblxuICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4IC8gZGVsdGFUaW1lIHx8IDAsXG4gICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICB2YXIgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0O1xuICB2YXIgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXA7XG4gIHZhciB2ZWxvY2l0eSA9IHZvaWQgMDtcbiAgdmFyIHZlbG9jaXR5WCA9IHZvaWQgMDtcbiAgdmFyIHZlbG9jaXR5WSA9IHZvaWQgMDtcbiAgdmFyIGRpcmVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHZhciBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICB2YXIgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgdmVsb2NpdHkgPSBhYnModi54KSA+IGFicyh2LnkpID8gdi54IDogdi55O1xuICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICBzZXNzaW9uLmxhc3RJbnRlcnZhbCA9IGlucHV0O1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBsYXRlc3QgdmVsb2NpdHkgaW5mbyBpZiBpdCBkb2Vzbid0IG92ZXJ0YWtlIGEgbWluaW11bSBwZXJpb2RcbiAgICB2ZWxvY2l0eSA9IGxhc3QudmVsb2NpdHk7XG4gICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgdmVsb2NpdHlZID0gbGFzdC52ZWxvY2l0eVk7XG4gICAgZGlyZWN0aW9uID0gbGFzdC5kaXJlY3Rpb247XG4gIH1cblxuICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICBpbnB1dC52ZWxvY2l0eVggPSB2ZWxvY2l0eVg7XG4gIGlucHV0LnZlbG9jaXR5WSA9IHZlbG9jaXR5WTtcbiAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiogQHByaXZhdGVcbiAqIGV4dGVuZCB0aGUgZGF0YSB3aXRoIHNvbWUgdXNhYmxlIHByb3BlcnRpZXMgbGlrZSBzY2FsZSwgcm90YXRlLCB2ZWxvY2l0eSBldGNcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYW5hZ2VyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCkge1xuICB2YXIgc2Vzc2lvbiA9IG1hbmFnZXIuc2Vzc2lvbjtcbiAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDtcblxuICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG5cbiAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH1cblxuICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGZpcnN0SW5wdXQgPSBzZXNzaW9uLmZpcnN0SW5wdXQ7XG4gIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuXG4gIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gIGlucHV0LnNjYWxlID0gZmlyc3RNdWx0aXBsZSA/IGdldFNjYWxlKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDE7XG4gIGlucHV0LnJvdGF0aW9uID0gZmlyc3RNdWx0aXBsZSA/IGdldFJvdGF0aW9uKGZpcnN0TXVsdGlwbGUucG9pbnRlcnMsIHBvaW50ZXJzKSA6IDA7XG5cbiAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBpbnB1dC5wb2ludGVycy5sZW5ndGggPiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzO1xuXG4gIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgdmFyIHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICB0YXJnZXQgPSBpbnB1dC5zcmNFdmVudC50YXJnZXQ7XG4gIH1cbiAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgaXNGaXJzdCA9IGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuXG4gIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgaWYgKGlzRmlyc3QpIHtcbiAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgfVxuXG4gIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5cbmZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCBmdW5jdGlvbiAodHlwZSkge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElucHV0KG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXQpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzaG91bGQgaGFuZGxlIHRoZSBpbnB1dEV2ZW50IGRhdGEgYW5kIHRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoSW5wdXQsIFt7XG4gICAga2V5OiAnaGFuZGxlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5pdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLmV2RWwgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy5lbGVtZW50LCB0aGlzLmV2RWwsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiB1bmJpbmQgdGhlIGV2ZW50c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgICB0aGlzLmV2V2luICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKGdldFdpbmRvd0ZvckVsZW1lbnQodGhpcy5lbGVtZW50KSwgdGhpcy5ldldpbiwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIElucHV0O1xufSgpO1xuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG52YXIgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG52YXIgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFBvaW50ZXJFdmVudElucHV0ID0gZnVuY3Rpb24gKF9JbnB1dCkge1xuICBpbmhlcml0cyhQb2ludGVyRXZlbnRJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludGVyRXZlbnRJbnB1dCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQb2ludGVyRXZlbnRJbnB1dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvaW50ZXJFdmVudElucHV0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICBfdGhpcy5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcblxuICAgIF90aGlzLnN0b3JlID0gX3RoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cblxuICBjcmVhdGVDbGFzcyhQb2ludGVyRXZlbnRJbnB1dCwgW3tcbiAgICBrZXk6ICdoYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcblxuICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDtcblxuICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQb2ludGVyRXZlbnRJbnB1dDtcbn0oSW5wdXQpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5JDEob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5mdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICB2YXIgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgfVxuICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICBpKys7XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFRvdWNoSW5wdXQgPSBmdW5jdGlvbiAoX0lucHV0KSB7XG4gIGluaGVyaXRzKFRvdWNoSW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUb3VjaElucHV0KTtcblxuICAgIFRvdWNoSW5wdXQucHJvdG90eXBlLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBUb3VjaElucHV0LnByb3RvdHlwZS50YXJnZXRJZHMgPSB7fTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRvdWNoSW5wdXQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUb3VjaElucHV0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgX3RoaXMudGFyZ2V0SWRzID0ge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgY3JlYXRlQ2xhc3MoVG91Y2hJbnB1dCwgW3tcbiAgICBrZXk6ICdoYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkkMShldi50b3VjaGVzKTtcbiAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gIC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICB9XG5cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIHZhciB0YXJnZXRUb3VjaGVzID0gdm9pZCAwO1xuICB2YXIgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5JDEoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICB2YXIgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXTtcbiAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuXG4gIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcblxuICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gIH0pO1xuXG4gIC8vIGNvbGxlY3QgdG91Y2hlc1xuICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cbiAgLy8gZmlsdGVyIGNoYW5nZWQgdG91Y2hlcyB0byBvbmx5IGNvbnRhaW4gdG91Y2hlcyB0aGF0IGV4aXN0IGluIHRoZSBjb2xsZWN0ZWQgdGFyZ2V0IGlkc1xuICBpID0gMDtcbiAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSwgY2hhbmdlZFRhcmdldFRvdWNoZXNdO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxudmFyIE1PVVNFX0VMRU1FTlRfRVZFTlRTID0gJ21vdXNlZG93bic7XG52YXIgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBNb3VzZUlucHV0ID0gZnVuY3Rpb24gKF9JbnB1dCkge1xuICBpbmhlcml0cyhNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2VJbnB1dCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChNb3VzZUlucHV0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW91c2VJbnB1dCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX3RoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIF90aGlzLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgIF90aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoTW91c2VJbnB1dCwgW3tcbiAgICBrZXk6ICdoYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICAgIH1cblxuICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNb3VzZUlucHV0O1xufShJbnB1dCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG52YXIgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxudmFyIFRvdWNoTW91c2VJbnB1dCA9IGZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgaW5oZXJpdHMoVG91Y2hNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFRvdWNoTW91c2VJbnB1dCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUb3VjaE1vdXNlSW5wdXQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVG91Y2hNb3VzZUlucHV0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVG91Y2hNb3VzZUlucHV0KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbihfdGhpcy5oYW5kbGVyLCBfdGhpcyk7XG4gICAgX3RoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dChfdGhpcy5tYW5hZ2VyLCBoYW5kbGVyKTtcbiAgICBfdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KF90aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuXG4gICAgX3RoaXMucHJpbWFyeVRvdWNoID0gbnVsbDtcbiAgICBfdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqL1xuXG5cbiAgY3JlYXRlQ2xhc3MoVG91Y2hNb3VzZUlucHV0LCBbe1xuICAgIGtleTogJ2hhbmRsZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVyKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgdmFyIGlzVG91Y2ggPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0g7XG4gICAgICB2YXIgaXNNb3VzZSA9IGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9NT1VTRTtcblxuICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHdlJ3JlIGluIGEgdG91Y2ggZXZlbnQsIHJlY29yZCB0b3VjaGVzIHRvICBkZS1kdXBlIHN5bnRoZXRpYyBtb3VzZSBldmVudFxuICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKHRoaXMsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgaXNTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGlucHV0RGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUb3VjaE1vdXNlSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcbiAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHZhciBfZXZlbnREYXRhJGNoYW5nZWRQb2kgPSBzbGljZWRUb0FycmF5KGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnMsIDEpO1xuXG4gIHZhciB0b3VjaCA9IF9ldmVudERhdGEkY2hhbmdlZFBvaVswXTtcblxuICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3RUb3VjaCA9IHsgeDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WSB9O1xuICAgICAgX3RoaXMyLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcbiAgICAgIHZhciBsdHMgPSBfdGhpczIubGFzdFRvdWNoZXM7XG4gICAgICB2YXIgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24gcmVtb3ZlTGFzdFRvdWNoKCkge1xuICAgICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG4gICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICAgIH0pKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WDtcbiAgdmFyIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHQgPSB0aGlzLmxhc3RUb3VjaGVzW2ldO1xuICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpO1xuICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgIGlmIChkeCA8PSBERURVUF9ESVNUQU5DRSAmJiBkeSA8PSBERURVUF9ESVNUQU5DRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gIHZhciBUeXBlID0gdm9pZCAwO1xuICAvLyBsZXQgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gIGlmIChpbnB1dENsYXNzKSB7XG4gICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICB9IGVsc2Uge1xuICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBUeXBlKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbnZhciBTVE9QID0gMTtcbnZhciBGT1JDRURfU1RPUCA9IDI7XG5cbi8qKlxuKiBAcHJpdmF0ZVxuICogTWFuYWdlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hbmFnZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNYW5hZ2VyKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbiQxKHt9LCBIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZWNvZ25pemVyID0gX3RoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKE1hbmFnZXIsIFt7XG4gICAga2V5OiAnc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKGZvcmNlKSB7XG4gICAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZWNvZ25pemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcblxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICB2YXIgcmVjb2duaXplciA9IHZvaWQgMDtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG5cbiAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuXG4gICAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjtcblxuICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuXG4gICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoIC8vIDFcbiAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHtcbiAgICAgICAgICAvLyAzXG4gICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemUoaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHJlY29nbml6ZXIpIHtcbiAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PT0gcmVjb2duaXplcikge1xuICAgICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgYWRkIGEgcmVjb2duaXplciB0byB0aGUgbWFuYWdlclxuICAgICAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxNYW5hZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUocmVjb2duaXplcikge1xuICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuXG4gICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cbiAgICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZSBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YS50eXBlID0gZXZlbnQ7XG4gICAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZGVzdHJveSB0aGUgbWFuYWdlciBhbmQgdW5iaW5kcyBhbGwgZXZlbnRzXG4gICAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuXG4gICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hbmFnZXI7XG59KCk7XG5cbmZ1bmN0aW9uIHRvZ2dsZUNzc1Byb3BzKG1hbmFnZXIsIGFkZCkge1xuICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcblxuICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByb3AgPSB2b2lkIDA7XG4gIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG4gICAgaWYgKGFkZCkge1xuICAgICAgbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgIH1cbiAgfSk7XG4gIGlmICghYWRkKSB7XG4gICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBIYW1tZXIgPSBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIYW1tZXIpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gIHJldHVybiBuZXcgTWFuYWdlcihlbGVtZW50LCBvcHRpb25zKTtcbn07XG5cbkhhbW1lci5WRVJTSU9OID0gJzIuMC44JztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgKi9cbiAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBpbnB1dENsYXNzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgcHJlc2V0OiBbXG4gIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICBbUm90YXRlUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH1dLCBbUGluY2hSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfSwgWydyb3RhdGUnXV0sIFtTd2lwZVJlY29nbml6ZXIsIHsgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB9XSwgW1BhblJlY29nbml6ZXIsIHsgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB9LCBbJ3N3aXBlJ11dLCBbVGFwUmVjb2duaXplcl0sIFtUYXBSZWNvZ25pemVyLCB7IGV2ZW50OiAnZG91YmxldGFwJywgdGFwczogMiB9LCBbJ3RhcCddXSwgW1ByZXNzUmVjb2duaXplcl1dLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIGNzc1Byb3BzOiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdG91Y2hTZWxlY3Q6ICdub25lJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cbiAgICAgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcbiAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgY29udGVudFpvb21pbmc6ICdub25lJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgKi9cbiAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gIH1cbn07XG5cbnZhciBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgU2luZ2xlVG91Y2hJbnB1dCA9IGZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgaW5oZXJpdHMoU2luZ2xlVG91Y2hJbnB1dCwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbmdsZVRvdWNoSW5wdXQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2luZ2xlVG91Y2hJbnB1dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNpbmdsZVRvdWNoSW5wdXQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF90aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgX3RoaXMuZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBjcmVhdGVDbGFzcyhTaW5nbGVUb3VjaElucHV0LCBbe1xuICAgIGtleTogJ2hhbmRsZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgIC8vIHNob3VsZCB3ZSBoYW5kbGUgdGhlIHRvdWNoIGV2ZW50cz9cbiAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNpbmdsZVRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsID0gdG9BcnJheSQxKGV2LnRvdWNoZXMpO1xuICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkkMShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKCdnZXQtc3RhY2stdHJhY2UnKTtcbiAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJykucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgaWYgKGxvZykge1xuICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjLCBtZXJnZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgIGlmICghbWVyZ2UgfHwgbWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICByZXR1cm4gZXh0ZW5kKGRlc3QsIHNyYywgdHJ1ZSk7XG59LCAnbWVyZ2UnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGU7XG4gIHZhciBjaGlsZFAgPSB2b2lkIDA7XG5cbiAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBhc3NpZ24kMShjaGlsZFAsIHByb3BlcnRpZXMpO1xuICB9XG59XG5cbi8vIHRoaXMgcHJldmVudHMgZXJyb3JzIHdoZW4gSGFtbWVyIGlzIGxvYWRlZCBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EXG4vLyAgc3R5bGUgbG9hZGVyIGJ1dCBieSBzY3JpcHQgdGFnLCBub3QgYnkgdGhlIGxvYWRlci5cblxuYXNzaWduJDEoSGFtbWVyLCB7XG4gIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgSU5QVVRfTU9WRTogSU5QVVRfTU9WRSxcbiAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuXG4gIFNUQVRFX1BPU1NJQkxFOiBTVEFURV9QT1NTSUJMRSxcbiAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxuICBTVEFURV9FTkRFRDogU1RBVEVfRU5ERUQsXG4gIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxuICBTVEFURV9GQUlMRUQ6IFNUQVRFX0ZBSUxFRCxcblxuICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgRElSRUNUSU9OX1JJR0hUOiBESVJFQ1RJT05fUklHSFQsXG4gIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gIERJUkVDVElPTl9IT1JJWk9OVEFMOiBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG5cbiAgTWFuYWdlcjogTWFuYWdlcixcbiAgSW5wdXQ6IElucHV0LFxuICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG5cbiAgVG91Y2hJbnB1dDogVG91Y2hJbnB1dCxcbiAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxuICBUb3VjaE1vdXNlSW5wdXQ6IFRvdWNoTW91c2VJbnB1dCxcbiAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICBBdHRyUmVjb2duaXplcjogQXR0clJlY29nbml6ZXIsXG4gIFRhcDogVGFwUmVjb2duaXplcixcbiAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICBTd2lwZTogU3dpcGVSZWNvZ25pemVyLFxuICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gIFByZXNzOiBQcmVzc1JlY29nbml6ZXIsXG5cbiAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICBlYWNoOiBlYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICBhc3NpZ246IGFzc2lnbiQxLFxuICBpbmhlcml0OiBpbmhlcml0LFxuICBiaW5kRm46IGJpbmRGbixcbiAgcHJlZml4ZWQ6IHByZWZpeGVkLFxuICB0b0FycmF5OiB0b0FycmF5JDEsXG4gIGluQXJyYXk6IGluQXJyYXksXG4gIHVuaXF1ZUFycmF5OiB1bmlxdWVBcnJheSxcbiAgc3BsaXRTdHI6IHNwbGl0U3RyLFxuICBib29sT3JGbjogYm9vbE9yRm4sXG4gIGhhc1BhcmVudDogaGFzUGFyZW50LFxuICBhZGRFdmVudExpc3RlbmVyczogYWRkRXZlbnRMaXN0ZW5lcnMsXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzOiByZW1vdmVFdmVudExpc3RlbmVyc1xufSk7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gSGFtbWVyO1xuICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBIYW1tZXI7XG59IGVsc2Uge1xuICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xufSkod2luZG93LCBkb2N1bWVudCwgJ0hhbW1lcicpOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF8gPSByZXF1aXJlKCcuLycpO1xuXG52YXIgXzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF8pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvdW50XVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBCbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmxvY2sob3B0aW9ucywgY291bnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmxvY2spO1xuXG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy50aGF3cyA9IFtdO1xuICAgIHRoaXMuY291bnQgPSBjb3VudCB8fCAyMDA7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGQgYW4gaXRlbSB0byB0aGUgZW5kIG9mIGl0ZW1zXG4gICAqIEBwYXJhbSBpdGVtXG4gICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmxvY2ssIFt7XG4gICAga2V5OiAnYWRkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGl0ZW0pIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5fbmV4dCgpO1xuICAgICAgbmV4dC5hZGQoaXRlbSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhbiBBcnJheSB0byB0aGUgZW5kIG9mIGl0ZW1zXG4gICAgICogQHBhcmFtIGl0ZW1zXG4gICAgICogQHJldHVybnMge0Jsb2NrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRBcnJheScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFycmF5KGl0ZW1zKSB7XG4gICAgICB2YXIgbmV4dCA9IHRoaXMuX25leHQoKTtcbiAgICAgIG5leHQuYWRkQXJyYXkoaXRlbXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbnNlcnQgYW4gaXRlbSBpbnRvIGl0ZW1zIEAgY3VycmVudCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBpdGVtXG4gICAgICogQHJldHVybnMge0Jsb2NrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnNlcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnQoaXRlbSkge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLl9uZXh0KCk7XG4gICAgICBuZXh0Lmluc2VydChpdGVtKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5zZXJ0IGFuZCBhcnJheSBpbnRvIGl0ZW1zIEAgY3VycmVudCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtCbG9ja31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaW5zZXJ0QXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBcnJheShpdGVtcykge1xuICAgICAgdmFyIG5leHQgPSB0aGlzLl9uZXh0KCk7XG4gICAgICBuZXh0Lmluc2VydEFycmF5KGl0ZW1zKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcHMgYWxsIHRoYXdzIGluIHRoaXMgYmxvY2tcbiAgICAgKiBAcmV0dXJucyB7QmxvY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRoYXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudGhhd3NbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IG5leHQgYXZhaWxhYmxlIGluIGJsb2NrXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnX25leHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbmV4dCgpIHtcbiAgICAgIHZhciB0aGF3ID0gbnVsbDtcbiAgICAgIHZhciB0aGF3cyA9IHRoaXMudGhhd3M7XG5cbiAgICAgIGlmICh0aGF3cy5sZW5ndGggPCB0aGlzLmNvdW50KSB7XG4gICAgICAgIHRoYXdzLnB1c2godGhhdyA9IG5ldyBfMi5kZWZhdWx0KFtdLCB0aGlzLm9wdGlvbnMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXcgPSB0aGF3c1t0aGlzLmluZGV4XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMuY291bnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGF3O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCbG9jaztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2s7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJsb2NrID0gdW5kZWZpbmVkO1xuXG52YXIgX3RoYXcgPSByZXF1aXJlKCcuL3RoYXcnKTtcblxudmFyIF90aGF3MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoYXcpO1xuXG52YXIgX2Jsb2NrID0gcmVxdWlyZSgnLi9ibG9jaycpO1xuXG52YXIgX2Jsb2NrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jsb2NrKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX3RoYXcyLmRlZmF1bHQ7XG5leHBvcnRzLkJsb2NrID0gX2Jsb2NrMi5kZWZhdWx0O1xuXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuVGhhdyA9IF90aGF3Mi5kZWZhdWx0O1xuICB3aW5kb3cuVGhhdy5CbG9jayA9IF9ibG9jazIuZGVmYXVsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLnRoYXcgPSB0aGF3O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vL3ByaXZhdGUgdmFyaWFibGVzXG52YXIgdGhhd2luZyA9IGZhbHNlO1xudmFyIHRoYXdzID0gW107XG5cbi8qKlxuICogdGhhdyBhbiBhcnJheSBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBUaGF3ID0gZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoVGhhdywgbnVsbCwgW3tcbiAgICBrZXk6IFwic3RvcEFsbFwiLFxuXG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbGwgVGhhdyBpbnN0YW5jZXNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcEFsbCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhhd3NbaV0uc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWZhdWx0U2V0dGluZ3NcIixcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3tlYWNoOiBudWxsLCBkb25lOiBudWxsfX1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVhY2g6IG51bGwsXG4gICAgICAgIGRvbmU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBpZiBUaGF3LmpzIGlzIHRoYXdpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzVGhhd2luZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoYXdpbmc7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gVGhhdyhpdGVtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhhdyk7XG5cbiAgICB2YXIgX2NvbnN0cnVjdG9yJGRlZmF1bHRTID0gX2V4dGVuZHMoe30sIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFNldHRpbmdzLCBvcHRpb25zKSxcbiAgICAgICAgZWFjaCA9IF9jb25zdHJ1Y3RvciRkZWZhdWx0Uy5lYWNoLFxuICAgICAgICBkb25lID0gX2NvbnN0cnVjdG9yJGRlZmF1bHRTLmRvbmU7XG5cbiAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5pID0gMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciB0aWNrID0gdGhpcy50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmkgPCAwKSByZXR1cm47XG5cbiAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDApO1xuXG4gICAgICBpZiAodGhhd2luZykgcmV0dXJuO1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tfdGhpcy5pXTtcbiAgICAgIGlmIChfdGhpcy5pID49IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBpZiAoZG9uZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoYXdpbmcgPSB0cnVlO1xuICAgICAgICAgIGRvbmUoaXRlbSwgX3RoaXMuaSk7XG4gICAgICAgICAgdGhhd2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuaSA9IC0xO1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlYWNoICE9PSBudWxsKSB7XG4gICAgICAgIHRoYXdpbmcgPSB0cnVlO1xuICAgICAgICBlYWNoKGl0ZW0sIF90aGlzLmkpO1xuICAgICAgICB0aGF3aW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpdGVtKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5pKys7XG4gICAgfTtcblxuICAgIHRoYXdzLnB1c2godGhpcyk7XG4gICAgaWYgKCFvcHRpb25zLmRlbGF5KSB7XG4gICAgICB0aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHJlYWRpZXMgdGhhdyB0byBjb250aW51ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gaWYgaGFkIHRvIGdldCByZWFkeVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhUaGF3LCBbe1xuICAgIGtleTogXCJtYWtlUmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVJlYWR5KCkge1xuICAgICAgaWYgKHRoaXMuaSA8IDApIHtcbiAgICAgICAgdGhpcy5pID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaXRlbSB0byB0aGUgZW5kIG9mIHRoaXMgaW5zdGFuY2Ugb2YgVGhhdyBhbmQgcmVhZGllcyBUaGF3IHRvIHByb2Nlc3MgaXRcbiAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtUaGF3fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChpdGVtKSB7XG4gICAgICB2YXIgZG9UaWNrID0gdGhpcy5tYWtlUmVhZHkoKTtcblxuICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICBpZiAoZG9UaWNrKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIGp1c3QgYWZ0ZXIgdGhlIGN1cnJlbnQgaXRlbSBiZWluZyBwcm9jZXNzZWQgaW4gVGhhdyBhbmQgcmVhZGllcyBUaGF3IHRvIHByb2Nlc3MgaXRcbiAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtUaGF3fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydChpdGVtKSB7XG4gICAgICB2YXIgZG9UaWNrID0gdGhpcy5tYWtlUmVhZHkoKTtcblxuICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pLCAwLCBpdGVtKTtcblxuICAgICAgaWYgKGRvVGljaykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBBcnJheSB0byB0aGUgZW5kIG9mIHRoaXMgaW5zdGFuY2Ugb2YgVGhhdyBhbmQgcmVhZGllcyBUaGF3IHRvIHByb2Nlc3MgaXRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICAgICAqIEByZXR1cm5zIHtUaGF3fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXJyYXkoaXRlbXMpIHtcbiAgICAgIHZhciBkb1RpY2sgPSB0aGlzLm1ha2VSZWFkeSgpO1xuXG4gICAgICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcy5jb25jYXQoaXRlbXMpO1xuXG4gICAgICBpZiAoZG9UaWNrKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEFycmF5IGp1c3QgYWZ0ZXIgdGhlIGN1cnJlbnQgaXRlbSBiZWluZyBwcm9jZXNzZWQgaW4gVGhhdyBhbmQgcmVhZGllcyBUaGF3IHRvIHByb2Nlc3MgdGhlbVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gICAgICogQHJldHVybnMge1RoYXd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBcnJheShpdGVtcykge1xuICAgICAgdmFyIGRvVGljayA9IHRoaXMubWFrZVJlYWR5KCk7XG4gICAgICB2YXIgbGVmdCA9IHRoaXMuaXRlbXM7XG4gICAgICB2YXIgbWlkZGxlID0gaXRlbXM7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLmksIHRoaXMuaXRlbXMubGVuZ3RoIC0gdGhpcy5pICsgMSk7XG5cbiAgICAgIHRoaXMuaXRlbXMgPSBsZWZ0LmNvbmNhdChtaWRkbGUsIHJpZ2h0KTtcblxuICAgICAgaWYgKGRvVGljaykge1xuICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoaXMgaW5zdGFuY2Ugb2YgVGhhd1xuICAgICAqIEByZXR1cm5zIHtUaGF3fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5pID0gLTE7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9uZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZG9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRoYXc7XG59KCk7XG5cbi8qKlxuICogc2ltcGxlIHRoYXdcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyBUaGF3XG4gKi9cblxuXG5leHBvcnRzLmRlZmF1bHQgPSBUaGF3O1xuZnVuY3Rpb24gdGhhdyhpdGVtcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgcmV0dXJuIG5ldyBUaGF3KGl0ZW1zLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRoYXcuanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iXX0=
